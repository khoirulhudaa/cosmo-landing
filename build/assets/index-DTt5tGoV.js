function _mergeNamespaces(F,w){for(var D=0;D<w.length;D++){const O=w[D];if(typeof O!="string"&&!Array.isArray(O)){for(const U in O)if(U!=="default"&&!(U in F)){const G=Object.getOwnPropertyDescriptor(O,U);G&&Object.defineProperty(F,U,G.get?G:{enumerable:!0,get:()=>O[U]})}}}return Object.freeze(Object.defineProperty(F,Symbol.toStringTag,{value:"Module"}))}(function(){const w=document.createElement("link").relList;if(w&&w.supports&&w.supports("modulepreload"))return;for(const U of document.querySelectorAll('link[rel="modulepreload"]'))O(U);new MutationObserver(U=>{for(const G of U)if(G.type==="childList")for(const q of G.addedNodes)q.tagName==="LINK"&&q.rel==="modulepreload"&&O(q)}).observe(document,{childList:!0,subtree:!0});function D(U){const G={};return U.integrity&&(G.integrity=U.integrity),U.referrerPolicy&&(G.referrerPolicy=U.referrerPolicy),U.crossOrigin==="use-credentials"?G.credentials="include":U.crossOrigin==="anonymous"?G.credentials="omit":G.credentials="same-origin",G}function O(U){if(U.ep)return;U.ep=!0;const G=D(U);fetch(U.href,G)}})();function getDefaultExportFromCjs(F){return F&&F.__esModule&&Object.prototype.hasOwnProperty.call(F,"default")?F.default:F}function getAugmentedNamespace(F){if(Object.prototype.hasOwnProperty.call(F,"__esModule"))return F;var w=F.default;if(typeof w=="function"){var D=function O(){var U=!1;try{U=this instanceof O}catch{}return U?Reflect.construct(w,arguments,this.constructor):w.apply(this,arguments)};D.prototype=w.prototype}else D={};return Object.defineProperty(D,"__esModule",{value:!0}),Object.keys(F).forEach(function(O){var U=Object.getOwnPropertyDescriptor(F,O);Object.defineProperty(D,O,U.get?U:{enumerable:!0,get:function(){return F[O]}})}),D}var jsxRuntime={exports:{}},reactJsxRuntime_production={};/**
 * @license React
 * react-jsx-runtime.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var hasRequiredReactJsxRuntime_production;function requireReactJsxRuntime_production(){if(hasRequiredReactJsxRuntime_production)return reactJsxRuntime_production;hasRequiredReactJsxRuntime_production=1;var F=Symbol.for("react.transitional.element"),w=Symbol.for("react.fragment");function D(O,U,G){var q=null;if(G!==void 0&&(q=""+G),U.key!==void 0&&(q=""+U.key),"key"in U){G={};for(var K in U)K!=="key"&&(G[K]=U[K])}else G=U;return U=G.ref,{$$typeof:F,type:O,key:q,ref:U!==void 0?U:null,props:G}}return reactJsxRuntime_production.Fragment=w,reactJsxRuntime_production.jsx=D,reactJsxRuntime_production.jsxs=D,reactJsxRuntime_production}var hasRequiredJsxRuntime;function requireJsxRuntime(){return hasRequiredJsxRuntime||(hasRequiredJsxRuntime=1,jsxRuntime.exports=requireReactJsxRuntime_production()),jsxRuntime.exports}var jsxRuntimeExports=requireJsxRuntime(),react={exports:{}},react_production={};/**
 * @license React
 * react.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var hasRequiredReact_production;function requireReact_production(){if(hasRequiredReact_production)return react_production;hasRequiredReact_production=1;var F=Symbol.for("react.transitional.element"),w=Symbol.for("react.portal"),D=Symbol.for("react.fragment"),O=Symbol.for("react.strict_mode"),U=Symbol.for("react.profiler"),G=Symbol.for("react.consumer"),q=Symbol.for("react.context"),K=Symbol.for("react.forward_ref"),ee=Symbol.for("react.suspense"),Z=Symbol.for("react.memo"),ie=Symbol.for("react.lazy"),Y=Symbol.for("react.activity"),W=Symbol.iterator;function ne(ke){return ke===null||typeof ke!="object"?null:(ke=W&&ke[W]||ke["@@iterator"],typeof ke=="function"?ke:null)}var se={isMounted:function(){return!1},enqueueForceUpdate:function(){},enqueueReplaceState:function(){},enqueueSetState:function(){}},le=Object.assign,ce={};function he(ke,rt,St){this.props=ke,this.context=rt,this.refs=ce,this.updater=St||se}he.prototype.isReactComponent={},he.prototype.setState=function(ke,rt){if(typeof ke!="object"&&typeof ke!="function"&&ke!=null)throw Error("takes an object of state variables to update or a function which returns an object of state variables.");this.updater.enqueueSetState(this,ke,rt,"setState")},he.prototype.forceUpdate=function(ke){this.updater.enqueueForceUpdate(this,ke,"forceUpdate")};function pe(){}pe.prototype=he.prototype;function me(ke,rt,St){this.props=ke,this.context=rt,this.refs=ce,this.updater=St||se}var be=me.prototype=new pe;be.constructor=me,le(be,he.prototype),be.isPureReactComponent=!0;var ge=Array.isArray;function ve(){}var Se={H:null,A:null,T:null,S:null},Me=Object.prototype.hasOwnProperty;function Ee(ke,rt,St){var Lt=St.ref;return{$$typeof:F,type:ke,key:rt,ref:Lt!==void 0?Lt:null,props:St}}function we(ke,rt){return Ee(ke.type,rt,ke.props)}function Re(ke){return typeof ke=="object"&&ke!==null&&ke.$$typeof===F}function Le(ke){var rt={"=":"=0",":":"=2"};return"$"+ke.replace(/[=:]/g,function(St){return rt[St]})}var Ne=/\/+/g;function Oe(ke,rt){return typeof ke=="object"&&ke!==null&&ke.key!=null?Le(""+ke.key):rt.toString(36)}function Pe(ke){switch(ke.status){case"fulfilled":return ke.value;case"rejected":throw ke.reason;default:switch(typeof ke.status=="string"?ke.then(ve,ve):(ke.status="pending",ke.then(function(rt){ke.status==="pending"&&(ke.status="fulfilled",ke.value=rt)},function(rt){ke.status==="pending"&&(ke.status="rejected",ke.reason=rt)})),ke.status){case"fulfilled":return ke.value;case"rejected":throw ke.reason}}throw ke}function Ce(ke,rt,St,Lt,$t){var mt=typeof ke;(mt==="undefined"||mt==="boolean")&&(ke=null);var bt=!1;if(ke===null)bt=!0;else switch(mt){case"bigint":case"string":case"number":bt=!0;break;case"object":switch(ke.$$typeof){case F:case w:bt=!0;break;case ie:return bt=ke._init,Ce(bt(ke._payload),rt,St,Lt,$t)}}if(bt)return $t=$t(ke),bt=Lt===""?"."+Oe(ke,0):Lt,ge($t)?(St="",bt!=null&&(St=bt.replace(Ne,"$&/")+"/"),Ce($t,rt,St,"",function(Jt){return Jt})):$t!=null&&(Re($t)&&($t=we($t,St+($t.key==null||ke&&ke.key===$t.key?"":(""+$t.key).replace(Ne,"$&/")+"/")+bt)),rt.push($t)),1;bt=0;var Xt=Lt===""?".":Lt+":";if(ge(ke))for(var hn=0;hn<ke.length;hn++)Lt=ke[hn],mt=Xt+Oe(Lt,hn),bt+=Ce(Lt,rt,St,mt,$t);else if(hn=ne(ke),typeof hn=="function")for(ke=hn.call(ke),hn=0;!(Lt=ke.next()).done;)Lt=Lt.value,mt=Xt+Oe(Lt,hn++),bt+=Ce(Lt,rt,St,mt,$t);else if(mt==="object"){if(typeof ke.then=="function")return Ce(Pe(ke),rt,St,Lt,$t);throw rt=String(ke),Error("Objects are not valid as a React child (found: "+(rt==="[object Object]"?"object with keys {"+Object.keys(ke).join(", ")+"}":rt)+"). If you meant to render a collection of children, use an array instead.")}return bt}function Be(ke,rt,St){if(ke==null)return ke;var Lt=[],$t=0;return Ce(ke,Lt,"","",function(mt){return rt.call(St,mt,$t++)}),Lt}function ze(ke){if(ke._status===-1){var rt=ke._result;rt=rt(),rt.then(function(St){(ke._status===0||ke._status===-1)&&(ke._status=1,ke._result=St)},function(St){(ke._status===0||ke._status===-1)&&(ke._status=2,ke._result=St)}),ke._status===-1&&(ke._status=0,ke._result=rt)}if(ke._status===1)return ke._result.default;throw ke._result}var Xe=typeof reportError=="function"?reportError:function(ke){if(typeof window=="object"&&typeof window.ErrorEvent=="function"){var rt=new window.ErrorEvent("error",{bubbles:!0,cancelable:!0,message:typeof ke=="object"&&ke!==null&&typeof ke.message=="string"?String(ke.message):String(ke),error:ke});if(!window.dispatchEvent(rt))return}else if(typeof process=="object"&&typeof process.emit=="function"){process.emit("uncaughtException",ke);return}console.error(ke)},lt={map:Be,forEach:function(ke,rt,St){Be(ke,function(){rt.apply(this,arguments)},St)},count:function(ke){var rt=0;return Be(ke,function(){rt++}),rt},toArray:function(ke){return Be(ke,function(rt){return rt})||[]},only:function(ke){if(!Re(ke))throw Error("React.Children.only expected to receive a single React element child.");return ke}};return react_production.Activity=Y,react_production.Children=lt,react_production.Component=he,react_production.Fragment=D,react_production.Profiler=U,react_production.PureComponent=me,react_production.StrictMode=O,react_production.Suspense=ee,react_production.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE=Se,react_production.__COMPILER_RUNTIME={__proto__:null,c:function(ke){return Se.H.useMemoCache(ke)}},react_production.cache=function(ke){return function(){return ke.apply(null,arguments)}},react_production.cacheSignal=function(){return null},react_production.cloneElement=function(ke,rt,St){if(ke==null)throw Error("The argument must be a React element, but you passed "+ke+".");var Lt=le({},ke.props),$t=ke.key;if(rt!=null)for(mt in rt.key!==void 0&&($t=""+rt.key),rt)!Me.call(rt,mt)||mt==="key"||mt==="__self"||mt==="__source"||mt==="ref"&&rt.ref===void 0||(Lt[mt]=rt[mt]);var mt=arguments.length-2;if(mt===1)Lt.children=St;else if(1<mt){for(var bt=Array(mt),Xt=0;Xt<mt;Xt++)bt[Xt]=arguments[Xt+2];Lt.children=bt}return Ee(ke.type,$t,Lt)},react_production.createContext=function(ke){return ke={$$typeof:q,_currentValue:ke,_currentValue2:ke,_threadCount:0,Provider:null,Consumer:null},ke.Provider=ke,ke.Consumer={$$typeof:G,_context:ke},ke},react_production.createElement=function(ke,rt,St){var Lt,$t={},mt=null;if(rt!=null)for(Lt in rt.key!==void 0&&(mt=""+rt.key),rt)Me.call(rt,Lt)&&Lt!=="key"&&Lt!=="__self"&&Lt!=="__source"&&($t[Lt]=rt[Lt]);var bt=arguments.length-2;if(bt===1)$t.children=St;else if(1<bt){for(var Xt=Array(bt),hn=0;hn<bt;hn++)Xt[hn]=arguments[hn+2];$t.children=Xt}if(ke&&ke.defaultProps)for(Lt in bt=ke.defaultProps,bt)$t[Lt]===void 0&&($t[Lt]=bt[Lt]);return Ee(ke,mt,$t)},react_production.createRef=function(){return{current:null}},react_production.forwardRef=function(ke){return{$$typeof:K,render:ke}},react_production.isValidElement=Re,react_production.lazy=function(ke){return{$$typeof:ie,_payload:{_status:-1,_result:ke},_init:ze}},react_production.memo=function(ke,rt){return{$$typeof:Z,type:ke,compare:rt===void 0?null:rt}},react_production.startTransition=function(ke){var rt=Se.T,St={};Se.T=St;try{var Lt=ke(),$t=Se.S;$t!==null&&$t(St,Lt),typeof Lt=="object"&&Lt!==null&&typeof Lt.then=="function"&&Lt.then(ve,Xe)}catch(mt){Xe(mt)}finally{rt!==null&&St.types!==null&&(rt.types=St.types),Se.T=rt}},react_production.unstable_useCacheRefresh=function(){return Se.H.useCacheRefresh()},react_production.use=function(ke){return Se.H.use(ke)},react_production.useActionState=function(ke,rt,St){return Se.H.useActionState(ke,rt,St)},react_production.useCallback=function(ke,rt){return Se.H.useCallback(ke,rt)},react_production.useContext=function(ke){return Se.H.useContext(ke)},react_production.useDebugValue=function(){},react_production.useDeferredValue=function(ke,rt){return Se.H.useDeferredValue(ke,rt)},react_production.useEffect=function(ke,rt){return Se.H.useEffect(ke,rt)},react_production.useEffectEvent=function(ke){return Se.H.useEffectEvent(ke)},react_production.useId=function(){return Se.H.useId()},react_production.useImperativeHandle=function(ke,rt,St){return Se.H.useImperativeHandle(ke,rt,St)},react_production.useInsertionEffect=function(ke,rt){return Se.H.useInsertionEffect(ke,rt)},react_production.useLayoutEffect=function(ke,rt){return Se.H.useLayoutEffect(ke,rt)},react_production.useMemo=function(ke,rt){return Se.H.useMemo(ke,rt)},react_production.useOptimistic=function(ke,rt){return Se.H.useOptimistic(ke,rt)},react_production.useReducer=function(ke,rt,St){return Se.H.useReducer(ke,rt,St)},react_production.useRef=function(ke){return Se.H.useRef(ke)},react_production.useState=function(ke){return Se.H.useState(ke)},react_production.useSyncExternalStore=function(ke,rt,St){return Se.H.useSyncExternalStore(ke,rt,St)},react_production.useTransition=function(){return Se.H.useTransition()},react_production.version="19.2.0",react_production}var hasRequiredReact;function requireReact(){return hasRequiredReact||(hasRequiredReact=1,react.exports=requireReact_production()),react.exports}var reactExports=requireReact(),client={exports:{}},reactDomClient_production={},scheduler={exports:{}},scheduler_production={};/**
 * @license React
 * scheduler.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var hasRequiredScheduler_production;function requireScheduler_production(){return hasRequiredScheduler_production||(hasRequiredScheduler_production=1,(function(F){function w(Ce,Be){var ze=Ce.length;Ce.push(Be);e:for(;0<ze;){var Xe=ze-1>>>1,lt=Ce[Xe];if(0<U(lt,Be))Ce[Xe]=Be,Ce[ze]=lt,ze=Xe;else break e}}function D(Ce){return Ce.length===0?null:Ce[0]}function O(Ce){if(Ce.length===0)return null;var Be=Ce[0],ze=Ce.pop();if(ze!==Be){Ce[0]=ze;e:for(var Xe=0,lt=Ce.length,ke=lt>>>1;Xe<ke;){var rt=2*(Xe+1)-1,St=Ce[rt],Lt=rt+1,$t=Ce[Lt];if(0>U(St,ze))Lt<lt&&0>U($t,St)?(Ce[Xe]=$t,Ce[Lt]=ze,Xe=Lt):(Ce[Xe]=St,Ce[rt]=ze,Xe=rt);else if(Lt<lt&&0>U($t,ze))Ce[Xe]=$t,Ce[Lt]=ze,Xe=Lt;else break e}}return Be}function U(Ce,Be){var ze=Ce.sortIndex-Be.sortIndex;return ze!==0?ze:Ce.id-Be.id}if(F.unstable_now=void 0,typeof performance=="object"&&typeof performance.now=="function"){var G=performance;F.unstable_now=function(){return G.now()}}else{var q=Date,K=q.now();F.unstable_now=function(){return q.now()-K}}var ee=[],Z=[],ie=1,Y=null,W=3,ne=!1,se=!1,le=!1,ce=!1,he=typeof setTimeout=="function"?setTimeout:null,pe=typeof clearTimeout=="function"?clearTimeout:null,me=typeof setImmediate<"u"?setImmediate:null;function be(Ce){for(var Be=D(Z);Be!==null;){if(Be.callback===null)O(Z);else if(Be.startTime<=Ce)O(Z),Be.sortIndex=Be.expirationTime,w(ee,Be);else break;Be=D(Z)}}function ge(Ce){if(le=!1,be(Ce),!se)if(D(ee)!==null)se=!0,ve||(ve=!0,Le());else{var Be=D(Z);Be!==null&&Pe(ge,Be.startTime-Ce)}}var ve=!1,Se=-1,Me=5,Ee=-1;function we(){return ce?!0:!(F.unstable_now()-Ee<Me)}function Re(){if(ce=!1,ve){var Ce=F.unstable_now();Ee=Ce;var Be=!0;try{e:{se=!1,le&&(le=!1,pe(Se),Se=-1),ne=!0;var ze=W;try{t:{for(be(Ce),Y=D(ee);Y!==null&&!(Y.expirationTime>Ce&&we());){var Xe=Y.callback;if(typeof Xe=="function"){Y.callback=null,W=Y.priorityLevel;var lt=Xe(Y.expirationTime<=Ce);if(Ce=F.unstable_now(),typeof lt=="function"){Y.callback=lt,be(Ce),Be=!0;break t}Y===D(ee)&&O(ee),be(Ce)}else O(ee);Y=D(ee)}if(Y!==null)Be=!0;else{var ke=D(Z);ke!==null&&Pe(ge,ke.startTime-Ce),Be=!1}}break e}finally{Y=null,W=ze,ne=!1}Be=void 0}}finally{Be?Le():ve=!1}}}var Le;if(typeof me=="function")Le=function(){me(Re)};else if(typeof MessageChannel<"u"){var Ne=new MessageChannel,Oe=Ne.port2;Ne.port1.onmessage=Re,Le=function(){Oe.postMessage(null)}}else Le=function(){he(Re,0)};function Pe(Ce,Be){Se=he(function(){Ce(F.unstable_now())},Be)}F.unstable_IdlePriority=5,F.unstable_ImmediatePriority=1,F.unstable_LowPriority=4,F.unstable_NormalPriority=3,F.unstable_Profiling=null,F.unstable_UserBlockingPriority=2,F.unstable_cancelCallback=function(Ce){Ce.callback=null},F.unstable_forceFrameRate=function(Ce){0>Ce||125<Ce?console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"):Me=0<Ce?Math.floor(1e3/Ce):5},F.unstable_getCurrentPriorityLevel=function(){return W},F.unstable_next=function(Ce){switch(W){case 1:case 2:case 3:var Be=3;break;default:Be=W}var ze=W;W=Be;try{return Ce()}finally{W=ze}},F.unstable_requestPaint=function(){ce=!0},F.unstable_runWithPriority=function(Ce,Be){switch(Ce){case 1:case 2:case 3:case 4:case 5:break;default:Ce=3}var ze=W;W=Ce;try{return Be()}finally{W=ze}},F.unstable_scheduleCallback=function(Ce,Be,ze){var Xe=F.unstable_now();switch(typeof ze=="object"&&ze!==null?(ze=ze.delay,ze=typeof ze=="number"&&0<ze?Xe+ze:Xe):ze=Xe,Ce){case 1:var lt=-1;break;case 2:lt=250;break;case 5:lt=1073741823;break;case 4:lt=1e4;break;default:lt=5e3}return lt=ze+lt,Ce={id:ie++,callback:Be,priorityLevel:Ce,startTime:ze,expirationTime:lt,sortIndex:-1},ze>Xe?(Ce.sortIndex=ze,w(Z,Ce),D(ee)===null&&Ce===D(Z)&&(le?(pe(Se),Se=-1):le=!0,Pe(ge,ze-Xe))):(Ce.sortIndex=lt,w(ee,Ce),se||ne||(se=!0,ve||(ve=!0,Le()))),Ce},F.unstable_shouldYield=we,F.unstable_wrapCallback=function(Ce){var Be=W;return function(){var ze=W;W=Be;try{return Ce.apply(this,arguments)}finally{W=ze}}}})(scheduler_production)),scheduler_production}var hasRequiredScheduler;function requireScheduler(){return hasRequiredScheduler||(hasRequiredScheduler=1,scheduler.exports=requireScheduler_production()),scheduler.exports}var reactDom={exports:{}},reactDom_production={};/**
 * @license React
 * react-dom.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var hasRequiredReactDom_production;function requireReactDom_production(){if(hasRequiredReactDom_production)return reactDom_production;hasRequiredReactDom_production=1;var F=requireReact();function w(ee){var Z="https://react.dev/errors/"+ee;if(1<arguments.length){Z+="?args[]="+encodeURIComponent(arguments[1]);for(var ie=2;ie<arguments.length;ie++)Z+="&args[]="+encodeURIComponent(arguments[ie])}return"Minified React error #"+ee+"; visit "+Z+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}function D(){}var O={d:{f:D,r:function(){throw Error(w(522))},D,C:D,L:D,m:D,X:D,S:D,M:D},p:0,findDOMNode:null},U=Symbol.for("react.portal");function G(ee,Z,ie){var Y=3<arguments.length&&arguments[3]!==void 0?arguments[3]:null;return{$$typeof:U,key:Y==null?null:""+Y,children:ee,containerInfo:Z,implementation:ie}}var q=F.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;function K(ee,Z){if(ee==="font")return"";if(typeof Z=="string")return Z==="use-credentials"?Z:""}return reactDom_production.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE=O,reactDom_production.createPortal=function(ee,Z){var ie=2<arguments.length&&arguments[2]!==void 0?arguments[2]:null;if(!Z||Z.nodeType!==1&&Z.nodeType!==9&&Z.nodeType!==11)throw Error(w(299));return G(ee,Z,null,ie)},reactDom_production.flushSync=function(ee){var Z=q.T,ie=O.p;try{if(q.T=null,O.p=2,ee)return ee()}finally{q.T=Z,O.p=ie,O.d.f()}},reactDom_production.preconnect=function(ee,Z){typeof ee=="string"&&(Z?(Z=Z.crossOrigin,Z=typeof Z=="string"?Z==="use-credentials"?Z:"":void 0):Z=null,O.d.C(ee,Z))},reactDom_production.prefetchDNS=function(ee){typeof ee=="string"&&O.d.D(ee)},reactDom_production.preinit=function(ee,Z){if(typeof ee=="string"&&Z&&typeof Z.as=="string"){var ie=Z.as,Y=K(ie,Z.crossOrigin),W=typeof Z.integrity=="string"?Z.integrity:void 0,ne=typeof Z.fetchPriority=="string"?Z.fetchPriority:void 0;ie==="style"?O.d.S(ee,typeof Z.precedence=="string"?Z.precedence:void 0,{crossOrigin:Y,integrity:W,fetchPriority:ne}):ie==="script"&&O.d.X(ee,{crossOrigin:Y,integrity:W,fetchPriority:ne,nonce:typeof Z.nonce=="string"?Z.nonce:void 0})}},reactDom_production.preinitModule=function(ee,Z){if(typeof ee=="string")if(typeof Z=="object"&&Z!==null){if(Z.as==null||Z.as==="script"){var ie=K(Z.as,Z.crossOrigin);O.d.M(ee,{crossOrigin:ie,integrity:typeof Z.integrity=="string"?Z.integrity:void 0,nonce:typeof Z.nonce=="string"?Z.nonce:void 0})}}else Z==null&&O.d.M(ee)},reactDom_production.preload=function(ee,Z){if(typeof ee=="string"&&typeof Z=="object"&&Z!==null&&typeof Z.as=="string"){var ie=Z.as,Y=K(ie,Z.crossOrigin);O.d.L(ee,ie,{crossOrigin:Y,integrity:typeof Z.integrity=="string"?Z.integrity:void 0,nonce:typeof Z.nonce=="string"?Z.nonce:void 0,type:typeof Z.type=="string"?Z.type:void 0,fetchPriority:typeof Z.fetchPriority=="string"?Z.fetchPriority:void 0,referrerPolicy:typeof Z.referrerPolicy=="string"?Z.referrerPolicy:void 0,imageSrcSet:typeof Z.imageSrcSet=="string"?Z.imageSrcSet:void 0,imageSizes:typeof Z.imageSizes=="string"?Z.imageSizes:void 0,media:typeof Z.media=="string"?Z.media:void 0})}},reactDom_production.preloadModule=function(ee,Z){if(typeof ee=="string")if(Z){var ie=K(Z.as,Z.crossOrigin);O.d.m(ee,{as:typeof Z.as=="string"&&Z.as!=="script"?Z.as:void 0,crossOrigin:ie,integrity:typeof Z.integrity=="string"?Z.integrity:void 0})}else O.d.m(ee)},reactDom_production.requestFormReset=function(ee){O.d.r(ee)},reactDom_production.unstable_batchedUpdates=function(ee,Z){return ee(Z)},reactDom_production.useFormState=function(ee,Z,ie){return q.H.useFormState(ee,Z,ie)},reactDom_production.useFormStatus=function(){return q.H.useHostTransitionStatus()},reactDom_production.version="19.2.0",reactDom_production}var hasRequiredReactDom;function requireReactDom(){if(hasRequiredReactDom)return reactDom.exports;hasRequiredReactDom=1;function F(){if(!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__>"u"||typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE!="function"))try{__REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(F)}catch(w){console.error(w)}}return F(),reactDom.exports=requireReactDom_production(),reactDom.exports}/**
 * @license React
 * react-dom-client.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var hasRequiredReactDomClient_production;function requireReactDomClient_production(){if(hasRequiredReactDomClient_production)return reactDomClient_production;hasRequiredReactDomClient_production=1;var F=requireScheduler(),w=requireReact(),D=requireReactDom();function O(J){var re="https://react.dev/errors/"+J;if(1<arguments.length){re+="?args[]="+encodeURIComponent(arguments[1]);for(var oe=2;oe<arguments.length;oe++)re+="&args[]="+encodeURIComponent(arguments[oe])}return"Minified React error #"+J+"; visit "+re+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}function U(J){return!(!J||J.nodeType!==1&&J.nodeType!==9&&J.nodeType!==11)}function G(J){var re=J,oe=J;if(J.alternate)for(;re.return;)re=re.return;else{J=re;do re=J,(re.flags&4098)!==0&&(oe=re.return),J=re.return;while(J)}return re.tag===3?oe:null}function q(J){if(J.tag===13){var re=J.memoizedState;if(re===null&&(J=J.alternate,J!==null&&(re=J.memoizedState)),re!==null)return re.dehydrated}return null}function K(J){if(J.tag===31){var re=J.memoizedState;if(re===null&&(J=J.alternate,J!==null&&(re=J.memoizedState)),re!==null)return re.dehydrated}return null}function ee(J){if(G(J)!==J)throw Error(O(188))}function Z(J){var re=J.alternate;if(!re){if(re=G(J),re===null)throw Error(O(188));return re!==J?null:J}for(var oe=J,fe=re;;){var xe=oe.return;if(xe===null)break;var Te=xe.alternate;if(Te===null){if(fe=xe.return,fe!==null){oe=fe;continue}break}if(xe.child===Te.child){for(Te=xe.child;Te;){if(Te===oe)return ee(xe),J;if(Te===fe)return ee(xe),re;Te=Te.sibling}throw Error(O(188))}if(oe.return!==fe.return)oe=xe,fe=Te;else{for(var Ie=!1,Ve=xe.child;Ve;){if(Ve===oe){Ie=!0,oe=xe,fe=Te;break}if(Ve===fe){Ie=!0,fe=xe,oe=Te;break}Ve=Ve.sibling}if(!Ie){for(Ve=Te.child;Ve;){if(Ve===oe){Ie=!0,oe=Te,fe=xe;break}if(Ve===fe){Ie=!0,fe=Te,oe=xe;break}Ve=Ve.sibling}if(!Ie)throw Error(O(189))}}if(oe.alternate!==fe)throw Error(O(190))}if(oe.tag!==3)throw Error(O(188));return oe.stateNode.current===oe?J:re}function ie(J){var re=J.tag;if(re===5||re===26||re===27||re===6)return J;for(J=J.child;J!==null;){if(re=ie(J),re!==null)return re;J=J.sibling}return null}var Y=Object.assign,W=Symbol.for("react.element"),ne=Symbol.for("react.transitional.element"),se=Symbol.for("react.portal"),le=Symbol.for("react.fragment"),ce=Symbol.for("react.strict_mode"),he=Symbol.for("react.profiler"),pe=Symbol.for("react.consumer"),me=Symbol.for("react.context"),be=Symbol.for("react.forward_ref"),ge=Symbol.for("react.suspense"),ve=Symbol.for("react.suspense_list"),Se=Symbol.for("react.memo"),Me=Symbol.for("react.lazy"),Ee=Symbol.for("react.activity"),we=Symbol.for("react.memo_cache_sentinel"),Re=Symbol.iterator;function Le(J){return J===null||typeof J!="object"?null:(J=Re&&J[Re]||J["@@iterator"],typeof J=="function"?J:null)}var Ne=Symbol.for("react.client.reference");function Oe(J){if(J==null)return null;if(typeof J=="function")return J.$$typeof===Ne?null:J.displayName||J.name||null;if(typeof J=="string")return J;switch(J){case le:return"Fragment";case he:return"Profiler";case ce:return"StrictMode";case ge:return"Suspense";case ve:return"SuspenseList";case Ee:return"Activity"}if(typeof J=="object")switch(J.$$typeof){case se:return"Portal";case me:return J.displayName||"Context";case pe:return(J._context.displayName||"Context")+".Consumer";case be:var re=J.render;return J=J.displayName,J||(J=re.displayName||re.name||"",J=J!==""?"ForwardRef("+J+")":"ForwardRef"),J;case Se:return re=J.displayName||null,re!==null?re:Oe(J.type)||"Memo";case Me:re=J._payload,J=J._init;try{return Oe(J(re))}catch{}}return null}var Pe=Array.isArray,Ce=w.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,Be=D.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,ze={pending:!1,data:null,method:null,action:null},Xe=[],lt=-1;function ke(J){return{current:J}}function rt(J){0>lt||(J.current=Xe[lt],Xe[lt]=null,lt--)}function St(J,re){lt++,Xe[lt]=J.current,J.current=re}var Lt=ke(null),$t=ke(null),mt=ke(null),bt=ke(null);function Xt(J,re){switch(St(mt,re),St($t,J),St(Lt,null),re.nodeType){case 9:case 11:J=(J=re.documentElement)&&(J=J.namespaceURI)?Gf(J):0;break;default:if(J=re.tagName,re=re.namespaceURI)re=Gf(re),J=zf(re,J);else switch(J){case"svg":J=1;break;case"math":J=2;break;default:J=0}}rt(Lt),St(Lt,J)}function hn(){rt(Lt),rt($t),rt(mt)}function Jt(J){J.memoizedState!==null&&St(bt,J);var re=Lt.current,oe=zf(re,J.type);re!==oe&&(St($t,J),St(Lt,oe))}function Mn(J){$t.current===J&&(rt(Lt),rt($t)),bt.current===J&&(rt(bt),Io._currentValue=ze)}var Zn,vn;function In(J){if(Zn===void 0)try{throw Error()}catch(oe){var re=oe.stack.trim().match(/\n( *(at )?)/);Zn=re&&re[1]||"",vn=-1<oe.stack.indexOf(`
    at`)?" (<anonymous>)":-1<oe.stack.indexOf("@")?"@unknown:0:0":""}return`
`+Zn+J+vn}var st=!1;function Gn(J,re){if(!J||st)return"";st=!0;var oe=Error.prepareStackTrace;Error.prepareStackTrace=void 0;try{var fe={DetermineComponentFrameRoot:function(){try{if(re){var Ht=function(){throw Error()};if(Object.defineProperty(Ht.prototype,"props",{set:function(){throw Error()}}),typeof Reflect=="object"&&Reflect.construct){try{Reflect.construct(Ht,[])}catch(Ot){var Rt=Ot}Reflect.construct(J,[],Ht)}else{try{Ht.call()}catch(Ot){Rt=Ot}J.call(Ht.prototype)}}else{try{throw Error()}catch(Ot){Rt=Ot}(Ht=J())&&typeof Ht.catch=="function"&&Ht.catch(function(){})}}catch(Ot){if(Ot&&Rt&&typeof Ot.stack=="string")return[Ot.stack,Rt.stack]}return[null,null]}};fe.DetermineComponentFrameRoot.displayName="DetermineComponentFrameRoot";var xe=Object.getOwnPropertyDescriptor(fe.DetermineComponentFrameRoot,"name");xe&&xe.configurable&&Object.defineProperty(fe.DetermineComponentFrameRoot,"name",{value:"DetermineComponentFrameRoot"});var Te=fe.DetermineComponentFrameRoot(),Ie=Te[0],Ve=Te[1];if(Ie&&Ve){var at=Ie.split(`
`),Ct=Ve.split(`
`);for(xe=fe=0;fe<at.length&&!at[fe].includes("DetermineComponentFrameRoot");)fe++;for(;xe<Ct.length&&!Ct[xe].includes("DetermineComponentFrameRoot");)xe++;if(fe===at.length||xe===Ct.length)for(fe=at.length-1,xe=Ct.length-1;1<=fe&&0<=xe&&at[fe]!==Ct[xe];)xe--;for(;1<=fe&&0<=xe;fe--,xe--)if(at[fe]!==Ct[xe]){if(fe!==1||xe!==1)do if(fe--,xe--,0>xe||at[fe]!==Ct[xe]){var Vt=`
`+at[fe].replace(" at new "," at ");return J.displayName&&Vt.includes("<anonymous>")&&(Vt=Vt.replace("<anonymous>",J.displayName)),Vt}while(1<=fe&&0<=xe);break}}}finally{st=!1,Error.prepareStackTrace=oe}return(oe=J?J.displayName||J.name:"")?In(oe):""}function qn(J,re){switch(J.tag){case 26:case 27:case 5:return In(J.type);case 16:return In("Lazy");case 13:return J.child!==re&&re!==null?In("Suspense Fallback"):In("Suspense");case 19:return In("SuspenseList");case 0:case 15:return Gn(J.type,!1);case 11:return Gn(J.type.render,!1);case 1:return Gn(J.type,!0);case 31:return In("Activity");default:return""}}function ai(J){try{var re="",oe=null;do re+=qn(J,oe),oe=J,J=J.return;while(J);return re}catch(fe){return`
Error generating stack: `+fe.message+`
`+fe.stack}}var yn=Object.prototype.hasOwnProperty,li=F.unstable_scheduleCallback,Tn=F.unstable_cancelCallback,En=F.unstable_shouldYield,Ke=F.unstable_requestPaint,Fe=F.unstable_now,pt=F.unstable_getCurrentPriorityLevel,zt=F.unstable_ImmediatePriority,qt=F.unstable_UserBlockingPriority,Nt=F.unstable_NormalPriority,Rn=F.unstable_LowPriority,fn=F.unstable_IdlePriority,Nn=F.log,An=F.unstable_setDisableYieldValue,Wt=null,Dt=null;function Bn(J){if(typeof Nn=="function"&&An(J),Dt&&typeof Dt.setStrictMode=="function")try{Dt.setStrictMode(Wt,J)}catch{}}var Sn=Math.clz32?Math.clz32:nt,bn=Math.log,kn=Math.LN2;function nt(J){return J>>>=0,J===0?32:31-(bn(J)/kn|0)|0}var dn=256,tn=262144,Zt=4194304;function Bt(J){var re=J&42;if(re!==0)return re;switch(J&-J){case 1:return 1;case 2:return 2;case 4:return 4;case 8:return 8;case 16:return 16;case 32:return 32;case 64:return 64;case 128:return 128;case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:return J&261888;case 262144:case 524288:case 1048576:case 2097152:return J&3932160;case 4194304:case 8388608:case 16777216:case 33554432:return J&62914560;case 67108864:return 67108864;case 134217728:return 134217728;case 268435456:return 268435456;case 536870912:return 536870912;case 1073741824:return 0;default:return J}}function wt(J,re,oe){var fe=J.pendingLanes;if(fe===0)return 0;var xe=0,Te=J.suspendedLanes,Ie=J.pingedLanes;J=J.warmLanes;var Ve=fe&134217727;return Ve!==0?(fe=Ve&~Te,fe!==0?xe=Bt(fe):(Ie&=Ve,Ie!==0?xe=Bt(Ie):oe||(oe=Ve&~J,oe!==0&&(xe=Bt(oe))))):(Ve=fe&~Te,Ve!==0?xe=Bt(Ve):Ie!==0?xe=Bt(Ie):oe||(oe=fe&~J,oe!==0&&(xe=Bt(oe)))),xe===0?0:re!==0&&re!==xe&&(re&Te)===0&&(Te=xe&-xe,oe=re&-re,Te>=oe||Te===32&&(oe&4194048)!==0)?re:xe}function Qt(J,re){return(J.pendingLanes&~(J.suspendedLanes&~J.pingedLanes)&re)===0}function Yn(J,re){switch(J){case 1:case 2:case 4:case 8:case 64:return re+250;case 16:case 32:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:return re+5e3;case 4194304:case 8388608:case 16777216:case 33554432:return-1;case 67108864:case 134217728:case 268435456:case 536870912:case 1073741824:return-1;default:return-1}}function Ai(){var J=Zt;return Zt<<=1,(Zt&62914560)===0&&(Zt=4194304),J}function hi(J){for(var re=[],oe=0;31>oe;oe++)re.push(J);return re}function Xi(J,re){J.pendingLanes|=re,re!==268435456&&(J.suspendedLanes=0,J.pingedLanes=0,J.warmLanes=0)}function lr(J,re,oe,fe,xe,Te){var Ie=J.pendingLanes;J.pendingLanes=oe,J.suspendedLanes=0,J.pingedLanes=0,J.warmLanes=0,J.expiredLanes&=oe,J.entangledLanes&=oe,J.errorRecoveryDisabledLanes&=oe,J.shellSuspendCounter=0;var Ve=J.entanglements,at=J.expirationTimes,Ct=J.hiddenUpdates;for(oe=Ie&~oe;0<oe;){var Vt=31-Sn(oe),Ht=1<<Vt;Ve[Vt]=0,at[Vt]=-1;var Rt=Ct[Vt];if(Rt!==null)for(Ct[Vt]=null,Vt=0;Vt<Rt.length;Vt++){var Ot=Rt[Vt];Ot!==null&&(Ot.lane&=-536870913)}oe&=~Ht}fe!==0&&es(J,fe,0),Te!==0&&xe===0&&J.tag!==0&&(J.suspendedLanes|=Te&~(Ie&~re))}function es(J,re,oe){J.pendingLanes|=re,J.suspendedLanes&=~re;var fe=31-Sn(re);J.entangledLanes|=re,J.entanglements[fe]=J.entanglements[fe]|1073741824|oe&261930}function Qr(J,re){var oe=J.entangledLanes|=re;for(J=J.entanglements;oe;){var fe=31-Sn(oe),xe=1<<fe;xe&re|J[fe]&re&&(J[fe]|=re),oe&=~xe}}function qr(J,re){var oe=re&-re;return oe=(oe&42)!==0?1:hr(oe),(oe&(J.suspendedLanes|re))!==0?0:oe}function hr(J){switch(J){case 2:J=1;break;case 8:J=4;break;case 32:J=16;break;case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:case 4194304:case 8388608:case 16777216:case 33554432:J=128;break;case 268435456:J=134217728;break;default:J=0}return J}function wr(J){return J&=-J,2<J?8<J?(J&134217727)!==0?32:268435456:8:2}function Wr(){var J=Be.p;return J!==0?J:(J=window.event,J===void 0?32:hp(J.type))}function Xr(J,re){var oe=Be.p;try{return Be.p=J,re()}finally{Be.p=oe}}var cr=Math.random().toString(36).slice(2),ji="__reactFiber$"+cr,Ge="__reactProps$"+cr,tt="__reactContainer$"+cr,ft="__reactEvents$"+cr,yt="__reactListeners$"+cr,It="__reactHandles$"+cr,kt="__reactResources$"+cr,Kt="__reactMarker$"+cr;function On(J){delete J[ji],delete J[Ge],delete J[ft],delete J[yt],delete J[It]}function gn(J){var re=J[ji];if(re)return re;for(var oe=J.parentNode;oe;){if(re=oe[tt]||oe[ji]){if(oe=re.alternate,re.child!==null||oe!==null&&oe.child!==null)for(J=Yf(J);J!==null;){if(oe=J[ji])return oe;J=Yf(J)}return re}J=oe,oe=J.parentNode}return null}function Ue(J){if(J=J[ji]||J[tt]){var re=J.tag;if(re===5||re===6||re===13||re===31||re===26||re===27||re===3)return J}return null}function ct(J){var re=J.tag;if(re===5||re===26||re===27||re===6)return J.stateNode;throw Error(O(33))}function vt(J){var re=J[kt];return re||(re=J[kt]={hoistableStyles:new Map,hoistableScripts:new Map}),re}function _t(J){J[Kt]=!0}var je=new Set,Gt={};function Yt(J,re){mn(J,re),mn(J+"Capture",re)}function mn(J,re){for(Gt[J]=re,J=0;J<re.length;J++)je.add(re[J])}var _n=RegExp("^[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"),zn={},Wn={};function $n(J){return yn.call(Wn,J)?!0:yn.call(zn,J)?!1:_n.test(J)?Wn[J]=!0:(zn[J]=!0,!1)}function jn(J,re,oe){if($n(re))if(oe===null)J.removeAttribute(re);else{switch(typeof oe){case"undefined":case"function":case"symbol":J.removeAttribute(re);return;case"boolean":var fe=re.toLowerCase().slice(0,5);if(fe!=="data-"&&fe!=="aria-"){J.removeAttribute(re);return}}J.setAttribute(re,""+oe)}}function fi(J,re,oe){if(oe===null)J.removeAttribute(re);else{switch(typeof oe){case"undefined":case"function":case"symbol":case"boolean":J.removeAttribute(re);return}J.setAttribute(re,""+oe)}}function vi(J,re,oe,fe){if(fe===null)J.removeAttribute(oe);else{switch(typeof fe){case"undefined":case"function":case"symbol":case"boolean":J.removeAttribute(oe);return}J.setAttributeNS(re,oe,""+fe)}}function pi(J){switch(typeof J){case"bigint":case"boolean":case"number":case"string":case"undefined":return J;case"object":return J;default:return""}}function Ti(J){var re=J.type;return(J=J.nodeName)&&J.toLowerCase()==="input"&&(re==="checkbox"||re==="radio")}function Hn(J,re,oe){var fe=Object.getOwnPropertyDescriptor(J.constructor.prototype,re);if(!J.hasOwnProperty(re)&&typeof fe<"u"&&typeof fe.get=="function"&&typeof fe.set=="function"){var xe=fe.get,Te=fe.set;return Object.defineProperty(J,re,{configurable:!0,get:function(){return xe.call(this)},set:function(Ie){oe=""+Ie,Te.call(this,Ie)}}),Object.defineProperty(J,re,{enumerable:fe.enumerable}),{getValue:function(){return oe},setValue:function(Ie){oe=""+Ie},stopTracking:function(){J._valueTracker=null,delete J[re]}}}}function Di(J){if(!J._valueTracker){var re=Ti(J)?"checked":"value";J._valueTracker=Hn(J,re,""+J[re])}}function ui(J){if(!J)return!1;var re=J._valueTracker;if(!re)return!0;var oe=re.getValue(),fe="";return J&&(fe=Ti(J)?J.checked?"true":"false":J.value),J=fe,J!==oe?(re.setValue(J),!0):!1}function Yi(J){if(J=J||(typeof document<"u"?document:void 0),typeof J>"u")return null;try{return J.activeElement||J.body}catch{return J.body}}var Yr=/[\n"\\]/g;function Bi(J){return J.replace(Yr,function(re){return"\\"+re.charCodeAt(0).toString(16)+" "})}function Lr(J,re,oe,fe,xe,Te,Ie,Ve){J.name="",Ie!=null&&typeof Ie!="function"&&typeof Ie!="symbol"&&typeof Ie!="boolean"?J.type=Ie:J.removeAttribute("type"),re!=null?Ie==="number"?(re===0&&J.value===""||J.value!=re)&&(J.value=""+pi(re)):J.value!==""+pi(re)&&(J.value=""+pi(re)):Ie!=="submit"&&Ie!=="reset"||J.removeAttribute("value"),re!=null?Wi(J,Ie,pi(re)):oe!=null?Wi(J,Ie,pi(oe)):fe!=null&&J.removeAttribute("value"),xe==null&&Te!=null&&(J.defaultChecked=!!Te),xe!=null&&(J.checked=xe&&typeof xe!="function"&&typeof xe!="symbol"),Ve!=null&&typeof Ve!="function"&&typeof Ve!="symbol"&&typeof Ve!="boolean"?J.name=""+pi(Ve):J.removeAttribute("name")}function Pi(J,re,oe,fe,xe,Te,Ie,Ve){if(Te!=null&&typeof Te!="function"&&typeof Te!="symbol"&&typeof Te!="boolean"&&(J.type=Te),re!=null||oe!=null){if(!(Te!=="submit"&&Te!=="reset"||re!=null)){Di(J);return}oe=oe!=null?""+pi(oe):"",re=re!=null?""+pi(re):oe,Ve||re===J.value||(J.value=re),J.defaultValue=re}fe=fe??xe,fe=typeof fe!="function"&&typeof fe!="symbol"&&!!fe,J.checked=Ve?J.checked:!!fe,J.defaultChecked=!!fe,Ie!=null&&typeof Ie!="function"&&typeof Ie!="symbol"&&typeof Ie!="boolean"&&(J.name=Ie),Di(J)}function Wi(J,re,oe){re==="number"&&Yi(J.ownerDocument)===J||J.defaultValue===""+oe||(J.defaultValue=""+oe)}function Ki(J,re,oe,fe){if(J=J.options,re){re={};for(var xe=0;xe<oe.length;xe++)re["$"+oe[xe]]=!0;for(oe=0;oe<J.length;oe++)xe=re.hasOwnProperty("$"+J[oe].value),J[oe].selected!==xe&&(J[oe].selected=xe),xe&&fe&&(J[oe].defaultSelected=!0)}else{for(oe=""+pi(oe),re=null,xe=0;xe<J.length;xe++){if(J[xe].value===oe){J[xe].selected=!0,fe&&(J[xe].defaultSelected=!0);return}re!==null||J[xe].disabled||(re=J[xe])}re!==null&&(re.selected=!0)}}function er(J,re,oe){if(re!=null&&(re=""+pi(re),re!==J.value&&(J.value=re),oe==null)){J.defaultValue!==re&&(J.defaultValue=re);return}J.defaultValue=oe!=null?""+pi(oe):""}function tr(J,re,oe,fe){if(re==null){if(fe!=null){if(oe!=null)throw Error(O(92));if(Pe(fe)){if(1<fe.length)throw Error(O(93));fe=fe[0]}oe=fe}oe==null&&(oe=""),re=oe}oe=pi(re),J.defaultValue=oe,fe=J.textContent,fe===oe&&fe!==""&&fe!==null&&(J.value=fe),Di(J)}function Mr(J,re){if(re){var oe=J.firstChild;if(oe&&oe===J.lastChild&&oe.nodeType===3){oe.nodeValue=re;return}}J.textContent=re}var Jn=new Set("animationIterationCount aspectRatio borderImageOutset borderImageSlice borderImageWidth boxFlex boxFlexGroup boxOrdinalGroup columnCount columns flex flexGrow flexPositive flexShrink flexNegative flexOrder gridArea gridRow gridRowEnd gridRowSpan gridRowStart gridColumn gridColumnEnd gridColumnSpan gridColumnStart fontWeight lineClamp lineHeight opacity order orphans scale tabSize widows zIndex zoom fillOpacity floodOpacity stopOpacity strokeDasharray strokeDashoffset strokeMiterlimit strokeOpacity strokeWidth MozAnimationIterationCount MozBoxFlex MozBoxFlexGroup MozLineClamp msAnimationIterationCount msFlex msZoom msFlexGrow msFlexNegative msFlexOrder msFlexPositive msFlexShrink msGridColumn msGridColumnSpan msGridRow msGridRowSpan WebkitAnimationIterationCount WebkitBoxFlex WebKitBoxFlexGroup WebkitBoxOrdinalGroup WebkitColumnCount WebkitColumns WebkitFlex WebkitFlexGrow WebkitFlexPositive WebkitFlexShrink WebkitLineClamp".split(" "));function ja(J,re,oe){var fe=re.indexOf("--")===0;oe==null||typeof oe=="boolean"||oe===""?fe?J.setProperty(re,""):re==="float"?J.cssFloat="":J[re]="":fe?J.setProperty(re,oe):typeof oe!="number"||oe===0||Jn.has(re)?re==="float"?J.cssFloat=oe:J[re]=(""+oe).trim():J[re]=oe+"px"}function ni(J,re,oe){if(re!=null&&typeof re!="object")throw Error(O(62));if(J=J.style,oe!=null){for(var fe in oe)!oe.hasOwnProperty(fe)||re!=null&&re.hasOwnProperty(fe)||(fe.indexOf("--")===0?J.setProperty(fe,""):fe==="float"?J.cssFloat="":J[fe]="");for(var xe in re)fe=re[xe],re.hasOwnProperty(xe)&&oe[xe]!==fe&&ja(J,xe,fe)}else for(var Te in re)re.hasOwnProperty(Te)&&ja(J,Te,re[Te])}function ti(J){if(J.indexOf("-")===-1)return!1;switch(J){case"annotation-xml":case"color-profile":case"font-face":case"font-face-src":case"font-face-uri":case"font-face-format":case"font-face-name":case"missing-glyph":return!1;default:return!0}}var Ha=new Map([["acceptCharset","accept-charset"],["htmlFor","for"],["httpEquiv","http-equiv"],["crossOrigin","crossorigin"],["accentHeight","accent-height"],["alignmentBaseline","alignment-baseline"],["arabicForm","arabic-form"],["baselineShift","baseline-shift"],["capHeight","cap-height"],["clipPath","clip-path"],["clipRule","clip-rule"],["colorInterpolation","color-interpolation"],["colorInterpolationFilters","color-interpolation-filters"],["colorProfile","color-profile"],["colorRendering","color-rendering"],["dominantBaseline","dominant-baseline"],["enableBackground","enable-background"],["fillOpacity","fill-opacity"],["fillRule","fill-rule"],["floodColor","flood-color"],["floodOpacity","flood-opacity"],["fontFamily","font-family"],["fontSize","font-size"],["fontSizeAdjust","font-size-adjust"],["fontStretch","font-stretch"],["fontStyle","font-style"],["fontVariant","font-variant"],["fontWeight","font-weight"],["glyphName","glyph-name"],["glyphOrientationHorizontal","glyph-orientation-horizontal"],["glyphOrientationVertical","glyph-orientation-vertical"],["horizAdvX","horiz-adv-x"],["horizOriginX","horiz-origin-x"],["imageRendering","image-rendering"],["letterSpacing","letter-spacing"],["lightingColor","lighting-color"],["markerEnd","marker-end"],["markerMid","marker-mid"],["markerStart","marker-start"],["overlinePosition","overline-position"],["overlineThickness","overline-thickness"],["paintOrder","paint-order"],["panose-1","panose-1"],["pointerEvents","pointer-events"],["renderingIntent","rendering-intent"],["shapeRendering","shape-rendering"],["stopColor","stop-color"],["stopOpacity","stop-opacity"],["strikethroughPosition","strikethrough-position"],["strikethroughThickness","strikethrough-thickness"],["strokeDasharray","stroke-dasharray"],["strokeDashoffset","stroke-dashoffset"],["strokeLinecap","stroke-linecap"],["strokeLinejoin","stroke-linejoin"],["strokeMiterlimit","stroke-miterlimit"],["strokeOpacity","stroke-opacity"],["strokeWidth","stroke-width"],["textAnchor","text-anchor"],["textDecoration","text-decoration"],["textRendering","text-rendering"],["transformOrigin","transform-origin"],["underlinePosition","underline-position"],["underlineThickness","underline-thickness"],["unicodeBidi","unicode-bidi"],["unicodeRange","unicode-range"],["unitsPerEm","units-per-em"],["vAlphabetic","v-alphabetic"],["vHanging","v-hanging"],["vIdeographic","v-ideographic"],["vMathematical","v-mathematical"],["vectorEffect","vector-effect"],["vertAdvY","vert-adv-y"],["vertOriginX","vert-origin-x"],["vertOriginY","vert-origin-y"],["wordSpacing","word-spacing"],["writingMode","writing-mode"],["xmlnsXlink","xmlns:xlink"],["xHeight","x-height"]]),ca=/^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*:/i;function Qs(J){return ca.test(""+J)?"javascript:throw new Error('React has blocked a javascript: URL as a security precaution.')":J}function Nr(){}var ua=null;function da(J){return J=J.target||J.srcElement||window,J.correspondingUseElement&&(J=J.correspondingUseElement),J.nodeType===3?J.parentNode:J}var ss=null,as=null;function Qa(J){var re=Ue(J);if(re&&(J=re.stateNode)){var oe=J[Ge]||null;e:switch(J=re.stateNode,re.type){case"input":if(Lr(J,oe.value,oe.defaultValue,oe.defaultValue,oe.checked,oe.defaultChecked,oe.type,oe.name),re=oe.name,oe.type==="radio"&&re!=null){for(oe=J;oe.parentNode;)oe=oe.parentNode;for(oe=oe.querySelectorAll('input[name="'+Bi(""+re)+'"][type="radio"]'),re=0;re<oe.length;re++){var fe=oe[re];if(fe!==J&&fe.form===J.form){var xe=fe[Ge]||null;if(!xe)throw Error(O(90));Lr(fe,xe.value,xe.defaultValue,xe.defaultValue,xe.checked,xe.defaultChecked,xe.type,xe.name)}}for(re=0;re<oe.length;re++)fe=oe[re],fe.form===J.form&&ui(fe)}break e;case"textarea":er(J,oe.value,oe.defaultValue);break e;case"select":re=oe.value,re!=null&&Ki(J,!!oe.multiple,re,!1)}}}var ha=!1;function qa(J,re,oe){if(ha)return J(re,oe);ha=!0;try{var fe=J(re);return fe}finally{if(ha=!1,(ss!==null||as!==null)&&(ml(),ss&&(re=ss,J=as,as=ss=null,Qa(re),J)))for(re=0;re<J.length;re++)Qa(J[re])}}function Es(J,re){var oe=J.stateNode;if(oe===null)return null;var fe=oe[Ge]||null;if(fe===null)return null;oe=fe[re];e:switch(re){case"onClick":case"onClickCapture":case"onDoubleClick":case"onDoubleClickCapture":case"onMouseDown":case"onMouseDownCapture":case"onMouseMove":case"onMouseMoveCapture":case"onMouseUp":case"onMouseUpCapture":case"onMouseEnter":(fe=!fe.disabled)||(J=J.type,fe=!(J==="button"||J==="input"||J==="select"||J==="textarea")),J=!fe;break e;default:J=!1}if(J)return null;if(oe&&typeof oe!="function")throw Error(O(231,re,typeof oe));return oe}var Fr=!(typeof window>"u"||typeof window.document>"u"||typeof window.document.createElement>"u"),fa=!1;if(Fr)try{var De={};Object.defineProperty(De,"passive",{get:function(){fa=!0}}),window.addEventListener("test",De,De),window.removeEventListener("test",De,De)}catch{fa=!1}var $e=null,Ye=null,ot=null;function Tt(){if(ot)return ot;var J,re=Ye,oe=re.length,fe,xe="value"in $e?$e.value:$e.textContent,Te=xe.length;for(J=0;J<oe&&re[J]===xe[J];J++);var Ie=oe-J;for(fe=1;fe<=Ie&&re[oe-fe]===xe[Te-fe];fe++);return ot=xe.slice(J,1<fe?1-fe:void 0)}function Pt(J){var re=J.keyCode;return"charCode"in J?(J=J.charCode,J===0&&re===13&&(J=13)):J=re,J===10&&(J=13),32<=J||J===13?J:0}function un(){return!0}function Fn(){return!1}function Xn(J){function re(oe,fe,xe,Te,Ie){this._reactName=oe,this._targetInst=xe,this.type=fe,this.nativeEvent=Te,this.target=Ie,this.currentTarget=null;for(var Ve in J)J.hasOwnProperty(Ve)&&(oe=J[Ve],this[Ve]=oe?oe(Te):Te[Ve]);return this.isDefaultPrevented=(Te.defaultPrevented!=null?Te.defaultPrevented:Te.returnValue===!1)?un:Fn,this.isPropagationStopped=Fn,this}return Y(re.prototype,{preventDefault:function(){this.defaultPrevented=!0;var oe=this.nativeEvent;oe&&(oe.preventDefault?oe.preventDefault():typeof oe.returnValue!="unknown"&&(oe.returnValue=!1),this.isDefaultPrevented=un)},stopPropagation:function(){var oe=this.nativeEvent;oe&&(oe.stopPropagation?oe.stopPropagation():typeof oe.cancelBubble!="unknown"&&(oe.cancelBubble=!0),this.isPropagationStopped=un)},persist:function(){},isPersistent:un}),re}var ei={eventPhase:0,bubbles:0,cancelable:0,timeStamp:function(J){return J.timeStamp||Date.now()},defaultPrevented:0,isTrusted:0},Gi=Xn(ei),Ar=Y({},ei,{view:0,detail:0}),br=Xn(Ar),Ut,di,Li,xr=Y({},Ar,{screenX:0,screenY:0,clientX:0,clientY:0,pageX:0,pageY:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,getModifierState:$l,button:0,buttons:0,relatedTarget:function(J){return J.relatedTarget===void 0?J.fromElement===J.srcElement?J.toElement:J.fromElement:J.relatedTarget},movementX:function(J){return"movementX"in J?J.movementX:(J!==Li&&(Li&&J.type==="mousemove"?(Ut=J.screenX-Li.screenX,di=J.screenY-Li.screenY):di=Ut=0,Li=J),Ut)},movementY:function(J){return"movementY"in J?J.movementY:di}}),os=Xn(xr),xp=Y({},xr,{dataTransfer:0}),yp=Xn(xp),vp=Y({},Ar,{relatedTarget:0}),Ul=Xn(vp),Ep=Y({},ei,{animationName:0,elapsedTime:0,pseudoElement:0}),Tp=Xn(Ep),Sp=Y({},ei,{clipboardData:function(J){return"clipboardData"in J?J.clipboardData:window.clipboardData}}),wp=Xn(Sp),Mp=Y({},ei,{data:0}),ku=Xn(Mp),Cp={Esc:"Escape",Spacebar:" ",Left:"ArrowLeft",Up:"ArrowUp",Right:"ArrowRight",Down:"ArrowDown",Del:"Delete",Win:"OS",Menu:"ContextMenu",Apps:"ContextMenu",Scroll:"ScrollLock",MozPrintableKey:"Unidentified"},Ip={8:"Backspace",9:"Tab",12:"Clear",13:"Enter",16:"Shift",17:"Control",18:"Alt",19:"Pause",20:"CapsLock",27:"Escape",32:" ",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"ArrowLeft",38:"ArrowUp",39:"ArrowRight",40:"ArrowDown",45:"Insert",46:"Delete",112:"F1",113:"F2",114:"F3",115:"F4",116:"F5",117:"F6",118:"F7",119:"F8",120:"F9",121:"F10",122:"F11",123:"F12",144:"NumLock",145:"ScrollLock",224:"Meta"},Rp={Alt:"altKey",Control:"ctrlKey",Meta:"metaKey",Shift:"shiftKey"};function Dp(J){var re=this.nativeEvent;return re.getModifierState?re.getModifierState(J):(J=Rp[J])?!!re[J]:!1}function $l(){return Dp}var Bp=Y({},Ar,{key:function(J){if(J.key){var re=Cp[J.key]||J.key;if(re!=="Unidentified")return re}return J.type==="keypress"?(J=Pt(J),J===13?"Enter":String.fromCharCode(J)):J.type==="keydown"||J.type==="keyup"?Ip[J.keyCode]||"Unidentified":""},code:0,location:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,repeat:0,locale:0,getModifierState:$l,charCode:function(J){return J.type==="keypress"?Pt(J):0},keyCode:function(J){return J.type==="keydown"||J.type==="keyup"?J.keyCode:0},which:function(J){return J.type==="keypress"?Pt(J):J.type==="keydown"||J.type==="keyup"?J.keyCode:0}}),Pp=Xn(Bp),Op=Y({},xr,{pointerId:0,width:0,height:0,pressure:0,tangentialPressure:0,tiltX:0,tiltY:0,twist:0,pointerType:0,isPrimary:0}),Uu=Xn(Op),Lp=Y({},Ar,{touches:0,targetTouches:0,changedTouches:0,altKey:0,metaKey:0,ctrlKey:0,shiftKey:0,getModifierState:$l}),Np=Xn(Lp),Fp=Y({},ei,{propertyName:0,elapsedTime:0,pseudoElement:0}),kp=Xn(Fp),Up=Y({},xr,{deltaX:function(J){return"deltaX"in J?J.deltaX:"wheelDeltaX"in J?-J.wheelDeltaX:0},deltaY:function(J){return"deltaY"in J?J.deltaY:"wheelDeltaY"in J?-J.wheelDeltaY:"wheelDelta"in J?-J.wheelDelta:0},deltaZ:0,deltaMode:0}),$p=Xn(Up),Vp=Y({},ei,{newState:0,oldState:0}),Gp=Xn(Vp),zp=[9,13,27,32],Vl=Fr&&"CompositionEvent"in window,Wa=null;Fr&&"documentMode"in document&&(Wa=document.documentMode);var jp=Fr&&"TextEvent"in window&&!Wa,$u=Fr&&(!Vl||Wa&&8<Wa&&11>=Wa),Vu=" ",Gu=!1;function zu(J,re){switch(J){case"keyup":return zp.indexOf(re.keyCode)!==-1;case"keydown":return re.keyCode!==229;case"keypress":case"mousedown":case"focusout":return!0;default:return!1}}function ju(J){return J=J.detail,typeof J=="object"&&"data"in J?J.data:null}var pa=!1;function Hp(J,re){switch(J){case"compositionend":return ju(re);case"keypress":return re.which!==32?null:(Gu=!0,Vu);case"textInput":return J=re.data,J===Vu&&Gu?null:J;default:return null}}function Qp(J,re){if(pa)return J==="compositionend"||!Vl&&zu(J,re)?(J=Tt(),ot=Ye=$e=null,pa=!1,J):null;switch(J){case"paste":return null;case"keypress":if(!(re.ctrlKey||re.altKey||re.metaKey)||re.ctrlKey&&re.altKey){if(re.char&&1<re.char.length)return re.char;if(re.which)return String.fromCharCode(re.which)}return null;case"compositionend":return $u&&re.locale!=="ko"?null:re.data;default:return null}}var qp={color:!0,date:!0,datetime:!0,"datetime-local":!0,email:!0,month:!0,number:!0,password:!0,range:!0,search:!0,tel:!0,text:!0,time:!0,url:!0,week:!0};function Hu(J){var re=J&&J.nodeName&&J.nodeName.toLowerCase();return re==="input"?!!qp[J.type]:re==="textarea"}function Qu(J,re,oe,fe){ss?as?as.push(fe):as=[fe]:ss=fe,re=El(re,"onChange"),0<re.length&&(oe=new Gi("onChange","change",null,oe,fe),J.push({event:oe,listeners:re}))}var Xa=null,Ya=null;function Wp(J){Nf(J,0)}function Po(J){var re=ct(J);if(ui(re))return J}function qu(J,re){if(J==="change")return re}var Wu=!1;if(Fr){var Gl;if(Fr){var zl="oninput"in document;if(!zl){var Xu=document.createElement("div");Xu.setAttribute("oninput","return;"),zl=typeof Xu.oninput=="function"}Gl=zl}else Gl=!1;Wu=Gl&&(!document.documentMode||9<document.documentMode)}function Yu(){Xa&&(Xa.detachEvent("onpropertychange",Ku),Ya=Xa=null)}function Ku(J){if(J.propertyName==="value"&&Po(Ya)){var re=[];Qu(re,Ya,J,da(J)),qa(Wp,re)}}function Xp(J,re,oe){J==="focusin"?(Yu(),Xa=re,Ya=oe,Xa.attachEvent("onpropertychange",Ku)):J==="focusout"&&Yu()}function Yp(J){if(J==="selectionchange"||J==="keyup"||J==="keydown")return Po(Ya)}function Kp(J,re){if(J==="click")return Po(re)}function Jp(J,re){if(J==="input"||J==="change")return Po(re)}function Zp(J,re){return J===re&&(J!==0||1/J===1/re)||J!==J&&re!==re}var Cr=typeof Object.is=="function"?Object.is:Zp;function Ka(J,re){if(Cr(J,re))return!0;if(typeof J!="object"||J===null||typeof re!="object"||re===null)return!1;var oe=Object.keys(J),fe=Object.keys(re);if(oe.length!==fe.length)return!1;for(fe=0;fe<oe.length;fe++){var xe=oe[fe];if(!yn.call(re,xe)||!Cr(J[xe],re[xe]))return!1}return!0}function Ju(J){for(;J&&J.firstChild;)J=J.firstChild;return J}function Zu(J,re){var oe=Ju(J);J=0;for(var fe;oe;){if(oe.nodeType===3){if(fe=J+oe.textContent.length,J<=re&&fe>=re)return{node:oe,offset:re-J};J=fe}e:{for(;oe;){if(oe.nextSibling){oe=oe.nextSibling;break e}oe=oe.parentNode}oe=void 0}oe=Ju(oe)}}function ed(J,re){return J&&re?J===re?!0:J&&J.nodeType===3?!1:re&&re.nodeType===3?ed(J,re.parentNode):"contains"in J?J.contains(re):J.compareDocumentPosition?!!(J.compareDocumentPosition(re)&16):!1:!1}function nd(J){J=J!=null&&J.ownerDocument!=null&&J.ownerDocument.defaultView!=null?J.ownerDocument.defaultView:window;for(var re=Yi(J.document);re instanceof J.HTMLIFrameElement;){try{var oe=typeof re.contentWindow.location.href=="string"}catch{oe=!1}if(oe)J=re.contentWindow;else break;re=Yi(J.document)}return re}function jl(J){var re=J&&J.nodeName&&J.nodeName.toLowerCase();return re&&(re==="input"&&(J.type==="text"||J.type==="search"||J.type==="tel"||J.type==="url"||J.type==="password")||re==="textarea"||J.contentEditable==="true")}var em=Fr&&"documentMode"in document&&11>=document.documentMode,ma=null,Hl=null,Ja=null,Ql=!1;function rd(J,re,oe){var fe=oe.window===oe?oe.document:oe.nodeType===9?oe:oe.ownerDocument;Ql||ma==null||ma!==Yi(fe)||(fe=ma,"selectionStart"in fe&&jl(fe)?fe={start:fe.selectionStart,end:fe.selectionEnd}:(fe=(fe.ownerDocument&&fe.ownerDocument.defaultView||window).getSelection(),fe={anchorNode:fe.anchorNode,anchorOffset:fe.anchorOffset,focusNode:fe.focusNode,focusOffset:fe.focusOffset}),Ja&&Ka(Ja,fe)||(Ja=fe,fe=El(Hl,"onSelect"),0<fe.length&&(re=new Gi("onSelect","select",null,re,oe),J.push({event:re,listeners:fe}),re.target=ma)))}function qs(J,re){var oe={};return oe[J.toLowerCase()]=re.toLowerCase(),oe["Webkit"+J]="webkit"+re,oe["Moz"+J]="moz"+re,oe}var ga={animationend:qs("Animation","AnimationEnd"),animationiteration:qs("Animation","AnimationIteration"),animationstart:qs("Animation","AnimationStart"),transitionrun:qs("Transition","TransitionRun"),transitionstart:qs("Transition","TransitionStart"),transitioncancel:qs("Transition","TransitionCancel"),transitionend:qs("Transition","TransitionEnd")},ql={},sd={};Fr&&(sd=document.createElement("div").style,"AnimationEvent"in window||(delete ga.animationend.animation,delete ga.animationiteration.animation,delete ga.animationstart.animation),"TransitionEvent"in window||delete ga.transitionend.transition);function Ws(J){if(ql[J])return ql[J];if(!ga[J])return J;var re=ga[J],oe;for(oe in re)if(re.hasOwnProperty(oe)&&oe in sd)return ql[J]=re[oe];return J}var ad=Ws("animationend"),od=Ws("animationiteration"),ld=Ws("animationstart"),tm=Ws("transitionrun"),nm=Ws("transitionstart"),im=Ws("transitioncancel"),cd=Ws("transitionend"),ud=new Map,Wl="abort auxClick beforeToggle cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");Wl.push("scrollEnd");function Kr(J,re){ud.set(J,re),Yt(re,[J])}var Oo=typeof reportError=="function"?reportError:function(J){if(typeof window=="object"&&typeof window.ErrorEvent=="function"){var re=new window.ErrorEvent("error",{bubbles:!0,cancelable:!0,message:typeof J=="object"&&J!==null&&typeof J.message=="string"?String(J.message):String(J),error:J});if(!window.dispatchEvent(re))return}else if(typeof process=="object"&&typeof process.emit=="function"){process.emit("uncaughtException",J);return}console.error(J)},kr=[],Aa=0,Xl=0;function Lo(){for(var J=Aa,re=Xl=Aa=0;re<J;){var oe=kr[re];kr[re++]=null;var fe=kr[re];kr[re++]=null;var xe=kr[re];kr[re++]=null;var Te=kr[re];if(kr[re++]=null,fe!==null&&xe!==null){var Ie=fe.pending;Ie===null?xe.next=xe:(xe.next=Ie.next,Ie.next=xe),fe.pending=xe}Te!==0&&dd(oe,xe,Te)}}function No(J,re,oe,fe){kr[Aa++]=J,kr[Aa++]=re,kr[Aa++]=oe,kr[Aa++]=fe,Xl|=fe,J.lanes|=fe,J=J.alternate,J!==null&&(J.lanes|=fe)}function Yl(J,re,oe,fe){return No(J,re,oe,fe),Fo(J)}function Xs(J,re){return No(J,null,null,re),Fo(J)}function dd(J,re,oe){J.lanes|=oe;var fe=J.alternate;fe!==null&&(fe.lanes|=oe);for(var xe=!1,Te=J.return;Te!==null;)Te.childLanes|=oe,fe=Te.alternate,fe!==null&&(fe.childLanes|=oe),Te.tag===22&&(J=Te.stateNode,J===null||J._visibility&1||(xe=!0)),J=Te,Te=Te.return;return J.tag===3?(Te=J.stateNode,xe&&re!==null&&(xe=31-Sn(oe),J=Te.hiddenUpdates,fe=J[xe],fe===null?J[xe]=[re]:fe.push(re),re.lane=oe|536870912),Te):null}function Fo(J){if(50<vo)throw vo=0,lu=null,Error(O(185));for(var re=J.return;re!==null;)J=re,re=J.return;return J.tag===3?J.stateNode:null}var ba={};function rm(J,re,oe,fe){this.tag=J,this.key=oe,this.sibling=this.child=this.return=this.stateNode=this.type=this.elementType=null,this.index=0,this.refCleanup=this.ref=null,this.pendingProps=re,this.dependencies=this.memoizedState=this.updateQueue=this.memoizedProps=null,this.mode=fe,this.subtreeFlags=this.flags=0,this.deletions=null,this.childLanes=this.lanes=0,this.alternate=null}function Ir(J,re,oe,fe){return new rm(J,re,oe,fe)}function Kl(J){return J=J.prototype,!(!J||!J.isReactComponent)}function ls(J,re){var oe=J.alternate;return oe===null?(oe=Ir(J.tag,re,J.key,J.mode),oe.elementType=J.elementType,oe.type=J.type,oe.stateNode=J.stateNode,oe.alternate=J,J.alternate=oe):(oe.pendingProps=re,oe.type=J.type,oe.flags=0,oe.subtreeFlags=0,oe.deletions=null),oe.flags=J.flags&65011712,oe.childLanes=J.childLanes,oe.lanes=J.lanes,oe.child=J.child,oe.memoizedProps=J.memoizedProps,oe.memoizedState=J.memoizedState,oe.updateQueue=J.updateQueue,re=J.dependencies,oe.dependencies=re===null?null:{lanes:re.lanes,firstContext:re.firstContext},oe.sibling=J.sibling,oe.index=J.index,oe.ref=J.ref,oe.refCleanup=J.refCleanup,oe}function hd(J,re){J.flags&=65011714;var oe=J.alternate;return oe===null?(J.childLanes=0,J.lanes=re,J.child=null,J.subtreeFlags=0,J.memoizedProps=null,J.memoizedState=null,J.updateQueue=null,J.dependencies=null,J.stateNode=null):(J.childLanes=oe.childLanes,J.lanes=oe.lanes,J.child=oe.child,J.subtreeFlags=0,J.deletions=null,J.memoizedProps=oe.memoizedProps,J.memoizedState=oe.memoizedState,J.updateQueue=oe.updateQueue,J.type=oe.type,re=oe.dependencies,J.dependencies=re===null?null:{lanes:re.lanes,firstContext:re.firstContext}),J}function ko(J,re,oe,fe,xe,Te){var Ie=0;if(fe=J,typeof J=="function")Kl(J)&&(Ie=1);else if(typeof J=="string")Ie=ug(J,oe,Lt.current)?26:J==="html"||J==="head"||J==="body"?27:5;else e:switch(J){case Ee:return J=Ir(31,oe,re,xe),J.elementType=Ee,J.lanes=Te,J;case le:return Ys(oe.children,xe,Te,re);case ce:Ie=8,xe|=24;break;case he:return J=Ir(12,oe,re,xe|2),J.elementType=he,J.lanes=Te,J;case ge:return J=Ir(13,oe,re,xe),J.elementType=ge,J.lanes=Te,J;case ve:return J=Ir(19,oe,re,xe),J.elementType=ve,J.lanes=Te,J;default:if(typeof J=="object"&&J!==null)switch(J.$$typeof){case me:Ie=10;break e;case pe:Ie=9;break e;case be:Ie=11;break e;case Se:Ie=14;break e;case Me:Ie=16,fe=null;break e}Ie=29,oe=Error(O(130,J===null?"null":typeof J,"")),fe=null}return re=Ir(Ie,oe,re,xe),re.elementType=J,re.type=fe,re.lanes=Te,re}function Ys(J,re,oe,fe){return J=Ir(7,J,fe,re),J.lanes=oe,J}function Jl(J,re,oe){return J=Ir(6,J,null,re),J.lanes=oe,J}function fd(J){var re=Ir(18,null,null,0);return re.stateNode=J,re}function Zl(J,re,oe){return re=Ir(4,J.children!==null?J.children:[],J.key,re),re.lanes=oe,re.stateNode={containerInfo:J.containerInfo,pendingChildren:null,implementation:J.implementation},re}var pd=new WeakMap;function Ur(J,re){if(typeof J=="object"&&J!==null){var oe=pd.get(J);return oe!==void 0?oe:(re={value:J,source:re,stack:ai(re)},pd.set(J,re),re)}return{value:J,source:re,stack:ai(re)}}var xa=[],ya=0,Uo=null,Za=0,$r=[],Vr=0,Ts=null,ts=1,ns="";function cs(J,re){xa[ya++]=Za,xa[ya++]=Uo,Uo=J,Za=re}function md(J,re,oe){$r[Vr++]=ts,$r[Vr++]=ns,$r[Vr++]=Ts,Ts=J;var fe=ts;J=ns;var xe=32-Sn(fe)-1;fe&=~(1<<xe),oe+=1;var Te=32-Sn(re)+xe;if(30<Te){var Ie=xe-xe%5;Te=(fe&(1<<Ie)-1).toString(32),fe>>=Ie,xe-=Ie,ts=1<<32-Sn(re)+xe|oe<<xe|fe,ns=Te+J}else ts=1<<Te|oe<<xe|fe,ns=J}function tc(J){J.return!==null&&(cs(J,1),md(J,1,0))}function nc(J){for(;J===Uo;)Uo=xa[--ya],xa[ya]=null,Za=xa[--ya],xa[ya]=null;for(;J===Ts;)Ts=$r[--Vr],$r[Vr]=null,ns=$r[--Vr],$r[Vr]=null,ts=$r[--Vr],$r[Vr]=null}function gd(J,re){$r[Vr++]=ts,$r[Vr++]=ns,$r[Vr++]=Ts,ts=re.id,ns=re.overflow,Ts=J}var fr=null,Hi=null,Ei=!1,Ss=null,Gr=!1,ic=Error(O(519));function ws(J){var re=Error(O(418,1<arguments.length&&arguments[1]!==void 0&&arguments[1]?"text":"HTML",""));throw eo(Ur(re,J)),ic}function Ad(J){var re=J.stateNode,oe=J.type,fe=J.memoizedProps;switch(re[ji]=J,re[Ge]=fe,oe){case"dialog":gi("cancel",re),gi("close",re);break;case"iframe":case"object":case"embed":gi("load",re);break;case"video":case"audio":for(oe=0;oe<To.length;oe++)gi(To[oe],re);break;case"source":gi("error",re);break;case"img":case"image":case"link":gi("error",re),gi("load",re);break;case"details":gi("toggle",re);break;case"input":gi("invalid",re),Pi(re,fe.value,fe.defaultValue,fe.checked,fe.defaultChecked,fe.type,fe.name,!0);break;case"select":gi("invalid",re);break;case"textarea":gi("invalid",re),tr(re,fe.value,fe.defaultValue,fe.children)}oe=fe.children,typeof oe!="string"&&typeof oe!="number"&&typeof oe!="bigint"||re.textContent===""+oe||fe.suppressHydrationWarning===!0||$f(re.textContent,oe)?(fe.popover!=null&&(gi("beforetoggle",re),gi("toggle",re)),fe.onScroll!=null&&gi("scroll",re),fe.onScrollEnd!=null&&gi("scrollend",re),fe.onClick!=null&&(re.onclick=Nr),re=!0):re=!1,re||ws(J,!0)}function bd(J){for(fr=J.return;fr;)switch(fr.tag){case 5:case 31:case 13:Gr=!1;return;case 27:case 3:Gr=!0;return;default:fr=fr.return}}function va(J){if(J!==fr)return!1;if(!Ei)return bd(J),Ei=!0,!1;var re=J.tag,oe;if((oe=re!==3&&re!==27)&&((oe=re===5)&&(oe=J.type,oe=!(oe!=="form"&&oe!=="button")||Eu(J.type,J.memoizedProps)),oe=!oe),oe&&Hi&&ws(J),bd(J),re===13){if(J=J.memoizedState,J=J!==null?J.dehydrated:null,!J)throw Error(O(317));Hi=Xf(J)}else if(re===31){if(J=J.memoizedState,J=J!==null?J.dehydrated:null,!J)throw Error(O(317));Hi=Xf(J)}else re===27?(re=Hi,$s(J.type)?(J=Cu,Cu=null,Hi=J):Hi=re):Hi=fr?jr(J.stateNode.nextSibling):null;return!0}function Ks(){Hi=fr=null,Ei=!1}function rc(){var J=Ss;return J!==null&&(Tr===null?Tr=J:Tr.push.apply(Tr,J),Ss=null),J}function eo(J){Ss===null?Ss=[J]:Ss.push(J)}var sc=ke(null),Js=null,us=null;function Ms(J,re,oe){St(sc,re._currentValue),re._currentValue=oe}function ds(J){J._currentValue=sc.current,rt(sc)}function ac(J,re,oe){for(;J!==null;){var fe=J.alternate;if((J.childLanes&re)!==re?(J.childLanes|=re,fe!==null&&(fe.childLanes|=re)):fe!==null&&(fe.childLanes&re)!==re&&(fe.childLanes|=re),J===oe)break;J=J.return}}function oc(J,re,oe,fe){var xe=J.child;for(xe!==null&&(xe.return=J);xe!==null;){var Te=xe.dependencies;if(Te!==null){var Ie=xe.child;Te=Te.firstContext;e:for(;Te!==null;){var Ve=Te;Te=xe;for(var at=0;at<re.length;at++)if(Ve.context===re[at]){Te.lanes|=oe,Ve=Te.alternate,Ve!==null&&(Ve.lanes|=oe),ac(Te.return,oe,J),fe||(Ie=null);break e}Te=Ve.next}}else if(xe.tag===18){if(Ie=xe.return,Ie===null)throw Error(O(341));Ie.lanes|=oe,Te=Ie.alternate,Te!==null&&(Te.lanes|=oe),ac(Ie,oe,J),Ie=null}else Ie=xe.child;if(Ie!==null)Ie.return=xe;else for(Ie=xe;Ie!==null;){if(Ie===J){Ie=null;break}if(xe=Ie.sibling,xe!==null){xe.return=Ie.return,Ie=xe;break}Ie=Ie.return}xe=Ie}}function Ea(J,re,oe,fe){J=null;for(var xe=re,Te=!1;xe!==null;){if(!Te){if((xe.flags&524288)!==0)Te=!0;else if((xe.flags&262144)!==0)break}if(xe.tag===10){var Ie=xe.alternate;if(Ie===null)throw Error(O(387));if(Ie=Ie.memoizedProps,Ie!==null){var Ve=xe.type;Cr(xe.pendingProps.value,Ie.value)||(J!==null?J.push(Ve):J=[Ve])}}else if(xe===bt.current){if(Ie=xe.alternate,Ie===null)throw Error(O(387));Ie.memoizedState.memoizedState!==xe.memoizedState.memoizedState&&(J!==null?J.push(Io):J=[Io])}xe=xe.return}J!==null&&oc(re,J,oe,fe),re.flags|=262144}function $o(J){for(J=J.firstContext;J!==null;){if(!Cr(J.context._currentValue,J.memoizedValue))return!0;J=J.next}return!1}function Zs(J){Js=J,us=null,J=J.dependencies,J!==null&&(J.firstContext=null)}function pr(J){return xd(Js,J)}function Vo(J,re){return Js===null&&Zs(J),xd(J,re)}function xd(J,re){var oe=re._currentValue;if(re={context:re,memoizedValue:oe,next:null},us===null){if(J===null)throw Error(O(308));us=re,J.dependencies={lanes:0,firstContext:re},J.flags|=524288}else us=us.next=re;return oe}var sm=typeof AbortController<"u"?AbortController:function(){var J=[],re=this.signal={aborted:!1,addEventListener:function(oe,fe){J.push(fe)}};this.abort=function(){re.aborted=!0,J.forEach(function(oe){return oe()})}},am=F.unstable_scheduleCallback,om=F.unstable_NormalPriority,rr={$$typeof:me,Consumer:null,Provider:null,_currentValue:null,_currentValue2:null,_threadCount:0};function cc(){return{controller:new sm,data:new Map,refCount:0}}function to(J){J.refCount--,J.refCount===0&&am(om,function(){J.controller.abort()})}var no=null,uc=0,Ta=0,Sa=null;function lm(J,re){if(no===null){var oe=no=[];uc=0,Ta=pu(),Sa={status:"pending",value:void 0,then:function(fe){oe.push(fe)}}}return uc++,re.then(yd,yd),re}function yd(){if(--uc===0&&no!==null){Sa!==null&&(Sa.status="fulfilled");var J=no;no=null,Ta=0,Sa=null;for(var re=0;re<J.length;re++)(0,J[re])()}}function cm(J,re){var oe=[],fe={status:"pending",value:null,reason:null,then:function(xe){oe.push(xe)}};return J.then(function(){fe.status="fulfilled",fe.value=re;for(var xe=0;xe<oe.length;xe++)(0,oe[xe])(re)},function(xe){for(fe.status="rejected",fe.reason=xe,xe=0;xe<oe.length;xe++)(0,oe[xe])(void 0)}),fe}var vd=Ce.S;Ce.S=function(J,re){lf=Fe(),typeof re=="object"&&re!==null&&typeof re.then=="function"&&lm(J,re),vd!==null&&vd(J,re)};var ea=ke(null);function dc(){var J=ea.current;return J!==null?J:zi.pooledCache}function Go(J,re){re===null?St(ea,ea.current):St(ea,re.pool)}function Ed(){var J=dc();return J===null?null:{parent:rr._currentValue,pool:J}}var wa=Error(O(460)),hc=Error(O(474)),zo=Error(O(542)),jo={then:function(){}};function Td(J){return J=J.status,J==="fulfilled"||J==="rejected"}function Sd(J,re,oe){switch(oe=J[oe],oe===void 0?J.push(re):oe!==re&&(re.then(Nr,Nr),re=oe),re.status){case"fulfilled":return re.value;case"rejected":throw J=re.reason,Md(J),J;default:if(typeof re.status=="string")re.then(Nr,Nr);else{if(J=zi,J!==null&&100<J.shellSuspendCounter)throw Error(O(482));J=re,J.status="pending",J.then(function(fe){if(re.status==="pending"){var xe=re;xe.status="fulfilled",xe.value=fe}},function(fe){if(re.status==="pending"){var xe=re;xe.status="rejected",xe.reason=fe}})}switch(re.status){case"fulfilled":return re.value;case"rejected":throw J=re.reason,Md(J),J}throw na=re,wa}}function ta(J){try{var re=J._init;return re(J._payload)}catch(oe){throw oe!==null&&typeof oe=="object"&&typeof oe.then=="function"?(na=oe,wa):oe}}var na=null;function wd(){if(na===null)throw Error(O(459));var J=na;return na=null,J}function Md(J){if(J===wa||J===zo)throw Error(O(483))}var Ma=null,io=0;function Ho(J){var re=io;return io+=1,Ma===null&&(Ma=[]),Sd(Ma,J,re)}function ro(J,re){re=re.props.ref,J.ref=re!==void 0?re:null}function Qo(J,re){throw re.$$typeof===W?Error(O(525)):(J=Object.prototype.toString.call(re),Error(O(31,J==="[object Object]"?"object with keys {"+Object.keys(re).join(", ")+"}":J)))}function Cd(J){function re(At,ut){if(J){var Mt=At.deletions;Mt===null?(At.deletions=[ut],At.flags|=16):Mt.push(ut)}}function oe(At,ut){if(!J)return null;for(;ut!==null;)re(At,ut),ut=ut.sibling;return null}function fe(At){for(var ut=new Map;At!==null;)At.key!==null?ut.set(At.key,At):ut.set(At.index,At),At=At.sibling;return ut}function xe(At,ut){return At=ls(At,ut),At.index=0,At.sibling=null,At}function Te(At,ut,Mt){return At.index=Mt,J?(Mt=At.alternate,Mt!==null?(Mt=Mt.index,Mt<ut?(At.flags|=67108866,ut):Mt):(At.flags|=67108866,ut)):(At.flags|=1048576,ut)}function Ie(At){return J&&At.alternate===null&&(At.flags|=67108866),At}function Ve(At,ut,Mt,jt){return ut===null||ut.tag!==6?(ut=Jl(Mt,At.mode,jt),ut.return=At,ut):(ut=xe(ut,Mt),ut.return=At,ut)}function at(At,ut,Mt,jt){var Qn=Mt.type;return Qn===le?Vt(At,ut,Mt.props.children,jt,Mt.key):ut!==null&&(ut.elementType===Qn||typeof Qn=="object"&&Qn!==null&&Qn.$$typeof===Me&&ta(Qn)===ut.type)?(ut=xe(ut,Mt.props),ro(ut,Mt),ut.return=At,ut):(ut=ko(Mt.type,Mt.key,Mt.props,null,At.mode,jt),ro(ut,Mt),ut.return=At,ut)}function Ct(At,ut,Mt,jt){return ut===null||ut.tag!==4||ut.stateNode.containerInfo!==Mt.containerInfo||ut.stateNode.implementation!==Mt.implementation?(ut=Zl(Mt,At.mode,jt),ut.return=At,ut):(ut=xe(ut,Mt.children||[]),ut.return=At,ut)}function Vt(At,ut,Mt,jt,Qn){return ut===null||ut.tag!==7?(ut=Ys(Mt,At.mode,jt,Qn),ut.return=At,ut):(ut=xe(ut,Mt),ut.return=At,ut)}function Ht(At,ut,Mt){if(typeof ut=="string"&&ut!==""||typeof ut=="number"||typeof ut=="bigint")return ut=Jl(""+ut,At.mode,Mt),ut.return=At,ut;if(typeof ut=="object"&&ut!==null){switch(ut.$$typeof){case ne:return Mt=ko(ut.type,ut.key,ut.props,null,At.mode,Mt),ro(Mt,ut),Mt.return=At,Mt;case se:return ut=Zl(ut,At.mode,Mt),ut.return=At,ut;case Me:return ut=ta(ut),Ht(At,ut,Mt)}if(Pe(ut)||Le(ut))return ut=Ys(ut,At.mode,Mt,null),ut.return=At,ut;if(typeof ut.then=="function")return Ht(At,Ho(ut),Mt);if(ut.$$typeof===me)return Ht(At,Vo(At,ut),Mt);Qo(At,ut)}return null}function Rt(At,ut,Mt,jt){var Qn=ut!==null?ut.key:null;if(typeof Mt=="string"&&Mt!==""||typeof Mt=="number"||typeof Mt=="bigint")return Qn!==null?null:Ve(At,ut,""+Mt,jt);if(typeof Mt=="object"&&Mt!==null){switch(Mt.$$typeof){case ne:return Mt.key===Qn?at(At,ut,Mt,jt):null;case se:return Mt.key===Qn?Ct(At,ut,Mt,jt):null;case Me:return Mt=ta(Mt),Rt(At,ut,Mt,jt)}if(Pe(Mt)||Le(Mt))return Qn!==null?null:Vt(At,ut,Mt,jt,null);if(typeof Mt.then=="function")return Rt(At,ut,Ho(Mt),jt);if(Mt.$$typeof===me)return Rt(At,ut,Vo(At,Mt),jt);Qo(At,Mt)}return null}function Ot(At,ut,Mt,jt,Qn){if(typeof jt=="string"&&jt!==""||typeof jt=="number"||typeof jt=="bigint")return At=At.get(Mt)||null,Ve(ut,At,""+jt,Qn);if(typeof jt=="object"&&jt!==null){switch(jt.$$typeof){case ne:return At=At.get(jt.key===null?Mt:jt.key)||null,at(ut,At,jt,Qn);case se:return At=At.get(jt.key===null?Mt:jt.key)||null,Ct(ut,At,jt,Qn);case Me:return jt=ta(jt),Ot(At,ut,Mt,jt,Qn)}if(Pe(jt)||Le(jt))return At=At.get(Mt)||null,Vt(ut,At,jt,Qn,null);if(typeof jt.then=="function")return Ot(At,ut,Mt,Ho(jt),Qn);if(jt.$$typeof===me)return Ot(At,ut,Mt,Vo(ut,jt),Qn);Qo(ut,jt)}return null}function Pn(At,ut,Mt,jt){for(var Qn=null,wi=null,Ln=ut,si=ut=0,xi=null;Ln!==null&&si<Mt.length;si++){Ln.index>si?(xi=Ln,Ln=null):xi=Ln.sibling;var Ii=Rt(At,Ln,Mt[si],jt);if(Ii===null){Ln===null&&(Ln=xi);break}J&&Ln&&Ii.alternate===null&&re(At,Ln),ut=Te(Ii,ut,si),wi===null?Qn=Ii:wi.sibling=Ii,wi=Ii,Ln=xi}if(si===Mt.length)return oe(At,Ln),Ei&&cs(At,si),Qn;if(Ln===null){for(;si<Mt.length;si++)Ln=Ht(At,Mt[si],jt),Ln!==null&&(ut=Te(Ln,ut,si),wi===null?Qn=Ln:wi.sibling=Ln,wi=Ln);return Ei&&cs(At,si),Qn}for(Ln=fe(Ln);si<Mt.length;si++)xi=Ot(Ln,At,si,Mt[si],jt),xi!==null&&(J&&xi.alternate!==null&&Ln.delete(xi.key===null?si:xi.key),ut=Te(xi,ut,si),wi===null?Qn=xi:wi.sibling=xi,wi=xi);return J&&Ln.forEach(function(Hs){return re(At,Hs)}),Ei&&cs(At,si),Qn}function Kn(At,ut,Mt,jt){if(Mt==null)throw Error(O(151));for(var Qn=null,wi=null,Ln=ut,si=ut=0,xi=null,Ii=Mt.next();Ln!==null&&!Ii.done;si++,Ii=Mt.next()){Ln.index>si?(xi=Ln,Ln=null):xi=Ln.sibling;var Hs=Rt(At,Ln,Ii.value,jt);if(Hs===null){Ln===null&&(Ln=xi);break}J&&Ln&&Hs.alternate===null&&re(At,Ln),ut=Te(Hs,ut,si),wi===null?Qn=Hs:wi.sibling=Hs,wi=Hs,Ln=xi}if(Ii.done)return oe(At,Ln),Ei&&cs(At,si),Qn;if(Ln===null){for(;!Ii.done;si++,Ii=Mt.next())Ii=Ht(At,Ii.value,jt),Ii!==null&&(ut=Te(Ii,ut,si),wi===null?Qn=Ii:wi.sibling=Ii,wi=Ii);return Ei&&cs(At,si),Qn}for(Ln=fe(Ln);!Ii.done;si++,Ii=Mt.next())Ii=Ot(Ln,At,si,Ii.value,jt),Ii!==null&&(J&&Ii.alternate!==null&&Ln.delete(Ii.key===null?si:Ii.key),ut=Te(Ii,ut,si),wi===null?Qn=Ii:wi.sibling=Ii,wi=Ii);return J&&Ln.forEach(function(vg){return re(At,vg)}),Ei&&cs(At,si),Qn}function Vi(At,ut,Mt,jt){if(typeof Mt=="object"&&Mt!==null&&Mt.type===le&&Mt.key===null&&(Mt=Mt.props.children),typeof Mt=="object"&&Mt!==null){switch(Mt.$$typeof){case ne:e:{for(var Qn=Mt.key;ut!==null;){if(ut.key===Qn){if(Qn=Mt.type,Qn===le){if(ut.tag===7){oe(At,ut.sibling),jt=xe(ut,Mt.props.children),jt.return=At,At=jt;break e}}else if(ut.elementType===Qn||typeof Qn=="object"&&Qn!==null&&Qn.$$typeof===Me&&ta(Qn)===ut.type){oe(At,ut.sibling),jt=xe(ut,Mt.props),ro(jt,Mt),jt.return=At,At=jt;break e}oe(At,ut);break}else re(At,ut);ut=ut.sibling}Mt.type===le?(jt=Ys(Mt.props.children,At.mode,jt,Mt.key),jt.return=At,At=jt):(jt=ko(Mt.type,Mt.key,Mt.props,null,At.mode,jt),ro(jt,Mt),jt.return=At,At=jt)}return Ie(At);case se:e:{for(Qn=Mt.key;ut!==null;){if(ut.key===Qn)if(ut.tag===4&&ut.stateNode.containerInfo===Mt.containerInfo&&ut.stateNode.implementation===Mt.implementation){oe(At,ut.sibling),jt=xe(ut,Mt.children||[]),jt.return=At,At=jt;break e}else{oe(At,ut);break}else re(At,ut);ut=ut.sibling}jt=Zl(Mt,At.mode,jt),jt.return=At,At=jt}return Ie(At);case Me:return Mt=ta(Mt),Vi(At,ut,Mt,jt)}if(Pe(Mt))return Pn(At,ut,Mt,jt);if(Le(Mt)){if(Qn=Le(Mt),typeof Qn!="function")throw Error(O(150));return Mt=Qn.call(Mt),Kn(At,ut,Mt,jt)}if(typeof Mt.then=="function")return Vi(At,ut,Ho(Mt),jt);if(Mt.$$typeof===me)return Vi(At,ut,Vo(At,Mt),jt);Qo(At,Mt)}return typeof Mt=="string"&&Mt!==""||typeof Mt=="number"||typeof Mt=="bigint"?(Mt=""+Mt,ut!==null&&ut.tag===6?(oe(At,ut.sibling),jt=xe(ut,Mt),jt.return=At,At=jt):(oe(At,ut),jt=Jl(Mt,At.mode,jt),jt.return=At,At=jt),Ie(At)):oe(At,ut)}return function(At,ut,Mt,jt){try{io=0;var Qn=Vi(At,ut,Mt,jt);return Ma=null,Qn}catch(Ln){if(Ln===wa||Ln===zo)throw Ln;var wi=Ir(29,Ln,null,At.mode);return wi.lanes=jt,wi.return=At,wi}finally{}}}var ia=Cd(!0),Id=Cd(!1),Cs=!1;function fc(J){J.updateQueue={baseState:J.memoizedState,firstBaseUpdate:null,lastBaseUpdate:null,shared:{pending:null,lanes:0,hiddenCallbacks:null},callbacks:null}}function pc(J,re){J=J.updateQueue,re.updateQueue===J&&(re.updateQueue={baseState:J.baseState,firstBaseUpdate:J.firstBaseUpdate,lastBaseUpdate:J.lastBaseUpdate,shared:J.shared,callbacks:null})}function Is(J){return{lane:J,tag:0,payload:null,callback:null,next:null}}function Rs(J,re,oe){var fe=J.updateQueue;if(fe===null)return null;if(fe=fe.shared,(Ri&2)!==0){var xe=fe.pending;return xe===null?re.next=re:(re.next=xe.next,xe.next=re),fe.pending=re,re=Fo(J),dd(J,null,oe),re}return No(J,fe,re,oe),Fo(J)}function so(J,re,oe){if(re=re.updateQueue,re!==null&&(re=re.shared,(oe&4194048)!==0)){var fe=re.lanes;fe&=J.pendingLanes,oe|=fe,re.lanes=oe,Qr(J,oe)}}function mc(J,re){var oe=J.updateQueue,fe=J.alternate;if(fe!==null&&(fe=fe.updateQueue,oe===fe)){var xe=null,Te=null;if(oe=oe.firstBaseUpdate,oe!==null){do{var Ie={lane:oe.lane,tag:oe.tag,payload:oe.payload,callback:null,next:null};Te===null?xe=Te=Ie:Te=Te.next=Ie,oe=oe.next}while(oe!==null);Te===null?xe=Te=re:Te=Te.next=re}else xe=Te=re;oe={baseState:fe.baseState,firstBaseUpdate:xe,lastBaseUpdate:Te,shared:fe.shared,callbacks:fe.callbacks},J.updateQueue=oe;return}J=oe.lastBaseUpdate,J===null?oe.firstBaseUpdate=re:J.next=re,oe.lastBaseUpdate=re}var gc=!1;function ao(){if(gc){var J=Sa;if(J!==null)throw J}}function oo(J,re,oe,fe){gc=!1;var xe=J.updateQueue;Cs=!1;var Te=xe.firstBaseUpdate,Ie=xe.lastBaseUpdate,Ve=xe.shared.pending;if(Ve!==null){xe.shared.pending=null;var at=Ve,Ct=at.next;at.next=null,Ie===null?Te=Ct:Ie.next=Ct,Ie=at;var Vt=J.alternate;Vt!==null&&(Vt=Vt.updateQueue,Ve=Vt.lastBaseUpdate,Ve!==Ie&&(Ve===null?Vt.firstBaseUpdate=Ct:Ve.next=Ct,Vt.lastBaseUpdate=at))}if(Te!==null){var Ht=xe.baseState;Ie=0,Vt=Ct=at=null,Ve=Te;do{var Rt=Ve.lane&-536870913,Ot=Rt!==Ve.lane;if(Ot?(bi&Rt)===Rt:(fe&Rt)===Rt){Rt!==0&&Rt===Ta&&(gc=!0),Vt!==null&&(Vt=Vt.next={lane:0,tag:Ve.tag,payload:Ve.payload,callback:null,next:null});e:{var Pn=J,Kn=Ve;Rt=re;var Vi=oe;switch(Kn.tag){case 1:if(Pn=Kn.payload,typeof Pn=="function"){Ht=Pn.call(Vi,Ht,Rt);break e}Ht=Pn;break e;case 3:Pn.flags=Pn.flags&-65537|128;case 0:if(Pn=Kn.payload,Rt=typeof Pn=="function"?Pn.call(Vi,Ht,Rt):Pn,Rt==null)break e;Ht=Y({},Ht,Rt);break e;case 2:Cs=!0}}Rt=Ve.callback,Rt!==null&&(J.flags|=64,Ot&&(J.flags|=8192),Ot=xe.callbacks,Ot===null?xe.callbacks=[Rt]:Ot.push(Rt))}else Ot={lane:Rt,tag:Ve.tag,payload:Ve.payload,callback:Ve.callback,next:null},Vt===null?(Ct=Vt=Ot,at=Ht):Vt=Vt.next=Ot,Ie|=Rt;if(Ve=Ve.next,Ve===null){if(Ve=xe.shared.pending,Ve===null)break;Ot=Ve,Ve=Ot.next,Ot.next=null,xe.lastBaseUpdate=Ot,xe.shared.pending=null}}while(!0);Vt===null&&(at=Ht),xe.baseState=at,xe.firstBaseUpdate=Ct,xe.lastBaseUpdate=Vt,Te===null&&(xe.shared.lanes=0),Ls|=Ie,J.lanes=Ie,J.memoizedState=Ht}}function Rd(J,re){if(typeof J!="function")throw Error(O(191,J));J.call(re)}function Dd(J,re){var oe=J.callbacks;if(oe!==null)for(J.callbacks=null,J=0;J<oe.length;J++)Rd(oe[J],re)}var Ca=ke(null),qo=ke(0);function Bd(J,re){J=xs,St(qo,J),St(Ca,re),xs=J|re.baseLanes}function Ac(){St(qo,xs),St(Ca,Ca.current)}function bc(){xs=qo.current,rt(Ca),rt(qo)}var Rr=ke(null),zr=null;function Ds(J){var re=J.alternate;St(nr,nr.current&1),St(Rr,J),zr===null&&(re===null||Ca.current!==null||re.memoizedState!==null)&&(zr=J)}function xc(J){St(nr,nr.current),St(Rr,J),zr===null&&(zr=J)}function Pd(J){J.tag===22?(St(nr,nr.current),St(Rr,J),zr===null&&(zr=J)):Bs()}function Bs(){St(nr,nr.current),St(Rr,Rr.current)}function Dr(J){rt(Rr),zr===J&&(zr=null),rt(nr)}var nr=ke(0);function Wo(J){for(var re=J;re!==null;){if(re.tag===13){var oe=re.memoizedState;if(oe!==null&&(oe=oe.dehydrated,oe===null||wu(oe)||Mu(oe)))return re}else if(re.tag===19&&(re.memoizedProps.revealOrder==="forwards"||re.memoizedProps.revealOrder==="backwards"||re.memoizedProps.revealOrder==="unstable_legacy-backwards"||re.memoizedProps.revealOrder==="together")){if((re.flags&128)!==0)return re}else if(re.child!==null){re.child.return=re,re=re.child;continue}if(re===J)break;for(;re.sibling===null;){if(re.return===null||re.return===J)return null;re=re.return}re.sibling.return=re.return,re=re.sibling}return null}var hs=0,ii=null,ki=null,sr=null,Xo=!1,Ia=!1,ra=!1,Yo=0,lo=0,Ra=null,um=0;function Ji(){throw Error(O(321))}function yc(J,re){if(re===null)return!1;for(var oe=0;oe<re.length&&oe<J.length;oe++)if(!Cr(J[oe],re[oe]))return!1;return!0}function vc(J,re,oe,fe,xe,Te){return hs=Te,ii=re,re.memoizedState=null,re.updateQueue=null,re.lanes=0,Ce.H=J===null||J.memoizedState===null?gh:Fc,ra=!1,Te=oe(fe,xe),ra=!1,Ia&&(Te=Ld(re,oe,fe,xe)),Od(J),Te}function Od(J){Ce.H=ho;var re=ki!==null&&ki.next!==null;if(hs=0,sr=ki=ii=null,Xo=!1,lo=0,Ra=null,re)throw Error(O(300));J===null||ar||(J=J.dependencies,J!==null&&$o(J)&&(ar=!0))}function Ld(J,re,oe,fe){ii=J;var xe=0;do{if(Ia&&(Ra=null),lo=0,Ia=!1,25<=xe)throw Error(O(301));if(xe+=1,sr=ki=null,J.updateQueue!=null){var Te=J.updateQueue;Te.lastEffect=null,Te.events=null,Te.stores=null,Te.memoCache!=null&&(Te.memoCache.index=0)}Ce.H=Ah,Te=re(oe,fe)}while(Ia);return Te}function dm(){var J=Ce.H,re=J.useState()[0];return re=typeof re.then=="function"?co(re):re,J=J.useState()[0],(ki!==null?ki.memoizedState:null)!==J&&(ii.flags|=1024),re}function Ec(){var J=Yo!==0;return Yo=0,J}function Tc(J,re,oe){re.updateQueue=J.updateQueue,re.flags&=-2053,J.lanes&=~oe}function Sc(J){if(Xo){for(J=J.memoizedState;J!==null;){var re=J.queue;re!==null&&(re.pending=null),J=J.next}Xo=!1}hs=0,sr=ki=ii=null,Ia=!1,lo=Yo=0,Ra=null}function _r(){var J={memoizedState:null,baseState:null,baseQueue:null,queue:null,next:null};return sr===null?ii.memoizedState=sr=J:sr=sr.next=J,sr}function ir(){if(ki===null){var J=ii.alternate;J=J!==null?J.memoizedState:null}else J=ki.next;var re=sr===null?ii.memoizedState:sr.next;if(re!==null)sr=re,ki=J;else{if(J===null)throw ii.alternate===null?Error(O(467)):Error(O(310));ki=J,J={memoizedState:ki.memoizedState,baseState:ki.baseState,baseQueue:ki.baseQueue,queue:ki.queue,next:null},sr===null?ii.memoizedState=sr=J:sr=sr.next=J}return sr}function Ko(){return{lastEffect:null,events:null,stores:null,memoCache:null}}function co(J){var re=lo;return lo+=1,Ra===null&&(Ra=[]),J=Sd(Ra,J,re),re=ii,(sr===null?re.memoizedState:sr.next)===null&&(re=re.alternate,Ce.H=re===null||re.memoizedState===null?gh:Fc),J}function Jo(J){if(J!==null&&typeof J=="object"){if(typeof J.then=="function")return co(J);if(J.$$typeof===me)return pr(J)}throw Error(O(438,String(J)))}function wc(J){var re=null,oe=ii.updateQueue;if(oe!==null&&(re=oe.memoCache),re==null){var fe=ii.alternate;fe!==null&&(fe=fe.updateQueue,fe!==null&&(fe=fe.memoCache,fe!=null&&(re={data:fe.data.map(function(xe){return xe.slice()}),index:0})))}if(re==null&&(re={data:[],index:0}),oe===null&&(oe=Ko(),ii.updateQueue=oe),oe.memoCache=re,oe=re.data[re.index],oe===void 0)for(oe=re.data[re.index]=Array(J),fe=0;fe<J;fe++)oe[fe]=we;return re.index++,oe}function fs(J,re){return typeof re=="function"?re(J):re}function Zo(J){var re=ir();return Mc(re,ki,J)}function Mc(J,re,oe){var fe=J.queue;if(fe===null)throw Error(O(311));fe.lastRenderedReducer=oe;var xe=J.baseQueue,Te=fe.pending;if(Te!==null){if(xe!==null){var Ie=xe.next;xe.next=Te.next,Te.next=Ie}re.baseQueue=xe=Te,fe.pending=null}if(Te=J.baseState,xe===null)J.memoizedState=Te;else{re=xe.next;var Ve=Ie=null,at=null,Ct=re,Vt=!1;do{var Ht=Ct.lane&-536870913;if(Ht!==Ct.lane?(bi&Ht)===Ht:(hs&Ht)===Ht){var Rt=Ct.revertLane;if(Rt===0)at!==null&&(at=at.next={lane:0,revertLane:0,gesture:null,action:Ct.action,hasEagerState:Ct.hasEagerState,eagerState:Ct.eagerState,next:null}),Ht===Ta&&(Vt=!0);else if((hs&Rt)===Rt){Ct=Ct.next,Rt===Ta&&(Vt=!0);continue}else Ht={lane:0,revertLane:Ct.revertLane,gesture:null,action:Ct.action,hasEagerState:Ct.hasEagerState,eagerState:Ct.eagerState,next:null},at===null?(Ve=at=Ht,Ie=Te):at=at.next=Ht,ii.lanes|=Rt,Ls|=Rt;Ht=Ct.action,ra&&oe(Te,Ht),Te=Ct.hasEagerState?Ct.eagerState:oe(Te,Ht)}else Rt={lane:Ht,revertLane:Ct.revertLane,gesture:Ct.gesture,action:Ct.action,hasEagerState:Ct.hasEagerState,eagerState:Ct.eagerState,next:null},at===null?(Ve=at=Rt,Ie=Te):at=at.next=Rt,ii.lanes|=Ht,Ls|=Ht;Ct=Ct.next}while(Ct!==null&&Ct!==re);if(at===null?Ie=Te:at.next=Ve,!Cr(Te,J.memoizedState)&&(ar=!0,Vt&&(oe=Sa,oe!==null)))throw oe;J.memoizedState=Te,J.baseState=Ie,J.baseQueue=at,fe.lastRenderedState=Te}return xe===null&&(fe.lanes=0),[J.memoizedState,fe.dispatch]}function Cc(J){var re=ir(),oe=re.queue;if(oe===null)throw Error(O(311));oe.lastRenderedReducer=J;var fe=oe.dispatch,xe=oe.pending,Te=re.memoizedState;if(xe!==null){oe.pending=null;var Ie=xe=xe.next;do Te=J(Te,Ie.action),Ie=Ie.next;while(Ie!==xe);Cr(Te,re.memoizedState)||(ar=!0),re.memoizedState=Te,re.baseQueue===null&&(re.baseState=Te),oe.lastRenderedState=Te}return[Te,fe]}function Nd(J,re,oe){var fe=ii,xe=ir(),Te=Ei;if(Te){if(oe===void 0)throw Error(O(407));oe=oe()}else oe=re();var Ie=!Cr((ki||xe).memoizedState,oe);if(Ie&&(xe.memoizedState=oe,ar=!0),xe=xe.queue,Dc(Ud.bind(null,fe,xe,J),[J]),xe.getSnapshot!==re||Ie||sr!==null&&sr.memoizedState.tag&1){if(fe.flags|=2048,Da(9,{destroy:void 0},kd.bind(null,fe,xe,oe,re),null),zi===null)throw Error(O(349));Te||(hs&127)!==0||Fd(fe,re,oe)}return oe}function Fd(J,re,oe){J.flags|=16384,J={getSnapshot:re,value:oe},re=ii.updateQueue,re===null?(re=Ko(),ii.updateQueue=re,re.stores=[J]):(oe=re.stores,oe===null?re.stores=[J]:oe.push(J))}function kd(J,re,oe,fe){re.value=oe,re.getSnapshot=fe,$d(re)&&Vd(J)}function Ud(J,re,oe){return oe(function(){$d(re)&&Vd(J)})}function $d(J){var re=J.getSnapshot;J=J.value;try{var oe=re();return!Cr(J,oe)}catch{return!0}}function Vd(J){var re=Xs(J,2);re!==null&&Sr(re,J,2)}function Ic(J){var re=_r();if(typeof J=="function"){var oe=J;if(J=oe(),ra){Bn(!0);try{oe()}finally{Bn(!1)}}}return re.memoizedState=re.baseState=J,re.queue={pending:null,lanes:0,dispatch:null,lastRenderedReducer:fs,lastRenderedState:J},re}function Gd(J,re,oe,fe){return J.baseState=oe,Mc(J,ki,typeof fe=="function"?fe:fs)}function hm(J,re,oe,fe,xe){if(nl(J))throw Error(O(485));if(J=re.action,J!==null){var Te={payload:xe,action:J,next:null,isTransition:!0,status:"pending",value:null,reason:null,listeners:[],then:function(Ie){Te.listeners.push(Ie)}};Ce.T!==null?oe(!0):Te.isTransition=!1,fe(Te),oe=re.pending,oe===null?(Te.next=re.pending=Te,zd(re,Te)):(Te.next=oe.next,re.pending=oe.next=Te)}}function zd(J,re){var oe=re.action,fe=re.payload,xe=J.state;if(re.isTransition){var Te=Ce.T,Ie={};Ce.T=Ie;try{var Ve=oe(xe,fe),at=Ce.S;at!==null&&at(Ie,Ve),jd(J,re,Ve)}catch(Ct){Rc(J,re,Ct)}finally{Te!==null&&Ie.types!==null&&(Te.types=Ie.types),Ce.T=Te}}else try{Te=oe(xe,fe),jd(J,re,Te)}catch(Ct){Rc(J,re,Ct)}}function jd(J,re,oe){oe!==null&&typeof oe=="object"&&typeof oe.then=="function"?oe.then(function(fe){Hd(J,re,fe)},function(fe){return Rc(J,re,fe)}):Hd(J,re,oe)}function Hd(J,re,oe){re.status="fulfilled",re.value=oe,Qd(re),J.state=oe,re=J.pending,re!==null&&(oe=re.next,oe===re?J.pending=null:(oe=oe.next,re.next=oe,zd(J,oe)))}function Rc(J,re,oe){var fe=J.pending;if(J.pending=null,fe!==null){fe=fe.next;do re.status="rejected",re.reason=oe,Qd(re),re=re.next;while(re!==fe)}J.action=null}function Qd(J){J=J.listeners;for(var re=0;re<J.length;re++)(0,J[re])()}function qd(J,re){return re}function Wd(J,re){if(Ei){var oe=zi.formState;if(oe!==null){e:{var fe=ii;if(Ei){if(Hi){t:{for(var xe=Hi,Te=Gr;xe.nodeType!==8;){if(!Te){xe=null;break t}if(xe=jr(xe.nextSibling),xe===null){xe=null;break t}}Te=xe.data,xe=Te==="F!"||Te==="F"?xe:null}if(xe){Hi=jr(xe.nextSibling),fe=xe.data==="F!";break e}}ws(fe)}fe=!1}fe&&(re=oe[0])}}return oe=_r(),oe.memoizedState=oe.baseState=re,fe={pending:null,lanes:0,dispatch:null,lastRenderedReducer:qd,lastRenderedState:re},oe.queue=fe,oe=fh.bind(null,ii,fe),fe.dispatch=oe,fe=Ic(!1),Te=Nc.bind(null,ii,!1,fe.queue),fe=_r(),xe={state:re,dispatch:null,action:J,pending:null},fe.queue=xe,oe=hm.bind(null,ii,xe,Te,oe),xe.dispatch=oe,fe.memoizedState=J,[re,oe,!1]}function Xd(J){var re=ir();return Yd(re,ki,J)}function Yd(J,re,oe){if(re=Mc(J,re,qd)[0],J=Zo(fs)[0],typeof re=="object"&&re!==null&&typeof re.then=="function")try{var fe=co(re)}catch(Ie){throw Ie===wa?zo:Ie}else fe=re;re=ir();var xe=re.queue,Te=xe.dispatch;return oe!==re.memoizedState&&(ii.flags|=2048,Da(9,{destroy:void 0},fm.bind(null,xe,oe),null)),[fe,Te,J]}function fm(J,re){J.action=re}function Kd(J){var re=ir(),oe=ki;if(oe!==null)return Yd(re,oe,J);ir(),re=re.memoizedState,oe=ir();var fe=oe.queue.dispatch;return oe.memoizedState=J,[re,fe,!1]}function Da(J,re,oe,fe){return J={tag:J,create:oe,deps:fe,inst:re,next:null},re=ii.updateQueue,re===null&&(re=Ko(),ii.updateQueue=re),oe=re.lastEffect,oe===null?re.lastEffect=J.next=J:(fe=oe.next,oe.next=J,J.next=fe,re.lastEffect=J),J}function Jd(){return ir().memoizedState}function el(J,re,oe,fe){var xe=_r();ii.flags|=J,xe.memoizedState=Da(1|re,{destroy:void 0},oe,fe===void 0?null:fe)}function tl(J,re,oe,fe){var xe=ir();fe=fe===void 0?null:fe;var Te=xe.memoizedState.inst;ki!==null&&fe!==null&&yc(fe,ki.memoizedState.deps)?xe.memoizedState=Da(re,Te,oe,fe):(ii.flags|=J,xe.memoizedState=Da(1|re,Te,oe,fe))}function Zd(J,re){el(8390656,8,J,re)}function Dc(J,re){tl(2048,8,J,re)}function pm(J){ii.flags|=4;var re=ii.updateQueue;if(re===null)re=Ko(),ii.updateQueue=re,re.events=[J];else{var oe=re.events;oe===null?re.events=[J]:oe.push(J)}}function eh(J){var re=ir().memoizedState;return pm({ref:re,nextImpl:J}),function(){if((Ri&2)!==0)throw Error(O(440));return re.impl.apply(void 0,arguments)}}function th(J,re){return tl(4,2,J,re)}function nh(J,re){return tl(4,4,J,re)}function ih(J,re){if(typeof re=="function"){J=J();var oe=re(J);return function(){typeof oe=="function"?oe():re(null)}}if(re!=null)return J=J(),re.current=J,function(){re.current=null}}function rh(J,re,oe){oe=oe!=null?oe.concat([J]):null,tl(4,4,ih.bind(null,re,J),oe)}function Bc(){}function sh(J,re){var oe=ir();re=re===void 0?null:re;var fe=oe.memoizedState;return re!==null&&yc(re,fe[1])?fe[0]:(oe.memoizedState=[J,re],J)}function ah(J,re){var oe=ir();re=re===void 0?null:re;var fe=oe.memoizedState;if(re!==null&&yc(re,fe[1]))return fe[0];if(fe=J(),ra){Bn(!0);try{J()}finally{Bn(!1)}}return oe.memoizedState=[fe,re],fe}function Pc(J,re,oe){return oe===void 0||(hs&1073741824)!==0&&(bi&261930)===0?J.memoizedState=re:(J.memoizedState=oe,J=uf(),ii.lanes|=J,Ls|=J,oe)}function oh(J,re,oe,fe){return Cr(oe,re)?oe:Ca.current!==null?(J=Pc(J,oe,fe),Cr(J,re)||(ar=!0),J):(hs&42)===0||(hs&1073741824)!==0&&(bi&261930)===0?(ar=!0,J.memoizedState=oe):(J=uf(),ii.lanes|=J,Ls|=J,re)}function lh(J,re,oe,fe,xe){var Te=Be.p;Be.p=Te!==0&&8>Te?Te:8;var Ie=Ce.T,Ve={};Ce.T=Ve,Nc(J,!1,re,oe);try{var at=xe(),Ct=Ce.S;if(Ct!==null&&Ct(Ve,at),at!==null&&typeof at=="object"&&typeof at.then=="function"){var Vt=cm(at,fe);uo(J,re,Vt,Or(J))}else uo(J,re,fe,Or(J))}catch(Ht){uo(J,re,{then:function(){},status:"rejected",reason:Ht},Or())}finally{Be.p=Te,Ie!==null&&Ve.types!==null&&(Ie.types=Ve.types),Ce.T=Ie}}function mm(){}function Oc(J,re,oe,fe){if(J.tag!==5)throw Error(O(476));var xe=ch(J).queue;lh(J,xe,re,ze,oe===null?mm:function(){return uh(J),oe(fe)})}function ch(J){var re=J.memoizedState;if(re!==null)return re;re={memoizedState:ze,baseState:ze,baseQueue:null,queue:{pending:null,lanes:0,dispatch:null,lastRenderedReducer:fs,lastRenderedState:ze},next:null};var oe={};return re.next={memoizedState:oe,baseState:oe,baseQueue:null,queue:{pending:null,lanes:0,dispatch:null,lastRenderedReducer:fs,lastRenderedState:oe},next:null},J.memoizedState=re,J=J.alternate,J!==null&&(J.memoizedState=re),re}function uh(J){var re=ch(J);re.next===null&&(re=J.alternate.memoizedState),uo(J,re.next.queue,{},Or())}function Lc(){return pr(Io)}function dh(){return ir().memoizedState}function hh(){return ir().memoizedState}function gm(J){for(var re=J.return;re!==null;){switch(re.tag){case 24:case 3:var oe=Or();J=Is(oe);var fe=Rs(re,J,oe);fe!==null&&(Sr(fe,re,oe),so(fe,re,oe)),re={cache:cc()},J.payload=re;return}re=re.return}}function Am(J,re,oe){var fe=Or();oe={lane:fe,revertLane:0,gesture:null,action:oe,hasEagerState:!1,eagerState:null,next:null},nl(J)?ph(re,oe):(oe=Yl(J,re,oe,fe),oe!==null&&(Sr(oe,J,fe),mh(oe,re,fe)))}function fh(J,re,oe){var fe=Or();uo(J,re,oe,fe)}function uo(J,re,oe,fe){var xe={lane:fe,revertLane:0,gesture:null,action:oe,hasEagerState:!1,eagerState:null,next:null};if(nl(J))ph(re,xe);else{var Te=J.alternate;if(J.lanes===0&&(Te===null||Te.lanes===0)&&(Te=re.lastRenderedReducer,Te!==null))try{var Ie=re.lastRenderedState,Ve=Te(Ie,oe);if(xe.hasEagerState=!0,xe.eagerState=Ve,Cr(Ve,Ie))return No(J,re,xe,0),zi===null&&Lo(),!1}catch{}finally{}if(oe=Yl(J,re,xe,fe),oe!==null)return Sr(oe,J,fe),mh(oe,re,fe),!0}return!1}function Nc(J,re,oe,fe){if(fe={lane:2,revertLane:pu(),gesture:null,action:fe,hasEagerState:!1,eagerState:null,next:null},nl(J)){if(re)throw Error(O(479))}else re=Yl(J,oe,fe,2),re!==null&&Sr(re,J,2)}function nl(J){var re=J.alternate;return J===ii||re!==null&&re===ii}function ph(J,re){Ia=Xo=!0;var oe=J.pending;oe===null?re.next=re:(re.next=oe.next,oe.next=re),J.pending=re}function mh(J,re,oe){if((oe&4194048)!==0){var fe=re.lanes;fe&=J.pendingLanes,oe|=fe,re.lanes=oe,Qr(J,oe)}}var ho={readContext:pr,use:Jo,useCallback:Ji,useContext:Ji,useEffect:Ji,useImperativeHandle:Ji,useLayoutEffect:Ji,useInsertionEffect:Ji,useMemo:Ji,useReducer:Ji,useRef:Ji,useState:Ji,useDebugValue:Ji,useDeferredValue:Ji,useTransition:Ji,useSyncExternalStore:Ji,useId:Ji,useHostTransitionStatus:Ji,useFormState:Ji,useActionState:Ji,useOptimistic:Ji,useMemoCache:Ji,useCacheRefresh:Ji};ho.useEffectEvent=Ji;var gh={readContext:pr,use:Jo,useCallback:function(J,re){return _r().memoizedState=[J,re===void 0?null:re],J},useContext:pr,useEffect:Zd,useImperativeHandle:function(J,re,oe){oe=oe!=null?oe.concat([J]):null,el(4194308,4,ih.bind(null,re,J),oe)},useLayoutEffect:function(J,re){return el(4194308,4,J,re)},useInsertionEffect:function(J,re){el(4,2,J,re)},useMemo:function(J,re){var oe=_r();re=re===void 0?null:re;var fe=J();if(ra){Bn(!0);try{J()}finally{Bn(!1)}}return oe.memoizedState=[fe,re],fe},useReducer:function(J,re,oe){var fe=_r();if(oe!==void 0){var xe=oe(re);if(ra){Bn(!0);try{oe(re)}finally{Bn(!1)}}}else xe=re;return fe.memoizedState=fe.baseState=xe,J={pending:null,lanes:0,dispatch:null,lastRenderedReducer:J,lastRenderedState:xe},fe.queue=J,J=J.dispatch=Am.bind(null,ii,J),[fe.memoizedState,J]},useRef:function(J){var re=_r();return J={current:J},re.memoizedState=J},useState:function(J){J=Ic(J);var re=J.queue,oe=fh.bind(null,ii,re);return re.dispatch=oe,[J.memoizedState,oe]},useDebugValue:Bc,useDeferredValue:function(J,re){var oe=_r();return Pc(oe,J,re)},useTransition:function(){var J=Ic(!1);return J=lh.bind(null,ii,J.queue,!0,!1),_r().memoizedState=J,[!1,J]},useSyncExternalStore:function(J,re,oe){var fe=ii,xe=_r();if(Ei){if(oe===void 0)throw Error(O(407));oe=oe()}else{if(oe=re(),zi===null)throw Error(O(349));(bi&127)!==0||Fd(fe,re,oe)}xe.memoizedState=oe;var Te={value:oe,getSnapshot:re};return xe.queue=Te,Zd(Ud.bind(null,fe,Te,J),[J]),fe.flags|=2048,Da(9,{destroy:void 0},kd.bind(null,fe,Te,oe,re),null),oe},useId:function(){var J=_r(),re=zi.identifierPrefix;if(Ei){var oe=ns,fe=ts;oe=(fe&~(1<<32-Sn(fe)-1)).toString(32)+oe,re="_"+re+"R_"+oe,oe=Yo++,0<oe&&(re+="H"+oe.toString(32)),re+="_"}else oe=um++,re="_"+re+"r_"+oe.toString(32)+"_";return J.memoizedState=re},useHostTransitionStatus:Lc,useFormState:Wd,useActionState:Wd,useOptimistic:function(J){var re=_r();re.memoizedState=re.baseState=J;var oe={pending:null,lanes:0,dispatch:null,lastRenderedReducer:null,lastRenderedState:null};return re.queue=oe,re=Nc.bind(null,ii,!0,oe),oe.dispatch=re,[J,re]},useMemoCache:wc,useCacheRefresh:function(){return _r().memoizedState=gm.bind(null,ii)},useEffectEvent:function(J){var re=_r(),oe={impl:J};return re.memoizedState=oe,function(){if((Ri&2)!==0)throw Error(O(440));return oe.impl.apply(void 0,arguments)}}},Fc={readContext:pr,use:Jo,useCallback:sh,useContext:pr,useEffect:Dc,useImperativeHandle:rh,useInsertionEffect:th,useLayoutEffect:nh,useMemo:ah,useReducer:Zo,useRef:Jd,useState:function(){return Zo(fs)},useDebugValue:Bc,useDeferredValue:function(J,re){var oe=ir();return oh(oe,ki.memoizedState,J,re)},useTransition:function(){var J=Zo(fs)[0],re=ir().memoizedState;return[typeof J=="boolean"?J:co(J),re]},useSyncExternalStore:Nd,useId:dh,useHostTransitionStatus:Lc,useFormState:Xd,useActionState:Xd,useOptimistic:function(J,re){var oe=ir();return Gd(oe,ki,J,re)},useMemoCache:wc,useCacheRefresh:hh};Fc.useEffectEvent=eh;var Ah={readContext:pr,use:Jo,useCallback:sh,useContext:pr,useEffect:Dc,useImperativeHandle:rh,useInsertionEffect:th,useLayoutEffect:nh,useMemo:ah,useReducer:Cc,useRef:Jd,useState:function(){return Cc(fs)},useDebugValue:Bc,useDeferredValue:function(J,re){var oe=ir();return ki===null?Pc(oe,J,re):oh(oe,ki.memoizedState,J,re)},useTransition:function(){var J=Cc(fs)[0],re=ir().memoizedState;return[typeof J=="boolean"?J:co(J),re]},useSyncExternalStore:Nd,useId:dh,useHostTransitionStatus:Lc,useFormState:Kd,useActionState:Kd,useOptimistic:function(J,re){var oe=ir();return ki!==null?Gd(oe,ki,J,re):(oe.baseState=J,[J,oe.queue.dispatch])},useMemoCache:wc,useCacheRefresh:hh};Ah.useEffectEvent=eh;function kc(J,re,oe,fe){re=J.memoizedState,oe=oe(fe,re),oe=oe==null?re:Y({},re,oe),J.memoizedState=oe,J.lanes===0&&(J.updateQueue.baseState=oe)}var Uc={enqueueSetState:function(J,re,oe){J=J._reactInternals;var fe=Or(),xe=Is(fe);xe.payload=re,oe!=null&&(xe.callback=oe),re=Rs(J,xe,fe),re!==null&&(Sr(re,J,fe),so(re,J,fe))},enqueueReplaceState:function(J,re,oe){J=J._reactInternals;var fe=Or(),xe=Is(fe);xe.tag=1,xe.payload=re,oe!=null&&(xe.callback=oe),re=Rs(J,xe,fe),re!==null&&(Sr(re,J,fe),so(re,J,fe))},enqueueForceUpdate:function(J,re){J=J._reactInternals;var oe=Or(),fe=Is(oe);fe.tag=2,re!=null&&(fe.callback=re),re=Rs(J,fe,oe),re!==null&&(Sr(re,J,oe),so(re,J,oe))}};function bh(J,re,oe,fe,xe,Te,Ie){return J=J.stateNode,typeof J.shouldComponentUpdate=="function"?J.shouldComponentUpdate(fe,Te,Ie):re.prototype&&re.prototype.isPureReactComponent?!Ka(oe,fe)||!Ka(xe,Te):!0}function xh(J,re,oe,fe){J=re.state,typeof re.componentWillReceiveProps=="function"&&re.componentWillReceiveProps(oe,fe),typeof re.UNSAFE_componentWillReceiveProps=="function"&&re.UNSAFE_componentWillReceiveProps(oe,fe),re.state!==J&&Uc.enqueueReplaceState(re,re.state,null)}function sa(J,re){var oe=re;if("ref"in re){oe={};for(var fe in re)fe!=="ref"&&(oe[fe]=re[fe])}if(J=J.defaultProps){oe===re&&(oe=Y({},oe));for(var xe in J)oe[xe]===void 0&&(oe[xe]=J[xe])}return oe}function yh(J){Oo(J)}function Eh(J){console.error(J)}function Th(J){Oo(J)}function il(J,re){try{var oe=J.onUncaughtError;oe(re.value,{componentStack:re.stack})}catch(fe){setTimeout(function(){throw fe})}}function Sh(J,re,oe){try{var fe=J.onCaughtError;fe(oe.value,{componentStack:oe.stack,errorBoundary:re.tag===1?re.stateNode:null})}catch(xe){setTimeout(function(){throw xe})}}function $c(J,re,oe){return oe=Is(oe),oe.tag=3,oe.payload={element:null},oe.callback=function(){il(J,re)},oe}function wh(J){return J=Is(J),J.tag=3,J}function Mh(J,re,oe,fe){var xe=oe.type.getDerivedStateFromError;if(typeof xe=="function"){var Te=fe.value;J.payload=function(){return xe(Te)},J.callback=function(){Sh(re,oe,fe)}}var Ie=oe.stateNode;Ie!==null&&typeof Ie.componentDidCatch=="function"&&(J.callback=function(){Sh(re,oe,fe),typeof xe!="function"&&(Ns===null?Ns=new Set([this]):Ns.add(this));var Ve=fe.stack;this.componentDidCatch(fe.value,{componentStack:Ve!==null?Ve:""})})}function bm(J,re,oe,fe,xe){if(oe.flags|=32768,fe!==null&&typeof fe=="object"&&typeof fe.then=="function"){if(re=oe.alternate,re!==null&&Ea(re,oe,xe,!0),oe=Rr.current,oe!==null){switch(oe.tag){case 31:case 13:return zr===null?gl():oe.alternate===null&&Zi===0&&(Zi=3),oe.flags&=-257,oe.flags|=65536,oe.lanes=xe,fe===jo?oe.flags|=16384:(re=oe.updateQueue,re===null?oe.updateQueue=new Set([fe]):re.add(fe),du(J,fe,xe)),!1;case 22:return oe.flags|=65536,fe===jo?oe.flags|=16384:(re=oe.updateQueue,re===null?(re={transitions:null,markerInstances:null,retryQueue:new Set([fe])},oe.updateQueue=re):(oe=re.retryQueue,oe===null?re.retryQueue=new Set([fe]):oe.add(fe)),du(J,fe,xe)),!1}throw Error(O(435,oe.tag))}return du(J,fe,xe),gl(),!1}if(Ei)return re=Rr.current,re!==null?((re.flags&65536)===0&&(re.flags|=256),re.flags|=65536,re.lanes=xe,fe!==ic&&(J=Error(O(422),{cause:fe}),eo(Ur(J,oe)))):(fe!==ic&&(re=Error(O(423),{cause:fe}),eo(Ur(re,oe))),J=J.current.alternate,J.flags|=65536,xe&=-xe,J.lanes|=xe,fe=Ur(fe,oe),xe=$c(J.stateNode,fe,xe),mc(J,xe),Zi!==4&&(Zi=2)),!1;var Te=Error(O(520),{cause:fe});if(Te=Ur(Te,oe),yo===null?yo=[Te]:yo.push(Te),Zi!==4&&(Zi=2),re===null)return!0;fe=Ur(fe,oe),oe=re;do{switch(oe.tag){case 3:return oe.flags|=65536,J=xe&-xe,oe.lanes|=J,J=$c(oe.stateNode,fe,J),mc(oe,J),!1;case 1:if(re=oe.type,Te=oe.stateNode,(oe.flags&128)===0&&(typeof re.getDerivedStateFromError=="function"||Te!==null&&typeof Te.componentDidCatch=="function"&&(Ns===null||!Ns.has(Te))))return oe.flags|=65536,xe&=-xe,oe.lanes|=xe,xe=wh(xe),Mh(xe,J,oe,fe),mc(oe,xe),!1}oe=oe.return}while(oe!==null);return!1}var Vc=Error(O(461)),ar=!1;function mr(J,re,oe,fe){re.child=J===null?Id(re,null,oe,fe):ia(re,J.child,oe,fe)}function Ch(J,re,oe,fe,xe){oe=oe.render;var Te=re.ref;if("ref"in fe){var Ie={};for(var Ve in fe)Ve!=="ref"&&(Ie[Ve]=fe[Ve])}else Ie=fe;return Zs(re),fe=vc(J,re,oe,Ie,Te,xe),Ve=Ec(),J!==null&&!ar?(Tc(J,re,xe),ps(J,re,xe)):(Ei&&Ve&&tc(re),re.flags|=1,mr(J,re,fe,xe),re.child)}function Ih(J,re,oe,fe,xe){if(J===null){var Te=oe.type;return typeof Te=="function"&&!Kl(Te)&&Te.defaultProps===void 0&&oe.compare===null?(re.tag=15,re.type=Te,Rh(J,re,Te,fe,xe)):(J=ko(oe.type,null,fe,re,re.mode,xe),J.ref=re.ref,J.return=re,re.child=J)}if(Te=J.child,!Xc(J,xe)){var Ie=Te.memoizedProps;if(oe=oe.compare,oe=oe!==null?oe:Ka,oe(Ie,fe)&&J.ref===re.ref)return ps(J,re,xe)}return re.flags|=1,J=ls(Te,fe),J.ref=re.ref,J.return=re,re.child=J}function Rh(J,re,oe,fe,xe){if(J!==null){var Te=J.memoizedProps;if(Ka(Te,fe)&&J.ref===re.ref)if(ar=!1,re.pendingProps=fe=Te,Xc(J,xe))(J.flags&131072)!==0&&(ar=!0);else return re.lanes=J.lanes,ps(J,re,xe)}return Gc(J,re,oe,fe,xe)}function Dh(J,re,oe,fe){var xe=fe.children,Te=J!==null?J.memoizedState:null;if(J===null&&re.stateNode===null&&(re.stateNode={_visibility:1,_pendingMarkers:null,_retryCache:null,_transitions:null}),fe.mode==="hidden"){if((re.flags&128)!==0){if(Te=Te!==null?Te.baseLanes|oe:oe,J!==null){for(fe=re.child=J.child,xe=0;fe!==null;)xe=xe|fe.lanes|fe.childLanes,fe=fe.sibling;fe=xe&~Te}else fe=0,re.child=null;return Bh(J,re,Te,oe,fe)}if((oe&536870912)!==0)re.memoizedState={baseLanes:0,cachePool:null},J!==null&&Go(re,Te!==null?Te.cachePool:null),Te!==null?Bd(re,Te):Ac(),Pd(re);else return fe=re.lanes=536870912,Bh(J,re,Te!==null?Te.baseLanes|oe:oe,oe,fe)}else Te!==null?(Go(re,Te.cachePool),Bd(re,Te),Bs(),re.memoizedState=null):(J!==null&&Go(re,null),Ac(),Bs());return mr(J,re,xe,oe),re.child}function fo(J,re){return J!==null&&J.tag===22||re.stateNode!==null||(re.stateNode={_visibility:1,_pendingMarkers:null,_retryCache:null,_transitions:null}),re.sibling}function Bh(J,re,oe,fe,xe){var Te=dc();return Te=Te===null?null:{parent:rr._currentValue,pool:Te},re.memoizedState={baseLanes:oe,cachePool:Te},J!==null&&Go(re,null),Ac(),Pd(re),J!==null&&Ea(J,re,fe,!0),re.childLanes=xe,null}function rl(J,re){return re=al({mode:re.mode,children:re.children},J.mode),re.ref=J.ref,J.child=re,re.return=J,re}function Ph(J,re,oe){return ia(re,J.child,null,oe),J=rl(re,re.pendingProps),J.flags|=2,Dr(re),re.memoizedState=null,J}function xm(J,re,oe){var fe=re.pendingProps,xe=(re.flags&128)!==0;if(re.flags&=-129,J===null){if(Ei){if(fe.mode==="hidden")return J=rl(re,fe),re.lanes=536870912,fo(null,J);if(xc(re),(J=Hi)?(J=Wf(J,Gr),J=J!==null&&J.data==="&"?J:null,J!==null&&(re.memoizedState={dehydrated:J,treeContext:Ts!==null?{id:ts,overflow:ns}:null,retryLane:536870912,hydrationErrors:null},oe=fd(J),oe.return=re,re.child=oe,fr=re,Hi=null)):J=null,J===null)throw ws(re);return re.lanes=536870912,null}return rl(re,fe)}var Te=J.memoizedState;if(Te!==null){var Ie=Te.dehydrated;if(xc(re),xe)if(re.flags&256)re.flags&=-257,re=Ph(J,re,oe);else if(re.memoizedState!==null)re.child=J.child,re.flags|=128,re=null;else throw Error(O(558));else if(ar||Ea(J,re,oe,!1),xe=(oe&J.childLanes)!==0,ar||xe){if(fe=zi,fe!==null&&(Ie=qr(fe,oe),Ie!==0&&Ie!==Te.retryLane))throw Te.retryLane=Ie,Xs(J,Ie),Sr(fe,J,Ie),Vc;gl(),re=Ph(J,re,oe)}else J=Te.treeContext,Hi=jr(Ie.nextSibling),fr=re,Ei=!0,Ss=null,Gr=!1,J!==null&&gd(re,J),re=rl(re,fe),re.flags|=4096;return re}return J=ls(J.child,{mode:fe.mode,children:fe.children}),J.ref=re.ref,re.child=J,J.return=re,J}function sl(J,re){var oe=re.ref;if(oe===null)J!==null&&J.ref!==null&&(re.flags|=4194816);else{if(typeof oe!="function"&&typeof oe!="object")throw Error(O(284));(J===null||J.ref!==oe)&&(re.flags|=4194816)}}function Gc(J,re,oe,fe,xe){return Zs(re),oe=vc(J,re,oe,fe,void 0,xe),fe=Ec(),J!==null&&!ar?(Tc(J,re,xe),ps(J,re,xe)):(Ei&&fe&&tc(re),re.flags|=1,mr(J,re,oe,xe),re.child)}function Oh(J,re,oe,fe,xe,Te){return Zs(re),re.updateQueue=null,oe=Ld(re,fe,oe,xe),Od(J),fe=Ec(),J!==null&&!ar?(Tc(J,re,Te),ps(J,re,Te)):(Ei&&fe&&tc(re),re.flags|=1,mr(J,re,oe,Te),re.child)}function Lh(J,re,oe,fe,xe){if(Zs(re),re.stateNode===null){var Te=ba,Ie=oe.contextType;typeof Ie=="object"&&Ie!==null&&(Te=pr(Ie)),Te=new oe(fe,Te),re.memoizedState=Te.state!==null&&Te.state!==void 0?Te.state:null,Te.updater=Uc,re.stateNode=Te,Te._reactInternals=re,Te=re.stateNode,Te.props=fe,Te.state=re.memoizedState,Te.refs={},fc(re),Ie=oe.contextType,Te.context=typeof Ie=="object"&&Ie!==null?pr(Ie):ba,Te.state=re.memoizedState,Ie=oe.getDerivedStateFromProps,typeof Ie=="function"&&(kc(re,oe,Ie,fe),Te.state=re.memoizedState),typeof oe.getDerivedStateFromProps=="function"||typeof Te.getSnapshotBeforeUpdate=="function"||typeof Te.UNSAFE_componentWillMount!="function"&&typeof Te.componentWillMount!="function"||(Ie=Te.state,typeof Te.componentWillMount=="function"&&Te.componentWillMount(),typeof Te.UNSAFE_componentWillMount=="function"&&Te.UNSAFE_componentWillMount(),Ie!==Te.state&&Uc.enqueueReplaceState(Te,Te.state,null),oo(re,fe,Te,xe),ao(),Te.state=re.memoizedState),typeof Te.componentDidMount=="function"&&(re.flags|=4194308),fe=!0}else if(J===null){Te=re.stateNode;var Ve=re.memoizedProps,at=sa(oe,Ve);Te.props=at;var Ct=Te.context,Vt=oe.contextType;Ie=ba,typeof Vt=="object"&&Vt!==null&&(Ie=pr(Vt));var Ht=oe.getDerivedStateFromProps;Vt=typeof Ht=="function"||typeof Te.getSnapshotBeforeUpdate=="function",Ve=re.pendingProps!==Ve,Vt||typeof Te.UNSAFE_componentWillReceiveProps!="function"&&typeof Te.componentWillReceiveProps!="function"||(Ve||Ct!==Ie)&&xh(re,Te,fe,Ie),Cs=!1;var Rt=re.memoizedState;Te.state=Rt,oo(re,fe,Te,xe),ao(),Ct=re.memoizedState,Ve||Rt!==Ct||Cs?(typeof Ht=="function"&&(kc(re,oe,Ht,fe),Ct=re.memoizedState),(at=Cs||bh(re,oe,at,fe,Rt,Ct,Ie))?(Vt||typeof Te.UNSAFE_componentWillMount!="function"&&typeof Te.componentWillMount!="function"||(typeof Te.componentWillMount=="function"&&Te.componentWillMount(),typeof Te.UNSAFE_componentWillMount=="function"&&Te.UNSAFE_componentWillMount()),typeof Te.componentDidMount=="function"&&(re.flags|=4194308)):(typeof Te.componentDidMount=="function"&&(re.flags|=4194308),re.memoizedProps=fe,re.memoizedState=Ct),Te.props=fe,Te.state=Ct,Te.context=Ie,fe=at):(typeof Te.componentDidMount=="function"&&(re.flags|=4194308),fe=!1)}else{Te=re.stateNode,pc(J,re),Ie=re.memoizedProps,Vt=sa(oe,Ie),Te.props=Vt,Ht=re.pendingProps,Rt=Te.context,Ct=oe.contextType,at=ba,typeof Ct=="object"&&Ct!==null&&(at=pr(Ct)),Ve=oe.getDerivedStateFromProps,(Ct=typeof Ve=="function"||typeof Te.getSnapshotBeforeUpdate=="function")||typeof Te.UNSAFE_componentWillReceiveProps!="function"&&typeof Te.componentWillReceiveProps!="function"||(Ie!==Ht||Rt!==at)&&xh(re,Te,fe,at),Cs=!1,Rt=re.memoizedState,Te.state=Rt,oo(re,fe,Te,xe),ao();var Ot=re.memoizedState;Ie!==Ht||Rt!==Ot||Cs||J!==null&&J.dependencies!==null&&$o(J.dependencies)?(typeof Ve=="function"&&(kc(re,oe,Ve,fe),Ot=re.memoizedState),(Vt=Cs||bh(re,oe,Vt,fe,Rt,Ot,at)||J!==null&&J.dependencies!==null&&$o(J.dependencies))?(Ct||typeof Te.UNSAFE_componentWillUpdate!="function"&&typeof Te.componentWillUpdate!="function"||(typeof Te.componentWillUpdate=="function"&&Te.componentWillUpdate(fe,Ot,at),typeof Te.UNSAFE_componentWillUpdate=="function"&&Te.UNSAFE_componentWillUpdate(fe,Ot,at)),typeof Te.componentDidUpdate=="function"&&(re.flags|=4),typeof Te.getSnapshotBeforeUpdate=="function"&&(re.flags|=1024)):(typeof Te.componentDidUpdate!="function"||Ie===J.memoizedProps&&Rt===J.memoizedState||(re.flags|=4),typeof Te.getSnapshotBeforeUpdate!="function"||Ie===J.memoizedProps&&Rt===J.memoizedState||(re.flags|=1024),re.memoizedProps=fe,re.memoizedState=Ot),Te.props=fe,Te.state=Ot,Te.context=at,fe=Vt):(typeof Te.componentDidUpdate!="function"||Ie===J.memoizedProps&&Rt===J.memoizedState||(re.flags|=4),typeof Te.getSnapshotBeforeUpdate!="function"||Ie===J.memoizedProps&&Rt===J.memoizedState||(re.flags|=1024),fe=!1)}return Te=fe,sl(J,re),fe=(re.flags&128)!==0,Te||fe?(Te=re.stateNode,oe=fe&&typeof oe.getDerivedStateFromError!="function"?null:Te.render(),re.flags|=1,J!==null&&fe?(re.child=ia(re,J.child,null,xe),re.child=ia(re,null,oe,xe)):mr(J,re,oe,xe),re.memoizedState=Te.state,J=re.child):J=ps(J,re,xe),J}function Nh(J,re,oe,fe){return Ks(),re.flags|=256,mr(J,re,oe,fe),re.child}var zc={dehydrated:null,treeContext:null,retryLane:0,hydrationErrors:null};function jc(J){return{baseLanes:J,cachePool:Ed()}}function Hc(J,re,oe){return J=J!==null?J.childLanes&~oe:0,re&&(J|=Pr),J}function Fh(J,re,oe){var fe=re.pendingProps,xe=!1,Te=(re.flags&128)!==0,Ie;if((Ie=Te)||(Ie=J!==null&&J.memoizedState===null?!1:(nr.current&2)!==0),Ie&&(xe=!0,re.flags&=-129),Ie=(re.flags&32)!==0,re.flags&=-33,J===null){if(Ei){if(xe?Ds(re):Bs(),(J=Hi)?(J=Wf(J,Gr),J=J!==null&&J.data!=="&"?J:null,J!==null&&(re.memoizedState={dehydrated:J,treeContext:Ts!==null?{id:ts,overflow:ns}:null,retryLane:536870912,hydrationErrors:null},oe=fd(J),oe.return=re,re.child=oe,fr=re,Hi=null)):J=null,J===null)throw ws(re);return Mu(J)?re.lanes=32:re.lanes=536870912,null}var Ve=fe.children;return fe=fe.fallback,xe?(Bs(),xe=re.mode,Ve=al({mode:"hidden",children:Ve},xe),fe=Ys(fe,xe,oe,null),Ve.return=re,fe.return=re,Ve.sibling=fe,re.child=Ve,fe=re.child,fe.memoizedState=jc(oe),fe.childLanes=Hc(J,Ie,oe),re.memoizedState=zc,fo(null,fe)):(Ds(re),Qc(re,Ve))}var at=J.memoizedState;if(at!==null&&(Ve=at.dehydrated,Ve!==null)){if(Te)re.flags&256?(Ds(re),re.flags&=-257,re=qc(J,re,oe)):re.memoizedState!==null?(Bs(),re.child=J.child,re.flags|=128,re=null):(Bs(),Ve=fe.fallback,xe=re.mode,fe=al({mode:"visible",children:fe.children},xe),Ve=Ys(Ve,xe,oe,null),Ve.flags|=2,fe.return=re,Ve.return=re,fe.sibling=Ve,re.child=fe,ia(re,J.child,null,oe),fe=re.child,fe.memoizedState=jc(oe),fe.childLanes=Hc(J,Ie,oe),re.memoizedState=zc,re=fo(null,fe));else if(Ds(re),Mu(Ve)){if(Ie=Ve.nextSibling&&Ve.nextSibling.dataset,Ie)var Ct=Ie.dgst;Ie=Ct,fe=Error(O(419)),fe.stack="",fe.digest=Ie,eo({value:fe,source:null,stack:null}),re=qc(J,re,oe)}else if(ar||Ea(J,re,oe,!1),Ie=(oe&J.childLanes)!==0,ar||Ie){if(Ie=zi,Ie!==null&&(fe=qr(Ie,oe),fe!==0&&fe!==at.retryLane))throw at.retryLane=fe,Xs(J,fe),Sr(Ie,J,fe),Vc;wu(Ve)||gl(),re=qc(J,re,oe)}else wu(Ve)?(re.flags|=192,re.child=J.child,re=null):(J=at.treeContext,Hi=jr(Ve.nextSibling),fr=re,Ei=!0,Ss=null,Gr=!1,J!==null&&gd(re,J),re=Qc(re,fe.children),re.flags|=4096);return re}return xe?(Bs(),Ve=fe.fallback,xe=re.mode,at=J.child,Ct=at.sibling,fe=ls(at,{mode:"hidden",children:fe.children}),fe.subtreeFlags=at.subtreeFlags&65011712,Ct!==null?Ve=ls(Ct,Ve):(Ve=Ys(Ve,xe,oe,null),Ve.flags|=2),Ve.return=re,fe.return=re,fe.sibling=Ve,re.child=fe,fo(null,fe),fe=re.child,Ve=J.child.memoizedState,Ve===null?Ve=jc(oe):(xe=Ve.cachePool,xe!==null?(at=rr._currentValue,xe=xe.parent!==at?{parent:at,pool:at}:xe):xe=Ed(),Ve={baseLanes:Ve.baseLanes|oe,cachePool:xe}),fe.memoizedState=Ve,fe.childLanes=Hc(J,Ie,oe),re.memoizedState=zc,fo(J.child,fe)):(Ds(re),oe=J.child,J=oe.sibling,oe=ls(oe,{mode:"visible",children:fe.children}),oe.return=re,oe.sibling=null,J!==null&&(Ie=re.deletions,Ie===null?(re.deletions=[J],re.flags|=16):Ie.push(J)),re.child=oe,re.memoizedState=null,oe)}function Qc(J,re){return re=al({mode:"visible",children:re},J.mode),re.return=J,J.child=re}function al(J,re){return J=Ir(22,J,null,re),J.lanes=0,J}function qc(J,re,oe){return ia(re,J.child,null,oe),J=Qc(re,re.pendingProps.children),J.flags|=2,re.memoizedState=null,J}function kh(J,re,oe){J.lanes|=re;var fe=J.alternate;fe!==null&&(fe.lanes|=re),ac(J.return,re,oe)}function Wc(J,re,oe,fe,xe,Te){var Ie=J.memoizedState;Ie===null?J.memoizedState={isBackwards:re,rendering:null,renderingStartTime:0,last:fe,tail:oe,tailMode:xe,treeForkCount:Te}:(Ie.isBackwards=re,Ie.rendering=null,Ie.renderingStartTime=0,Ie.last=fe,Ie.tail=oe,Ie.tailMode=xe,Ie.treeForkCount=Te)}function Uh(J,re,oe){var fe=re.pendingProps,xe=fe.revealOrder,Te=fe.tail;fe=fe.children;var Ie=nr.current,Ve=(Ie&2)!==0;if(Ve?(Ie=Ie&1|2,re.flags|=128):Ie&=1,St(nr,Ie),mr(J,re,fe,oe),fe=Ei?Za:0,!Ve&&J!==null&&(J.flags&128)!==0)e:for(J=re.child;J!==null;){if(J.tag===13)J.memoizedState!==null&&kh(J,oe,re);else if(J.tag===19)kh(J,oe,re);else if(J.child!==null){J.child.return=J,J=J.child;continue}if(J===re)break e;for(;J.sibling===null;){if(J.return===null||J.return===re)break e;J=J.return}J.sibling.return=J.return,J=J.sibling}switch(xe){case"forwards":for(oe=re.child,xe=null;oe!==null;)J=oe.alternate,J!==null&&Wo(J)===null&&(xe=oe),oe=oe.sibling;oe=xe,oe===null?(xe=re.child,re.child=null):(xe=oe.sibling,oe.sibling=null),Wc(re,!1,xe,oe,Te,fe);break;case"backwards":case"unstable_legacy-backwards":for(oe=null,xe=re.child,re.child=null;xe!==null;){if(J=xe.alternate,J!==null&&Wo(J)===null){re.child=xe;break}J=xe.sibling,xe.sibling=oe,oe=xe,xe=J}Wc(re,!0,oe,null,Te,fe);break;case"together":Wc(re,!1,null,null,void 0,fe);break;default:re.memoizedState=null}return re.child}function ps(J,re,oe){if(J!==null&&(re.dependencies=J.dependencies),Ls|=re.lanes,(oe&re.childLanes)===0)if(J!==null){if(Ea(J,re,oe,!1),(oe&re.childLanes)===0)return null}else return null;if(J!==null&&re.child!==J.child)throw Error(O(153));if(re.child!==null){for(J=re.child,oe=ls(J,J.pendingProps),re.child=oe,oe.return=re;J.sibling!==null;)J=J.sibling,oe=oe.sibling=ls(J,J.pendingProps),oe.return=re;oe.sibling=null}return re.child}function Xc(J,re){return(J.lanes&re)!==0?!0:(J=J.dependencies,!!(J!==null&&$o(J)))}function ym(J,re,oe){switch(re.tag){case 3:Xt(re,re.stateNode.containerInfo),Ms(re,rr,J.memoizedState.cache),Ks();break;case 27:case 5:Jt(re);break;case 4:Xt(re,re.stateNode.containerInfo);break;case 10:Ms(re,re.type,re.memoizedProps.value);break;case 31:if(re.memoizedState!==null)return re.flags|=128,xc(re),null;break;case 13:var fe=re.memoizedState;if(fe!==null)return fe.dehydrated!==null?(Ds(re),re.flags|=128,null):(oe&re.child.childLanes)!==0?Fh(J,re,oe):(Ds(re),J=ps(J,re,oe),J!==null?J.sibling:null);Ds(re);break;case 19:var xe=(J.flags&128)!==0;if(fe=(oe&re.childLanes)!==0,fe||(Ea(J,re,oe,!1),fe=(oe&re.childLanes)!==0),xe){if(fe)return Uh(J,re,oe);re.flags|=128}if(xe=re.memoizedState,xe!==null&&(xe.rendering=null,xe.tail=null,xe.lastEffect=null),St(nr,nr.current),fe)break;return null;case 22:return re.lanes=0,Dh(J,re,oe,re.pendingProps);case 24:Ms(re,rr,J.memoizedState.cache)}return ps(J,re,oe)}function $h(J,re,oe){if(J!==null)if(J.memoizedProps!==re.pendingProps)ar=!0;else{if(!Xc(J,oe)&&(re.flags&128)===0)return ar=!1,ym(J,re,oe);ar=(J.flags&131072)!==0}else ar=!1,Ei&&(re.flags&1048576)!==0&&md(re,Za,re.index);switch(re.lanes=0,re.tag){case 16:e:{var fe=re.pendingProps;if(J=ta(re.elementType),re.type=J,typeof J=="function")Kl(J)?(fe=sa(J,fe),re.tag=1,re=Lh(null,re,J,fe,oe)):(re.tag=0,re=Gc(null,re,J,fe,oe));else{if(J!=null){var xe=J.$$typeof;if(xe===be){re.tag=11,re=Ch(null,re,J,fe,oe);break e}else if(xe===Se){re.tag=14,re=Ih(null,re,J,fe,oe);break e}}throw re=Oe(J)||J,Error(O(306,re,""))}}return re;case 0:return Gc(J,re,re.type,re.pendingProps,oe);case 1:return fe=re.type,xe=sa(fe,re.pendingProps),Lh(J,re,fe,xe,oe);case 3:e:{if(Xt(re,re.stateNode.containerInfo),J===null)throw Error(O(387));fe=re.pendingProps;var Te=re.memoizedState;xe=Te.element,pc(J,re),oo(re,fe,null,oe);var Ie=re.memoizedState;if(fe=Ie.cache,Ms(re,rr,fe),fe!==Te.cache&&oc(re,[rr],oe,!0),ao(),fe=Ie.element,Te.isDehydrated)if(Te={element:fe,isDehydrated:!1,cache:Ie.cache},re.updateQueue.baseState=Te,re.memoizedState=Te,re.flags&256){re=Nh(J,re,fe,oe);break e}else if(fe!==xe){xe=Ur(Error(O(424)),re),eo(xe),re=Nh(J,re,fe,oe);break e}else{switch(J=re.stateNode.containerInfo,J.nodeType){case 9:J=J.body;break;default:J=J.nodeName==="HTML"?J.ownerDocument.body:J}for(Hi=jr(J.firstChild),fr=re,Ei=!0,Ss=null,Gr=!0,oe=Id(re,null,fe,oe),re.child=oe;oe;)oe.flags=oe.flags&-3|4096,oe=oe.sibling}else{if(Ks(),fe===xe){re=ps(J,re,oe);break e}mr(J,re,fe,oe)}re=re.child}return re;case 26:return sl(J,re),J===null?(oe=ep(re.type,null,re.pendingProps,null))?re.memoizedState=oe:Ei||(oe=re.type,J=re.pendingProps,fe=Tl(mt.current).createElement(oe),fe[ji]=re,fe[Ge]=J,gr(fe,oe,J),_t(fe),re.stateNode=fe):re.memoizedState=ep(re.type,J.memoizedProps,re.pendingProps,J.memoizedState),null;case 27:return Jt(re),J===null&&Ei&&(fe=re.stateNode=Kf(re.type,re.pendingProps,mt.current),fr=re,Gr=!0,xe=Hi,$s(re.type)?(Cu=xe,Hi=jr(fe.firstChild)):Hi=xe),mr(J,re,re.pendingProps.children,oe),sl(J,re),J===null&&(re.flags|=4194304),re.child;case 5:return J===null&&Ei&&((xe=fe=Hi)&&(fe=Km(fe,re.type,re.pendingProps,Gr),fe!==null?(re.stateNode=fe,fr=re,Hi=jr(fe.firstChild),Gr=!1,xe=!0):xe=!1),xe||ws(re)),Jt(re),xe=re.type,Te=re.pendingProps,Ie=J!==null?J.memoizedProps:null,fe=Te.children,Eu(xe,Te)?fe=null:Ie!==null&&Eu(xe,Ie)&&(re.flags|=32),re.memoizedState!==null&&(xe=vc(J,re,dm,null,null,oe),Io._currentValue=xe),sl(J,re),mr(J,re,fe,oe),re.child;case 6:return J===null&&Ei&&((J=oe=Hi)&&(oe=Jm(oe,re.pendingProps,Gr),oe!==null?(re.stateNode=oe,fr=re,Hi=null,J=!0):J=!1),J||ws(re)),null;case 13:return Fh(J,re,oe);case 4:return Xt(re,re.stateNode.containerInfo),fe=re.pendingProps,J===null?re.child=ia(re,null,fe,oe):mr(J,re,fe,oe),re.child;case 11:return Ch(J,re,re.type,re.pendingProps,oe);case 7:return mr(J,re,re.pendingProps,oe),re.child;case 8:return mr(J,re,re.pendingProps.children,oe),re.child;case 12:return mr(J,re,re.pendingProps.children,oe),re.child;case 10:return fe=re.pendingProps,Ms(re,re.type,fe.value),mr(J,re,fe.children,oe),re.child;case 9:return xe=re.type._context,fe=re.pendingProps.children,Zs(re),xe=pr(xe),fe=fe(xe),re.flags|=1,mr(J,re,fe,oe),re.child;case 14:return Ih(J,re,re.type,re.pendingProps,oe);case 15:return Rh(J,re,re.type,re.pendingProps,oe);case 19:return Uh(J,re,oe);case 31:return xm(J,re,oe);case 22:return Dh(J,re,oe,re.pendingProps);case 24:return Zs(re),fe=pr(rr),J===null?(xe=dc(),xe===null&&(xe=zi,Te=cc(),xe.pooledCache=Te,Te.refCount++,Te!==null&&(xe.pooledCacheLanes|=oe),xe=Te),re.memoizedState={parent:fe,cache:xe},fc(re),Ms(re,rr,xe)):((J.lanes&oe)!==0&&(pc(J,re),oo(re,null,null,oe),ao()),xe=J.memoizedState,Te=re.memoizedState,xe.parent!==fe?(xe={parent:fe,cache:fe},re.memoizedState=xe,re.lanes===0&&(re.memoizedState=re.updateQueue.baseState=xe),Ms(re,rr,fe)):(fe=Te.cache,Ms(re,rr,fe),fe!==xe.cache&&oc(re,[rr],oe,!0))),mr(J,re,re.pendingProps.children,oe),re.child;case 29:throw re.pendingProps}throw Error(O(156,re.tag))}function ms(J){J.flags|=4}function Yc(J,re,oe,fe,xe){if((re=(J.mode&32)!==0)&&(re=!1),re){if(J.flags|=16777216,(xe&335544128)===xe)if(J.stateNode.complete)J.flags|=8192;else if(pf())J.flags|=8192;else throw na=jo,hc}else J.flags&=-16777217}function Vh(J,re){if(re.type!=="stylesheet"||(re.state.loading&4)!==0)J.flags&=-16777217;else if(J.flags|=16777216,!sp(re))if(pf())J.flags|=8192;else throw na=jo,hc}function ol(J,re){re!==null&&(J.flags|=4),J.flags&16384&&(re=J.tag!==22?Ai():536870912,J.lanes|=re,La|=re)}function po(J,re){if(!Ei)switch(J.tailMode){case"hidden":re=J.tail;for(var oe=null;re!==null;)re.alternate!==null&&(oe=re),re=re.sibling;oe===null?J.tail=null:oe.sibling=null;break;case"collapsed":oe=J.tail;for(var fe=null;oe!==null;)oe.alternate!==null&&(fe=oe),oe=oe.sibling;fe===null?re||J.tail===null?J.tail=null:J.tail.sibling=null:fe.sibling=null}}function Qi(J){var re=J.alternate!==null&&J.alternate.child===J.child,oe=0,fe=0;if(re)for(var xe=J.child;xe!==null;)oe|=xe.lanes|xe.childLanes,fe|=xe.subtreeFlags&65011712,fe|=xe.flags&65011712,xe.return=J,xe=xe.sibling;else for(xe=J.child;xe!==null;)oe|=xe.lanes|xe.childLanes,fe|=xe.subtreeFlags,fe|=xe.flags,xe.return=J,xe=xe.sibling;return J.subtreeFlags|=fe,J.childLanes=oe,re}function vm(J,re,oe){var fe=re.pendingProps;switch(nc(re),re.tag){case 16:case 15:case 0:case 11:case 7:case 8:case 12:case 9:case 14:return Qi(re),null;case 1:return Qi(re),null;case 3:return oe=re.stateNode,fe=null,J!==null&&(fe=J.memoizedState.cache),re.memoizedState.cache!==fe&&(re.flags|=2048),ds(rr),hn(),oe.pendingContext&&(oe.context=oe.pendingContext,oe.pendingContext=null),(J===null||J.child===null)&&(va(re)?ms(re):J===null||J.memoizedState.isDehydrated&&(re.flags&256)===0||(re.flags|=1024,rc())),Qi(re),null;case 26:var xe=re.type,Te=re.memoizedState;return J===null?(ms(re),Te!==null?(Qi(re),Vh(re,Te)):(Qi(re),Yc(re,xe,null,fe,oe))):Te?Te!==J.memoizedState?(ms(re),Qi(re),Vh(re,Te)):(Qi(re),re.flags&=-16777217):(J=J.memoizedProps,J!==fe&&ms(re),Qi(re),Yc(re,xe,J,fe,oe)),null;case 27:if(Mn(re),oe=mt.current,xe=re.type,J!==null&&re.stateNode!=null)J.memoizedProps!==fe&&ms(re);else{if(!fe){if(re.stateNode===null)throw Error(O(166));return Qi(re),null}J=Lt.current,va(re)?Ad(re):(J=Kf(xe,fe,oe),re.stateNode=J,ms(re))}return Qi(re),null;case 5:if(Mn(re),xe=re.type,J!==null&&re.stateNode!=null)J.memoizedProps!==fe&&ms(re);else{if(!fe){if(re.stateNode===null)throw Error(O(166));return Qi(re),null}if(Te=Lt.current,va(re))Ad(re);else{var Ie=Tl(mt.current);switch(Te){case 1:Te=Ie.createElementNS("http://www.w3.org/2000/svg",xe);break;case 2:Te=Ie.createElementNS("http://www.w3.org/1998/Math/MathML",xe);break;default:switch(xe){case"svg":Te=Ie.createElementNS("http://www.w3.org/2000/svg",xe);break;case"math":Te=Ie.createElementNS("http://www.w3.org/1998/Math/MathML",xe);break;case"script":Te=Ie.createElement("div"),Te.innerHTML="<script><\/script>",Te=Te.removeChild(Te.firstChild);break;case"select":Te=typeof fe.is=="string"?Ie.createElement("select",{is:fe.is}):Ie.createElement("select"),fe.multiple?Te.multiple=!0:fe.size&&(Te.size=fe.size);break;default:Te=typeof fe.is=="string"?Ie.createElement(xe,{is:fe.is}):Ie.createElement(xe)}}Te[ji]=re,Te[Ge]=fe;e:for(Ie=re.child;Ie!==null;){if(Ie.tag===5||Ie.tag===6)Te.appendChild(Ie.stateNode);else if(Ie.tag!==4&&Ie.tag!==27&&Ie.child!==null){Ie.child.return=Ie,Ie=Ie.child;continue}if(Ie===re)break e;for(;Ie.sibling===null;){if(Ie.return===null||Ie.return===re)break e;Ie=Ie.return}Ie.sibling.return=Ie.return,Ie=Ie.sibling}re.stateNode=Te;e:switch(gr(Te,xe,fe),xe){case"button":case"input":case"select":case"textarea":fe=!!fe.autoFocus;break e;case"img":fe=!0;break e;default:fe=!1}fe&&ms(re)}}return Qi(re),Yc(re,re.type,J===null?null:J.memoizedProps,re.pendingProps,oe),null;case 6:if(J&&re.stateNode!=null)J.memoizedProps!==fe&&ms(re);else{if(typeof fe!="string"&&re.stateNode===null)throw Error(O(166));if(J=mt.current,va(re)){if(J=re.stateNode,oe=re.memoizedProps,fe=null,xe=fr,xe!==null)switch(xe.tag){case 27:case 5:fe=xe.memoizedProps}J[ji]=re,J=!!(J.nodeValue===oe||fe!==null&&fe.suppressHydrationWarning===!0||$f(J.nodeValue,oe)),J||ws(re,!0)}else J=Tl(J).createTextNode(fe),J[ji]=re,re.stateNode=J}return Qi(re),null;case 31:if(oe=re.memoizedState,J===null||J.memoizedState!==null){if(fe=va(re),oe!==null){if(J===null){if(!fe)throw Error(O(318));if(J=re.memoizedState,J=J!==null?J.dehydrated:null,!J)throw Error(O(557));J[ji]=re}else Ks(),(re.flags&128)===0&&(re.memoizedState=null),re.flags|=4;Qi(re),J=!1}else oe=rc(),J!==null&&J.memoizedState!==null&&(J.memoizedState.hydrationErrors=oe),J=!0;if(!J)return re.flags&256?(Dr(re),re):(Dr(re),null);if((re.flags&128)!==0)throw Error(O(558))}return Qi(re),null;case 13:if(fe=re.memoizedState,J===null||J.memoizedState!==null&&J.memoizedState.dehydrated!==null){if(xe=va(re),fe!==null&&fe.dehydrated!==null){if(J===null){if(!xe)throw Error(O(318));if(xe=re.memoizedState,xe=xe!==null?xe.dehydrated:null,!xe)throw Error(O(317));xe[ji]=re}else Ks(),(re.flags&128)===0&&(re.memoizedState=null),re.flags|=4;Qi(re),xe=!1}else xe=rc(),J!==null&&J.memoizedState!==null&&(J.memoizedState.hydrationErrors=xe),xe=!0;if(!xe)return re.flags&256?(Dr(re),re):(Dr(re),null)}return Dr(re),(re.flags&128)!==0?(re.lanes=oe,re):(oe=fe!==null,J=J!==null&&J.memoizedState!==null,oe&&(fe=re.child,xe=null,fe.alternate!==null&&fe.alternate.memoizedState!==null&&fe.alternate.memoizedState.cachePool!==null&&(xe=fe.alternate.memoizedState.cachePool.pool),Te=null,fe.memoizedState!==null&&fe.memoizedState.cachePool!==null&&(Te=fe.memoizedState.cachePool.pool),Te!==xe&&(fe.flags|=2048)),oe!==J&&oe&&(re.child.flags|=8192),ol(re,re.updateQueue),Qi(re),null);case 4:return hn(),J===null&&_u(re.stateNode.containerInfo),Qi(re),null;case 10:return ds(re.type),Qi(re),null;case 19:if(rt(nr),fe=re.memoizedState,fe===null)return Qi(re),null;if(xe=(re.flags&128)!==0,Te=fe.rendering,Te===null)if(xe)po(fe,!1);else{if(Zi!==0||J!==null&&(J.flags&128)!==0)for(J=re.child;J!==null;){if(Te=Wo(J),Te!==null){for(re.flags|=128,po(fe,!1),J=Te.updateQueue,re.updateQueue=J,ol(re,J),re.subtreeFlags=0,J=oe,oe=re.child;oe!==null;)hd(oe,J),oe=oe.sibling;return St(nr,nr.current&1|2),Ei&&cs(re,fe.treeForkCount),re.child}J=J.sibling}fe.tail!==null&&Fe()>hl&&(re.flags|=128,xe=!0,po(fe,!1),re.lanes=4194304)}else{if(!xe)if(J=Wo(Te),J!==null){if(re.flags|=128,xe=!0,J=J.updateQueue,re.updateQueue=J,ol(re,J),po(fe,!0),fe.tail===null&&fe.tailMode==="hidden"&&!Te.alternate&&!Ei)return Qi(re),null}else 2*Fe()-fe.renderingStartTime>hl&&oe!==536870912&&(re.flags|=128,xe=!0,po(fe,!1),re.lanes=4194304);fe.isBackwards?(Te.sibling=re.child,re.child=Te):(J=fe.last,J!==null?J.sibling=Te:re.child=Te,fe.last=Te)}return fe.tail!==null?(J=fe.tail,fe.rendering=J,fe.tail=J.sibling,fe.renderingStartTime=Fe(),J.sibling=null,oe=nr.current,St(nr,xe?oe&1|2:oe&1),Ei&&cs(re,fe.treeForkCount),J):(Qi(re),null);case 22:case 23:return Dr(re),bc(),fe=re.memoizedState!==null,J!==null?J.memoizedState!==null!==fe&&(re.flags|=8192):fe&&(re.flags|=8192),fe?(oe&536870912)!==0&&(re.flags&128)===0&&(Qi(re),re.subtreeFlags&6&&(re.flags|=8192)):Qi(re),oe=re.updateQueue,oe!==null&&ol(re,oe.retryQueue),oe=null,J!==null&&J.memoizedState!==null&&J.memoizedState.cachePool!==null&&(oe=J.memoizedState.cachePool.pool),fe=null,re.memoizedState!==null&&re.memoizedState.cachePool!==null&&(fe=re.memoizedState.cachePool.pool),fe!==oe&&(re.flags|=2048),J!==null&&rt(ea),null;case 24:return oe=null,J!==null&&(oe=J.memoizedState.cache),re.memoizedState.cache!==oe&&(re.flags|=2048),ds(rr),Qi(re),null;case 25:return null;case 30:return null}throw Error(O(156,re.tag))}function Em(J,re){switch(nc(re),re.tag){case 1:return J=re.flags,J&65536?(re.flags=J&-65537|128,re):null;case 3:return ds(rr),hn(),J=re.flags,(J&65536)!==0&&(J&128)===0?(re.flags=J&-65537|128,re):null;case 26:case 27:case 5:return Mn(re),null;case 31:if(re.memoizedState!==null){if(Dr(re),re.alternate===null)throw Error(O(340));Ks()}return J=re.flags,J&65536?(re.flags=J&-65537|128,re):null;case 13:if(Dr(re),J=re.memoizedState,J!==null&&J.dehydrated!==null){if(re.alternate===null)throw Error(O(340));Ks()}return J=re.flags,J&65536?(re.flags=J&-65537|128,re):null;case 19:return rt(nr),null;case 4:return hn(),null;case 10:return ds(re.type),null;case 22:case 23:return Dr(re),bc(),J!==null&&rt(ea),J=re.flags,J&65536?(re.flags=J&-65537|128,re):null;case 24:return ds(rr),null;case 25:return null;default:return null}}function Gh(J,re){switch(nc(re),re.tag){case 3:ds(rr),hn();break;case 26:case 27:case 5:Mn(re);break;case 4:hn();break;case 31:re.memoizedState!==null&&Dr(re);break;case 13:Dr(re);break;case 19:rt(nr);break;case 10:ds(re.type);break;case 22:case 23:Dr(re),bc(),J!==null&&rt(ea);break;case 24:ds(rr)}}function mo(J,re){try{var oe=re.updateQueue,fe=oe!==null?oe.lastEffect:null;if(fe!==null){var xe=fe.next;oe=xe;do{if((oe.tag&J)===J){fe=void 0;var Te=oe.create,Ie=oe.inst;fe=Te(),Ie.destroy=fe}oe=oe.next}while(oe!==xe)}}catch(Ve){Fi(re,re.return,Ve)}}function Ps(J,re,oe){try{var fe=re.updateQueue,xe=fe!==null?fe.lastEffect:null;if(xe!==null){var Te=xe.next;fe=Te;do{if((fe.tag&J)===J){var Ie=fe.inst,Ve=Ie.destroy;if(Ve!==void 0){Ie.destroy=void 0,xe=re;var at=oe,Ct=Ve;try{Ct()}catch(Vt){Fi(xe,at,Vt)}}}fe=fe.next}while(fe!==Te)}}catch(Vt){Fi(re,re.return,Vt)}}function zh(J){var re=J.updateQueue;if(re!==null){var oe=J.stateNode;try{Dd(re,oe)}catch(fe){Fi(J,J.return,fe)}}}function jh(J,re,oe){oe.props=sa(J.type,J.memoizedProps),oe.state=J.memoizedState;try{oe.componentWillUnmount()}catch(fe){Fi(J,re,fe)}}function go(J,re){try{var oe=J.ref;if(oe!==null){switch(J.tag){case 26:case 27:case 5:var fe=J.stateNode;break;case 30:fe=J.stateNode;break;default:fe=J.stateNode}typeof oe=="function"?J.refCleanup=oe(fe):oe.current=fe}}catch(xe){Fi(J,re,xe)}}function is(J,re){var oe=J.ref,fe=J.refCleanup;if(oe!==null)if(typeof fe=="function")try{fe()}catch(xe){Fi(J,re,xe)}finally{J.refCleanup=null,J=J.alternate,J!=null&&(J.refCleanup=null)}else if(typeof oe=="function")try{oe(null)}catch(xe){Fi(J,re,xe)}else oe.current=null}function Hh(J){var re=J.type,oe=J.memoizedProps,fe=J.stateNode;try{e:switch(re){case"button":case"input":case"select":case"textarea":oe.autoFocus&&fe.focus();break e;case"img":oe.src?fe.src=oe.src:oe.srcSet&&(fe.srcset=oe.srcSet)}}catch(xe){Fi(J,J.return,xe)}}function Kc(J,re,oe){try{var fe=J.stateNode;Hm(fe,J.type,oe,re),fe[Ge]=re}catch(xe){Fi(J,J.return,xe)}}function Qh(J){return J.tag===5||J.tag===3||J.tag===26||J.tag===27&&$s(J.type)||J.tag===4}function Jc(J){e:for(;;){for(;J.sibling===null;){if(J.return===null||Qh(J.return))return null;J=J.return}for(J.sibling.return=J.return,J=J.sibling;J.tag!==5&&J.tag!==6&&J.tag!==18;){if(J.tag===27&&$s(J.type)||J.flags&2||J.child===null||J.tag===4)continue e;J.child.return=J,J=J.child}if(!(J.flags&2))return J.stateNode}}function Zc(J,re,oe){var fe=J.tag;if(fe===5||fe===6)J=J.stateNode,re?(oe.nodeType===9?oe.body:oe.nodeName==="HTML"?oe.ownerDocument.body:oe).insertBefore(J,re):(re=oe.nodeType===9?oe.body:oe.nodeName==="HTML"?oe.ownerDocument.body:oe,re.appendChild(J),oe=oe._reactRootContainer,oe!=null||re.onclick!==null||(re.onclick=Nr));else if(fe!==4&&(fe===27&&$s(J.type)&&(oe=J.stateNode,re=null),J=J.child,J!==null))for(Zc(J,re,oe),J=J.sibling;J!==null;)Zc(J,re,oe),J=J.sibling}function ll(J,re,oe){var fe=J.tag;if(fe===5||fe===6)J=J.stateNode,re?oe.insertBefore(J,re):oe.appendChild(J);else if(fe!==4&&(fe===27&&$s(J.type)&&(oe=J.stateNode),J=J.child,J!==null))for(ll(J,re,oe),J=J.sibling;J!==null;)ll(J,re,oe),J=J.sibling}function qh(J){var re=J.stateNode,oe=J.memoizedProps;try{for(var fe=J.type,xe=re.attributes;xe.length;)re.removeAttributeNode(xe[0]);gr(re,fe,oe),re[ji]=J,re[Ge]=oe}catch(Te){Fi(J,J.return,Te)}}var gs=!1,or=!1,eu=!1,Wh=typeof WeakSet=="function"?WeakSet:Set,dr=null;function Tm(J,re){if(J=J.containerInfo,yu=Dl,J=nd(J),jl(J)){if("selectionStart"in J)var oe={start:J.selectionStart,end:J.selectionEnd};else e:{oe=(oe=J.ownerDocument)&&oe.defaultView||window;var fe=oe.getSelection&&oe.getSelection();if(fe&&fe.rangeCount!==0){oe=fe.anchorNode;var xe=fe.anchorOffset,Te=fe.focusNode;fe=fe.focusOffset;try{oe.nodeType,Te.nodeType}catch{oe=null;break e}var Ie=0,Ve=-1,at=-1,Ct=0,Vt=0,Ht=J,Rt=null;t:for(;;){for(var Ot;Ht!==oe||xe!==0&&Ht.nodeType!==3||(Ve=Ie+xe),Ht!==Te||fe!==0&&Ht.nodeType!==3||(at=Ie+fe),Ht.nodeType===3&&(Ie+=Ht.nodeValue.length),(Ot=Ht.firstChild)!==null;)Rt=Ht,Ht=Ot;for(;;){if(Ht===J)break t;if(Rt===oe&&++Ct===xe&&(Ve=Ie),Rt===Te&&++Vt===fe&&(at=Ie),(Ot=Ht.nextSibling)!==null)break;Ht=Rt,Rt=Ht.parentNode}Ht=Ot}oe=Ve===-1||at===-1?null:{start:Ve,end:at}}else oe=null}oe=oe||{start:0,end:0}}else oe=null;for(vu={focusedElem:J,selectionRange:oe},Dl=!1,dr=re;dr!==null;)if(re=dr,J=re.child,(re.subtreeFlags&1028)!==0&&J!==null)J.return=re,dr=J;else for(;dr!==null;){switch(re=dr,Te=re.alternate,J=re.flags,re.tag){case 0:if((J&4)!==0&&(J=re.updateQueue,J=J!==null?J.events:null,J!==null))for(oe=0;oe<J.length;oe++)xe=J[oe],xe.ref.impl=xe.nextImpl;break;case 11:case 15:break;case 1:if((J&1024)!==0&&Te!==null){J=void 0,oe=re,xe=Te.memoizedProps,Te=Te.memoizedState,fe=oe.stateNode;try{var Pn=sa(oe.type,xe);J=fe.getSnapshotBeforeUpdate(Pn,Te),fe.__reactInternalSnapshotBeforeUpdate=J}catch(Kn){Fi(oe,oe.return,Kn)}}break;case 3:if((J&1024)!==0){if(J=re.stateNode.containerInfo,oe=J.nodeType,oe===9)Su(J);else if(oe===1)switch(J.nodeName){case"HEAD":case"HTML":case"BODY":Su(J);break;default:J.textContent=""}}break;case 5:case 26:case 27:case 6:case 4:case 17:break;default:if((J&1024)!==0)throw Error(O(163))}if(J=re.sibling,J!==null){J.return=re.return,dr=J;break}dr=re.return}}function Xh(J,re,oe){var fe=oe.flags;switch(oe.tag){case 0:case 11:case 15:_s(J,oe),fe&4&&mo(5,oe);break;case 1:if(_s(J,oe),fe&4)if(J=oe.stateNode,re===null)try{J.componentDidMount()}catch(Ie){Fi(oe,oe.return,Ie)}else{var xe=sa(oe.type,re.memoizedProps);re=re.memoizedState;try{J.componentDidUpdate(xe,re,J.__reactInternalSnapshotBeforeUpdate)}catch(Ie){Fi(oe,oe.return,Ie)}}fe&64&&zh(oe),fe&512&&go(oe,oe.return);break;case 3:if(_s(J,oe),fe&64&&(J=oe.updateQueue,J!==null)){if(re=null,oe.child!==null)switch(oe.child.tag){case 27:case 5:re=oe.child.stateNode;break;case 1:re=oe.child.stateNode}try{Dd(J,re)}catch(Ie){Fi(oe,oe.return,Ie)}}break;case 27:re===null&&fe&4&&qh(oe);case 26:case 5:_s(J,oe),re===null&&fe&4&&Hh(oe),fe&512&&go(oe,oe.return);break;case 12:_s(J,oe);break;case 31:_s(J,oe),fe&4&&Jh(J,oe);break;case 13:_s(J,oe),fe&4&&Zh(J,oe),fe&64&&(J=oe.memoizedState,J!==null&&(J=J.dehydrated,J!==null&&(oe=Pm.bind(null,oe),Zm(J,oe))));break;case 22:if(fe=oe.memoizedState!==null||gs,!fe){re=re!==null&&re.memoizedState!==null||or,xe=gs;var Te=or;gs=fe,(or=re)&&!Te?bs(J,oe,(oe.subtreeFlags&8772)!==0):_s(J,oe),gs=xe,or=Te}break;case 30:break;default:_s(J,oe)}}function Yh(J){var re=J.alternate;re!==null&&(J.alternate=null,Yh(re)),J.child=null,J.deletions=null,J.sibling=null,J.tag===5&&(re=J.stateNode,re!==null&&On(re)),J.stateNode=null,J.return=null,J.dependencies=null,J.memoizedProps=null,J.memoizedState=null,J.pendingProps=null,J.stateNode=null,J.updateQueue=null}var qi=null,yr=!1;function As(J,re,oe){for(oe=oe.child;oe!==null;)Kh(J,re,oe),oe=oe.sibling}function Kh(J,re,oe){if(Dt&&typeof Dt.onCommitFiberUnmount=="function")try{Dt.onCommitFiberUnmount(Wt,oe)}catch{}switch(oe.tag){case 26:or||is(oe,re),As(J,re,oe),oe.memoizedState?oe.memoizedState.count--:oe.stateNode&&(oe=oe.stateNode,oe.parentNode.removeChild(oe));break;case 27:or||is(oe,re);var fe=qi,xe=yr;$s(oe.type)&&(qi=oe.stateNode,yr=!1),As(J,re,oe),wo(oe.stateNode),qi=fe,yr=xe;break;case 5:or||is(oe,re);case 6:if(fe=qi,xe=yr,qi=null,As(J,re,oe),qi=fe,yr=xe,qi!==null)if(yr)try{(qi.nodeType===9?qi.body:qi.nodeName==="HTML"?qi.ownerDocument.body:qi).removeChild(oe.stateNode)}catch(Te){Fi(oe,re,Te)}else try{qi.removeChild(oe.stateNode)}catch(Te){Fi(oe,re,Te)}break;case 18:qi!==null&&(yr?(J=qi,Qf(J.nodeType===9?J.body:J.nodeName==="HTML"?J.ownerDocument.body:J,oe.stateNode),za(J)):Qf(qi,oe.stateNode));break;case 4:fe=qi,xe=yr,qi=oe.stateNode.containerInfo,yr=!0,As(J,re,oe),qi=fe,yr=xe;break;case 0:case 11:case 14:case 15:Ps(2,oe,re),or||Ps(4,oe,re),As(J,re,oe);break;case 1:or||(is(oe,re),fe=oe.stateNode,typeof fe.componentWillUnmount=="function"&&jh(oe,re,fe)),As(J,re,oe);break;case 21:As(J,re,oe);break;case 22:or=(fe=or)||oe.memoizedState!==null,As(J,re,oe),or=fe;break;default:As(J,re,oe)}}function Jh(J,re){if(re.memoizedState===null&&(J=re.alternate,J!==null&&(J=J.memoizedState,J!==null))){J=J.dehydrated;try{za(J)}catch(oe){Fi(re,re.return,oe)}}}function Zh(J,re){if(re.memoizedState===null&&(J=re.alternate,J!==null&&(J=J.memoizedState,J!==null&&(J=J.dehydrated,J!==null))))try{za(J)}catch(oe){Fi(re,re.return,oe)}}function Sm(J){switch(J.tag){case 31:case 13:case 19:var re=J.stateNode;return re===null&&(re=J.stateNode=new Wh),re;case 22:return J=J.stateNode,re=J._retryCache,re===null&&(re=J._retryCache=new Wh),re;default:throw Error(O(435,J.tag))}}function cl(J,re){var oe=Sm(J);re.forEach(function(fe){if(!oe.has(fe)){oe.add(fe);var xe=Om.bind(null,J,fe);fe.then(xe,xe)}})}function vr(J,re){var oe=re.deletions;if(oe!==null)for(var fe=0;fe<oe.length;fe++){var xe=oe[fe],Te=J,Ie=re,Ve=Ie;e:for(;Ve!==null;){switch(Ve.tag){case 27:if($s(Ve.type)){qi=Ve.stateNode,yr=!1;break e}break;case 5:qi=Ve.stateNode,yr=!1;break e;case 3:case 4:qi=Ve.stateNode.containerInfo,yr=!0;break e}Ve=Ve.return}if(qi===null)throw Error(O(160));Kh(Te,Ie,xe),qi=null,yr=!1,Te=xe.alternate,Te!==null&&(Te.return=null),xe.return=null}if(re.subtreeFlags&13886)for(re=re.child;re!==null;)ef(re,J),re=re.sibling}var Jr=null;function ef(J,re){var oe=J.alternate,fe=J.flags;switch(J.tag){case 0:case 11:case 14:case 15:vr(re,J),Er(J),fe&4&&(Ps(3,J,J.return),mo(3,J),Ps(5,J,J.return));break;case 1:vr(re,J),Er(J),fe&512&&(or||oe===null||is(oe,oe.return)),fe&64&&gs&&(J=J.updateQueue,J!==null&&(fe=J.callbacks,fe!==null&&(oe=J.shared.hiddenCallbacks,J.shared.hiddenCallbacks=oe===null?fe:oe.concat(fe))));break;case 26:var xe=Jr;if(vr(re,J),Er(J),fe&512&&(or||oe===null||is(oe,oe.return)),fe&4){var Te=oe!==null?oe.memoizedState:null;if(fe=J.memoizedState,oe===null)if(fe===null)if(J.stateNode===null){e:{fe=J.type,oe=J.memoizedProps,xe=xe.ownerDocument||xe;t:switch(fe){case"title":Te=xe.getElementsByTagName("title")[0],(!Te||Te[Kt]||Te[ji]||Te.namespaceURI==="http://www.w3.org/2000/svg"||Te.hasAttribute("itemprop"))&&(Te=xe.createElement(fe),xe.head.insertBefore(Te,xe.querySelector("head > title"))),gr(Te,fe,oe),Te[ji]=J,_t(Te),fe=Te;break e;case"link":var Ie=ip("link","href",xe).get(fe+(oe.href||""));if(Ie){for(var Ve=0;Ve<Ie.length;Ve++)if(Te=Ie[Ve],Te.getAttribute("href")===(oe.href==null||oe.href===""?null:oe.href)&&Te.getAttribute("rel")===(oe.rel==null?null:oe.rel)&&Te.getAttribute("title")===(oe.title==null?null:oe.title)&&Te.getAttribute("crossorigin")===(oe.crossOrigin==null?null:oe.crossOrigin)){Ie.splice(Ve,1);break t}}Te=xe.createElement(fe),gr(Te,fe,oe),xe.head.appendChild(Te);break;case"meta":if(Ie=ip("meta","content",xe).get(fe+(oe.content||""))){for(Ve=0;Ve<Ie.length;Ve++)if(Te=Ie[Ve],Te.getAttribute("content")===(oe.content==null?null:""+oe.content)&&Te.getAttribute("name")===(oe.name==null?null:oe.name)&&Te.getAttribute("property")===(oe.property==null?null:oe.property)&&Te.getAttribute("http-equiv")===(oe.httpEquiv==null?null:oe.httpEquiv)&&Te.getAttribute("charset")===(oe.charSet==null?null:oe.charSet)){Ie.splice(Ve,1);break t}}Te=xe.createElement(fe),gr(Te,fe,oe),xe.head.appendChild(Te);break;default:throw Error(O(468,fe))}Te[ji]=J,_t(Te),fe=Te}J.stateNode=fe}else rp(xe,J.type,J.stateNode);else J.stateNode=np(xe,fe,J.memoizedProps);else Te!==fe?(Te===null?oe.stateNode!==null&&(oe=oe.stateNode,oe.parentNode.removeChild(oe)):Te.count--,fe===null?rp(xe,J.type,J.stateNode):np(xe,fe,J.memoizedProps)):fe===null&&J.stateNode!==null&&Kc(J,J.memoizedProps,oe.memoizedProps)}break;case 27:vr(re,J),Er(J),fe&512&&(or||oe===null||is(oe,oe.return)),oe!==null&&fe&4&&Kc(J,J.memoizedProps,oe.memoizedProps);break;case 5:if(vr(re,J),Er(J),fe&512&&(or||oe===null||is(oe,oe.return)),J.flags&32){xe=J.stateNode;try{Mr(xe,"")}catch(Pn){Fi(J,J.return,Pn)}}fe&4&&J.stateNode!=null&&(xe=J.memoizedProps,Kc(J,xe,oe!==null?oe.memoizedProps:xe)),fe&1024&&(eu=!0);break;case 6:if(vr(re,J),Er(J),fe&4){if(J.stateNode===null)throw Error(O(162));fe=J.memoizedProps,oe=J.stateNode;try{oe.nodeValue=fe}catch(Pn){Fi(J,J.return,Pn)}}break;case 3:if(Ml=null,xe=Jr,Jr=Sl(re.containerInfo),vr(re,J),Jr=xe,Er(J),fe&4&&oe!==null&&oe.memoizedState.isDehydrated)try{za(re.containerInfo)}catch(Pn){Fi(J,J.return,Pn)}eu&&(eu=!1,tf(J));break;case 4:fe=Jr,Jr=Sl(J.stateNode.containerInfo),vr(re,J),Er(J),Jr=fe;break;case 12:vr(re,J),Er(J);break;case 31:vr(re,J),Er(J),fe&4&&(fe=J.updateQueue,fe!==null&&(J.updateQueue=null,cl(J,fe)));break;case 13:vr(re,J),Er(J),J.child.flags&8192&&J.memoizedState!==null!=(oe!==null&&oe.memoizedState!==null)&&(dl=Fe()),fe&4&&(fe=J.updateQueue,fe!==null&&(J.updateQueue=null,cl(J,fe)));break;case 22:xe=J.memoizedState!==null;var at=oe!==null&&oe.memoizedState!==null,Ct=gs,Vt=or;if(gs=Ct||xe,or=Vt||at,vr(re,J),or=Vt,gs=Ct,Er(J),fe&8192)e:for(re=J.stateNode,re._visibility=xe?re._visibility&-2:re._visibility|1,xe&&(oe===null||at||gs||or||aa(J)),oe=null,re=J;;){if(re.tag===5||re.tag===26){if(oe===null){at=oe=re;try{if(Te=at.stateNode,xe)Ie=Te.style,typeof Ie.setProperty=="function"?Ie.setProperty("display","none","important"):Ie.display="none";else{Ve=at.stateNode;var Ht=at.memoizedProps.style,Rt=Ht!=null&&Ht.hasOwnProperty("display")?Ht.display:null;Ve.style.display=Rt==null||typeof Rt=="boolean"?"":(""+Rt).trim()}}catch(Pn){Fi(at,at.return,Pn)}}}else if(re.tag===6){if(oe===null){at=re;try{at.stateNode.nodeValue=xe?"":at.memoizedProps}catch(Pn){Fi(at,at.return,Pn)}}}else if(re.tag===18){if(oe===null){at=re;try{var Ot=at.stateNode;xe?qf(Ot,!0):qf(at.stateNode,!1)}catch(Pn){Fi(at,at.return,Pn)}}}else if((re.tag!==22&&re.tag!==23||re.memoizedState===null||re===J)&&re.child!==null){re.child.return=re,re=re.child;continue}if(re===J)break e;for(;re.sibling===null;){if(re.return===null||re.return===J)break e;oe===re&&(oe=null),re=re.return}oe===re&&(oe=null),re.sibling.return=re.return,re=re.sibling}fe&4&&(fe=J.updateQueue,fe!==null&&(oe=fe.retryQueue,oe!==null&&(fe.retryQueue=null,cl(J,oe))));break;case 19:vr(re,J),Er(J),fe&4&&(fe=J.updateQueue,fe!==null&&(J.updateQueue=null,cl(J,fe)));break;case 30:break;case 21:break;default:vr(re,J),Er(J)}}function Er(J){var re=J.flags;if(re&2){try{for(var oe,fe=J.return;fe!==null;){if(Qh(fe)){oe=fe;break}fe=fe.return}if(oe==null)throw Error(O(160));switch(oe.tag){case 27:var xe=oe.stateNode,Te=Jc(J);ll(J,Te,xe);break;case 5:var Ie=oe.stateNode;oe.flags&32&&(Mr(Ie,""),oe.flags&=-33);var Ve=Jc(J);ll(J,Ve,Ie);break;case 3:case 4:var at=oe.stateNode.containerInfo,Ct=Jc(J);Zc(J,Ct,at);break;default:throw Error(O(161))}}catch(Vt){Fi(J,J.return,Vt)}J.flags&=-3}re&4096&&(J.flags&=-4097)}function tf(J){if(J.subtreeFlags&1024)for(J=J.child;J!==null;){var re=J;tf(re),re.tag===5&&re.flags&1024&&re.stateNode.reset(),J=J.sibling}}function _s(J,re){if(re.subtreeFlags&8772)for(re=re.child;re!==null;)Xh(J,re.alternate,re),re=re.sibling}function aa(J){for(J=J.child;J!==null;){var re=J;switch(re.tag){case 0:case 11:case 14:case 15:Ps(4,re,re.return),aa(re);break;case 1:is(re,re.return);var oe=re.stateNode;typeof oe.componentWillUnmount=="function"&&jh(re,re.return,oe),aa(re);break;case 27:wo(re.stateNode);case 26:case 5:is(re,re.return),aa(re);break;case 22:re.memoizedState===null&&aa(re);break;case 30:aa(re);break;default:aa(re)}J=J.sibling}}function bs(J,re,oe){for(oe=oe&&(re.subtreeFlags&8772)!==0,re=re.child;re!==null;){var fe=re.alternate,xe=J,Te=re,Ie=Te.flags;switch(Te.tag){case 0:case 11:case 15:bs(xe,Te,oe),mo(4,Te);break;case 1:if(bs(xe,Te,oe),fe=Te,xe=fe.stateNode,typeof xe.componentDidMount=="function")try{xe.componentDidMount()}catch(Ct){Fi(fe,fe.return,Ct)}if(fe=Te,xe=fe.updateQueue,xe!==null){var Ve=fe.stateNode;try{var at=xe.shared.hiddenCallbacks;if(at!==null)for(xe.shared.hiddenCallbacks=null,xe=0;xe<at.length;xe++)Rd(at[xe],Ve)}catch(Ct){Fi(fe,fe.return,Ct)}}oe&&Ie&64&&zh(Te),go(Te,Te.return);break;case 27:qh(Te);case 26:case 5:bs(xe,Te,oe),oe&&fe===null&&Ie&4&&Hh(Te),go(Te,Te.return);break;case 12:bs(xe,Te,oe);break;case 31:bs(xe,Te,oe),oe&&Ie&4&&Jh(xe,Te);break;case 13:bs(xe,Te,oe),oe&&Ie&4&&Zh(xe,Te);break;case 22:Te.memoizedState===null&&bs(xe,Te,oe),go(Te,Te.return);break;case 30:break;default:bs(xe,Te,oe)}re=re.sibling}}function tu(J,re){var oe=null;J!==null&&J.memoizedState!==null&&J.memoizedState.cachePool!==null&&(oe=J.memoizedState.cachePool.pool),J=null,re.memoizedState!==null&&re.memoizedState.cachePool!==null&&(J=re.memoizedState.cachePool.pool),J!==oe&&(J!=null&&J.refCount++,oe!=null&&to(oe))}function nu(J,re){J=null,re.alternate!==null&&(J=re.alternate.memoizedState.cache),re=re.memoizedState.cache,re!==J&&(re.refCount++,J!=null&&to(J))}function Zr(J,re,oe,fe){if(re.subtreeFlags&10256)for(re=re.child;re!==null;)nf(J,re,oe,fe),re=re.sibling}function nf(J,re,oe,fe){var xe=re.flags;switch(re.tag){case 0:case 11:case 15:Zr(J,re,oe,fe),xe&2048&&mo(9,re);break;case 1:Zr(J,re,oe,fe);break;case 3:Zr(J,re,oe,fe),xe&2048&&(J=null,re.alternate!==null&&(J=re.alternate.memoizedState.cache),re=re.memoizedState.cache,re!==J&&(re.refCount++,J!=null&&to(J)));break;case 12:if(xe&2048){Zr(J,re,oe,fe),J=re.stateNode;try{var Te=re.memoizedProps,Ie=Te.id,Ve=Te.onPostCommit;typeof Ve=="function"&&Ve(Ie,re.alternate===null?"mount":"update",J.passiveEffectDuration,-0)}catch(at){Fi(re,re.return,at)}}else Zr(J,re,oe,fe);break;case 31:Zr(J,re,oe,fe);break;case 13:Zr(J,re,oe,fe);break;case 23:break;case 22:Te=re.stateNode,Ie=re.alternate,re.memoizedState!==null?Te._visibility&2?Zr(J,re,oe,fe):Ao(J,re):Te._visibility&2?Zr(J,re,oe,fe):(Te._visibility|=2,Ba(J,re,oe,fe,(re.subtreeFlags&10256)!==0||!1)),xe&2048&&tu(Ie,re);break;case 24:Zr(J,re,oe,fe),xe&2048&&nu(re.alternate,re);break;default:Zr(J,re,oe,fe)}}function Ba(J,re,oe,fe,xe){for(xe=xe&&((re.subtreeFlags&10256)!==0||!1),re=re.child;re!==null;){var Te=J,Ie=re,Ve=oe,at=fe,Ct=Ie.flags;switch(Ie.tag){case 0:case 11:case 15:Ba(Te,Ie,Ve,at,xe),mo(8,Ie);break;case 23:break;case 22:var Vt=Ie.stateNode;Ie.memoizedState!==null?Vt._visibility&2?Ba(Te,Ie,Ve,at,xe):Ao(Te,Ie):(Vt._visibility|=2,Ba(Te,Ie,Ve,at,xe)),xe&&Ct&2048&&tu(Ie.alternate,Ie);break;case 24:Ba(Te,Ie,Ve,at,xe),xe&&Ct&2048&&nu(Ie.alternate,Ie);break;default:Ba(Te,Ie,Ve,at,xe)}re=re.sibling}}function Ao(J,re){if(re.subtreeFlags&10256)for(re=re.child;re!==null;){var oe=J,fe=re,xe=fe.flags;switch(fe.tag){case 22:Ao(oe,fe),xe&2048&&tu(fe.alternate,fe);break;case 24:Ao(oe,fe),xe&2048&&nu(fe.alternate,fe);break;default:Ao(oe,fe)}re=re.sibling}}var bo=8192;function Pa(J,re,oe){if(J.subtreeFlags&bo)for(J=J.child;J!==null;)rf(J,re,oe),J=J.sibling}function rf(J,re,oe){switch(J.tag){case 26:Pa(J,re,oe),J.flags&bo&&J.memoizedState!==null&&dg(oe,Jr,J.memoizedState,J.memoizedProps);break;case 5:Pa(J,re,oe);break;case 3:case 4:var fe=Jr;Jr=Sl(J.stateNode.containerInfo),Pa(J,re,oe),Jr=fe;break;case 22:J.memoizedState===null&&(fe=J.alternate,fe!==null&&fe.memoizedState!==null?(fe=bo,bo=16777216,Pa(J,re,oe),bo=fe):Pa(J,re,oe));break;default:Pa(J,re,oe)}}function sf(J){var re=J.alternate;if(re!==null&&(J=re.child,J!==null)){re.child=null;do re=J.sibling,J.sibling=null,J=re;while(J!==null)}}function xo(J){var re=J.deletions;if((J.flags&16)!==0){if(re!==null)for(var oe=0;oe<re.length;oe++){var fe=re[oe];dr=fe,of(fe,J)}sf(J)}if(J.subtreeFlags&10256)for(J=J.child;J!==null;)af(J),J=J.sibling}function af(J){switch(J.tag){case 0:case 11:case 15:xo(J),J.flags&2048&&Ps(9,J,J.return);break;case 3:xo(J);break;case 12:xo(J);break;case 22:var re=J.stateNode;J.memoizedState!==null&&re._visibility&2&&(J.return===null||J.return.tag!==13)?(re._visibility&=-3,ul(J)):xo(J);break;default:xo(J)}}function ul(J){var re=J.deletions;if((J.flags&16)!==0){if(re!==null)for(var oe=0;oe<re.length;oe++){var fe=re[oe];dr=fe,of(fe,J)}sf(J)}for(J=J.child;J!==null;){switch(re=J,re.tag){case 0:case 11:case 15:Ps(8,re,re.return),ul(re);break;case 22:oe=re.stateNode,oe._visibility&2&&(oe._visibility&=-3,ul(re));break;default:ul(re)}J=J.sibling}}function of(J,re){for(;dr!==null;){var oe=dr;switch(oe.tag){case 0:case 11:case 15:Ps(8,oe,re);break;case 23:case 22:if(oe.memoizedState!==null&&oe.memoizedState.cachePool!==null){var fe=oe.memoizedState.cachePool.pool;fe!=null&&fe.refCount++}break;case 24:to(oe.memoizedState.cache)}if(fe=oe.child,fe!==null)fe.return=oe,dr=fe;else e:for(oe=J;dr!==null;){fe=dr;var xe=fe.sibling,Te=fe.return;if(Yh(fe),fe===oe){dr=null;break e}if(xe!==null){xe.return=Te,dr=xe;break e}dr=Te}}}var wm={getCacheForType:function(J){var re=pr(rr),oe=re.data.get(J);return oe===void 0&&(oe=J(),re.data.set(J,oe)),oe},cacheSignal:function(){return pr(rr).controller.signal}},Mm=typeof WeakMap=="function"?WeakMap:Map,Ri=0,zi=null,mi=null,bi=0,Ni=0,Br=null,Os=!1,Oa=!1,iu=!1,xs=0,Zi=0,Ls=0,oa=0,ru=0,Pr=0,La=0,yo=null,Tr=null,su=!1,dl=0,lf=0,hl=1/0,pl=null,Ns=null,ur=0,Fs=null,Na=null,ys=0,au=0,ou=null,cf=null,vo=0,lu=null;function Or(){return(Ri&2)!==0&&bi!==0?bi&-bi:Ce.T!==null?pu():Wr()}function uf(){if(Pr===0)if((bi&536870912)===0||Ei){var J=tn;tn<<=1,(tn&3932160)===0&&(tn=262144),Pr=J}else Pr=536870912;return J=Rr.current,J!==null&&(J.flags|=32),Pr}function Sr(J,re,oe){(J===zi&&(Ni===2||Ni===9)||J.cancelPendingCommit!==null)&&(Fa(J,0),ks(J,bi,Pr,!1)),Xi(J,oe),((Ri&2)===0||J!==zi)&&(J===zi&&((Ri&2)===0&&(oa|=oe),Zi===4&&ks(J,bi,Pr,!1)),rs(J))}function df(J,re,oe){if((Ri&6)!==0)throw Error(O(327));var fe=!oe&&(re&127)===0&&(re&J.expiredLanes)===0||Qt(J,re),xe=fe?Rm(J,re):uu(J,re,!0),Te=fe;do{if(xe===0){Oa&&!fe&&ks(J,re,0,!1);break}else{if(oe=J.current.alternate,Te&&!Cm(oe)){xe=uu(J,re,!1),Te=!1;continue}if(xe===2){if(Te=re,J.errorRecoveryDisabledLanes&Te)var Ie=0;else Ie=J.pendingLanes&-536870913,Ie=Ie!==0?Ie:Ie&536870912?536870912:0;if(Ie!==0){re=Ie;e:{var Ve=J;xe=yo;var at=Ve.current.memoizedState.isDehydrated;if(at&&(Fa(Ve,Ie).flags|=256),Ie=uu(Ve,Ie,!1),Ie!==2){if(iu&&!at){Ve.errorRecoveryDisabledLanes|=Te,oa|=Te,xe=4;break e}Te=Tr,Tr=xe,Te!==null&&(Tr===null?Tr=Te:Tr.push.apply(Tr,Te))}xe=Ie}if(Te=!1,xe!==2)continue}}if(xe===1){Fa(J,0),ks(J,re,0,!0);break}e:{switch(fe=J,Te=xe,Te){case 0:case 1:throw Error(O(345));case 4:if((re&4194048)!==re)break;case 6:ks(fe,re,Pr,!Os);break e;case 2:Tr=null;break;case 3:case 5:break;default:throw Error(O(329))}if((re&62914560)===re&&(xe=dl+300-Fe(),10<xe)){if(ks(fe,re,Pr,!Os),wt(fe,0,!0)!==0)break e;ys=re,fe.timeoutHandle=jf(hf.bind(null,fe,oe,Tr,pl,su,re,Pr,oa,La,Os,Te,"Throttled",-0,0),xe);break e}hf(fe,oe,Tr,pl,su,re,Pr,oa,La,Os,Te,null,-0,0)}}break}while(!0);rs(J)}function hf(J,re,oe,fe,xe,Te,Ie,Ve,at,Ct,Vt,Ht,Rt,Ot){if(J.timeoutHandle=-1,Ht=re.subtreeFlags,Ht&8192||(Ht&16785408)===16785408){Ht={stylesheets:null,count:0,imgCount:0,imgBytes:0,suspenseyImages:[],waitingForImages:!0,waitingForViewTransition:!1,unsuspend:Nr},rf(re,Te,Ht);var Pn=(Te&62914560)===Te?dl-Fe():(Te&4194048)===Te?lf-Fe():0;if(Pn=hg(Ht,Pn),Pn!==null){ys=Te,J.cancelPendingCommit=Pn(yf.bind(null,J,re,Te,oe,fe,xe,Ie,Ve,at,Vt,Ht,null,Rt,Ot)),ks(J,Te,Ie,!Ct);return}}yf(J,re,Te,oe,fe,xe,Ie,Ve,at)}function Cm(J){for(var re=J;;){var oe=re.tag;if((oe===0||oe===11||oe===15)&&re.flags&16384&&(oe=re.updateQueue,oe!==null&&(oe=oe.stores,oe!==null)))for(var fe=0;fe<oe.length;fe++){var xe=oe[fe],Te=xe.getSnapshot;xe=xe.value;try{if(!Cr(Te(),xe))return!1}catch{return!1}}if(oe=re.child,re.subtreeFlags&16384&&oe!==null)oe.return=re,re=oe;else{if(re===J)break;for(;re.sibling===null;){if(re.return===null||re.return===J)return!0;re=re.return}re.sibling.return=re.return,re=re.sibling}}return!0}function ks(J,re,oe,fe){re&=~ru,re&=~oa,J.suspendedLanes|=re,J.pingedLanes&=~re,fe&&(J.warmLanes|=re),fe=J.expirationTimes;for(var xe=re;0<xe;){var Te=31-Sn(xe),Ie=1<<Te;fe[Te]=-1,xe&=~Ie}oe!==0&&es(J,oe,re)}function ml(){return(Ri&6)===0?(Eo(0),!1):!0}function cu(){if(mi!==null){if(Ni===0)var J=mi.return;else J=mi,us=Js=null,Sc(J),Ma=null,io=0,J=mi;for(;J!==null;)Gh(J.alternate,J),J=J.return;mi=null}}function Fa(J,re){var oe=J.timeoutHandle;oe!==-1&&(J.timeoutHandle=-1,Wm(oe)),oe=J.cancelPendingCommit,oe!==null&&(J.cancelPendingCommit=null,oe()),ys=0,cu(),zi=J,mi=oe=ls(J.current,null),bi=re,Ni=0,Br=null,Os=!1,Oa=Qt(J,re),iu=!1,La=Pr=ru=oa=Ls=Zi=0,Tr=yo=null,su=!1,(re&8)!==0&&(re|=re&32);var fe=J.entangledLanes;if(fe!==0)for(J=J.entanglements,fe&=re;0<fe;){var xe=31-Sn(fe),Te=1<<xe;re|=J[xe],fe&=~Te}return xs=re,Lo(),oe}function ff(J,re){ii=null,Ce.H=ho,re===wa||re===zo?(re=wd(),Ni=3):re===hc?(re=wd(),Ni=4):Ni=re===Vc?8:re!==null&&typeof re=="object"&&typeof re.then=="function"?6:1,Br=re,mi===null&&(Zi=1,il(J,Ur(re,J.current)))}function pf(){var J=Rr.current;return J===null?!0:(bi&4194048)===bi?zr===null:(bi&62914560)===bi||(bi&536870912)!==0?J===zr:!1}function mf(){var J=Ce.H;return Ce.H=ho,J===null?ho:J}function gf(){var J=Ce.A;return Ce.A=wm,J}function gl(){Zi=4,Os||(bi&4194048)!==bi&&Rr.current!==null||(Oa=!0),(Ls&134217727)===0&&(oa&134217727)===0||zi===null||ks(zi,bi,Pr,!1)}function uu(J,re,oe){var fe=Ri;Ri|=2;var xe=mf(),Te=gf();(zi!==J||bi!==re)&&(pl=null,Fa(J,re)),re=!1;var Ie=Zi;e:do try{if(Ni!==0&&mi!==null){var Ve=mi,at=Br;switch(Ni){case 8:cu(),Ie=6;break e;case 3:case 2:case 9:case 6:Rr.current===null&&(re=!0);var Ct=Ni;if(Ni=0,Br=null,ka(J,Ve,at,Ct),oe&&Oa){Ie=0;break e}break;default:Ct=Ni,Ni=0,Br=null,ka(J,Ve,at,Ct)}}Im(),Ie=Zi;break}catch(Vt){ff(J,Vt)}while(!0);return re&&J.shellSuspendCounter++,us=Js=null,Ri=fe,Ce.H=xe,Ce.A=Te,mi===null&&(zi=null,bi=0,Lo()),Ie}function Im(){for(;mi!==null;)Af(mi)}function Rm(J,re){var oe=Ri;Ri|=2;var fe=mf(),xe=gf();zi!==J||bi!==re?(pl=null,hl=Fe()+500,Fa(J,re)):Oa=Qt(J,re);e:do try{if(Ni!==0&&mi!==null){re=mi;var Te=Br;t:switch(Ni){case 1:Ni=0,Br=null,ka(J,re,Te,1);break;case 2:case 9:if(Td(Te)){Ni=0,Br=null,bf(re);break}re=function(){Ni!==2&&Ni!==9||zi!==J||(Ni=7),rs(J)},Te.then(re,re);break e;case 3:Ni=7;break e;case 4:Ni=5;break e;case 7:Td(Te)?(Ni=0,Br=null,bf(re)):(Ni=0,Br=null,ka(J,re,Te,7));break;case 5:var Ie=null;switch(mi.tag){case 26:Ie=mi.memoizedState;case 5:case 27:var Ve=mi;if(Ie?sp(Ie):Ve.stateNode.complete){Ni=0,Br=null;var at=Ve.sibling;if(at!==null)mi=at;else{var Ct=Ve.return;Ct!==null?(mi=Ct,Al(Ct)):mi=null}break t}}Ni=0,Br=null,ka(J,re,Te,5);break;case 6:Ni=0,Br=null,ka(J,re,Te,6);break;case 8:cu(),Zi=6;break e;default:throw Error(O(462))}}Dm();break}catch(Vt){ff(J,Vt)}while(!0);return us=Js=null,Ce.H=fe,Ce.A=xe,Ri=oe,mi!==null?0:(zi=null,bi=0,Lo(),Zi)}function Dm(){for(;mi!==null&&!En();)Af(mi)}function Af(J){var re=$h(J.alternate,J,xs);J.memoizedProps=J.pendingProps,re===null?Al(J):mi=re}function bf(J){var re=J,oe=re.alternate;switch(re.tag){case 15:case 0:re=Oh(oe,re,re.pendingProps,re.type,void 0,bi);break;case 11:re=Oh(oe,re,re.pendingProps,re.type.render,re.ref,bi);break;case 5:Sc(re);default:Gh(oe,re),re=mi=hd(re,xs),re=$h(oe,re,xs)}J.memoizedProps=J.pendingProps,re===null?Al(J):mi=re}function ka(J,re,oe,fe){us=Js=null,Sc(re),Ma=null,io=0;var xe=re.return;try{if(bm(J,xe,re,oe,bi)){Zi=1,il(J,Ur(oe,J.current)),mi=null;return}}catch(Te){if(xe!==null)throw mi=xe,Te;Zi=1,il(J,Ur(oe,J.current)),mi=null;return}re.flags&32768?(Ei||fe===1?J=!0:Oa||(bi&536870912)!==0?J=!1:(Os=J=!0,(fe===2||fe===9||fe===3||fe===6)&&(fe=Rr.current,fe!==null&&fe.tag===13&&(fe.flags|=16384))),xf(re,J)):Al(re)}function Al(J){var re=J;do{if((re.flags&32768)!==0){xf(re,Os);return}J=re.return;var oe=vm(re.alternate,re,xs);if(oe!==null){mi=oe;return}if(re=re.sibling,re!==null){mi=re;return}mi=re=J}while(re!==null);Zi===0&&(Zi=5)}function xf(J,re){do{var oe=Em(J.alternate,J);if(oe!==null){oe.flags&=32767,mi=oe;return}if(oe=J.return,oe!==null&&(oe.flags|=32768,oe.subtreeFlags=0,oe.deletions=null),!re&&(J=J.sibling,J!==null)){mi=J;return}mi=J=oe}while(J!==null);Zi=6,mi=null}function yf(J,re,oe,fe,xe,Te,Ie,Ve,at){J.cancelPendingCommit=null;do bl();while(ur!==0);if((Ri&6)!==0)throw Error(O(327));if(re!==null){if(re===J.current)throw Error(O(177));if(Te=re.lanes|re.childLanes,Te|=Xl,lr(J,oe,Te,Ie,Ve,at),J===zi&&(mi=zi=null,bi=0),Na=re,Fs=J,ys=oe,au=Te,ou=xe,cf=fe,(re.subtreeFlags&10256)!==0||(re.flags&10256)!==0?(J.callbackNode=null,J.callbackPriority=0,Lm(Nt,function(){return wf(),null})):(J.callbackNode=null,J.callbackPriority=0),fe=(re.flags&13878)!==0,(re.subtreeFlags&13878)!==0||fe){fe=Ce.T,Ce.T=null,xe=Be.p,Be.p=2,Ie=Ri,Ri|=4;try{Tm(J,re,oe)}finally{Ri=Ie,Be.p=xe,Ce.T=fe}}ur=1,vf(),Ef(),Tf()}}function vf(){if(ur===1){ur=0;var J=Fs,re=Na,oe=(re.flags&13878)!==0;if((re.subtreeFlags&13878)!==0||oe){oe=Ce.T,Ce.T=null;var fe=Be.p;Be.p=2;var xe=Ri;Ri|=4;try{ef(re,J);var Te=vu,Ie=nd(J.containerInfo),Ve=Te.focusedElem,at=Te.selectionRange;if(Ie!==Ve&&Ve&&Ve.ownerDocument&&ed(Ve.ownerDocument.documentElement,Ve)){if(at!==null&&jl(Ve)){var Ct=at.start,Vt=at.end;if(Vt===void 0&&(Vt=Ct),"selectionStart"in Ve)Ve.selectionStart=Ct,Ve.selectionEnd=Math.min(Vt,Ve.value.length);else{var Ht=Ve.ownerDocument||document,Rt=Ht&&Ht.defaultView||window;if(Rt.getSelection){var Ot=Rt.getSelection(),Pn=Ve.textContent.length,Kn=Math.min(at.start,Pn),Vi=at.end===void 0?Kn:Math.min(at.end,Pn);!Ot.extend&&Kn>Vi&&(Ie=Vi,Vi=Kn,Kn=Ie);var At=Zu(Ve,Kn),ut=Zu(Ve,Vi);if(At&&ut&&(Ot.rangeCount!==1||Ot.anchorNode!==At.node||Ot.anchorOffset!==At.offset||Ot.focusNode!==ut.node||Ot.focusOffset!==ut.offset)){var Mt=Ht.createRange();Mt.setStart(At.node,At.offset),Ot.removeAllRanges(),Kn>Vi?(Ot.addRange(Mt),Ot.extend(ut.node,ut.offset)):(Mt.setEnd(ut.node,ut.offset),Ot.addRange(Mt))}}}}for(Ht=[],Ot=Ve;Ot=Ot.parentNode;)Ot.nodeType===1&&Ht.push({element:Ot,left:Ot.scrollLeft,top:Ot.scrollTop});for(typeof Ve.focus=="function"&&Ve.focus(),Ve=0;Ve<Ht.length;Ve++){var jt=Ht[Ve];jt.element.scrollLeft=jt.left,jt.element.scrollTop=jt.top}}Dl=!!yu,vu=yu=null}finally{Ri=xe,Be.p=fe,Ce.T=oe}}J.current=re,ur=2}}function Ef(){if(ur===2){ur=0;var J=Fs,re=Na,oe=(re.flags&8772)!==0;if((re.subtreeFlags&8772)!==0||oe){oe=Ce.T,Ce.T=null;var fe=Be.p;Be.p=2;var xe=Ri;Ri|=4;try{Xh(J,re.alternate,re)}finally{Ri=xe,Be.p=fe,Ce.T=oe}}ur=3}}function Tf(){if(ur===4||ur===3){ur=0,Ke();var J=Fs,re=Na,oe=ys,fe=cf;(re.subtreeFlags&10256)!==0||(re.flags&10256)!==0?ur=5:(ur=0,Na=Fs=null,Sf(J,J.pendingLanes));var xe=J.pendingLanes;if(xe===0&&(Ns=null),wr(oe),re=re.stateNode,Dt&&typeof Dt.onCommitFiberRoot=="function")try{Dt.onCommitFiberRoot(Wt,re,void 0,(re.current.flags&128)===128)}catch{}if(fe!==null){re=Ce.T,xe=Be.p,Be.p=2,Ce.T=null;try{for(var Te=J.onRecoverableError,Ie=0;Ie<fe.length;Ie++){var Ve=fe[Ie];Te(Ve.value,{componentStack:Ve.stack})}}finally{Ce.T=re,Be.p=xe}}(ys&3)!==0&&bl(),rs(J),xe=J.pendingLanes,(oe&261930)!==0&&(xe&42)!==0?J===lu?vo++:(vo=0,lu=J):vo=0,Eo(0)}}function Sf(J,re){(J.pooledCacheLanes&=re)===0&&(re=J.pooledCache,re!=null&&(J.pooledCache=null,to(re)))}function bl(){return vf(),Ef(),Tf(),wf()}function wf(){if(ur!==5)return!1;var J=Fs,re=au;au=0;var oe=wr(ys),fe=Ce.T,xe=Be.p;try{Be.p=32>oe?32:oe,Ce.T=null,oe=ou,ou=null;var Te=Fs,Ie=ys;if(ur=0,Na=Fs=null,ys=0,(Ri&6)!==0)throw Error(O(331));var Ve=Ri;if(Ri|=4,af(Te.current),nf(Te,Te.current,Ie,oe),Ri=Ve,Eo(0,!1),Dt&&typeof Dt.onPostCommitFiberRoot=="function")try{Dt.onPostCommitFiberRoot(Wt,Te)}catch{}return!0}finally{Be.p=xe,Ce.T=fe,Sf(J,re)}}function Mf(J,re,oe){re=Ur(oe,re),re=$c(J.stateNode,re,2),J=Rs(J,re,2),J!==null&&(Xi(J,2),rs(J))}function Fi(J,re,oe){if(J.tag===3)Mf(J,J,oe);else for(;re!==null;){if(re.tag===3){Mf(re,J,oe);break}else if(re.tag===1){var fe=re.stateNode;if(typeof re.type.getDerivedStateFromError=="function"||typeof fe.componentDidCatch=="function"&&(Ns===null||!Ns.has(fe))){J=Ur(oe,J),oe=wh(2),fe=Rs(re,oe,2),fe!==null&&(Mh(oe,fe,re,J),Xi(fe,2),rs(fe));break}}re=re.return}}function du(J,re,oe){var fe=J.pingCache;if(fe===null){fe=J.pingCache=new Mm;var xe=new Set;fe.set(re,xe)}else xe=fe.get(re),xe===void 0&&(xe=new Set,fe.set(re,xe));xe.has(oe)||(iu=!0,xe.add(oe),J=Bm.bind(null,J,re,oe),re.then(J,J))}function Bm(J,re,oe){var fe=J.pingCache;fe!==null&&fe.delete(re),J.pingedLanes|=J.suspendedLanes&oe,J.warmLanes&=~oe,zi===J&&(bi&oe)===oe&&(Zi===4||Zi===3&&(bi&62914560)===bi&&300>Fe()-dl?(Ri&2)===0&&Fa(J,0):ru|=oe,La===bi&&(La=0)),rs(J)}function Cf(J,re){re===0&&(re=Ai()),J=Xs(J,re),J!==null&&(Xi(J,re),rs(J))}function Pm(J){var re=J.memoizedState,oe=0;re!==null&&(oe=re.retryLane),Cf(J,oe)}function Om(J,re){var oe=0;switch(J.tag){case 31:case 13:var fe=J.stateNode,xe=J.memoizedState;xe!==null&&(oe=xe.retryLane);break;case 19:fe=J.stateNode;break;case 22:fe=J.stateNode._retryCache;break;default:throw Error(O(314))}fe!==null&&fe.delete(re),Cf(J,oe)}function Lm(J,re){return li(J,re)}var xl=null,Ua=null,hu=!1,yl=!1,fu=!1,Us=0;function rs(J){J!==Ua&&J.next===null&&(Ua===null?xl=Ua=J:Ua=Ua.next=J),yl=!0,hu||(hu=!0,Fm())}function Eo(J,re){if(!fu&&yl){fu=!0;do for(var oe=!1,fe=xl;fe!==null;){if(J!==0){var xe=fe.pendingLanes;if(xe===0)var Te=0;else{var Ie=fe.suspendedLanes,Ve=fe.pingedLanes;Te=(1<<31-Sn(42|J)+1)-1,Te&=xe&~(Ie&~Ve),Te=Te&201326741?Te&201326741|1:Te?Te|2:0}Te!==0&&(oe=!0,Pf(fe,Te))}else Te=bi,Te=wt(fe,fe===zi?Te:0,fe.cancelPendingCommit!==null||fe.timeoutHandle!==-1),(Te&3)===0||Qt(fe,Te)||(oe=!0,Pf(fe,Te));fe=fe.next}while(oe);fu=!1}}function Nm(){Rf()}function Rf(){yl=hu=!1;var J=0;Us!==0&&qm()&&(J=Us);for(var re=Fe(),oe=null,fe=xl;fe!==null;){var xe=fe.next,Te=Df(fe,re);Te===0?(fe.next=null,oe===null?xl=xe:oe.next=xe,xe===null&&(Ua=oe)):(oe=fe,(J!==0||(Te&3)!==0)&&(yl=!0)),fe=xe}ur!==0&&ur!==5||Eo(J),Us!==0&&(Us=0)}function Df(J,re){for(var oe=J.suspendedLanes,fe=J.pingedLanes,xe=J.expirationTimes,Te=J.pendingLanes&-62914561;0<Te;){var Ie=31-Sn(Te),Ve=1<<Ie,at=xe[Ie];at===-1?((Ve&oe)===0||(Ve&fe)!==0)&&(xe[Ie]=Yn(Ve,re)):at<=re&&(J.expiredLanes|=Ve),Te&=~Ve}if(re=zi,oe=bi,oe=wt(J,J===re?oe:0,J.cancelPendingCommit!==null||J.timeoutHandle!==-1),fe=J.callbackNode,oe===0||J===re&&(Ni===2||Ni===9)||J.cancelPendingCommit!==null)return fe!==null&&fe!==null&&Tn(fe),J.callbackNode=null,J.callbackPriority=0;if((oe&3)===0||Qt(J,oe)){if(re=oe&-oe,re===J.callbackPriority)return re;switch(fe!==null&&Tn(fe),wr(oe)){case 2:case 8:oe=qt;break;case 32:oe=Nt;break;case 268435456:oe=fn;break;default:oe=Nt}return fe=Bf.bind(null,J),oe=li(oe,fe),J.callbackPriority=re,J.callbackNode=oe,re}return fe!==null&&fe!==null&&Tn(fe),J.callbackPriority=2,J.callbackNode=null,2}function Bf(J,re){if(ur!==0&&ur!==5)return J.callbackNode=null,J.callbackPriority=0,null;var oe=J.callbackNode;if(bl()&&J.callbackNode!==oe)return null;var fe=bi;return fe=wt(J,J===zi?fe:0,J.cancelPendingCommit!==null||J.timeoutHandle!==-1),fe===0?null:(df(J,fe,re),Df(J,Fe()),J.callbackNode!=null&&J.callbackNode===oe?Bf.bind(null,J):null)}function Pf(J,re){if(bl())return null;df(J,re,!0)}function Fm(){Xm(function(){(Ri&6)!==0?li(zt,Nm):Rf()})}function pu(){if(Us===0){var J=Ta;J===0&&(J=dn,dn<<=1,(dn&261888)===0&&(dn=256)),Us=J}return Us}function Of(J){return J==null||typeof J=="symbol"||typeof J=="boolean"?null:typeof J=="function"?J:Qs(""+J)}function Lf(J,re){var oe=re.ownerDocument.createElement("input");return oe.name=re.name,oe.value=re.value,J.id&&oe.setAttribute("form",J.id),re.parentNode.insertBefore(oe,re),J=new FormData(J),oe.parentNode.removeChild(oe),J}function km(J,re,oe,fe,xe){if(re==="submit"&&oe&&oe.stateNode===xe){var Te=Of((xe[Ge]||null).action),Ie=fe.submitter;Ie&&(re=(re=Ie[Ge]||null)?Of(re.formAction):Ie.getAttribute("formAction"),re!==null&&(Te=re,Ie=null));var Ve=new Gi("action","action",null,fe,xe);J.push({event:Ve,listeners:[{instance:null,listener:function(){if(fe.defaultPrevented){if(Us!==0){var at=Ie?Lf(xe,Ie):new FormData(xe);Oc(oe,{pending:!0,data:at,method:xe.method,action:Te},null,at)}}else typeof Te=="function"&&(Ve.preventDefault(),at=Ie?Lf(xe,Ie):new FormData(xe),Oc(oe,{pending:!0,data:at,method:xe.method,action:Te},Te,at))},currentTarget:xe}]})}}for(var mu=0;mu<Wl.length;mu++){var gu=Wl[mu],Um=gu.toLowerCase(),$m=gu[0].toUpperCase()+gu.slice(1);Kr(Um,"on"+$m)}Kr(ad,"onAnimationEnd"),Kr(od,"onAnimationIteration"),Kr(ld,"onAnimationStart"),Kr("dblclick","onDoubleClick"),Kr("focusin","onFocus"),Kr("focusout","onBlur"),Kr(tm,"onTransitionRun"),Kr(nm,"onTransitionStart"),Kr(im,"onTransitionCancel"),Kr(cd,"onTransitionEnd"),mn("onMouseEnter",["mouseout","mouseover"]),mn("onMouseLeave",["mouseout","mouseover"]),mn("onPointerEnter",["pointerout","pointerover"]),mn("onPointerLeave",["pointerout","pointerover"]),Yt("onChange","change click focusin focusout input keydown keyup selectionchange".split(" ")),Yt("onSelect","focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" ")),Yt("onBeforeInput",["compositionend","keypress","textInput","paste"]),Yt("onCompositionEnd","compositionend focusout keydown keypress keyup mousedown".split(" ")),Yt("onCompositionStart","compositionstart focusout keydown keypress keyup mousedown".split(" ")),Yt("onCompositionUpdate","compositionupdate focusout keydown keypress keyup mousedown".split(" "));var To="abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),Vm=new Set("beforetoggle cancel close invalid load scroll scrollend toggle".split(" ").concat(To));function Nf(J,re){re=(re&4)!==0;for(var oe=0;oe<J.length;oe++){var fe=J[oe],xe=fe.event;fe=fe.listeners;e:{var Te=void 0;if(re)for(var Ie=fe.length-1;0<=Ie;Ie--){var Ve=fe[Ie],at=Ve.instance,Ct=Ve.currentTarget;if(Ve=Ve.listener,at!==Te&&xe.isPropagationStopped())break e;Te=Ve,xe.currentTarget=Ct;try{Te(xe)}catch(Vt){Oo(Vt)}xe.currentTarget=null,Te=at}else for(Ie=0;Ie<fe.length;Ie++){if(Ve=fe[Ie],at=Ve.instance,Ct=Ve.currentTarget,Ve=Ve.listener,at!==Te&&xe.isPropagationStopped())break e;Te=Ve,xe.currentTarget=Ct;try{Te(xe)}catch(Vt){Oo(Vt)}xe.currentTarget=null,Te=at}}}}function gi(J,re){var oe=re[ft];oe===void 0&&(oe=re[ft]=new Set);var fe=J+"__bubble";oe.has(fe)||(Ff(re,J,2,!1),oe.add(fe))}function Au(J,re,oe){var fe=0;re&&(fe|=4),Ff(oe,J,fe,re)}var vl="_reactListening"+Math.random().toString(36).slice(2);function _u(J){if(!J[vl]){J[vl]=!0,je.forEach(function(oe){oe!=="selectionchange"&&(Vm.has(oe)||Au(oe,!1,J),Au(oe,!0,J))});var re=J.nodeType===9?J:J.ownerDocument;re===null||re[vl]||(re[vl]=!0,Au("selectionchange",!1,re))}}function Ff(J,re,oe,fe){switch(hp(re)){case 2:var xe=mg;break;case 8:xe=gg;break;default:xe=Pu}oe=xe.bind(null,re,oe,J),xe=void 0,!fa||re!=="touchstart"&&re!=="touchmove"&&re!=="wheel"||(xe=!0),fe?xe!==void 0?J.addEventListener(re,oe,{capture:!0,passive:xe}):J.addEventListener(re,oe,!0):xe!==void 0?J.addEventListener(re,oe,{passive:xe}):J.addEventListener(re,oe,!1)}function bu(J,re,oe,fe,xe){var Te=fe;if((re&1)===0&&(re&2)===0&&fe!==null)e:for(;;){if(fe===null)return;var Ie=fe.tag;if(Ie===3||Ie===4){var Ve=fe.stateNode.containerInfo;if(Ve===xe)break;if(Ie===4)for(Ie=fe.return;Ie!==null;){var at=Ie.tag;if((at===3||at===4)&&Ie.stateNode.containerInfo===xe)return;Ie=Ie.return}for(;Ve!==null;){if(Ie=gn(Ve),Ie===null)return;if(at=Ie.tag,at===5||at===6||at===26||at===27){fe=Te=Ie;continue e}Ve=Ve.parentNode}}fe=fe.return}qa(function(){var Ct=Te,Vt=da(oe),Ht=[];e:{var Rt=ud.get(J);if(Rt!==void 0){var Ot=Gi,Pn=J;switch(J){case"keypress":if(Pt(oe)===0)break e;case"keydown":case"keyup":Ot=Pp;break;case"focusin":Pn="focus",Ot=Ul;break;case"focusout":Pn="blur",Ot=Ul;break;case"beforeblur":case"afterblur":Ot=Ul;break;case"click":if(oe.button===2)break e;case"auxclick":case"dblclick":case"mousedown":case"mousemove":case"mouseup":case"mouseout":case"mouseover":case"contextmenu":Ot=os;break;case"drag":case"dragend":case"dragenter":case"dragexit":case"dragleave":case"dragover":case"dragstart":case"drop":Ot=yp;break;case"touchcancel":case"touchend":case"touchmove":case"touchstart":Ot=Np;break;case ad:case od:case ld:Ot=Tp;break;case cd:Ot=kp;break;case"scroll":case"scrollend":Ot=br;break;case"wheel":Ot=$p;break;case"copy":case"cut":case"paste":Ot=wp;break;case"gotpointercapture":case"lostpointercapture":case"pointercancel":case"pointerdown":case"pointermove":case"pointerout":case"pointerover":case"pointerup":Ot=Uu;break;case"toggle":case"beforetoggle":Ot=Gp}var Kn=(re&4)!==0,Vi=!Kn&&(J==="scroll"||J==="scrollend"),At=Kn?Rt!==null?Rt+"Capture":null:Rt;Kn=[];for(var ut=Ct,Mt;ut!==null;){var jt=ut;if(Mt=jt.stateNode,jt=jt.tag,jt!==5&&jt!==26&&jt!==27||Mt===null||At===null||(jt=Es(ut,At),jt!=null&&Kn.push(So(ut,jt,Mt))),Vi)break;ut=ut.return}0<Kn.length&&(Rt=new Ot(Rt,Pn,null,oe,Vt),Ht.push({event:Rt,listeners:Kn}))}}if((re&7)===0){e:{if(Rt=J==="mouseover"||J==="pointerover",Ot=J==="mouseout"||J==="pointerout",Rt&&oe!==ua&&(Pn=oe.relatedTarget||oe.fromElement)&&(gn(Pn)||Pn[tt]))break e;if((Ot||Rt)&&(Rt=Vt.window===Vt?Vt:(Rt=Vt.ownerDocument)?Rt.defaultView||Rt.parentWindow:window,Ot?(Pn=oe.relatedTarget||oe.toElement,Ot=Ct,Pn=Pn?gn(Pn):null,Pn!==null&&(Vi=G(Pn),Kn=Pn.tag,Pn!==Vi||Kn!==5&&Kn!==27&&Kn!==6)&&(Pn=null)):(Ot=null,Pn=Ct),Ot!==Pn)){if(Kn=os,jt="onMouseLeave",At="onMouseEnter",ut="mouse",(J==="pointerout"||J==="pointerover")&&(Kn=Uu,jt="onPointerLeave",At="onPointerEnter",ut="pointer"),Vi=Ot==null?Rt:ct(Ot),Mt=Pn==null?Rt:ct(Pn),Rt=new Kn(jt,ut+"leave",Ot,oe,Vt),Rt.target=Vi,Rt.relatedTarget=Mt,jt=null,gn(Vt)===Ct&&(Kn=new Kn(At,ut+"enter",Pn,oe,Vt),Kn.target=Mt,Kn.relatedTarget=Vi,jt=Kn),Vi=jt,Ot&&Pn)t:{for(Kn=Gm,At=Ot,ut=Pn,Mt=0,jt=At;jt;jt=Kn(jt))Mt++;jt=0;for(var Qn=ut;Qn;Qn=Kn(Qn))jt++;for(;0<Mt-jt;)At=Kn(At),Mt--;for(;0<jt-Mt;)ut=Kn(ut),jt--;for(;Mt--;){if(At===ut||ut!==null&&At===ut.alternate){Kn=At;break t}At=Kn(At),ut=Kn(ut)}Kn=null}else Kn=null;Ot!==null&&kf(Ht,Rt,Ot,Kn,!1),Pn!==null&&Vi!==null&&kf(Ht,Vi,Pn,Kn,!0)}}e:{if(Rt=Ct?ct(Ct):window,Ot=Rt.nodeName&&Rt.nodeName.toLowerCase(),Ot==="select"||Ot==="input"&&Rt.type==="file")var wi=qu;else if(Hu(Rt))if(Wu)wi=Jp;else{wi=Yp;var Ln=Xp}else Ot=Rt.nodeName,!Ot||Ot.toLowerCase()!=="input"||Rt.type!=="checkbox"&&Rt.type!=="radio"?Ct&&ti(Ct.elementType)&&(wi=qu):wi=Kp;if(wi&&(wi=wi(J,Ct))){Qu(Ht,wi,oe,Vt);break e}Ln&&Ln(J,Rt,Ct),J==="focusout"&&Ct&&Rt.type==="number"&&Ct.memoizedProps.value!=null&&Wi(Rt,"number",Rt.value)}switch(Ln=Ct?ct(Ct):window,J){case"focusin":(Hu(Ln)||Ln.contentEditable==="true")&&(ma=Ln,Hl=Ct,Ja=null);break;case"focusout":Ja=Hl=ma=null;break;case"mousedown":Ql=!0;break;case"contextmenu":case"mouseup":case"dragend":Ql=!1,rd(Ht,oe,Vt);break;case"selectionchange":if(em)break;case"keydown":case"keyup":rd(Ht,oe,Vt)}var si;if(Vl)e:{switch(J){case"compositionstart":var xi="onCompositionStart";break e;case"compositionend":xi="onCompositionEnd";break e;case"compositionupdate":xi="onCompositionUpdate";break e}xi=void 0}else pa?zu(J,oe)&&(xi="onCompositionEnd"):J==="keydown"&&oe.keyCode===229&&(xi="onCompositionStart");xi&&($u&&oe.locale!=="ko"&&(pa||xi!=="onCompositionStart"?xi==="onCompositionEnd"&&pa&&(si=Tt()):($e=Vt,Ye="value"in $e?$e.value:$e.textContent,pa=!0)),Ln=El(Ct,xi),0<Ln.length&&(xi=new ku(xi,J,null,oe,Vt),Ht.push({event:xi,listeners:Ln}),si?xi.data=si:(si=ju(oe),si!==null&&(xi.data=si)))),(si=jp?Hp(J,oe):Qp(J,oe))&&(xi=El(Ct,"onBeforeInput"),0<xi.length&&(Ln=new ku("onBeforeInput","beforeinput",null,oe,Vt),Ht.push({event:Ln,listeners:xi}),Ln.data=si)),km(Ht,J,Ct,oe,Vt)}Nf(Ht,re)})}function So(J,re,oe){return{instance:J,listener:re,currentTarget:oe}}function El(J,re){for(var oe=re+"Capture",fe=[];J!==null;){var xe=J,Te=xe.stateNode;if(xe=xe.tag,xe!==5&&xe!==26&&xe!==27||Te===null||(xe=Es(J,oe),xe!=null&&fe.unshift(So(J,xe,Te)),xe=Es(J,re),xe!=null&&fe.push(So(J,xe,Te))),J.tag===3)return fe;J=J.return}return[]}function Gm(J){if(J===null)return null;do J=J.return;while(J&&J.tag!==5&&J.tag!==27);return J||null}function kf(J,re,oe,fe,xe){for(var Te=re._reactName,Ie=[];oe!==null&&oe!==fe;){var Ve=oe,at=Ve.alternate,Ct=Ve.stateNode;if(Ve=Ve.tag,at!==null&&at===fe)break;Ve!==5&&Ve!==26&&Ve!==27||Ct===null||(at=Ct,xe?(Ct=Es(oe,Te),Ct!=null&&Ie.unshift(So(oe,Ct,at))):xe||(Ct=Es(oe,Te),Ct!=null&&Ie.push(So(oe,Ct,at)))),oe=oe.return}Ie.length!==0&&J.push({event:re,listeners:Ie})}var zm=/\r\n?/g,jm=/\u0000|\uFFFD/g;function Uf(J){return(typeof J=="string"?J:""+J).replace(zm,`
`).replace(jm,"")}function $f(J,re){return re=Uf(re),Uf(J)===re}function $i(J,re,oe,fe,xe,Te){switch(oe){case"children":typeof fe=="string"?re==="body"||re==="textarea"&&fe===""||Mr(J,fe):(typeof fe=="number"||typeof fe=="bigint")&&re!=="body"&&Mr(J,""+fe);break;case"className":fi(J,"class",fe);break;case"tabIndex":fi(J,"tabindex",fe);break;case"dir":case"role":case"viewBox":case"width":case"height":fi(J,oe,fe);break;case"style":ni(J,fe,Te);break;case"data":if(re!=="object"){fi(J,"data",fe);break}case"src":case"href":if(fe===""&&(re!=="a"||oe!=="href")){J.removeAttribute(oe);break}if(fe==null||typeof fe=="function"||typeof fe=="symbol"||typeof fe=="boolean"){J.removeAttribute(oe);break}fe=Qs(""+fe),J.setAttribute(oe,fe);break;case"action":case"formAction":if(typeof fe=="function"){J.setAttribute(oe,"javascript:throw new Error('A React form was unexpectedly submitted. If you called form.submit() manually, consider using form.requestSubmit() instead. If you\\'re trying to use event.stopPropagation() in a submit event handler, consider also calling event.preventDefault().')");break}else typeof Te=="function"&&(oe==="formAction"?(re!=="input"&&$i(J,re,"name",xe.name,xe,null),$i(J,re,"formEncType",xe.formEncType,xe,null),$i(J,re,"formMethod",xe.formMethod,xe,null),$i(J,re,"formTarget",xe.formTarget,xe,null)):($i(J,re,"encType",xe.encType,xe,null),$i(J,re,"method",xe.method,xe,null),$i(J,re,"target",xe.target,xe,null)));if(fe==null||typeof fe=="symbol"||typeof fe=="boolean"){J.removeAttribute(oe);break}fe=Qs(""+fe),J.setAttribute(oe,fe);break;case"onClick":fe!=null&&(J.onclick=Nr);break;case"onScroll":fe!=null&&gi("scroll",J);break;case"onScrollEnd":fe!=null&&gi("scrollend",J);break;case"dangerouslySetInnerHTML":if(fe!=null){if(typeof fe!="object"||!("__html"in fe))throw Error(O(61));if(oe=fe.__html,oe!=null){if(xe.children!=null)throw Error(O(60));J.innerHTML=oe}}break;case"multiple":J.multiple=fe&&typeof fe!="function"&&typeof fe!="symbol";break;case"muted":J.muted=fe&&typeof fe!="function"&&typeof fe!="symbol";break;case"suppressContentEditableWarning":case"suppressHydrationWarning":case"defaultValue":case"defaultChecked":case"innerHTML":case"ref":break;case"autoFocus":break;case"xlinkHref":if(fe==null||typeof fe=="function"||typeof fe=="boolean"||typeof fe=="symbol"){J.removeAttribute("xlink:href");break}oe=Qs(""+fe),J.setAttributeNS("http://www.w3.org/1999/xlink","xlink:href",oe);break;case"contentEditable":case"spellCheck":case"draggable":case"value":case"autoReverse":case"externalResourcesRequired":case"focusable":case"preserveAlpha":fe!=null&&typeof fe!="function"&&typeof fe!="symbol"?J.setAttribute(oe,""+fe):J.removeAttribute(oe);break;case"inert":case"allowFullScreen":case"async":case"autoPlay":case"controls":case"default":case"defer":case"disabled":case"disablePictureInPicture":case"disableRemotePlayback":case"formNoValidate":case"hidden":case"loop":case"noModule":case"noValidate":case"open":case"playsInline":case"readOnly":case"required":case"reversed":case"scoped":case"seamless":case"itemScope":fe&&typeof fe!="function"&&typeof fe!="symbol"?J.setAttribute(oe,""):J.removeAttribute(oe);break;case"capture":case"download":fe===!0?J.setAttribute(oe,""):fe!==!1&&fe!=null&&typeof fe!="function"&&typeof fe!="symbol"?J.setAttribute(oe,fe):J.removeAttribute(oe);break;case"cols":case"rows":case"size":case"span":fe!=null&&typeof fe!="function"&&typeof fe!="symbol"&&!isNaN(fe)&&1<=fe?J.setAttribute(oe,fe):J.removeAttribute(oe);break;case"rowSpan":case"start":fe==null||typeof fe=="function"||typeof fe=="symbol"||isNaN(fe)?J.removeAttribute(oe):J.setAttribute(oe,fe);break;case"popover":gi("beforetoggle",J),gi("toggle",J),jn(J,"popover",fe);break;case"xlinkActuate":vi(J,"http://www.w3.org/1999/xlink","xlink:actuate",fe);break;case"xlinkArcrole":vi(J,"http://www.w3.org/1999/xlink","xlink:arcrole",fe);break;case"xlinkRole":vi(J,"http://www.w3.org/1999/xlink","xlink:role",fe);break;case"xlinkShow":vi(J,"http://www.w3.org/1999/xlink","xlink:show",fe);break;case"xlinkTitle":vi(J,"http://www.w3.org/1999/xlink","xlink:title",fe);break;case"xlinkType":vi(J,"http://www.w3.org/1999/xlink","xlink:type",fe);break;case"xmlBase":vi(J,"http://www.w3.org/XML/1998/namespace","xml:base",fe);break;case"xmlLang":vi(J,"http://www.w3.org/XML/1998/namespace","xml:lang",fe);break;case"xmlSpace":vi(J,"http://www.w3.org/XML/1998/namespace","xml:space",fe);break;case"is":jn(J,"is",fe);break;case"innerText":case"textContent":break;default:(!(2<oe.length)||oe[0]!=="o"&&oe[0]!=="O"||oe[1]!=="n"&&oe[1]!=="N")&&(oe=Ha.get(oe)||oe,jn(J,oe,fe))}}function xu(J,re,oe,fe,xe,Te){switch(oe){case"style":ni(J,fe,Te);break;case"dangerouslySetInnerHTML":if(fe!=null){if(typeof fe!="object"||!("__html"in fe))throw Error(O(61));if(oe=fe.__html,oe!=null){if(xe.children!=null)throw Error(O(60));J.innerHTML=oe}}break;case"children":typeof fe=="string"?Mr(J,fe):(typeof fe=="number"||typeof fe=="bigint")&&Mr(J,""+fe);break;case"onScroll":fe!=null&&gi("scroll",J);break;case"onScrollEnd":fe!=null&&gi("scrollend",J);break;case"onClick":fe!=null&&(J.onclick=Nr);break;case"suppressContentEditableWarning":case"suppressHydrationWarning":case"innerHTML":case"ref":break;case"innerText":case"textContent":break;default:if(!Gt.hasOwnProperty(oe))e:{if(oe[0]==="o"&&oe[1]==="n"&&(xe=oe.endsWith("Capture"),re=oe.slice(2,xe?oe.length-7:void 0),Te=J[Ge]||null,Te=Te!=null?Te[oe]:null,typeof Te=="function"&&J.removeEventListener(re,Te,xe),typeof fe=="function")){typeof Te!="function"&&Te!==null&&(oe in J?J[oe]=null:J.hasAttribute(oe)&&J.removeAttribute(oe)),J.addEventListener(re,fe,xe);break e}oe in J?J[oe]=fe:fe===!0?J.setAttribute(oe,""):jn(J,oe,fe)}}}function gr(J,re,oe){switch(re){case"div":case"span":case"svg":case"path":case"a":case"g":case"p":case"li":break;case"img":gi("error",J),gi("load",J);var fe=!1,xe=!1,Te;for(Te in oe)if(oe.hasOwnProperty(Te)){var Ie=oe[Te];if(Ie!=null)switch(Te){case"src":fe=!0;break;case"srcSet":xe=!0;break;case"children":case"dangerouslySetInnerHTML":throw Error(O(137,re));default:$i(J,re,Te,Ie,oe,null)}}xe&&$i(J,re,"srcSet",oe.srcSet,oe,null),fe&&$i(J,re,"src",oe.src,oe,null);return;case"input":gi("invalid",J);var Ve=Te=Ie=xe=null,at=null,Ct=null;for(fe in oe)if(oe.hasOwnProperty(fe)){var Vt=oe[fe];if(Vt!=null)switch(fe){case"name":xe=Vt;break;case"type":Ie=Vt;break;case"checked":at=Vt;break;case"defaultChecked":Ct=Vt;break;case"value":Te=Vt;break;case"defaultValue":Ve=Vt;break;case"children":case"dangerouslySetInnerHTML":if(Vt!=null)throw Error(O(137,re));break;default:$i(J,re,fe,Vt,oe,null)}}Pi(J,Te,Ve,at,Ct,Ie,xe,!1);return;case"select":gi("invalid",J),fe=Ie=Te=null;for(xe in oe)if(oe.hasOwnProperty(xe)&&(Ve=oe[xe],Ve!=null))switch(xe){case"value":Te=Ve;break;case"defaultValue":Ie=Ve;break;case"multiple":fe=Ve;default:$i(J,re,xe,Ve,oe,null)}re=Te,oe=Ie,J.multiple=!!fe,re!=null?Ki(J,!!fe,re,!1):oe!=null&&Ki(J,!!fe,oe,!0);return;case"textarea":gi("invalid",J),Te=xe=fe=null;for(Ie in oe)if(oe.hasOwnProperty(Ie)&&(Ve=oe[Ie],Ve!=null))switch(Ie){case"value":fe=Ve;break;case"defaultValue":xe=Ve;break;case"children":Te=Ve;break;case"dangerouslySetInnerHTML":if(Ve!=null)throw Error(O(91));break;default:$i(J,re,Ie,Ve,oe,null)}tr(J,fe,xe,Te);return;case"option":for(at in oe)if(oe.hasOwnProperty(at)&&(fe=oe[at],fe!=null))switch(at){case"selected":J.selected=fe&&typeof fe!="function"&&typeof fe!="symbol";break;default:$i(J,re,at,fe,oe,null)}return;case"dialog":gi("beforetoggle",J),gi("toggle",J),gi("cancel",J),gi("close",J);break;case"iframe":case"object":gi("load",J);break;case"video":case"audio":for(fe=0;fe<To.length;fe++)gi(To[fe],J);break;case"image":gi("error",J),gi("load",J);break;case"details":gi("toggle",J);break;case"embed":case"source":case"link":gi("error",J),gi("load",J);case"area":case"base":case"br":case"col":case"hr":case"keygen":case"meta":case"param":case"track":case"wbr":case"menuitem":for(Ct in oe)if(oe.hasOwnProperty(Ct)&&(fe=oe[Ct],fe!=null))switch(Ct){case"children":case"dangerouslySetInnerHTML":throw Error(O(137,re));default:$i(J,re,Ct,fe,oe,null)}return;default:if(ti(re)){for(Vt in oe)oe.hasOwnProperty(Vt)&&(fe=oe[Vt],fe!==void 0&&xu(J,re,Vt,fe,oe,void 0));return}}for(Ve in oe)oe.hasOwnProperty(Ve)&&(fe=oe[Ve],fe!=null&&$i(J,re,Ve,fe,oe,null))}function Hm(J,re,oe,fe){switch(re){case"div":case"span":case"svg":case"path":case"a":case"g":case"p":case"li":break;case"input":var xe=null,Te=null,Ie=null,Ve=null,at=null,Ct=null,Vt=null;for(Ot in oe){var Ht=oe[Ot];if(oe.hasOwnProperty(Ot)&&Ht!=null)switch(Ot){case"checked":break;case"value":break;case"defaultValue":at=Ht;default:fe.hasOwnProperty(Ot)||$i(J,re,Ot,null,fe,Ht)}}for(var Rt in fe){var Ot=fe[Rt];if(Ht=oe[Rt],fe.hasOwnProperty(Rt)&&(Ot!=null||Ht!=null))switch(Rt){case"type":Te=Ot;break;case"name":xe=Ot;break;case"checked":Ct=Ot;break;case"defaultChecked":Vt=Ot;break;case"value":Ie=Ot;break;case"defaultValue":Ve=Ot;break;case"children":case"dangerouslySetInnerHTML":if(Ot!=null)throw Error(O(137,re));break;default:Ot!==Ht&&$i(J,re,Rt,Ot,fe,Ht)}}Lr(J,Ie,Ve,at,Ct,Vt,Te,xe);return;case"select":Ot=Ie=Ve=Rt=null;for(Te in oe)if(at=oe[Te],oe.hasOwnProperty(Te)&&at!=null)switch(Te){case"value":break;case"multiple":Ot=at;default:fe.hasOwnProperty(Te)||$i(J,re,Te,null,fe,at)}for(xe in fe)if(Te=fe[xe],at=oe[xe],fe.hasOwnProperty(xe)&&(Te!=null||at!=null))switch(xe){case"value":Rt=Te;break;case"defaultValue":Ve=Te;break;case"multiple":Ie=Te;default:Te!==at&&$i(J,re,xe,Te,fe,at)}re=Ve,oe=Ie,fe=Ot,Rt!=null?Ki(J,!!oe,Rt,!1):!!fe!=!!oe&&(re!=null?Ki(J,!!oe,re,!0):Ki(J,!!oe,oe?[]:"",!1));return;case"textarea":Ot=Rt=null;for(Ve in oe)if(xe=oe[Ve],oe.hasOwnProperty(Ve)&&xe!=null&&!fe.hasOwnProperty(Ve))switch(Ve){case"value":break;case"children":break;default:$i(J,re,Ve,null,fe,xe)}for(Ie in fe)if(xe=fe[Ie],Te=oe[Ie],fe.hasOwnProperty(Ie)&&(xe!=null||Te!=null))switch(Ie){case"value":Rt=xe;break;case"defaultValue":Ot=xe;break;case"children":break;case"dangerouslySetInnerHTML":if(xe!=null)throw Error(O(91));break;default:xe!==Te&&$i(J,re,Ie,xe,fe,Te)}er(J,Rt,Ot);return;case"option":for(var Pn in oe)if(Rt=oe[Pn],oe.hasOwnProperty(Pn)&&Rt!=null&&!fe.hasOwnProperty(Pn))switch(Pn){case"selected":J.selected=!1;break;default:$i(J,re,Pn,null,fe,Rt)}for(at in fe)if(Rt=fe[at],Ot=oe[at],fe.hasOwnProperty(at)&&Rt!==Ot&&(Rt!=null||Ot!=null))switch(at){case"selected":J.selected=Rt&&typeof Rt!="function"&&typeof Rt!="symbol";break;default:$i(J,re,at,Rt,fe,Ot)}return;case"img":case"link":case"area":case"base":case"br":case"col":case"embed":case"hr":case"keygen":case"meta":case"param":case"source":case"track":case"wbr":case"menuitem":for(var Kn in oe)Rt=oe[Kn],oe.hasOwnProperty(Kn)&&Rt!=null&&!fe.hasOwnProperty(Kn)&&$i(J,re,Kn,null,fe,Rt);for(Ct in fe)if(Rt=fe[Ct],Ot=oe[Ct],fe.hasOwnProperty(Ct)&&Rt!==Ot&&(Rt!=null||Ot!=null))switch(Ct){case"children":case"dangerouslySetInnerHTML":if(Rt!=null)throw Error(O(137,re));break;default:$i(J,re,Ct,Rt,fe,Ot)}return;default:if(ti(re)){for(var Vi in oe)Rt=oe[Vi],oe.hasOwnProperty(Vi)&&Rt!==void 0&&!fe.hasOwnProperty(Vi)&&xu(J,re,Vi,void 0,fe,Rt);for(Vt in fe)Rt=fe[Vt],Ot=oe[Vt],!fe.hasOwnProperty(Vt)||Rt===Ot||Rt===void 0&&Ot===void 0||xu(J,re,Vt,Rt,fe,Ot);return}}for(var At in oe)Rt=oe[At],oe.hasOwnProperty(At)&&Rt!=null&&!fe.hasOwnProperty(At)&&$i(J,re,At,null,fe,Rt);for(Ht in fe)Rt=fe[Ht],Ot=oe[Ht],!fe.hasOwnProperty(Ht)||Rt===Ot||Rt==null&&Ot==null||$i(J,re,Ht,Rt,fe,Ot)}function Vf(J){switch(J){case"css":case"script":case"font":case"img":case"image":case"input":case"link":return!0;default:return!1}}function Qm(){if(typeof performance.getEntriesByType=="function"){for(var J=0,re=0,oe=performance.getEntriesByType("resource"),fe=0;fe<oe.length;fe++){var xe=oe[fe],Te=xe.transferSize,Ie=xe.initiatorType,Ve=xe.duration;if(Te&&Ve&&Vf(Ie)){for(Ie=0,Ve=xe.responseEnd,fe+=1;fe<oe.length;fe++){var at=oe[fe],Ct=at.startTime;if(Ct>Ve)break;var Vt=at.transferSize,Ht=at.initiatorType;Vt&&Vf(Ht)&&(at=at.responseEnd,Ie+=Vt*(at<Ve?1:(Ve-Ct)/(at-Ct)))}if(--fe,re+=8*(Te+Ie)/(xe.duration/1e3),J++,10<J)break}}if(0<J)return re/J/1e6}return navigator.connection&&(J=navigator.connection.downlink,typeof J=="number")?J:5}var yu=null,vu=null;function Tl(J){return J.nodeType===9?J:J.ownerDocument}function Gf(J){switch(J){case"http://www.w3.org/2000/svg":return 1;case"http://www.w3.org/1998/Math/MathML":return 2;default:return 0}}function zf(J,re){if(J===0)switch(re){case"svg":return 1;case"math":return 2;default:return 0}return J===1&&re==="foreignObject"?0:J}function Eu(J,re){return J==="textarea"||J==="noscript"||typeof re.children=="string"||typeof re.children=="number"||typeof re.children=="bigint"||typeof re.dangerouslySetInnerHTML=="object"&&re.dangerouslySetInnerHTML!==null&&re.dangerouslySetInnerHTML.__html!=null}var Tu=null;function qm(){var J=window.event;return J&&J.type==="popstate"?J===Tu?!1:(Tu=J,!0):(Tu=null,!1)}var jf=typeof setTimeout=="function"?setTimeout:void 0,Wm=typeof clearTimeout=="function"?clearTimeout:void 0,Hf=typeof Promise=="function"?Promise:void 0,Xm=typeof queueMicrotask=="function"?queueMicrotask:typeof Hf<"u"?function(J){return Hf.resolve(null).then(J).catch(Ym)}:jf;function Ym(J){setTimeout(function(){throw J})}function $s(J){return J==="head"}function Qf(J,re){var oe=re,fe=0;do{var xe=oe.nextSibling;if(J.removeChild(oe),xe&&xe.nodeType===8)if(oe=xe.data,oe==="/$"||oe==="/&"){if(fe===0){J.removeChild(xe),za(re);return}fe--}else if(oe==="$"||oe==="$?"||oe==="$~"||oe==="$!"||oe==="&")fe++;else if(oe==="html")wo(J.ownerDocument.documentElement);else if(oe==="head"){oe=J.ownerDocument.head,wo(oe);for(var Te=oe.firstChild;Te;){var Ie=Te.nextSibling,Ve=Te.nodeName;Te[Kt]||Ve==="SCRIPT"||Ve==="STYLE"||Ve==="LINK"&&Te.rel.toLowerCase()==="stylesheet"||oe.removeChild(Te),Te=Ie}}else oe==="body"&&wo(J.ownerDocument.body);oe=xe}while(oe);za(re)}function qf(J,re){var oe=J;J=0;do{var fe=oe.nextSibling;if(oe.nodeType===1?re?(oe._stashedDisplay=oe.style.display,oe.style.display="none"):(oe.style.display=oe._stashedDisplay||"",oe.getAttribute("style")===""&&oe.removeAttribute("style")):oe.nodeType===3&&(re?(oe._stashedText=oe.nodeValue,oe.nodeValue=""):oe.nodeValue=oe._stashedText||""),fe&&fe.nodeType===8)if(oe=fe.data,oe==="/$"){if(J===0)break;J--}else oe!=="$"&&oe!=="$?"&&oe!=="$~"&&oe!=="$!"||J++;oe=fe}while(oe)}function Su(J){var re=J.firstChild;for(re&&re.nodeType===10&&(re=re.nextSibling);re;){var oe=re;switch(re=re.nextSibling,oe.nodeName){case"HTML":case"HEAD":case"BODY":Su(oe),On(oe);continue;case"SCRIPT":case"STYLE":continue;case"LINK":if(oe.rel.toLowerCase()==="stylesheet")continue}J.removeChild(oe)}}function Km(J,re,oe,fe){for(;J.nodeType===1;){var xe=oe;if(J.nodeName.toLowerCase()!==re.toLowerCase()){if(!fe&&(J.nodeName!=="INPUT"||J.type!=="hidden"))break}else if(fe){if(!J[Kt])switch(re){case"meta":if(!J.hasAttribute("itemprop"))break;return J;case"link":if(Te=J.getAttribute("rel"),Te==="stylesheet"&&J.hasAttribute("data-precedence"))break;if(Te!==xe.rel||J.getAttribute("href")!==(xe.href==null||xe.href===""?null:xe.href)||J.getAttribute("crossorigin")!==(xe.crossOrigin==null?null:xe.crossOrigin)||J.getAttribute("title")!==(xe.title==null?null:xe.title))break;return J;case"style":if(J.hasAttribute("data-precedence"))break;return J;case"script":if(Te=J.getAttribute("src"),(Te!==(xe.src==null?null:xe.src)||J.getAttribute("type")!==(xe.type==null?null:xe.type)||J.getAttribute("crossorigin")!==(xe.crossOrigin==null?null:xe.crossOrigin))&&Te&&J.hasAttribute("async")&&!J.hasAttribute("itemprop"))break;return J;default:return J}}else if(re==="input"&&J.type==="hidden"){var Te=xe.name==null?null:""+xe.name;if(xe.type==="hidden"&&J.getAttribute("name")===Te)return J}else return J;if(J=jr(J.nextSibling),J===null)break}return null}function Jm(J,re,oe){if(re==="")return null;for(;J.nodeType!==3;)if((J.nodeType!==1||J.nodeName!=="INPUT"||J.type!=="hidden")&&!oe||(J=jr(J.nextSibling),J===null))return null;return J}function Wf(J,re){for(;J.nodeType!==8;)if((J.nodeType!==1||J.nodeName!=="INPUT"||J.type!=="hidden")&&!re||(J=jr(J.nextSibling),J===null))return null;return J}function wu(J){return J.data==="$?"||J.data==="$~"}function Mu(J){return J.data==="$!"||J.data==="$?"&&J.ownerDocument.readyState!=="loading"}function Zm(J,re){var oe=J.ownerDocument;if(J.data==="$~")J._reactRetry=re;else if(J.data!=="$?"||oe.readyState!=="loading")re();else{var fe=function(){re(),oe.removeEventListener("DOMContentLoaded",fe)};oe.addEventListener("DOMContentLoaded",fe),J._reactRetry=fe}}function jr(J){for(;J!=null;J=J.nextSibling){var re=J.nodeType;if(re===1||re===3)break;if(re===8){if(re=J.data,re==="$"||re==="$!"||re==="$?"||re==="$~"||re==="&"||re==="F!"||re==="F")break;if(re==="/$"||re==="/&")return null}}return J}var Cu=null;function Xf(J){J=J.nextSibling;for(var re=0;J;){if(J.nodeType===8){var oe=J.data;if(oe==="/$"||oe==="/&"){if(re===0)return jr(J.nextSibling);re--}else oe!=="$"&&oe!=="$!"&&oe!=="$?"&&oe!=="$~"&&oe!=="&"||re++}J=J.nextSibling}return null}function Yf(J){J=J.previousSibling;for(var re=0;J;){if(J.nodeType===8){var oe=J.data;if(oe==="$"||oe==="$!"||oe==="$?"||oe==="$~"||oe==="&"){if(re===0)return J;re--}else oe!=="/$"&&oe!=="/&"||re++}J=J.previousSibling}return null}function Kf(J,re,oe){switch(re=Tl(oe),J){case"html":if(J=re.documentElement,!J)throw Error(O(452));return J;case"head":if(J=re.head,!J)throw Error(O(453));return J;case"body":if(J=re.body,!J)throw Error(O(454));return J;default:throw Error(O(451))}}function wo(J){for(var re=J.attributes;re.length;)J.removeAttributeNode(re[0]);On(J)}var Hr=new Map,Jf=new Set;function Sl(J){return typeof J.getRootNode=="function"?J.getRootNode():J.nodeType===9?J:J.ownerDocument}var vs=Be.d;Be.d={f:eg,r:tg,D:ng,C:ig,L:rg,m:sg,X:og,S:ag,M:lg};function eg(){var J=vs.f(),re=ml();return J||re}function tg(J){var re=Ue(J);re!==null&&re.tag===5&&re.type==="form"?uh(re):vs.r(J)}var $a=typeof document>"u"?null:document;function Zf(J,re,oe){var fe=$a;if(fe&&typeof re=="string"&&re){var xe=Bi(re);xe='link[rel="'+J+'"][href="'+xe+'"]',typeof oe=="string"&&(xe+='[crossorigin="'+oe+'"]'),Jf.has(xe)||(Jf.add(xe),J={rel:J,crossOrigin:oe,href:re},fe.querySelector(xe)===null&&(re=fe.createElement("link"),gr(re,"link",J),_t(re),fe.head.appendChild(re)))}}function ng(J){vs.D(J),Zf("dns-prefetch",J,null)}function ig(J,re){vs.C(J,re),Zf("preconnect",J,re)}function rg(J,re,oe){vs.L(J,re,oe);var fe=$a;if(fe&&J&&re){var xe='link[rel="preload"][as="'+Bi(re)+'"]';re==="image"&&oe&&oe.imageSrcSet?(xe+='[imagesrcset="'+Bi(oe.imageSrcSet)+'"]',typeof oe.imageSizes=="string"&&(xe+='[imagesizes="'+Bi(oe.imageSizes)+'"]')):xe+='[href="'+Bi(J)+'"]';var Te=xe;switch(re){case"style":Te=Va(J);break;case"script":Te=Ga(J)}Hr.has(Te)||(J=Y({rel:"preload",href:re==="image"&&oe&&oe.imageSrcSet?void 0:J,as:re},oe),Hr.set(Te,J),fe.querySelector(xe)!==null||re==="style"&&fe.querySelector(Mo(Te))||re==="script"&&fe.querySelector(Co(Te))||(re=fe.createElement("link"),gr(re,"link",J),_t(re),fe.head.appendChild(re)))}}function sg(J,re){vs.m(J,re);var oe=$a;if(oe&&J){var fe=re&&typeof re.as=="string"?re.as:"script",xe='link[rel="modulepreload"][as="'+Bi(fe)+'"][href="'+Bi(J)+'"]',Te=xe;switch(fe){case"audioworklet":case"paintworklet":case"serviceworker":case"sharedworker":case"worker":case"script":Te=Ga(J)}if(!Hr.has(Te)&&(J=Y({rel:"modulepreload",href:J},re),Hr.set(Te,J),oe.querySelector(xe)===null)){switch(fe){case"audioworklet":case"paintworklet":case"serviceworker":case"sharedworker":case"worker":case"script":if(oe.querySelector(Co(Te)))return}fe=oe.createElement("link"),gr(fe,"link",J),_t(fe),oe.head.appendChild(fe)}}}function ag(J,re,oe){vs.S(J,re,oe);var fe=$a;if(fe&&J){var xe=vt(fe).hoistableStyles,Te=Va(J);re=re||"default";var Ie=xe.get(Te);if(!Ie){var Ve={loading:0,preload:null};if(Ie=fe.querySelector(Mo(Te)))Ve.loading=5;else{J=Y({rel:"stylesheet",href:J,"data-precedence":re},oe),(oe=Hr.get(Te))&&Iu(J,oe);var at=Ie=fe.createElement("link");_t(at),gr(at,"link",J),at._p=new Promise(function(Ct,Vt){at.onload=Ct,at.onerror=Vt}),at.addEventListener("load",function(){Ve.loading|=1}),at.addEventListener("error",function(){Ve.loading|=2}),Ve.loading|=4,wl(Ie,re,fe)}Ie={type:"stylesheet",instance:Ie,count:1,state:Ve},xe.set(Te,Ie)}}}function og(J,re){vs.X(J,re);var oe=$a;if(oe&&J){var fe=vt(oe).hoistableScripts,xe=Ga(J),Te=fe.get(xe);Te||(Te=oe.querySelector(Co(xe)),Te||(J=Y({src:J,async:!0},re),(re=Hr.get(xe))&&Ru(J,re),Te=oe.createElement("script"),_t(Te),gr(Te,"link",J),oe.head.appendChild(Te)),Te={type:"script",instance:Te,count:1,state:null},fe.set(xe,Te))}}function lg(J,re){vs.M(J,re);var oe=$a;if(oe&&J){var fe=vt(oe).hoistableScripts,xe=Ga(J),Te=fe.get(xe);Te||(Te=oe.querySelector(Co(xe)),Te||(J=Y({src:J,async:!0,type:"module"},re),(re=Hr.get(xe))&&Ru(J,re),Te=oe.createElement("script"),_t(Te),gr(Te,"link",J),oe.head.appendChild(Te)),Te={type:"script",instance:Te,count:1,state:null},fe.set(xe,Te))}}function ep(J,re,oe,fe){var xe=(xe=mt.current)?Sl(xe):null;if(!xe)throw Error(O(446));switch(J){case"meta":case"title":return null;case"style":return typeof oe.precedence=="string"&&typeof oe.href=="string"?(re=Va(oe.href),oe=vt(xe).hoistableStyles,fe=oe.get(re),fe||(fe={type:"style",instance:null,count:0,state:null},oe.set(re,fe)),fe):{type:"void",instance:null,count:0,state:null};case"link":if(oe.rel==="stylesheet"&&typeof oe.href=="string"&&typeof oe.precedence=="string"){J=Va(oe.href);var Te=vt(xe).hoistableStyles,Ie=Te.get(J);if(Ie||(xe=xe.ownerDocument||xe,Ie={type:"stylesheet",instance:null,count:0,state:{loading:0,preload:null}},Te.set(J,Ie),(Te=xe.querySelector(Mo(J)))&&!Te._p&&(Ie.instance=Te,Ie.state.loading=5),Hr.has(J)||(oe={rel:"preload",as:"style",href:oe.href,crossOrigin:oe.crossOrigin,integrity:oe.integrity,media:oe.media,hrefLang:oe.hrefLang,referrerPolicy:oe.referrerPolicy},Hr.set(J,oe),Te||cg(xe,J,oe,Ie.state))),re&&fe===null)throw Error(O(528,""));return Ie}if(re&&fe!==null)throw Error(O(529,""));return null;case"script":return re=oe.async,oe=oe.src,typeof oe=="string"&&re&&typeof re!="function"&&typeof re!="symbol"?(re=Ga(oe),oe=vt(xe).hoistableScripts,fe=oe.get(re),fe||(fe={type:"script",instance:null,count:0,state:null},oe.set(re,fe)),fe):{type:"void",instance:null,count:0,state:null};default:throw Error(O(444,J))}}function Va(J){return'href="'+Bi(J)+'"'}function Mo(J){return'link[rel="stylesheet"]['+J+"]"}function tp(J){return Y({},J,{"data-precedence":J.precedence,precedence:null})}function cg(J,re,oe,fe){J.querySelector('link[rel="preload"][as="style"]['+re+"]")?fe.loading=1:(re=J.createElement("link"),fe.preload=re,re.addEventListener("load",function(){return fe.loading|=1}),re.addEventListener("error",function(){return fe.loading|=2}),gr(re,"link",oe),_t(re),J.head.appendChild(re))}function Ga(J){return'[src="'+Bi(J)+'"]'}function Co(J){return"script[async]"+J}function np(J,re,oe){if(re.count++,re.instance===null)switch(re.type){case"style":var fe=J.querySelector('style[data-href~="'+Bi(oe.href)+'"]');if(fe)return re.instance=fe,_t(fe),fe;var xe=Y({},oe,{"data-href":oe.href,"data-precedence":oe.precedence,href:null,precedence:null});return fe=(J.ownerDocument||J).createElement("style"),_t(fe),gr(fe,"style",xe),wl(fe,oe.precedence,J),re.instance=fe;case"stylesheet":xe=Va(oe.href);var Te=J.querySelector(Mo(xe));if(Te)return re.state.loading|=4,re.instance=Te,_t(Te),Te;fe=tp(oe),(xe=Hr.get(xe))&&Iu(fe,xe),Te=(J.ownerDocument||J).createElement("link"),_t(Te);var Ie=Te;return Ie._p=new Promise(function(Ve,at){Ie.onload=Ve,Ie.onerror=at}),gr(Te,"link",fe),re.state.loading|=4,wl(Te,oe.precedence,J),re.instance=Te;case"script":return Te=Ga(oe.src),(xe=J.querySelector(Co(Te)))?(re.instance=xe,_t(xe),xe):(fe=oe,(xe=Hr.get(Te))&&(fe=Y({},oe),Ru(fe,xe)),J=J.ownerDocument||J,xe=J.createElement("script"),_t(xe),gr(xe,"link",fe),J.head.appendChild(xe),re.instance=xe);case"void":return null;default:throw Error(O(443,re.type))}else re.type==="stylesheet"&&(re.state.loading&4)===0&&(fe=re.instance,re.state.loading|=4,wl(fe,oe.precedence,J));return re.instance}function wl(J,re,oe){for(var fe=oe.querySelectorAll('link[rel="stylesheet"][data-precedence],style[data-precedence]'),xe=fe.length?fe[fe.length-1]:null,Te=xe,Ie=0;Ie<fe.length;Ie++){var Ve=fe[Ie];if(Ve.dataset.precedence===re)Te=Ve;else if(Te!==xe)break}Te?Te.parentNode.insertBefore(J,Te.nextSibling):(re=oe.nodeType===9?oe.head:oe,re.insertBefore(J,re.firstChild))}function Iu(J,re){J.crossOrigin==null&&(J.crossOrigin=re.crossOrigin),J.referrerPolicy==null&&(J.referrerPolicy=re.referrerPolicy),J.title==null&&(J.title=re.title)}function Ru(J,re){J.crossOrigin==null&&(J.crossOrigin=re.crossOrigin),J.referrerPolicy==null&&(J.referrerPolicy=re.referrerPolicy),J.integrity==null&&(J.integrity=re.integrity)}var Ml=null;function ip(J,re,oe){if(Ml===null){var fe=new Map,xe=Ml=new Map;xe.set(oe,fe)}else xe=Ml,fe=xe.get(oe),fe||(fe=new Map,xe.set(oe,fe));if(fe.has(J))return fe;for(fe.set(J,null),oe=oe.getElementsByTagName(J),xe=0;xe<oe.length;xe++){var Te=oe[xe];if(!(Te[Kt]||Te[ji]||J==="link"&&Te.getAttribute("rel")==="stylesheet")&&Te.namespaceURI!=="http://www.w3.org/2000/svg"){var Ie=Te.getAttribute(re)||"";Ie=J+Ie;var Ve=fe.get(Ie);Ve?Ve.push(Te):fe.set(Ie,[Te])}}return fe}function rp(J,re,oe){J=J.ownerDocument||J,J.head.insertBefore(oe,re==="title"?J.querySelector("head > title"):null)}function ug(J,re,oe){if(oe===1||re.itemProp!=null)return!1;switch(J){case"meta":case"title":return!0;case"style":if(typeof re.precedence!="string"||typeof re.href!="string"||re.href==="")break;return!0;case"link":if(typeof re.rel!="string"||typeof re.href!="string"||re.href===""||re.onLoad||re.onError)break;switch(re.rel){case"stylesheet":return J=re.disabled,typeof re.precedence=="string"&&J==null;default:return!0}case"script":if(re.async&&typeof re.async!="function"&&typeof re.async!="symbol"&&!re.onLoad&&!re.onError&&re.src&&typeof re.src=="string")return!0}return!1}function sp(J){return!(J.type==="stylesheet"&&(J.state.loading&3)===0)}function dg(J,re,oe,fe){if(oe.type==="stylesheet"&&(typeof fe.media!="string"||matchMedia(fe.media).matches!==!1)&&(oe.state.loading&4)===0){if(oe.instance===null){var xe=Va(fe.href),Te=re.querySelector(Mo(xe));if(Te){re=Te._p,re!==null&&typeof re=="object"&&typeof re.then=="function"&&(J.count++,J=Cl.bind(J),re.then(J,J)),oe.state.loading|=4,oe.instance=Te,_t(Te);return}Te=re.ownerDocument||re,fe=tp(fe),(xe=Hr.get(xe))&&Iu(fe,xe),Te=Te.createElement("link"),_t(Te);var Ie=Te;Ie._p=new Promise(function(Ve,at){Ie.onload=Ve,Ie.onerror=at}),gr(Te,"link",fe),oe.instance=Te}J.stylesheets===null&&(J.stylesheets=new Map),J.stylesheets.set(oe,re),(re=oe.state.preload)&&(oe.state.loading&3)===0&&(J.count++,oe=Cl.bind(J),re.addEventListener("load",oe),re.addEventListener("error",oe))}}var Du=0;function hg(J,re){return J.stylesheets&&J.count===0&&Rl(J,J.stylesheets),0<J.count||0<J.imgCount?function(oe){var fe=setTimeout(function(){if(J.stylesheets&&Rl(J,J.stylesheets),J.unsuspend){var Te=J.unsuspend;J.unsuspend=null,Te()}},6e4+re);0<J.imgBytes&&Du===0&&(Du=62500*Qm());var xe=setTimeout(function(){if(J.waitingForImages=!1,J.count===0&&(J.stylesheets&&Rl(J,J.stylesheets),J.unsuspend)){var Te=J.unsuspend;J.unsuspend=null,Te()}},(J.imgBytes>Du?50:800)+re);return J.unsuspend=oe,function(){J.unsuspend=null,clearTimeout(fe),clearTimeout(xe)}}:null}function Cl(){if(this.count--,this.count===0&&(this.imgCount===0||!this.waitingForImages)){if(this.stylesheets)Rl(this,this.stylesheets);else if(this.unsuspend){var J=this.unsuspend;this.unsuspend=null,J()}}}var Il=null;function Rl(J,re){J.stylesheets=null,J.unsuspend!==null&&(J.count++,Il=new Map,re.forEach(fg,J),Il=null,Cl.call(J))}function fg(J,re){if(!(re.state.loading&4)){var oe=Il.get(J);if(oe)var fe=oe.get(null);else{oe=new Map,Il.set(J,oe);for(var xe=J.querySelectorAll("link[data-precedence],style[data-precedence]"),Te=0;Te<xe.length;Te++){var Ie=xe[Te];(Ie.nodeName==="LINK"||Ie.getAttribute("media")!=="not all")&&(oe.set(Ie.dataset.precedence,Ie),fe=Ie)}fe&&oe.set(null,fe)}xe=re.instance,Ie=xe.getAttribute("data-precedence"),Te=oe.get(Ie)||fe,Te===fe&&oe.set(null,xe),oe.set(Ie,xe),this.count++,fe=Cl.bind(this),xe.addEventListener("load",fe),xe.addEventListener("error",fe),Te?Te.parentNode.insertBefore(xe,Te.nextSibling):(J=J.nodeType===9?J.head:J,J.insertBefore(xe,J.firstChild)),re.state.loading|=4}}var Io={$$typeof:me,Provider:null,Consumer:null,_currentValue:ze,_currentValue2:ze,_threadCount:0};function pg(J,re,oe,fe,xe,Te,Ie,Ve,at){this.tag=1,this.containerInfo=J,this.pingCache=this.current=this.pendingChildren=null,this.timeoutHandle=-1,this.callbackNode=this.next=this.pendingContext=this.context=this.cancelPendingCommit=null,this.callbackPriority=0,this.expirationTimes=hi(-1),this.entangledLanes=this.shellSuspendCounter=this.errorRecoveryDisabledLanes=this.expiredLanes=this.warmLanes=this.pingedLanes=this.suspendedLanes=this.pendingLanes=0,this.entanglements=hi(0),this.hiddenUpdates=hi(null),this.identifierPrefix=fe,this.onUncaughtError=xe,this.onCaughtError=Te,this.onRecoverableError=Ie,this.pooledCache=null,this.pooledCacheLanes=0,this.formState=at,this.incompleteTransitions=new Map}function ap(J,re,oe,fe,xe,Te,Ie,Ve,at,Ct,Vt,Ht){return J=new pg(J,re,oe,Ie,at,Ct,Vt,Ht,Ve),re=1,Te===!0&&(re|=24),Te=Ir(3,null,null,re),J.current=Te,Te.stateNode=J,re=cc(),re.refCount++,J.pooledCache=re,re.refCount++,Te.memoizedState={element:fe,isDehydrated:oe,cache:re},fc(Te),J}function op(J){return J?(J=ba,J):ba}function lp(J,re,oe,fe,xe,Te){xe=op(xe),fe.context===null?fe.context=xe:fe.pendingContext=xe,fe=Is(re),fe.payload={element:oe},Te=Te===void 0?null:Te,Te!==null&&(fe.callback=Te),oe=Rs(J,fe,re),oe!==null&&(Sr(oe,J,re),so(oe,J,re))}function cp(J,re){if(J=J.memoizedState,J!==null&&J.dehydrated!==null){var oe=J.retryLane;J.retryLane=oe!==0&&oe<re?oe:re}}function Bu(J,re){cp(J,re),(J=J.alternate)&&cp(J,re)}function up(J){if(J.tag===13||J.tag===31){var re=Xs(J,67108864);re!==null&&Sr(re,J,67108864),Bu(J,67108864)}}function dp(J){if(J.tag===13||J.tag===31){var re=Or();re=hr(re);var oe=Xs(J,re);oe!==null&&Sr(oe,J,re),Bu(J,re)}}var Dl=!0;function mg(J,re,oe,fe){var xe=Ce.T;Ce.T=null;var Te=Be.p;try{Be.p=2,Pu(J,re,oe,fe)}finally{Be.p=Te,Ce.T=xe}}function gg(J,re,oe,fe){var xe=Ce.T;Ce.T=null;var Te=Be.p;try{Be.p=8,Pu(J,re,oe,fe)}finally{Be.p=Te,Ce.T=xe}}function Pu(J,re,oe,fe){if(Dl){var xe=Ou(fe);if(xe===null)bu(J,re,fe,Bl,oe),fp(J,fe);else if(bg(xe,J,re,oe,fe))fe.stopPropagation();else if(fp(J,fe),re&4&&-1<Ag.indexOf(J)){for(;xe!==null;){var Te=Ue(xe);if(Te!==null)switch(Te.tag){case 3:if(Te=Te.stateNode,Te.current.memoizedState.isDehydrated){var Ie=Bt(Te.pendingLanes);if(Ie!==0){var Ve=Te;for(Ve.pendingLanes|=2,Ve.entangledLanes|=2;Ie;){var at=1<<31-Sn(Ie);Ve.entanglements[1]|=at,Ie&=~at}rs(Te),(Ri&6)===0&&(hl=Fe()+500,Eo(0))}}break;case 31:case 13:Ve=Xs(Te,2),Ve!==null&&Sr(Ve,Te,2),ml(),Bu(Te,2)}if(Te=Ou(fe),Te===null&&bu(J,re,fe,Bl,oe),Te===xe)break;xe=Te}xe!==null&&fe.stopPropagation()}else bu(J,re,fe,null,oe)}}function Ou(J){return J=da(J),Lu(J)}var Bl=null;function Lu(J){if(Bl=null,J=gn(J),J!==null){var re=G(J);if(re===null)J=null;else{var oe=re.tag;if(oe===13){if(J=q(re),J!==null)return J;J=null}else if(oe===31){if(J=K(re),J!==null)return J;J=null}else if(oe===3){if(re.stateNode.current.memoizedState.isDehydrated)return re.tag===3?re.stateNode.containerInfo:null;J=null}else re!==J&&(J=null)}}return Bl=J,null}function hp(J){switch(J){case"beforetoggle":case"cancel":case"click":case"close":case"contextmenu":case"copy":case"cut":case"auxclick":case"dblclick":case"dragend":case"dragstart":case"drop":case"focusin":case"focusout":case"input":case"invalid":case"keydown":case"keypress":case"keyup":case"mousedown":case"mouseup":case"paste":case"pause":case"play":case"pointercancel":case"pointerdown":case"pointerup":case"ratechange":case"reset":case"resize":case"seeked":case"submit":case"toggle":case"touchcancel":case"touchend":case"touchstart":case"volumechange":case"change":case"selectionchange":case"textInput":case"compositionstart":case"compositionend":case"compositionupdate":case"beforeblur":case"afterblur":case"beforeinput":case"blur":case"fullscreenchange":case"focus":case"hashchange":case"popstate":case"select":case"selectstart":return 2;case"drag":case"dragenter":case"dragexit":case"dragleave":case"dragover":case"mousemove":case"mouseout":case"mouseover":case"pointermove":case"pointerout":case"pointerover":case"scroll":case"touchmove":case"wheel":case"mouseenter":case"mouseleave":case"pointerenter":case"pointerleave":return 8;case"message":switch(pt()){case zt:return 2;case qt:return 8;case Nt:case Rn:return 32;case fn:return 268435456;default:return 32}default:return 32}}var Nu=!1,Vs=null,Gs=null,zs=null,Ro=new Map,Do=new Map,js=[],Ag="mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset".split(" ");function fp(J,re){switch(J){case"focusin":case"focusout":Vs=null;break;case"dragenter":case"dragleave":Gs=null;break;case"mouseover":case"mouseout":zs=null;break;case"pointerover":case"pointerout":Ro.delete(re.pointerId);break;case"gotpointercapture":case"lostpointercapture":Do.delete(re.pointerId)}}function Bo(J,re,oe,fe,xe,Te){return J===null||J.nativeEvent!==Te?(J={blockedOn:re,domEventName:oe,eventSystemFlags:fe,nativeEvent:Te,targetContainers:[xe]},re!==null&&(re=Ue(re),re!==null&&up(re)),J):(J.eventSystemFlags|=fe,re=J.targetContainers,xe!==null&&re.indexOf(xe)===-1&&re.push(xe),J)}function bg(J,re,oe,fe,xe){switch(re){case"focusin":return Vs=Bo(Vs,J,re,oe,fe,xe),!0;case"dragenter":return Gs=Bo(Gs,J,re,oe,fe,xe),!0;case"mouseover":return zs=Bo(zs,J,re,oe,fe,xe),!0;case"pointerover":var Te=xe.pointerId;return Ro.set(Te,Bo(Ro.get(Te)||null,J,re,oe,fe,xe)),!0;case"gotpointercapture":return Te=xe.pointerId,Do.set(Te,Bo(Do.get(Te)||null,J,re,oe,fe,xe)),!0}return!1}function pp(J){var re=gn(J.target);if(re!==null){var oe=G(re);if(oe!==null){if(re=oe.tag,re===13){if(re=q(oe),re!==null){J.blockedOn=re,Xr(J.priority,function(){dp(oe)});return}}else if(re===31){if(re=K(oe),re!==null){J.blockedOn=re,Xr(J.priority,function(){dp(oe)});return}}else if(re===3&&oe.stateNode.current.memoizedState.isDehydrated){J.blockedOn=oe.tag===3?oe.stateNode.containerInfo:null;return}}}J.blockedOn=null}function Pl(J){if(J.blockedOn!==null)return!1;for(var re=J.targetContainers;0<re.length;){var oe=Ou(J.nativeEvent);if(oe===null){oe=J.nativeEvent;var fe=new oe.constructor(oe.type,oe);ua=fe,oe.target.dispatchEvent(fe),ua=null}else return re=Ue(oe),re!==null&&up(re),J.blockedOn=oe,!1;re.shift()}return!0}function mp(J,re,oe){Pl(J)&&oe.delete(re)}function xg(){Nu=!1,Vs!==null&&Pl(Vs)&&(Vs=null),Gs!==null&&Pl(Gs)&&(Gs=null),zs!==null&&Pl(zs)&&(zs=null),Ro.forEach(mp),Do.forEach(mp)}function Ol(J,re){J.blockedOn===re&&(J.blockedOn=null,Nu||(Nu=!0,F.unstable_scheduleCallback(F.unstable_NormalPriority,xg)))}var Ll=null;function gp(J){Ll!==J&&(Ll=J,F.unstable_scheduleCallback(F.unstable_NormalPriority,function(){Ll===J&&(Ll=null);for(var re=0;re<J.length;re+=3){var oe=J[re],fe=J[re+1],xe=J[re+2];if(typeof fe!="function"){if(Lu(fe||oe)===null)continue;break}var Te=Ue(oe);Te!==null&&(J.splice(re,3),re-=3,Oc(Te,{pending:!0,data:xe,method:oe.method,action:fe},fe,xe))}}))}function za(J){function re(at){return Ol(at,J)}Vs!==null&&Ol(Vs,J),Gs!==null&&Ol(Gs,J),zs!==null&&Ol(zs,J),Ro.forEach(re),Do.forEach(re);for(var oe=0;oe<js.length;oe++){var fe=js[oe];fe.blockedOn===J&&(fe.blockedOn=null)}for(;0<js.length&&(oe=js[0],oe.blockedOn===null);)pp(oe),oe.blockedOn===null&&js.shift();if(oe=(J.ownerDocument||J).$$reactFormReplay,oe!=null)for(fe=0;fe<oe.length;fe+=3){var xe=oe[fe],Te=oe[fe+1],Ie=xe[Ge]||null;if(typeof Te=="function")Ie||gp(oe);else if(Ie){var Ve=null;if(Te&&Te.hasAttribute("formAction")){if(xe=Te,Ie=Te[Ge]||null)Ve=Ie.formAction;else if(Lu(xe)!==null)continue}else Ve=Ie.action;typeof Ve=="function"?oe[fe+1]=Ve:(oe.splice(fe,3),fe-=3),gp(oe)}}}function Ap(){function J(Te){Te.canIntercept&&Te.info==="react-transition"&&Te.intercept({handler:function(){return new Promise(function(Ie){return xe=Ie})},focusReset:"manual",scroll:"manual"})}function re(){xe!==null&&(xe(),xe=null),fe||setTimeout(oe,20)}function oe(){if(!fe&&!navigation.transition){var Te=navigation.currentEntry;Te&&Te.url!=null&&navigation.navigate(Te.url,{state:Te.getState(),info:"react-transition",history:"replace"})}}if(typeof navigation=="object"){var fe=!1,xe=null;return navigation.addEventListener("navigate",J),navigation.addEventListener("navigatesuccess",re),navigation.addEventListener("navigateerror",re),setTimeout(oe,100),function(){fe=!0,navigation.removeEventListener("navigate",J),navigation.removeEventListener("navigatesuccess",re),navigation.removeEventListener("navigateerror",re),xe!==null&&(xe(),xe=null)}}}function Fu(J){this._internalRoot=J}Nl.prototype.render=Fu.prototype.render=function(J){var re=this._internalRoot;if(re===null)throw Error(O(409));var oe=re.current,fe=Or();lp(oe,fe,J,re,null,null)},Nl.prototype.unmount=Fu.prototype.unmount=function(){var J=this._internalRoot;if(J!==null){this._internalRoot=null;var re=J.containerInfo;lp(J.current,2,null,J,null,null),ml(),re[tt]=null}};function Nl(J){this._internalRoot=J}Nl.prototype.unstable_scheduleHydration=function(J){if(J){var re=Wr();J={blockedOn:null,target:J,priority:re};for(var oe=0;oe<js.length&&re!==0&&re<js[oe].priority;oe++);js.splice(oe,0,J),oe===0&&pp(J)}};var _p=w.version;if(_p!=="19.2.0")throw Error(O(527,_p,"19.2.0"));Be.findDOMNode=function(J){var re=J._reactInternals;if(re===void 0)throw typeof J.render=="function"?Error(O(188)):(J=Object.keys(J).join(","),Error(O(268,J)));return J=Z(re),J=J!==null?ie(J):null,J=J===null?null:J.stateNode,J};var yg={bundleType:0,version:"19.2.0",rendererPackageName:"react-dom",currentDispatcherRef:Ce,reconcilerVersion:"19.2.0"};if(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__<"u"){var Fl=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(!Fl.isDisabled&&Fl.supportsFiber)try{Wt=Fl.inject(yg),Dt=Fl}catch{}}return reactDomClient_production.createRoot=function(J,re){if(!U(J))throw Error(O(299));var oe=!1,fe="",xe=yh,Te=Eh,Ie=Th;return re!=null&&(re.unstable_strictMode===!0&&(oe=!0),re.identifierPrefix!==void 0&&(fe=re.identifierPrefix),re.onUncaughtError!==void 0&&(xe=re.onUncaughtError),re.onCaughtError!==void 0&&(Te=re.onCaughtError),re.onRecoverableError!==void 0&&(Ie=re.onRecoverableError)),re=ap(J,1,!1,null,null,oe,fe,null,xe,Te,Ie,Ap),J[tt]=re.current,_u(J),new Fu(re)},reactDomClient_production.hydrateRoot=function(J,re,oe){if(!U(J))throw Error(O(299));var fe=!1,xe="",Te=yh,Ie=Eh,Ve=Th,at=null;return oe!=null&&(oe.unstable_strictMode===!0&&(fe=!0),oe.identifierPrefix!==void 0&&(xe=oe.identifierPrefix),oe.onUncaughtError!==void 0&&(Te=oe.onUncaughtError),oe.onCaughtError!==void 0&&(Ie=oe.onCaughtError),oe.onRecoverableError!==void 0&&(Ve=oe.onRecoverableError),oe.formState!==void 0&&(at=oe.formState)),re=ap(J,1,!0,re,oe??null,fe,xe,at,Te,Ie,Ve,Ap),re.context=op(null),oe=re.current,fe=Or(),fe=hr(fe),xe=Is(fe),xe.callback=null,Rs(oe,xe,fe),oe=fe,re.current.lanes=oe,Xi(re,oe),rs(re),J[tt]=re.current,_u(J),new Nl(re)},reactDomClient_production.version="19.2.0",reactDomClient_production}var hasRequiredClient;function requireClient(){if(hasRequiredClient)return client.exports;hasRequiredClient=1;function F(){if(!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__>"u"||typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE!="function"))try{__REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(F)}catch(w){console.error(w)}}return F(),client.exports=requireReactDomClient_production(),client.exports}var clientExports=requireClient();/**
 * @license
 * Copyright 2019 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */const t$2=globalThis,e$2=t$2.ShadowRoot&&(t$2.ShadyCSS===void 0||t$2.ShadyCSS.nativeShadow)&&"adoptedStyleSheets"in Document.prototype&&"replace"in CSSStyleSheet.prototype,s$2=Symbol(),o$4=new WeakMap;let n$4=class{constructor(w,D,O){if(this._$cssResult$=!0,O!==s$2)throw Error("CSSResult is not constructable. Use `unsafeCSS` or `css` instead.");this.cssText=w,this.t=D}get styleSheet(){let w=this.o;const D=this.t;if(e$2&&w===void 0){const O=D!==void 0&&D.length===1;O&&(w=o$4.get(D)),w===void 0&&((this.o=w=new CSSStyleSheet).replaceSync(this.cssText),O&&o$4.set(D,w))}return w}toString(){return this.cssText}};const r$3=F=>new n$4(typeof F=="string"?F:F+"",void 0,s$2),S$2=(F,w)=>{if(e$2)F.adoptedStyleSheets=w.map((D=>D instanceof CSSStyleSheet?D:D.styleSheet));else for(const D of w){const O=document.createElement("style"),U=t$2.litNonce;U!==void 0&&O.setAttribute("nonce",U),O.textContent=D.cssText,F.appendChild(O)}},c$3=e$2?F=>F:F=>F instanceof CSSStyleSheet?(w=>{let D="";for(const O of w.cssRules)D+=O.cssText;return r$3(D)})(F):F;/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */const{is:i$3,defineProperty:e$1,getOwnPropertyDescriptor:h$1,getOwnPropertyNames:r$2,getOwnPropertySymbols:o$3,getPrototypeOf:n$3}=Object,a$2=globalThis,c$2=a$2.trustedTypes,l$1=c$2?c$2.emptyScript:"",p$1=a$2.reactiveElementPolyfillSupport,d$1=(F,w)=>F,u$2={toAttribute(F,w){switch(w){case Boolean:F=F?l$1:null;break;case Object:case Array:F=F==null?F:JSON.stringify(F)}return F},fromAttribute(F,w){let D=F;switch(w){case Boolean:D=F!==null;break;case Number:D=F===null?null:Number(F);break;case Object:case Array:try{D=JSON.parse(F)}catch{D=null}}return D}},f$1=(F,w)=>!i$3(F,w),b$1={attribute:!0,type:String,converter:u$2,reflect:!1,useDefault:!1,hasChanged:f$1};Symbol.metadata??=Symbol("metadata"),a$2.litPropertyMetadata??=new WeakMap;let y$2=class extends HTMLElement{static addInitializer(w){this._$Ei(),(this.l??=[]).push(w)}static get observedAttributes(){return this.finalize(),this._$Eh&&[...this._$Eh.keys()]}static createProperty(w,D=b$1){if(D.state&&(D.attribute=!1),this._$Ei(),this.prototype.hasOwnProperty(w)&&((D=Object.create(D)).wrapped=!0),this.elementProperties.set(w,D),!D.noAccessor){const O=Symbol(),U=this.getPropertyDescriptor(w,O,D);U!==void 0&&e$1(this.prototype,w,U)}}static getPropertyDescriptor(w,D,O){const{get:U,set:G}=h$1(this.prototype,w)??{get(){return this[D]},set(q){this[D]=q}};return{get:U,set(q){const K=U?.call(this);G?.call(this,q),this.requestUpdate(w,K,O)},configurable:!0,enumerable:!0}}static getPropertyOptions(w){return this.elementProperties.get(w)??b$1}static _$Ei(){if(this.hasOwnProperty(d$1("elementProperties")))return;const w=n$3(this);w.finalize(),w.l!==void 0&&(this.l=[...w.l]),this.elementProperties=new Map(w.elementProperties)}static finalize(){if(this.hasOwnProperty(d$1("finalized")))return;if(this.finalized=!0,this._$Ei(),this.hasOwnProperty(d$1("properties"))){const D=this.properties,O=[...r$2(D),...o$3(D)];for(const U of O)this.createProperty(U,D[U])}const w=this[Symbol.metadata];if(w!==null){const D=litPropertyMetadata.get(w);if(D!==void 0)for(const[O,U]of D)this.elementProperties.set(O,U)}this._$Eh=new Map;for(const[D,O]of this.elementProperties){const U=this._$Eu(D,O);U!==void 0&&this._$Eh.set(U,D)}this.elementStyles=this.finalizeStyles(this.styles)}static finalizeStyles(w){const D=[];if(Array.isArray(w)){const O=new Set(w.flat(1/0).reverse());for(const U of O)D.unshift(c$3(U))}else w!==void 0&&D.push(c$3(w));return D}static _$Eu(w,D){const O=D.attribute;return O===!1?void 0:typeof O=="string"?O:typeof w=="string"?w.toLowerCase():void 0}constructor(){super(),this._$Ep=void 0,this.isUpdatePending=!1,this.hasUpdated=!1,this._$Em=null,this._$Ev()}_$Ev(){this._$ES=new Promise((w=>this.enableUpdating=w)),this._$AL=new Map,this._$E_(),this.requestUpdate(),this.constructor.l?.forEach((w=>w(this)))}addController(w){(this._$EO??=new Set).add(w),this.renderRoot!==void 0&&this.isConnected&&w.hostConnected?.()}removeController(w){this._$EO?.delete(w)}_$E_(){const w=new Map,D=this.constructor.elementProperties;for(const O of D.keys())this.hasOwnProperty(O)&&(w.set(O,this[O]),delete this[O]);w.size>0&&(this._$Ep=w)}createRenderRoot(){const w=this.shadowRoot??this.attachShadow(this.constructor.shadowRootOptions);return S$2(w,this.constructor.elementStyles),w}connectedCallback(){this.renderRoot??=this.createRenderRoot(),this.enableUpdating(!0),this._$EO?.forEach((w=>w.hostConnected?.()))}enableUpdating(w){}disconnectedCallback(){this._$EO?.forEach((w=>w.hostDisconnected?.()))}attributeChangedCallback(w,D,O){this._$AK(w,O)}_$ET(w,D){const O=this.constructor.elementProperties.get(w),U=this.constructor._$Eu(w,O);if(U!==void 0&&O.reflect===!0){const G=(O.converter?.toAttribute!==void 0?O.converter:u$2).toAttribute(D,O.type);this._$Em=w,G==null?this.removeAttribute(U):this.setAttribute(U,G),this._$Em=null}}_$AK(w,D){const O=this.constructor,U=O._$Eh.get(w);if(U!==void 0&&this._$Em!==U){const G=O.getPropertyOptions(U),q=typeof G.converter=="function"?{fromAttribute:G.converter}:G.converter?.fromAttribute!==void 0?G.converter:u$2;this._$Em=U;const K=q.fromAttribute(D,G.type);this[U]=K??this._$Ej?.get(U)??K,this._$Em=null}}requestUpdate(w,D,O){if(w!==void 0){const U=this.constructor,G=this[w];if(O??=U.getPropertyOptions(w),!((O.hasChanged??f$1)(G,D)||O.useDefault&&O.reflect&&G===this._$Ej?.get(w)&&!this.hasAttribute(U._$Eu(w,O))))return;this.C(w,D,O)}this.isUpdatePending===!1&&(this._$ES=this._$EP())}C(w,D,{useDefault:O,reflect:U,wrapped:G},q){O&&!(this._$Ej??=new Map).has(w)&&(this._$Ej.set(w,q??D??this[w]),G!==!0||q!==void 0)||(this._$AL.has(w)||(this.hasUpdated||O||(D=void 0),this._$AL.set(w,D)),U===!0&&this._$Em!==w&&(this._$Eq??=new Set).add(w))}async _$EP(){this.isUpdatePending=!0;try{await this._$ES}catch(D){Promise.reject(D)}const w=this.scheduleUpdate();return w!=null&&await w,!this.isUpdatePending}scheduleUpdate(){return this.performUpdate()}performUpdate(){if(!this.isUpdatePending)return;if(!this.hasUpdated){if(this.renderRoot??=this.createRenderRoot(),this._$Ep){for(const[U,G]of this._$Ep)this[U]=G;this._$Ep=void 0}const O=this.constructor.elementProperties;if(O.size>0)for(const[U,G]of O){const{wrapped:q}=G,K=this[U];q!==!0||this._$AL.has(U)||K===void 0||this.C(U,void 0,G,K)}}let w=!1;const D=this._$AL;try{w=this.shouldUpdate(D),w?(this.willUpdate(D),this._$EO?.forEach((O=>O.hostUpdate?.())),this.update(D)):this._$EM()}catch(O){throw w=!1,this._$EM(),O}w&&this._$AE(D)}willUpdate(w){}_$AE(w){this._$EO?.forEach((D=>D.hostUpdated?.())),this.hasUpdated||(this.hasUpdated=!0,this.firstUpdated(w)),this.updated(w)}_$EM(){this._$AL=new Map,this.isUpdatePending=!1}get updateComplete(){return this.getUpdateComplete()}getUpdateComplete(){return this._$ES}shouldUpdate(w){return!0}update(w){this._$Eq&&=this._$Eq.forEach((D=>this._$ET(D,this[D]))),this._$EM()}updated(w){}firstUpdated(w){}};y$2.elementStyles=[],y$2.shadowRootOptions={mode:"open"},y$2[d$1("elementProperties")]=new Map,y$2[d$1("finalized")]=new Map,p$1?.({ReactiveElement:y$2}),(a$2.reactiveElementVersions??=[]).push("2.1.1");/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */const o$2={attribute:!0,type:String,converter:u$2,reflect:!1,hasChanged:f$1},r$1=(F=o$2,w,D)=>{const{kind:O,metadata:U}=D;let G=globalThis.litPropertyMetadata.get(U);if(G===void 0&&globalThis.litPropertyMetadata.set(U,G=new Map),O==="setter"&&((F=Object.create(F)).wrapped=!0),G.set(D.name,F),O==="accessor"){const{name:q}=D;return{set(K){const ee=w.get.call(this);w.set.call(this,K),this.requestUpdate(q,ee,F)},init(K){return K!==void 0&&this.C(q,void 0,F,K),K}}}if(O==="setter"){const{name:q}=D;return function(K){const ee=this[q];w.call(this,K),this.requestUpdate(q,ee,F)}}throw Error("Unsupported decorator location: "+O)};function n$2(F){return(w,D)=>typeof D=="object"?r$1(F,w,D):((O,U,G)=>{const q=U.hasOwnProperty(G);return U.constructor.createProperty(G,O),q?Object.getOwnPropertyDescriptor(U,G):void 0})(F,w,D)}/**
 * @license
 * Copyright 2010-2025 Three.js Authors
 * SPDX-License-Identifier: MIT
 */const REVISION="181",CullFaceNone=0,CullFaceBack=1,CullFaceFront=2,PCFShadowMap=1,PCFSoftShadowMap=2,VSMShadowMap=3,FrontSide=0,BackSide=1,DoubleSide=2,NoBlending=0,NormalBlending=1,AdditiveBlending=2,SubtractiveBlending=3,MultiplyBlending=4,CustomBlending=5,AddEquation=100,SubtractEquation=101,ReverseSubtractEquation=102,MinEquation=103,MaxEquation=104,ZeroFactor=200,OneFactor=201,SrcColorFactor=202,OneMinusSrcColorFactor=203,SrcAlphaFactor=204,OneMinusSrcAlphaFactor=205,DstAlphaFactor=206,OneMinusDstAlphaFactor=207,DstColorFactor=208,OneMinusDstColorFactor=209,SrcAlphaSaturateFactor=210,ConstantColorFactor=211,OneMinusConstantColorFactor=212,ConstantAlphaFactor=213,OneMinusConstantAlphaFactor=214,NeverDepth=0,AlwaysDepth=1,LessDepth=2,LessEqualDepth=3,EqualDepth=4,GreaterEqualDepth=5,GreaterDepth=6,NotEqualDepth=7,MultiplyOperation=0,MixOperation=1,AddOperation=2,NoToneMapping=0,LinearToneMapping=1,ReinhardToneMapping=2,CineonToneMapping=3,ACESFilmicToneMapping=4,CustomToneMapping=5,AgXToneMapping=6,NeutralToneMapping=7,AttachedBindMode="attached",DetachedBindMode="detached",UVMapping=300,CubeReflectionMapping=301,CubeRefractionMapping=302,EquirectangularReflectionMapping=303,EquirectangularRefractionMapping=304,CubeUVReflectionMapping=306,RepeatWrapping=1e3,ClampToEdgeWrapping=1001,MirroredRepeatWrapping=1002,NearestFilter=1003,NearestMipmapNearestFilter=1004,NearestMipmapLinearFilter=1005,LinearFilter=1006,LinearMipmapNearestFilter=1007,LinearMipmapLinearFilter=1008,LinearMipMapLinearFilter=1008,UnsignedByteType=1009,ByteType=1010,ShortType=1011,UnsignedShortType=1012,IntType=1013,UnsignedIntType=1014,FloatType=1015,HalfFloatType=1016,UnsignedShort4444Type=1017,UnsignedShort5551Type=1018,UnsignedInt248Type=1020,UnsignedInt5999Type=35902,UnsignedInt101111Type=35899,AlphaFormat=1021,RGBFormat=1022,RGBAFormat=1023,DepthFormat=1026,DepthStencilFormat=1027,RedFormat=1028,RedIntegerFormat=1029,RGFormat=1030,RGIntegerFormat=1031,RGBAIntegerFormat=1033,RGB_S3TC_DXT1_Format=33776,RGBA_S3TC_DXT1_Format=33777,RGBA_S3TC_DXT3_Format=33778,RGBA_S3TC_DXT5_Format=33779,RGB_PVRTC_4BPPV1_Format=35840,RGB_PVRTC_2BPPV1_Format=35841,RGBA_PVRTC_4BPPV1_Format=35842,RGBA_PVRTC_2BPPV1_Format=35843,RGB_ETC1_Format=36196,RGB_ETC2_Format=37492,RGBA_ETC2_EAC_Format=37496,RGBA_ASTC_4x4_Format=37808,RGBA_ASTC_5x4_Format=37809,RGBA_ASTC_5x5_Format=37810,RGBA_ASTC_6x5_Format=37811,RGBA_ASTC_6x6_Format=37812,RGBA_ASTC_8x5_Format=37813,RGBA_ASTC_8x6_Format=37814,RGBA_ASTC_8x8_Format=37815,RGBA_ASTC_10x5_Format=37816,RGBA_ASTC_10x6_Format=37817,RGBA_ASTC_10x8_Format=37818,RGBA_ASTC_10x10_Format=37819,RGBA_ASTC_12x10_Format=37820,RGBA_ASTC_12x12_Format=37821,RGBA_BPTC_Format=36492,RGB_BPTC_SIGNED_Format=36494,RGB_BPTC_UNSIGNED_Format=36495,RED_RGTC1_Format=36283,SIGNED_RED_RGTC1_Format=36284,RED_GREEN_RGTC2_Format=36285,SIGNED_RED_GREEN_RGTC2_Format=36286,LoopOnce=2200,LoopRepeat=2201,LoopPingPong=2202,InterpolateDiscrete=2300,InterpolateLinear=2301,InterpolateSmooth=2302,ZeroCurvatureEnding=2400,ZeroSlopeEnding=2401,WrapAroundEnding=2402,NormalAnimationBlendMode=2500,AdditiveAnimationBlendMode=2501,TrianglesDrawMode=0,TriangleStripDrawMode=1,TriangleFanDrawMode=2,BasicDepthPacking=3200,RGBADepthPacking=3201,TangentSpaceNormalMap=0,ObjectSpaceNormalMap=1,NoColorSpace="",SRGBColorSpace="srgb",LinearSRGBColorSpace="srgb-linear",LinearTransfer="linear",SRGBTransfer="srgb",KeepStencilOp=7680,AlwaysStencilFunc=519,NeverCompare=512,LessCompare=513,EqualCompare=514,LessEqualCompare=515,GreaterCompare=516,NotEqualCompare=517,GreaterEqualCompare=518,AlwaysCompare=519,StaticDrawUsage=35044,GLSL3="300 es",WebGLCoordinateSystem=2e3,WebGPUCoordinateSystem=2001;function arrayNeedsUint32(F){for(let w=F.length-1;w>=0;--w)if(F[w]>=65535)return!0;return!1}function createElementNS(F){return document.createElementNS("http://www.w3.org/1999/xhtml",F)}function createCanvasElement(){const F=createElementNS("canvas");return F.style.display="block",F}const _cache={};function log(...F){const w="THREE."+F.shift();console.log(w,...F)}function warn(...F){const w="THREE."+F.shift();console.warn(w,...F)}function error(...F){const w="THREE."+F.shift();console.error(w,...F)}function warnOnce(...F){const w=F.join(" ");w in _cache||(_cache[w]=!0,warn(...F))}function probeAsync(F,w,D){return new Promise(function(O,U){function G(){switch(F.clientWaitSync(w,F.SYNC_FLUSH_COMMANDS_BIT,0)){case F.WAIT_FAILED:U();break;case F.TIMEOUT_EXPIRED:setTimeout(G,D);break;default:O()}}setTimeout(G,D)})}class EventDispatcher{addEventListener(w,D){this._listeners===void 0&&(this._listeners={});const O=this._listeners;O[w]===void 0&&(O[w]=[]),O[w].indexOf(D)===-1&&O[w].push(D)}hasEventListener(w,D){const O=this._listeners;return O===void 0?!1:O[w]!==void 0&&O[w].indexOf(D)!==-1}removeEventListener(w,D){const O=this._listeners;if(O===void 0)return;const U=O[w];if(U!==void 0){const G=U.indexOf(D);G!==-1&&U.splice(G,1)}}dispatchEvent(w){const D=this._listeners;if(D===void 0)return;const O=D[w.type];if(O!==void 0){w.target=this;const U=O.slice(0);for(let G=0,q=U.length;G<q;G++)U[G].call(this,w);w.target=null}}}const _lut=["00","01","02","03","04","05","06","07","08","09","0a","0b","0c","0d","0e","0f","10","11","12","13","14","15","16","17","18","19","1a","1b","1c","1d","1e","1f","20","21","22","23","24","25","26","27","28","29","2a","2b","2c","2d","2e","2f","30","31","32","33","34","35","36","37","38","39","3a","3b","3c","3d","3e","3f","40","41","42","43","44","45","46","47","48","49","4a","4b","4c","4d","4e","4f","50","51","52","53","54","55","56","57","58","59","5a","5b","5c","5d","5e","5f","60","61","62","63","64","65","66","67","68","69","6a","6b","6c","6d","6e","6f","70","71","72","73","74","75","76","77","78","79","7a","7b","7c","7d","7e","7f","80","81","82","83","84","85","86","87","88","89","8a","8b","8c","8d","8e","8f","90","91","92","93","94","95","96","97","98","99","9a","9b","9c","9d","9e","9f","a0","a1","a2","a3","a4","a5","a6","a7","a8","a9","aa","ab","ac","ad","ae","af","b0","b1","b2","b3","b4","b5","b6","b7","b8","b9","ba","bb","bc","bd","be","bf","c0","c1","c2","c3","c4","c5","c6","c7","c8","c9","ca","cb","cc","cd","ce","cf","d0","d1","d2","d3","d4","d5","d6","d7","d8","d9","da","db","dc","dd","de","df","e0","e1","e2","e3","e4","e5","e6","e7","e8","e9","ea","eb","ec","ed","ee","ef","f0","f1","f2","f3","f4","f5","f6","f7","f8","f9","fa","fb","fc","fd","fe","ff"];let _seed=1234567;const DEG2RAD=Math.PI/180,RAD2DEG=180/Math.PI;function generateUUID(){const F=Math.random()*4294967295|0,w=Math.random()*4294967295|0,D=Math.random()*4294967295|0,O=Math.random()*4294967295|0;return(_lut[F&255]+_lut[F>>8&255]+_lut[F>>16&255]+_lut[F>>24&255]+"-"+_lut[w&255]+_lut[w>>8&255]+"-"+_lut[w>>16&15|64]+_lut[w>>24&255]+"-"+_lut[D&63|128]+_lut[D>>8&255]+"-"+_lut[D>>16&255]+_lut[D>>24&255]+_lut[O&255]+_lut[O>>8&255]+_lut[O>>16&255]+_lut[O>>24&255]).toLowerCase()}function clamp$2(F,w,D){return Math.max(w,Math.min(D,F))}function euclideanModulo(F,w){return(F%w+w)%w}function mapLinear(F,w,D,O,U){return O+(F-w)*(U-O)/(D-w)}function inverseLerp(F,w,D){return F!==w?(D-F)/(w-F):0}function lerp$1(F,w,D){return(1-D)*F+D*w}function damp(F,w,D,O){return lerp$1(F,w,1-Math.exp(-D*O))}function pingpong(F,w=1){return w-Math.abs(euclideanModulo(F,w*2)-w)}function smoothstep(F,w,D){return F<=w?0:F>=D?1:(F=(F-w)/(D-w),F*F*(3-2*F))}function smootherstep(F,w,D){return F<=w?0:F>=D?1:(F=(F-w)/(D-w),F*F*F*(F*(F*6-15)+10))}function randInt(F,w){return F+Math.floor(Math.random()*(w-F+1))}function randFloat(F,w){return F+Math.random()*(w-F)}function randFloatSpread(F){return F*(.5-Math.random())}function seededRandom(F){F!==void 0&&(_seed=F);let w=_seed+=1831565813;return w=Math.imul(w^w>>>15,w|1),w^=w+Math.imul(w^w>>>7,w|61),((w^w>>>14)>>>0)/4294967296}function degToRad(F){return F*DEG2RAD}function radToDeg$1(F){return F*RAD2DEG}function isPowerOfTwo$1(F){return(F&F-1)===0&&F!==0}function ceilPowerOfTwo(F){return Math.pow(2,Math.ceil(Math.log(F)/Math.LN2))}function floorPowerOfTwo(F){return Math.pow(2,Math.floor(Math.log(F)/Math.LN2))}function setQuaternionFromProperEuler(F,w,D,O,U){const G=Math.cos,q=Math.sin,K=G(D/2),ee=q(D/2),Z=G((w+O)/2),ie=q((w+O)/2),Y=G((w-O)/2),W=q((w-O)/2),ne=G((O-w)/2),se=q((O-w)/2);switch(U){case"XYX":F.set(K*ie,ee*Y,ee*W,K*Z);break;case"YZY":F.set(ee*W,K*ie,ee*Y,K*Z);break;case"ZXZ":F.set(ee*Y,ee*W,K*ie,K*Z);break;case"XZX":F.set(K*ie,ee*se,ee*ne,K*Z);break;case"YXY":F.set(ee*ne,K*ie,ee*se,K*Z);break;case"ZYZ":F.set(ee*se,ee*ne,K*ie,K*Z);break;default:warn("MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: "+U)}}function denormalize(F,w){switch(w.constructor){case Float32Array:return F;case Uint32Array:return F/4294967295;case Uint16Array:return F/65535;case Uint8Array:return F/255;case Int32Array:return Math.max(F/2147483647,-1);case Int16Array:return Math.max(F/32767,-1);case Int8Array:return Math.max(F/127,-1);default:throw new Error("Invalid component type.")}}function normalize(F,w){switch(w.constructor){case Float32Array:return F;case Uint32Array:return Math.round(F*4294967295);case Uint16Array:return Math.round(F*65535);case Uint8Array:return Math.round(F*255);case Int32Array:return Math.round(F*2147483647);case Int16Array:return Math.round(F*32767);case Int8Array:return Math.round(F*127);default:throw new Error("Invalid component type.")}}const MathUtils={DEG2RAD,RAD2DEG,generateUUID,clamp:clamp$2,euclideanModulo,mapLinear,inverseLerp,lerp:lerp$1,damp,pingpong,smoothstep,smootherstep,randInt,randFloat,randFloatSpread,seededRandom,degToRad,radToDeg:radToDeg$1,isPowerOfTwo:isPowerOfTwo$1,ceilPowerOfTwo,floorPowerOfTwo,setQuaternionFromProperEuler,normalize,denormalize};class Vector2{constructor(w=0,D=0){Vector2.prototype.isVector2=!0,this.x=w,this.y=D}get width(){return this.x}set width(w){this.x=w}get height(){return this.y}set height(w){this.y=w}set(w,D){return this.x=w,this.y=D,this}setScalar(w){return this.x=w,this.y=w,this}setX(w){return this.x=w,this}setY(w){return this.y=w,this}setComponent(w,D){switch(w){case 0:this.x=D;break;case 1:this.y=D;break;default:throw new Error("index is out of range: "+w)}return this}getComponent(w){switch(w){case 0:return this.x;case 1:return this.y;default:throw new Error("index is out of range: "+w)}}clone(){return new this.constructor(this.x,this.y)}copy(w){return this.x=w.x,this.y=w.y,this}add(w){return this.x+=w.x,this.y+=w.y,this}addScalar(w){return this.x+=w,this.y+=w,this}addVectors(w,D){return this.x=w.x+D.x,this.y=w.y+D.y,this}addScaledVector(w,D){return this.x+=w.x*D,this.y+=w.y*D,this}sub(w){return this.x-=w.x,this.y-=w.y,this}subScalar(w){return this.x-=w,this.y-=w,this}subVectors(w,D){return this.x=w.x-D.x,this.y=w.y-D.y,this}multiply(w){return this.x*=w.x,this.y*=w.y,this}multiplyScalar(w){return this.x*=w,this.y*=w,this}divide(w){return this.x/=w.x,this.y/=w.y,this}divideScalar(w){return this.multiplyScalar(1/w)}applyMatrix3(w){const D=this.x,O=this.y,U=w.elements;return this.x=U[0]*D+U[3]*O+U[6],this.y=U[1]*D+U[4]*O+U[7],this}min(w){return this.x=Math.min(this.x,w.x),this.y=Math.min(this.y,w.y),this}max(w){return this.x=Math.max(this.x,w.x),this.y=Math.max(this.y,w.y),this}clamp(w,D){return this.x=clamp$2(this.x,w.x,D.x),this.y=clamp$2(this.y,w.y,D.y),this}clampScalar(w,D){return this.x=clamp$2(this.x,w,D),this.y=clamp$2(this.y,w,D),this}clampLength(w,D){const O=this.length();return this.divideScalar(O||1).multiplyScalar(clamp$2(O,w,D))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this}roundToZero(){return this.x=Math.trunc(this.x),this.y=Math.trunc(this.y),this}negate(){return this.x=-this.x,this.y=-this.y,this}dot(w){return this.x*w.x+this.y*w.y}cross(w){return this.x*w.y-this.y*w.x}lengthSq(){return this.x*this.x+this.y*this.y}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)}normalize(){return this.divideScalar(this.length()||1)}angle(){return Math.atan2(-this.y,-this.x)+Math.PI}angleTo(w){const D=Math.sqrt(this.lengthSq()*w.lengthSq());if(D===0)return Math.PI/2;const O=this.dot(w)/D;return Math.acos(clamp$2(O,-1,1))}distanceTo(w){return Math.sqrt(this.distanceToSquared(w))}distanceToSquared(w){const D=this.x-w.x,O=this.y-w.y;return D*D+O*O}manhattanDistanceTo(w){return Math.abs(this.x-w.x)+Math.abs(this.y-w.y)}setLength(w){return this.normalize().multiplyScalar(w)}lerp(w,D){return this.x+=(w.x-this.x)*D,this.y+=(w.y-this.y)*D,this}lerpVectors(w,D,O){return this.x=w.x+(D.x-w.x)*O,this.y=w.y+(D.y-w.y)*O,this}equals(w){return w.x===this.x&&w.y===this.y}fromArray(w,D=0){return this.x=w[D],this.y=w[D+1],this}toArray(w=[],D=0){return w[D]=this.x,w[D+1]=this.y,w}fromBufferAttribute(w,D){return this.x=w.getX(D),this.y=w.getY(D),this}rotateAround(w,D){const O=Math.cos(D),U=Math.sin(D),G=this.x-w.x,q=this.y-w.y;return this.x=G*O-q*U+w.x,this.y=G*U+q*O+w.y,this}random(){return this.x=Math.random(),this.y=Math.random(),this}*[Symbol.iterator](){yield this.x,yield this.y}}class Quaternion{constructor(w=0,D=0,O=0,U=1){this.isQuaternion=!0,this._x=w,this._y=D,this._z=O,this._w=U}static slerpFlat(w,D,O,U,G,q,K){let ee=O[U+0],Z=O[U+1],ie=O[U+2],Y=O[U+3],W=G[q+0],ne=G[q+1],se=G[q+2],le=G[q+3];if(K<=0){w[D+0]=ee,w[D+1]=Z,w[D+2]=ie,w[D+3]=Y;return}if(K>=1){w[D+0]=W,w[D+1]=ne,w[D+2]=se,w[D+3]=le;return}if(Y!==le||ee!==W||Z!==ne||ie!==se){let ce=ee*W+Z*ne+ie*se+Y*le;ce<0&&(W=-W,ne=-ne,se=-se,le=-le,ce=-ce);let he=1-K;if(ce<.9995){const pe=Math.acos(ce),me=Math.sin(pe);he=Math.sin(he*pe)/me,K=Math.sin(K*pe)/me,ee=ee*he+W*K,Z=Z*he+ne*K,ie=ie*he+se*K,Y=Y*he+le*K}else{ee=ee*he+W*K,Z=Z*he+ne*K,ie=ie*he+se*K,Y=Y*he+le*K;const pe=1/Math.sqrt(ee*ee+Z*Z+ie*ie+Y*Y);ee*=pe,Z*=pe,ie*=pe,Y*=pe}}w[D]=ee,w[D+1]=Z,w[D+2]=ie,w[D+3]=Y}static multiplyQuaternionsFlat(w,D,O,U,G,q){const K=O[U],ee=O[U+1],Z=O[U+2],ie=O[U+3],Y=G[q],W=G[q+1],ne=G[q+2],se=G[q+3];return w[D]=K*se+ie*Y+ee*ne-Z*W,w[D+1]=ee*se+ie*W+Z*Y-K*ne,w[D+2]=Z*se+ie*ne+K*W-ee*Y,w[D+3]=ie*se-K*Y-ee*W-Z*ne,w}get x(){return this._x}set x(w){this._x=w,this._onChangeCallback()}get y(){return this._y}set y(w){this._y=w,this._onChangeCallback()}get z(){return this._z}set z(w){this._z=w,this._onChangeCallback()}get w(){return this._w}set w(w){this._w=w,this._onChangeCallback()}set(w,D,O,U){return this._x=w,this._y=D,this._z=O,this._w=U,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._w)}copy(w){return this._x=w.x,this._y=w.y,this._z=w.z,this._w=w.w,this._onChangeCallback(),this}setFromEuler(w,D=!0){const O=w._x,U=w._y,G=w._z,q=w._order,K=Math.cos,ee=Math.sin,Z=K(O/2),ie=K(U/2),Y=K(G/2),W=ee(O/2),ne=ee(U/2),se=ee(G/2);switch(q){case"XYZ":this._x=W*ie*Y+Z*ne*se,this._y=Z*ne*Y-W*ie*se,this._z=Z*ie*se+W*ne*Y,this._w=Z*ie*Y-W*ne*se;break;case"YXZ":this._x=W*ie*Y+Z*ne*se,this._y=Z*ne*Y-W*ie*se,this._z=Z*ie*se-W*ne*Y,this._w=Z*ie*Y+W*ne*se;break;case"ZXY":this._x=W*ie*Y-Z*ne*se,this._y=Z*ne*Y+W*ie*se,this._z=Z*ie*se+W*ne*Y,this._w=Z*ie*Y-W*ne*se;break;case"ZYX":this._x=W*ie*Y-Z*ne*se,this._y=Z*ne*Y+W*ie*se,this._z=Z*ie*se-W*ne*Y,this._w=Z*ie*Y+W*ne*se;break;case"YZX":this._x=W*ie*Y+Z*ne*se,this._y=Z*ne*Y+W*ie*se,this._z=Z*ie*se-W*ne*Y,this._w=Z*ie*Y-W*ne*se;break;case"XZY":this._x=W*ie*Y-Z*ne*se,this._y=Z*ne*Y-W*ie*se,this._z=Z*ie*se+W*ne*Y,this._w=Z*ie*Y+W*ne*se;break;default:warn("Quaternion: .setFromEuler() encountered an unknown order: "+q)}return D===!0&&this._onChangeCallback(),this}setFromAxisAngle(w,D){const O=D/2,U=Math.sin(O);return this._x=w.x*U,this._y=w.y*U,this._z=w.z*U,this._w=Math.cos(O),this._onChangeCallback(),this}setFromRotationMatrix(w){const D=w.elements,O=D[0],U=D[4],G=D[8],q=D[1],K=D[5],ee=D[9],Z=D[2],ie=D[6],Y=D[10],W=O+K+Y;if(W>0){const ne=.5/Math.sqrt(W+1);this._w=.25/ne,this._x=(ie-ee)*ne,this._y=(G-Z)*ne,this._z=(q-U)*ne}else if(O>K&&O>Y){const ne=2*Math.sqrt(1+O-K-Y);this._w=(ie-ee)/ne,this._x=.25*ne,this._y=(U+q)/ne,this._z=(G+Z)/ne}else if(K>Y){const ne=2*Math.sqrt(1+K-O-Y);this._w=(G-Z)/ne,this._x=(U+q)/ne,this._y=.25*ne,this._z=(ee+ie)/ne}else{const ne=2*Math.sqrt(1+Y-O-K);this._w=(q-U)/ne,this._x=(G+Z)/ne,this._y=(ee+ie)/ne,this._z=.25*ne}return this._onChangeCallback(),this}setFromUnitVectors(w,D){let O=w.dot(D)+1;return O<1e-8?(O=0,Math.abs(w.x)>Math.abs(w.z)?(this._x=-w.y,this._y=w.x,this._z=0,this._w=O):(this._x=0,this._y=-w.z,this._z=w.y,this._w=O)):(this._x=w.y*D.z-w.z*D.y,this._y=w.z*D.x-w.x*D.z,this._z=w.x*D.y-w.y*D.x,this._w=O),this.normalize()}angleTo(w){return 2*Math.acos(Math.abs(clamp$2(this.dot(w),-1,1)))}rotateTowards(w,D){const O=this.angleTo(w);if(O===0)return this;const U=Math.min(1,D/O);return this.slerp(w,U),this}identity(){return this.set(0,0,0,1)}invert(){return this.conjugate()}conjugate(){return this._x*=-1,this._y*=-1,this._z*=-1,this._onChangeCallback(),this}dot(w){return this._x*w._x+this._y*w._y+this._z*w._z+this._w*w._w}lengthSq(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}length(){return Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w)}normalize(){let w=this.length();return w===0?(this._x=0,this._y=0,this._z=0,this._w=1):(w=1/w,this._x=this._x*w,this._y=this._y*w,this._z=this._z*w,this._w=this._w*w),this._onChangeCallback(),this}multiply(w){return this.multiplyQuaternions(this,w)}premultiply(w){return this.multiplyQuaternions(w,this)}multiplyQuaternions(w,D){const O=w._x,U=w._y,G=w._z,q=w._w,K=D._x,ee=D._y,Z=D._z,ie=D._w;return this._x=O*ie+q*K+U*Z-G*ee,this._y=U*ie+q*ee+G*K-O*Z,this._z=G*ie+q*Z+O*ee-U*K,this._w=q*ie-O*K-U*ee-G*Z,this._onChangeCallback(),this}slerp(w,D){if(D<=0)return this;if(D>=1)return this.copy(w);let O=w._x,U=w._y,G=w._z,q=w._w,K=this.dot(w);K<0&&(O=-O,U=-U,G=-G,q=-q,K=-K);let ee=1-D;if(K<.9995){const Z=Math.acos(K),ie=Math.sin(Z);ee=Math.sin(ee*Z)/ie,D=Math.sin(D*Z)/ie,this._x=this._x*ee+O*D,this._y=this._y*ee+U*D,this._z=this._z*ee+G*D,this._w=this._w*ee+q*D,this._onChangeCallback()}else this._x=this._x*ee+O*D,this._y=this._y*ee+U*D,this._z=this._z*ee+G*D,this._w=this._w*ee+q*D,this.normalize();return this}slerpQuaternions(w,D,O){return this.copy(w).slerp(D,O)}random(){const w=2*Math.PI*Math.random(),D=2*Math.PI*Math.random(),O=Math.random(),U=Math.sqrt(1-O),G=Math.sqrt(O);return this.set(U*Math.sin(w),U*Math.cos(w),G*Math.sin(D),G*Math.cos(D))}equals(w){return w._x===this._x&&w._y===this._y&&w._z===this._z&&w._w===this._w}fromArray(w,D=0){return this._x=w[D],this._y=w[D+1],this._z=w[D+2],this._w=w[D+3],this._onChangeCallback(),this}toArray(w=[],D=0){return w[D]=this._x,w[D+1]=this._y,w[D+2]=this._z,w[D+3]=this._w,w}fromBufferAttribute(w,D){return this._x=w.getX(D),this._y=w.getY(D),this._z=w.getZ(D),this._w=w.getW(D),this._onChangeCallback(),this}toJSON(){return this.toArray()}_onChange(w){return this._onChangeCallback=w,this}_onChangeCallback(){}*[Symbol.iterator](){yield this._x,yield this._y,yield this._z,yield this._w}}class Vector3{constructor(w=0,D=0,O=0){Vector3.prototype.isVector3=!0,this.x=w,this.y=D,this.z=O}set(w,D,O){return O===void 0&&(O=this.z),this.x=w,this.y=D,this.z=O,this}setScalar(w){return this.x=w,this.y=w,this.z=w,this}setX(w){return this.x=w,this}setY(w){return this.y=w,this}setZ(w){return this.z=w,this}setComponent(w,D){switch(w){case 0:this.x=D;break;case 1:this.y=D;break;case 2:this.z=D;break;default:throw new Error("index is out of range: "+w)}return this}getComponent(w){switch(w){case 0:return this.x;case 1:return this.y;case 2:return this.z;default:throw new Error("index is out of range: "+w)}}clone(){return new this.constructor(this.x,this.y,this.z)}copy(w){return this.x=w.x,this.y=w.y,this.z=w.z,this}add(w){return this.x+=w.x,this.y+=w.y,this.z+=w.z,this}addScalar(w){return this.x+=w,this.y+=w,this.z+=w,this}addVectors(w,D){return this.x=w.x+D.x,this.y=w.y+D.y,this.z=w.z+D.z,this}addScaledVector(w,D){return this.x+=w.x*D,this.y+=w.y*D,this.z+=w.z*D,this}sub(w){return this.x-=w.x,this.y-=w.y,this.z-=w.z,this}subScalar(w){return this.x-=w,this.y-=w,this.z-=w,this}subVectors(w,D){return this.x=w.x-D.x,this.y=w.y-D.y,this.z=w.z-D.z,this}multiply(w){return this.x*=w.x,this.y*=w.y,this.z*=w.z,this}multiplyScalar(w){return this.x*=w,this.y*=w,this.z*=w,this}multiplyVectors(w,D){return this.x=w.x*D.x,this.y=w.y*D.y,this.z=w.z*D.z,this}applyEuler(w){return this.applyQuaternion(_quaternion$4.setFromEuler(w))}applyAxisAngle(w,D){return this.applyQuaternion(_quaternion$4.setFromAxisAngle(w,D))}applyMatrix3(w){const D=this.x,O=this.y,U=this.z,G=w.elements;return this.x=G[0]*D+G[3]*O+G[6]*U,this.y=G[1]*D+G[4]*O+G[7]*U,this.z=G[2]*D+G[5]*O+G[8]*U,this}applyNormalMatrix(w){return this.applyMatrix3(w).normalize()}applyMatrix4(w){const D=this.x,O=this.y,U=this.z,G=w.elements,q=1/(G[3]*D+G[7]*O+G[11]*U+G[15]);return this.x=(G[0]*D+G[4]*O+G[8]*U+G[12])*q,this.y=(G[1]*D+G[5]*O+G[9]*U+G[13])*q,this.z=(G[2]*D+G[6]*O+G[10]*U+G[14])*q,this}applyQuaternion(w){const D=this.x,O=this.y,U=this.z,G=w.x,q=w.y,K=w.z,ee=w.w,Z=2*(q*U-K*O),ie=2*(K*D-G*U),Y=2*(G*O-q*D);return this.x=D+ee*Z+q*Y-K*ie,this.y=O+ee*ie+K*Z-G*Y,this.z=U+ee*Y+G*ie-q*Z,this}project(w){return this.applyMatrix4(w.matrixWorldInverse).applyMatrix4(w.projectionMatrix)}unproject(w){return this.applyMatrix4(w.projectionMatrixInverse).applyMatrix4(w.matrixWorld)}transformDirection(w){const D=this.x,O=this.y,U=this.z,G=w.elements;return this.x=G[0]*D+G[4]*O+G[8]*U,this.y=G[1]*D+G[5]*O+G[9]*U,this.z=G[2]*D+G[6]*O+G[10]*U,this.normalize()}divide(w){return this.x/=w.x,this.y/=w.y,this.z/=w.z,this}divideScalar(w){return this.multiplyScalar(1/w)}min(w){return this.x=Math.min(this.x,w.x),this.y=Math.min(this.y,w.y),this.z=Math.min(this.z,w.z),this}max(w){return this.x=Math.max(this.x,w.x),this.y=Math.max(this.y,w.y),this.z=Math.max(this.z,w.z),this}clamp(w,D){return this.x=clamp$2(this.x,w.x,D.x),this.y=clamp$2(this.y,w.y,D.y),this.z=clamp$2(this.z,w.z,D.z),this}clampScalar(w,D){return this.x=clamp$2(this.x,w,D),this.y=clamp$2(this.y,w,D),this.z=clamp$2(this.z,w,D),this}clampLength(w,D){const O=this.length();return this.divideScalar(O||1).multiplyScalar(clamp$2(O,w,D))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this}roundToZero(){return this.x=Math.trunc(this.x),this.y=Math.trunc(this.y),this.z=Math.trunc(this.z),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this}dot(w){return this.x*w.x+this.y*w.y+this.z*w.z}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)}normalize(){return this.divideScalar(this.length()||1)}setLength(w){return this.normalize().multiplyScalar(w)}lerp(w,D){return this.x+=(w.x-this.x)*D,this.y+=(w.y-this.y)*D,this.z+=(w.z-this.z)*D,this}lerpVectors(w,D,O){return this.x=w.x+(D.x-w.x)*O,this.y=w.y+(D.y-w.y)*O,this.z=w.z+(D.z-w.z)*O,this}cross(w){return this.crossVectors(this,w)}crossVectors(w,D){const O=w.x,U=w.y,G=w.z,q=D.x,K=D.y,ee=D.z;return this.x=U*ee-G*K,this.y=G*q-O*ee,this.z=O*K-U*q,this}projectOnVector(w){const D=w.lengthSq();if(D===0)return this.set(0,0,0);const O=w.dot(this)/D;return this.copy(w).multiplyScalar(O)}projectOnPlane(w){return _vector$c.copy(this).projectOnVector(w),this.sub(_vector$c)}reflect(w){return this.sub(_vector$c.copy(w).multiplyScalar(2*this.dot(w)))}angleTo(w){const D=Math.sqrt(this.lengthSq()*w.lengthSq());if(D===0)return Math.PI/2;const O=this.dot(w)/D;return Math.acos(clamp$2(O,-1,1))}distanceTo(w){return Math.sqrt(this.distanceToSquared(w))}distanceToSquared(w){const D=this.x-w.x,O=this.y-w.y,U=this.z-w.z;return D*D+O*O+U*U}manhattanDistanceTo(w){return Math.abs(this.x-w.x)+Math.abs(this.y-w.y)+Math.abs(this.z-w.z)}setFromSpherical(w){return this.setFromSphericalCoords(w.radius,w.phi,w.theta)}setFromSphericalCoords(w,D,O){const U=Math.sin(D)*w;return this.x=U*Math.sin(O),this.y=Math.cos(D)*w,this.z=U*Math.cos(O),this}setFromCylindrical(w){return this.setFromCylindricalCoords(w.radius,w.theta,w.y)}setFromCylindricalCoords(w,D,O){return this.x=w*Math.sin(D),this.y=O,this.z=w*Math.cos(D),this}setFromMatrixPosition(w){const D=w.elements;return this.x=D[12],this.y=D[13],this.z=D[14],this}setFromMatrixScale(w){const D=this.setFromMatrixColumn(w,0).length(),O=this.setFromMatrixColumn(w,1).length(),U=this.setFromMatrixColumn(w,2).length();return this.x=D,this.y=O,this.z=U,this}setFromMatrixColumn(w,D){return this.fromArray(w.elements,D*4)}setFromMatrix3Column(w,D){return this.fromArray(w.elements,D*3)}setFromEuler(w){return this.x=w._x,this.y=w._y,this.z=w._z,this}setFromColor(w){return this.x=w.r,this.y=w.g,this.z=w.b,this}equals(w){return w.x===this.x&&w.y===this.y&&w.z===this.z}fromArray(w,D=0){return this.x=w[D],this.y=w[D+1],this.z=w[D+2],this}toArray(w=[],D=0){return w[D]=this.x,w[D+1]=this.y,w[D+2]=this.z,w}fromBufferAttribute(w,D){return this.x=w.getX(D),this.y=w.getY(D),this.z=w.getZ(D),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this}randomDirection(){const w=Math.random()*Math.PI*2,D=Math.random()*2-1,O=Math.sqrt(1-D*D);return this.x=O*Math.cos(w),this.y=D,this.z=O*Math.sin(w),this}*[Symbol.iterator](){yield this.x,yield this.y,yield this.z}}const _vector$c=new Vector3,_quaternion$4=new Quaternion;class Matrix3{constructor(w,D,O,U,G,q,K,ee,Z){Matrix3.prototype.isMatrix3=!0,this.elements=[1,0,0,0,1,0,0,0,1],w!==void 0&&this.set(w,D,O,U,G,q,K,ee,Z)}set(w,D,O,U,G,q,K,ee,Z){const ie=this.elements;return ie[0]=w,ie[1]=U,ie[2]=K,ie[3]=D,ie[4]=G,ie[5]=ee,ie[6]=O,ie[7]=q,ie[8]=Z,this}identity(){return this.set(1,0,0,0,1,0,0,0,1),this}copy(w){const D=this.elements,O=w.elements;return D[0]=O[0],D[1]=O[1],D[2]=O[2],D[3]=O[3],D[4]=O[4],D[5]=O[5],D[6]=O[6],D[7]=O[7],D[8]=O[8],this}extractBasis(w,D,O){return w.setFromMatrix3Column(this,0),D.setFromMatrix3Column(this,1),O.setFromMatrix3Column(this,2),this}setFromMatrix4(w){const D=w.elements;return this.set(D[0],D[4],D[8],D[1],D[5],D[9],D[2],D[6],D[10]),this}multiply(w){return this.multiplyMatrices(this,w)}premultiply(w){return this.multiplyMatrices(w,this)}multiplyMatrices(w,D){const O=w.elements,U=D.elements,G=this.elements,q=O[0],K=O[3],ee=O[6],Z=O[1],ie=O[4],Y=O[7],W=O[2],ne=O[5],se=O[8],le=U[0],ce=U[3],he=U[6],pe=U[1],me=U[4],be=U[7],ge=U[2],ve=U[5],Se=U[8];return G[0]=q*le+K*pe+ee*ge,G[3]=q*ce+K*me+ee*ve,G[6]=q*he+K*be+ee*Se,G[1]=Z*le+ie*pe+Y*ge,G[4]=Z*ce+ie*me+Y*ve,G[7]=Z*he+ie*be+Y*Se,G[2]=W*le+ne*pe+se*ge,G[5]=W*ce+ne*me+se*ve,G[8]=W*he+ne*be+se*Se,this}multiplyScalar(w){const D=this.elements;return D[0]*=w,D[3]*=w,D[6]*=w,D[1]*=w,D[4]*=w,D[7]*=w,D[2]*=w,D[5]*=w,D[8]*=w,this}determinant(){const w=this.elements,D=w[0],O=w[1],U=w[2],G=w[3],q=w[4],K=w[5],ee=w[6],Z=w[7],ie=w[8];return D*q*ie-D*K*Z-O*G*ie+O*K*ee+U*G*Z-U*q*ee}invert(){const w=this.elements,D=w[0],O=w[1],U=w[2],G=w[3],q=w[4],K=w[5],ee=w[6],Z=w[7],ie=w[8],Y=ie*q-K*Z,W=K*ee-ie*G,ne=Z*G-q*ee,se=D*Y+O*W+U*ne;if(se===0)return this.set(0,0,0,0,0,0,0,0,0);const le=1/se;return w[0]=Y*le,w[1]=(U*Z-ie*O)*le,w[2]=(K*O-U*q)*le,w[3]=W*le,w[4]=(ie*D-U*ee)*le,w[5]=(U*G-K*D)*le,w[6]=ne*le,w[7]=(O*ee-Z*D)*le,w[8]=(q*D-O*G)*le,this}transpose(){let w;const D=this.elements;return w=D[1],D[1]=D[3],D[3]=w,w=D[2],D[2]=D[6],D[6]=w,w=D[5],D[5]=D[7],D[7]=w,this}getNormalMatrix(w){return this.setFromMatrix4(w).invert().transpose()}transposeIntoArray(w){const D=this.elements;return w[0]=D[0],w[1]=D[3],w[2]=D[6],w[3]=D[1],w[4]=D[4],w[5]=D[7],w[6]=D[2],w[7]=D[5],w[8]=D[8],this}setUvTransform(w,D,O,U,G,q,K){const ee=Math.cos(G),Z=Math.sin(G);return this.set(O*ee,O*Z,-O*(ee*q+Z*K)+q+w,-U*Z,U*ee,-U*(-Z*q+ee*K)+K+D,0,0,1),this}scale(w,D){return this.premultiply(_m3.makeScale(w,D)),this}rotate(w){return this.premultiply(_m3.makeRotation(-w)),this}translate(w,D){return this.premultiply(_m3.makeTranslation(w,D)),this}makeTranslation(w,D){return w.isVector2?this.set(1,0,w.x,0,1,w.y,0,0,1):this.set(1,0,w,0,1,D,0,0,1),this}makeRotation(w){const D=Math.cos(w),O=Math.sin(w);return this.set(D,-O,0,O,D,0,0,0,1),this}makeScale(w,D){return this.set(w,0,0,0,D,0,0,0,1),this}equals(w){const D=this.elements,O=w.elements;for(let U=0;U<9;U++)if(D[U]!==O[U])return!1;return!0}fromArray(w,D=0){for(let O=0;O<9;O++)this.elements[O]=w[O+D];return this}toArray(w=[],D=0){const O=this.elements;return w[D]=O[0],w[D+1]=O[1],w[D+2]=O[2],w[D+3]=O[3],w[D+4]=O[4],w[D+5]=O[5],w[D+6]=O[6],w[D+7]=O[7],w[D+8]=O[8],w}clone(){return new this.constructor().fromArray(this.elements)}}const _m3=new Matrix3,LINEAR_REC709_TO_XYZ=new Matrix3().set(.4123908,.3575843,.1804808,.212639,.7151687,.0721923,.0193308,.1191948,.9505322),XYZ_TO_LINEAR_REC709=new Matrix3().set(3.2409699,-1.5373832,-.4986108,-.9692436,1.8759675,.0415551,.0556301,-.203977,1.0569715);function createColorManagement(){const F={enabled:!0,workingColorSpace:LinearSRGBColorSpace,spaces:{},convert:function(U,G,q){return this.enabled===!1||G===q||!G||!q||(this.spaces[G].transfer===SRGBTransfer&&(U.r=SRGBToLinear(U.r),U.g=SRGBToLinear(U.g),U.b=SRGBToLinear(U.b)),this.spaces[G].primaries!==this.spaces[q].primaries&&(U.applyMatrix3(this.spaces[G].toXYZ),U.applyMatrix3(this.spaces[q].fromXYZ)),this.spaces[q].transfer===SRGBTransfer&&(U.r=LinearToSRGB(U.r),U.g=LinearToSRGB(U.g),U.b=LinearToSRGB(U.b))),U},workingToColorSpace:function(U,G){return this.convert(U,this.workingColorSpace,G)},colorSpaceToWorking:function(U,G){return this.convert(U,G,this.workingColorSpace)},getPrimaries:function(U){return this.spaces[U].primaries},getTransfer:function(U){return U===NoColorSpace?LinearTransfer:this.spaces[U].transfer},getToneMappingMode:function(U){return this.spaces[U].outputColorSpaceConfig.toneMappingMode||"standard"},getLuminanceCoefficients:function(U,G=this.workingColorSpace){return U.fromArray(this.spaces[G].luminanceCoefficients)},define:function(U){Object.assign(this.spaces,U)},_getMatrix:function(U,G,q){return U.copy(this.spaces[G].toXYZ).multiply(this.spaces[q].fromXYZ)},_getDrawingBufferColorSpace:function(U){return this.spaces[U].outputColorSpaceConfig.drawingBufferColorSpace},_getUnpackColorSpace:function(U=this.workingColorSpace){return this.spaces[U].workingColorSpaceConfig.unpackColorSpace},fromWorkingColorSpace:function(U,G){return warnOnce("ColorManagement: .fromWorkingColorSpace() has been renamed to .workingToColorSpace()."),F.workingToColorSpace(U,G)},toWorkingColorSpace:function(U,G){return warnOnce("ColorManagement: .toWorkingColorSpace() has been renamed to .colorSpaceToWorking()."),F.colorSpaceToWorking(U,G)}},w=[.64,.33,.3,.6,.15,.06],D=[.2126,.7152,.0722],O=[.3127,.329];return F.define({[LinearSRGBColorSpace]:{primaries:w,whitePoint:O,transfer:LinearTransfer,toXYZ:LINEAR_REC709_TO_XYZ,fromXYZ:XYZ_TO_LINEAR_REC709,luminanceCoefficients:D,workingColorSpaceConfig:{unpackColorSpace:SRGBColorSpace},outputColorSpaceConfig:{drawingBufferColorSpace:SRGBColorSpace}},[SRGBColorSpace]:{primaries:w,whitePoint:O,transfer:SRGBTransfer,toXYZ:LINEAR_REC709_TO_XYZ,fromXYZ:XYZ_TO_LINEAR_REC709,luminanceCoefficients:D,outputColorSpaceConfig:{drawingBufferColorSpace:SRGBColorSpace}}}),F}const ColorManagement=createColorManagement();function SRGBToLinear(F){return F<.04045?F*.0773993808:Math.pow(F*.9478672986+.0521327014,2.4)}function LinearToSRGB(F){return F<.0031308?F*12.92:1.055*Math.pow(F,.41666)-.055}let _canvas;class ImageUtils{static getDataURL(w,D="image/png"){if(/^data:/i.test(w.src)||typeof HTMLCanvasElement>"u")return w.src;let O;if(w instanceof HTMLCanvasElement)O=w;else{_canvas===void 0&&(_canvas=createElementNS("canvas")),_canvas.width=w.width,_canvas.height=w.height;const U=_canvas.getContext("2d");w instanceof ImageData?U.putImageData(w,0,0):U.drawImage(w,0,0,w.width,w.height),O=_canvas}return O.toDataURL(D)}static sRGBToLinear(w){if(typeof HTMLImageElement<"u"&&w instanceof HTMLImageElement||typeof HTMLCanvasElement<"u"&&w instanceof HTMLCanvasElement||typeof ImageBitmap<"u"&&w instanceof ImageBitmap){const D=createElementNS("canvas");D.width=w.width,D.height=w.height;const O=D.getContext("2d");O.drawImage(w,0,0,w.width,w.height);const U=O.getImageData(0,0,w.width,w.height),G=U.data;for(let q=0;q<G.length;q++)G[q]=SRGBToLinear(G[q]/255)*255;return O.putImageData(U,0,0),D}else if(w.data){const D=w.data.slice(0);for(let O=0;O<D.length;O++)D instanceof Uint8Array||D instanceof Uint8ClampedArray?D[O]=Math.floor(SRGBToLinear(D[O]/255)*255):D[O]=SRGBToLinear(D[O]);return{data:D,width:w.width,height:w.height}}else return warn("ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."),w}}let _sourceId=0;class Source{constructor(w=null){this.isSource=!0,Object.defineProperty(this,"id",{value:_sourceId++}),this.uuid=generateUUID(),this.data=w,this.dataReady=!0,this.version=0}getSize(w){const D=this.data;return typeof HTMLVideoElement<"u"&&D instanceof HTMLVideoElement?w.set(D.videoWidth,D.videoHeight,0):D instanceof VideoFrame?w.set(D.displayHeight,D.displayWidth,0):D!==null?w.set(D.width,D.height,D.depth||0):w.set(0,0,0),w}set needsUpdate(w){w===!0&&this.version++}toJSON(w){const D=w===void 0||typeof w=="string";if(!D&&w.images[this.uuid]!==void 0)return w.images[this.uuid];const O={uuid:this.uuid,url:""},U=this.data;if(U!==null){let G;if(Array.isArray(U)){G=[];for(let q=0,K=U.length;q<K;q++)U[q].isDataTexture?G.push(serializeImage(U[q].image)):G.push(serializeImage(U[q]))}else G=serializeImage(U);O.url=G}return D||(w.images[this.uuid]=O),O}}function serializeImage(F){return typeof HTMLImageElement<"u"&&F instanceof HTMLImageElement||typeof HTMLCanvasElement<"u"&&F instanceof HTMLCanvasElement||typeof ImageBitmap<"u"&&F instanceof ImageBitmap?ImageUtils.getDataURL(F):F.data?{data:Array.from(F.data),width:F.width,height:F.height,type:F.data.constructor.name}:(warn("Texture: Unable to serialize Texture."),{})}let _textureId=0;const _tempVec3=new Vector3;let Texture$1=class kl extends EventDispatcher{constructor(w=kl.DEFAULT_IMAGE,D=kl.DEFAULT_MAPPING,O=ClampToEdgeWrapping,U=ClampToEdgeWrapping,G=LinearFilter,q=LinearMipmapLinearFilter,K=RGBAFormat,ee=UnsignedByteType,Z=kl.DEFAULT_ANISOTROPY,ie=NoColorSpace){super(),this.isTexture=!0,Object.defineProperty(this,"id",{value:_textureId++}),this.uuid=generateUUID(),this.name="",this.source=new Source(w),this.mipmaps=[],this.mapping=D,this.channel=0,this.wrapS=O,this.wrapT=U,this.magFilter=G,this.minFilter=q,this.anisotropy=Z,this.format=K,this.internalFormat=null,this.type=ee,this.offset=new Vector2(0,0),this.repeat=new Vector2(1,1),this.center=new Vector2(0,0),this.rotation=0,this.matrixAutoUpdate=!0,this.matrix=new Matrix3,this.generateMipmaps=!0,this.premultiplyAlpha=!1,this.flipY=!0,this.unpackAlignment=4,this.colorSpace=ie,this.userData={},this.updateRanges=[],this.version=0,this.onUpdate=null,this.renderTarget=null,this.isRenderTargetTexture=!1,this.isArrayTexture=!!(w&&w.depth&&w.depth>1),this.pmremVersion=0}get width(){return this.source.getSize(_tempVec3).x}get height(){return this.source.getSize(_tempVec3).y}get depth(){return this.source.getSize(_tempVec3).z}get image(){return this.source.data}set image(w=null){this.source.data=w}updateMatrix(){this.matrix.setUvTransform(this.offset.x,this.offset.y,this.repeat.x,this.repeat.y,this.rotation,this.center.x,this.center.y)}addUpdateRange(w,D){this.updateRanges.push({start:w,count:D})}clearUpdateRanges(){this.updateRanges.length=0}clone(){return new this.constructor().copy(this)}copy(w){return this.name=w.name,this.source=w.source,this.mipmaps=w.mipmaps.slice(0),this.mapping=w.mapping,this.channel=w.channel,this.wrapS=w.wrapS,this.wrapT=w.wrapT,this.magFilter=w.magFilter,this.minFilter=w.minFilter,this.anisotropy=w.anisotropy,this.format=w.format,this.internalFormat=w.internalFormat,this.type=w.type,this.offset.copy(w.offset),this.repeat.copy(w.repeat),this.center.copy(w.center),this.rotation=w.rotation,this.matrixAutoUpdate=w.matrixAutoUpdate,this.matrix.copy(w.matrix),this.generateMipmaps=w.generateMipmaps,this.premultiplyAlpha=w.premultiplyAlpha,this.flipY=w.flipY,this.unpackAlignment=w.unpackAlignment,this.colorSpace=w.colorSpace,this.renderTarget=w.renderTarget,this.isRenderTargetTexture=w.isRenderTargetTexture,this.isArrayTexture=w.isArrayTexture,this.userData=JSON.parse(JSON.stringify(w.userData)),this.needsUpdate=!0,this}setValues(w){for(const D in w){const O=w[D];if(O===void 0){warn(`Texture.setValues(): parameter '${D}' has value of undefined.`);continue}const U=this[D];if(U===void 0){warn(`Texture.setValues(): property '${D}' does not exist.`);continue}U&&O&&U.isVector2&&O.isVector2||U&&O&&U.isVector3&&O.isVector3||U&&O&&U.isMatrix3&&O.isMatrix3?U.copy(O):this[D]=O}}toJSON(w){const D=w===void 0||typeof w=="string";if(!D&&w.textures[this.uuid]!==void 0)return w.textures[this.uuid];const O={metadata:{version:4.7,type:"Texture",generator:"Texture.toJSON"},uuid:this.uuid,name:this.name,image:this.source.toJSON(w).uuid,mapping:this.mapping,channel:this.channel,repeat:[this.repeat.x,this.repeat.y],offset:[this.offset.x,this.offset.y],center:[this.center.x,this.center.y],rotation:this.rotation,wrap:[this.wrapS,this.wrapT],format:this.format,internalFormat:this.internalFormat,type:this.type,colorSpace:this.colorSpace,minFilter:this.minFilter,magFilter:this.magFilter,anisotropy:this.anisotropy,flipY:this.flipY,generateMipmaps:this.generateMipmaps,premultiplyAlpha:this.premultiplyAlpha,unpackAlignment:this.unpackAlignment};return Object.keys(this.userData).length>0&&(O.userData=this.userData),D||(w.textures[this.uuid]=O),O}dispose(){this.dispatchEvent({type:"dispose"})}transformUv(w){if(this.mapping!==UVMapping)return w;if(w.applyMatrix3(this.matrix),w.x<0||w.x>1)switch(this.wrapS){case RepeatWrapping:w.x=w.x-Math.floor(w.x);break;case ClampToEdgeWrapping:w.x=w.x<0?0:1;break;case MirroredRepeatWrapping:Math.abs(Math.floor(w.x)%2)===1?w.x=Math.ceil(w.x)-w.x:w.x=w.x-Math.floor(w.x);break}if(w.y<0||w.y>1)switch(this.wrapT){case RepeatWrapping:w.y=w.y-Math.floor(w.y);break;case ClampToEdgeWrapping:w.y=w.y<0?0:1;break;case MirroredRepeatWrapping:Math.abs(Math.floor(w.y)%2)===1?w.y=Math.ceil(w.y)-w.y:w.y=w.y-Math.floor(w.y);break}return this.flipY&&(w.y=1-w.y),w}set needsUpdate(w){w===!0&&(this.version++,this.source.needsUpdate=!0)}set needsPMREMUpdate(w){w===!0&&this.pmremVersion++}};Texture$1.DEFAULT_IMAGE=null;Texture$1.DEFAULT_MAPPING=UVMapping;Texture$1.DEFAULT_ANISOTROPY=1;class Vector4{constructor(w=0,D=0,O=0,U=1){Vector4.prototype.isVector4=!0,this.x=w,this.y=D,this.z=O,this.w=U}get width(){return this.z}set width(w){this.z=w}get height(){return this.w}set height(w){this.w=w}set(w,D,O,U){return this.x=w,this.y=D,this.z=O,this.w=U,this}setScalar(w){return this.x=w,this.y=w,this.z=w,this.w=w,this}setX(w){return this.x=w,this}setY(w){return this.y=w,this}setZ(w){return this.z=w,this}setW(w){return this.w=w,this}setComponent(w,D){switch(w){case 0:this.x=D;break;case 1:this.y=D;break;case 2:this.z=D;break;case 3:this.w=D;break;default:throw new Error("index is out of range: "+w)}return this}getComponent(w){switch(w){case 0:return this.x;case 1:return this.y;case 2:return this.z;case 3:return this.w;default:throw new Error("index is out of range: "+w)}}clone(){return new this.constructor(this.x,this.y,this.z,this.w)}copy(w){return this.x=w.x,this.y=w.y,this.z=w.z,this.w=w.w!==void 0?w.w:1,this}add(w){return this.x+=w.x,this.y+=w.y,this.z+=w.z,this.w+=w.w,this}addScalar(w){return this.x+=w,this.y+=w,this.z+=w,this.w+=w,this}addVectors(w,D){return this.x=w.x+D.x,this.y=w.y+D.y,this.z=w.z+D.z,this.w=w.w+D.w,this}addScaledVector(w,D){return this.x+=w.x*D,this.y+=w.y*D,this.z+=w.z*D,this.w+=w.w*D,this}sub(w){return this.x-=w.x,this.y-=w.y,this.z-=w.z,this.w-=w.w,this}subScalar(w){return this.x-=w,this.y-=w,this.z-=w,this.w-=w,this}subVectors(w,D){return this.x=w.x-D.x,this.y=w.y-D.y,this.z=w.z-D.z,this.w=w.w-D.w,this}multiply(w){return this.x*=w.x,this.y*=w.y,this.z*=w.z,this.w*=w.w,this}multiplyScalar(w){return this.x*=w,this.y*=w,this.z*=w,this.w*=w,this}applyMatrix4(w){const D=this.x,O=this.y,U=this.z,G=this.w,q=w.elements;return this.x=q[0]*D+q[4]*O+q[8]*U+q[12]*G,this.y=q[1]*D+q[5]*O+q[9]*U+q[13]*G,this.z=q[2]*D+q[6]*O+q[10]*U+q[14]*G,this.w=q[3]*D+q[7]*O+q[11]*U+q[15]*G,this}divide(w){return this.x/=w.x,this.y/=w.y,this.z/=w.z,this.w/=w.w,this}divideScalar(w){return this.multiplyScalar(1/w)}setAxisAngleFromQuaternion(w){this.w=2*Math.acos(w.w);const D=Math.sqrt(1-w.w*w.w);return D<1e-4?(this.x=1,this.y=0,this.z=0):(this.x=w.x/D,this.y=w.y/D,this.z=w.z/D),this}setAxisAngleFromRotationMatrix(w){let D,O,U,G;const ee=w.elements,Z=ee[0],ie=ee[4],Y=ee[8],W=ee[1],ne=ee[5],se=ee[9],le=ee[2],ce=ee[6],he=ee[10];if(Math.abs(ie-W)<.01&&Math.abs(Y-le)<.01&&Math.abs(se-ce)<.01){if(Math.abs(ie+W)<.1&&Math.abs(Y+le)<.1&&Math.abs(se+ce)<.1&&Math.abs(Z+ne+he-3)<.1)return this.set(1,0,0,0),this;D=Math.PI;const me=(Z+1)/2,be=(ne+1)/2,ge=(he+1)/2,ve=(ie+W)/4,Se=(Y+le)/4,Me=(se+ce)/4;return me>be&&me>ge?me<.01?(O=0,U=.707106781,G=.707106781):(O=Math.sqrt(me),U=ve/O,G=Se/O):be>ge?be<.01?(O=.707106781,U=0,G=.707106781):(U=Math.sqrt(be),O=ve/U,G=Me/U):ge<.01?(O=.707106781,U=.707106781,G=0):(G=Math.sqrt(ge),O=Se/G,U=Me/G),this.set(O,U,G,D),this}let pe=Math.sqrt((ce-se)*(ce-se)+(Y-le)*(Y-le)+(W-ie)*(W-ie));return Math.abs(pe)<.001&&(pe=1),this.x=(ce-se)/pe,this.y=(Y-le)/pe,this.z=(W-ie)/pe,this.w=Math.acos((Z+ne+he-1)/2),this}setFromMatrixPosition(w){const D=w.elements;return this.x=D[12],this.y=D[13],this.z=D[14],this.w=D[15],this}min(w){return this.x=Math.min(this.x,w.x),this.y=Math.min(this.y,w.y),this.z=Math.min(this.z,w.z),this.w=Math.min(this.w,w.w),this}max(w){return this.x=Math.max(this.x,w.x),this.y=Math.max(this.y,w.y),this.z=Math.max(this.z,w.z),this.w=Math.max(this.w,w.w),this}clamp(w,D){return this.x=clamp$2(this.x,w.x,D.x),this.y=clamp$2(this.y,w.y,D.y),this.z=clamp$2(this.z,w.z,D.z),this.w=clamp$2(this.w,w.w,D.w),this}clampScalar(w,D){return this.x=clamp$2(this.x,w,D),this.y=clamp$2(this.y,w,D),this.z=clamp$2(this.z,w,D),this.w=clamp$2(this.w,w,D),this}clampLength(w,D){const O=this.length();return this.divideScalar(O||1).multiplyScalar(clamp$2(O,w,D))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this.w=Math.floor(this.w),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this.w=Math.ceil(this.w),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this.w=Math.round(this.w),this}roundToZero(){return this.x=Math.trunc(this.x),this.y=Math.trunc(this.y),this.z=Math.trunc(this.z),this.w=Math.trunc(this.w),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this.w=-this.w,this}dot(w){return this.x*w.x+this.y*w.y+this.z*w.z+this.w*w.w}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)+Math.abs(this.w)}normalize(){return this.divideScalar(this.length()||1)}setLength(w){return this.normalize().multiplyScalar(w)}lerp(w,D){return this.x+=(w.x-this.x)*D,this.y+=(w.y-this.y)*D,this.z+=(w.z-this.z)*D,this.w+=(w.w-this.w)*D,this}lerpVectors(w,D,O){return this.x=w.x+(D.x-w.x)*O,this.y=w.y+(D.y-w.y)*O,this.z=w.z+(D.z-w.z)*O,this.w=w.w+(D.w-w.w)*O,this}equals(w){return w.x===this.x&&w.y===this.y&&w.z===this.z&&w.w===this.w}fromArray(w,D=0){return this.x=w[D],this.y=w[D+1],this.z=w[D+2],this.w=w[D+3],this}toArray(w=[],D=0){return w[D]=this.x,w[D+1]=this.y,w[D+2]=this.z,w[D+3]=this.w,w}fromBufferAttribute(w,D){return this.x=w.getX(D),this.y=w.getY(D),this.z=w.getZ(D),this.w=w.getW(D),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this.w=Math.random(),this}*[Symbol.iterator](){yield this.x,yield this.y,yield this.z,yield this.w}}class RenderTarget extends EventDispatcher{constructor(w=1,D=1,O={}){super(),O=Object.assign({generateMipmaps:!1,internalFormat:null,minFilter:LinearFilter,depthBuffer:!0,stencilBuffer:!1,resolveDepthBuffer:!0,resolveStencilBuffer:!0,depthTexture:null,samples:0,count:1,depth:1,multiview:!1},O),this.isRenderTarget=!0,this.width=w,this.height=D,this.depth=O.depth,this.scissor=new Vector4(0,0,w,D),this.scissorTest=!1,this.viewport=new Vector4(0,0,w,D);const U={width:w,height:D,depth:O.depth},G=new Texture$1(U);this.textures=[];const q=O.count;for(let K=0;K<q;K++)this.textures[K]=G.clone(),this.textures[K].isRenderTargetTexture=!0,this.textures[K].renderTarget=this;this._setTextureOptions(O),this.depthBuffer=O.depthBuffer,this.stencilBuffer=O.stencilBuffer,this.resolveDepthBuffer=O.resolveDepthBuffer,this.resolveStencilBuffer=O.resolveStencilBuffer,this._depthTexture=null,this.depthTexture=O.depthTexture,this.samples=O.samples,this.multiview=O.multiview}_setTextureOptions(w={}){const D={minFilter:LinearFilter,generateMipmaps:!1,flipY:!1,internalFormat:null};w.mapping!==void 0&&(D.mapping=w.mapping),w.wrapS!==void 0&&(D.wrapS=w.wrapS),w.wrapT!==void 0&&(D.wrapT=w.wrapT),w.wrapR!==void 0&&(D.wrapR=w.wrapR),w.magFilter!==void 0&&(D.magFilter=w.magFilter),w.minFilter!==void 0&&(D.minFilter=w.minFilter),w.format!==void 0&&(D.format=w.format),w.type!==void 0&&(D.type=w.type),w.anisotropy!==void 0&&(D.anisotropy=w.anisotropy),w.colorSpace!==void 0&&(D.colorSpace=w.colorSpace),w.flipY!==void 0&&(D.flipY=w.flipY),w.generateMipmaps!==void 0&&(D.generateMipmaps=w.generateMipmaps),w.internalFormat!==void 0&&(D.internalFormat=w.internalFormat);for(let O=0;O<this.textures.length;O++)this.textures[O].setValues(D)}get texture(){return this.textures[0]}set texture(w){this.textures[0]=w}set depthTexture(w){this._depthTexture!==null&&(this._depthTexture.renderTarget=null),w!==null&&(w.renderTarget=this),this._depthTexture=w}get depthTexture(){return this._depthTexture}setSize(w,D,O=1){if(this.width!==w||this.height!==D||this.depth!==O){this.width=w,this.height=D,this.depth=O;for(let U=0,G=this.textures.length;U<G;U++)this.textures[U].image.width=w,this.textures[U].image.height=D,this.textures[U].image.depth=O,this.textures[U].isData3DTexture!==!0&&(this.textures[U].isArrayTexture=this.textures[U].image.depth>1);this.dispose()}this.viewport.set(0,0,w,D),this.scissor.set(0,0,w,D)}clone(){return new this.constructor().copy(this)}copy(w){this.width=w.width,this.height=w.height,this.depth=w.depth,this.scissor.copy(w.scissor),this.scissorTest=w.scissorTest,this.viewport.copy(w.viewport),this.textures.length=0;for(let D=0,O=w.textures.length;D<O;D++){this.textures[D]=w.textures[D].clone(),this.textures[D].isRenderTargetTexture=!0,this.textures[D].renderTarget=this;const U=Object.assign({},w.textures[D].image);this.textures[D].source=new Source(U)}return this.depthBuffer=w.depthBuffer,this.stencilBuffer=w.stencilBuffer,this.resolveDepthBuffer=w.resolveDepthBuffer,this.resolveStencilBuffer=w.resolveStencilBuffer,w.depthTexture!==null&&(this.depthTexture=w.depthTexture.clone()),this.samples=w.samples,this}dispose(){this.dispatchEvent({type:"dispose"})}}class WebGLRenderTarget extends RenderTarget{constructor(w=1,D=1,O={}){super(w,D,O),this.isWebGLRenderTarget=!0}}class DataArrayTexture extends Texture$1{constructor(w=null,D=1,O=1,U=1){super(null),this.isDataArrayTexture=!0,this.image={data:w,width:D,height:O,depth:U},this.magFilter=NearestFilter,this.minFilter=NearestFilter,this.wrapR=ClampToEdgeWrapping,this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1,this.layerUpdates=new Set}addLayerUpdate(w){this.layerUpdates.add(w)}clearLayerUpdates(){this.layerUpdates.clear()}}class Data3DTexture extends Texture$1{constructor(w=null,D=1,O=1,U=1){super(null),this.isData3DTexture=!0,this.image={data:w,width:D,height:O,depth:U},this.magFilter=NearestFilter,this.minFilter=NearestFilter,this.wrapR=ClampToEdgeWrapping,this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1}}class Box3{constructor(w=new Vector3(1/0,1/0,1/0),D=new Vector3(-1/0,-1/0,-1/0)){this.isBox3=!0,this.min=w,this.max=D}set(w,D){return this.min.copy(w),this.max.copy(D),this}setFromArray(w){this.makeEmpty();for(let D=0,O=w.length;D<O;D+=3)this.expandByPoint(_vector$b.fromArray(w,D));return this}setFromBufferAttribute(w){this.makeEmpty();for(let D=0,O=w.count;D<O;D++)this.expandByPoint(_vector$b.fromBufferAttribute(w,D));return this}setFromPoints(w){this.makeEmpty();for(let D=0,O=w.length;D<O;D++)this.expandByPoint(w[D]);return this}setFromCenterAndSize(w,D){const O=_vector$b.copy(D).multiplyScalar(.5);return this.min.copy(w).sub(O),this.max.copy(w).add(O),this}setFromObject(w,D=!1){return this.makeEmpty(),this.expandByObject(w,D)}clone(){return new this.constructor().copy(this)}copy(w){return this.min.copy(w.min),this.max.copy(w.max),this}makeEmpty(){return this.min.x=this.min.y=this.min.z=1/0,this.max.x=this.max.y=this.max.z=-1/0,this}isEmpty(){return this.max.x<this.min.x||this.max.y<this.min.y||this.max.z<this.min.z}getCenter(w){return this.isEmpty()?w.set(0,0,0):w.addVectors(this.min,this.max).multiplyScalar(.5)}getSize(w){return this.isEmpty()?w.set(0,0,0):w.subVectors(this.max,this.min)}expandByPoint(w){return this.min.min(w),this.max.max(w),this}expandByVector(w){return this.min.sub(w),this.max.add(w),this}expandByScalar(w){return this.min.addScalar(-w),this.max.addScalar(w),this}expandByObject(w,D=!1){w.updateWorldMatrix(!1,!1);const O=w.geometry;if(O!==void 0){const G=O.getAttribute("position");if(D===!0&&G!==void 0&&w.isInstancedMesh!==!0)for(let q=0,K=G.count;q<K;q++)w.isMesh===!0?w.getVertexPosition(q,_vector$b):_vector$b.fromBufferAttribute(G,q),_vector$b.applyMatrix4(w.matrixWorld),this.expandByPoint(_vector$b);else w.boundingBox!==void 0?(w.boundingBox===null&&w.computeBoundingBox(),_box$4.copy(w.boundingBox)):(O.boundingBox===null&&O.computeBoundingBox(),_box$4.copy(O.boundingBox)),_box$4.applyMatrix4(w.matrixWorld),this.union(_box$4)}const U=w.children;for(let G=0,q=U.length;G<q;G++)this.expandByObject(U[G],D);return this}containsPoint(w){return w.x>=this.min.x&&w.x<=this.max.x&&w.y>=this.min.y&&w.y<=this.max.y&&w.z>=this.min.z&&w.z<=this.max.z}containsBox(w){return this.min.x<=w.min.x&&w.max.x<=this.max.x&&this.min.y<=w.min.y&&w.max.y<=this.max.y&&this.min.z<=w.min.z&&w.max.z<=this.max.z}getParameter(w,D){return D.set((w.x-this.min.x)/(this.max.x-this.min.x),(w.y-this.min.y)/(this.max.y-this.min.y),(w.z-this.min.z)/(this.max.z-this.min.z))}intersectsBox(w){return w.max.x>=this.min.x&&w.min.x<=this.max.x&&w.max.y>=this.min.y&&w.min.y<=this.max.y&&w.max.z>=this.min.z&&w.min.z<=this.max.z}intersectsSphere(w){return this.clampPoint(w.center,_vector$b),_vector$b.distanceToSquared(w.center)<=w.radius*w.radius}intersectsPlane(w){let D,O;return w.normal.x>0?(D=w.normal.x*this.min.x,O=w.normal.x*this.max.x):(D=w.normal.x*this.max.x,O=w.normal.x*this.min.x),w.normal.y>0?(D+=w.normal.y*this.min.y,O+=w.normal.y*this.max.y):(D+=w.normal.y*this.max.y,O+=w.normal.y*this.min.y),w.normal.z>0?(D+=w.normal.z*this.min.z,O+=w.normal.z*this.max.z):(D+=w.normal.z*this.max.z,O+=w.normal.z*this.min.z),D<=-w.constant&&O>=-w.constant}intersectsTriangle(w){if(this.isEmpty())return!1;this.getCenter(_center),_extents.subVectors(this.max,_center),_v0$2.subVectors(w.a,_center),_v1$7.subVectors(w.b,_center),_v2$4.subVectors(w.c,_center),_f0.subVectors(_v1$7,_v0$2),_f1.subVectors(_v2$4,_v1$7),_f2.subVectors(_v0$2,_v2$4);let D=[0,-_f0.z,_f0.y,0,-_f1.z,_f1.y,0,-_f2.z,_f2.y,_f0.z,0,-_f0.x,_f1.z,0,-_f1.x,_f2.z,0,-_f2.x,-_f0.y,_f0.x,0,-_f1.y,_f1.x,0,-_f2.y,_f2.x,0];return!satForAxes(D,_v0$2,_v1$7,_v2$4,_extents)||(D=[1,0,0,0,1,0,0,0,1],!satForAxes(D,_v0$2,_v1$7,_v2$4,_extents))?!1:(_triangleNormal.crossVectors(_f0,_f1),D=[_triangleNormal.x,_triangleNormal.y,_triangleNormal.z],satForAxes(D,_v0$2,_v1$7,_v2$4,_extents))}clampPoint(w,D){return D.copy(w).clamp(this.min,this.max)}distanceToPoint(w){return this.clampPoint(w,_vector$b).distanceTo(w)}getBoundingSphere(w){return this.isEmpty()?w.makeEmpty():(this.getCenter(w.center),w.radius=this.getSize(_vector$b).length()*.5),w}intersect(w){return this.min.max(w.min),this.max.min(w.max),this.isEmpty()&&this.makeEmpty(),this}union(w){return this.min.min(w.min),this.max.max(w.max),this}applyMatrix4(w){return this.isEmpty()?this:(_points[0].set(this.min.x,this.min.y,this.min.z).applyMatrix4(w),_points[1].set(this.min.x,this.min.y,this.max.z).applyMatrix4(w),_points[2].set(this.min.x,this.max.y,this.min.z).applyMatrix4(w),_points[3].set(this.min.x,this.max.y,this.max.z).applyMatrix4(w),_points[4].set(this.max.x,this.min.y,this.min.z).applyMatrix4(w),_points[5].set(this.max.x,this.min.y,this.max.z).applyMatrix4(w),_points[6].set(this.max.x,this.max.y,this.min.z).applyMatrix4(w),_points[7].set(this.max.x,this.max.y,this.max.z).applyMatrix4(w),this.setFromPoints(_points),this)}translate(w){return this.min.add(w),this.max.add(w),this}equals(w){return w.min.equals(this.min)&&w.max.equals(this.max)}toJSON(){return{min:this.min.toArray(),max:this.max.toArray()}}fromJSON(w){return this.min.fromArray(w.min),this.max.fromArray(w.max),this}}const _points=[new Vector3,new Vector3,new Vector3,new Vector3,new Vector3,new Vector3,new Vector3,new Vector3],_vector$b=new Vector3,_box$4=new Box3,_v0$2=new Vector3,_v1$7=new Vector3,_v2$4=new Vector3,_f0=new Vector3,_f1=new Vector3,_f2=new Vector3,_center=new Vector3,_extents=new Vector3,_triangleNormal=new Vector3,_testAxis=new Vector3;function satForAxes(F,w,D,O,U){for(let G=0,q=F.length-3;G<=q;G+=3){_testAxis.fromArray(F,G);const K=U.x*Math.abs(_testAxis.x)+U.y*Math.abs(_testAxis.y)+U.z*Math.abs(_testAxis.z),ee=w.dot(_testAxis),Z=D.dot(_testAxis),ie=O.dot(_testAxis);if(Math.max(-Math.max(ee,Z,ie),Math.min(ee,Z,ie))>K)return!1}return!0}const _box$3=new Box3,_v1$6=new Vector3,_v2$3=new Vector3;class Sphere{constructor(w=new Vector3,D=-1){this.isSphere=!0,this.center=w,this.radius=D}set(w,D){return this.center.copy(w),this.radius=D,this}setFromPoints(w,D){const O=this.center;D!==void 0?O.copy(D):_box$3.setFromPoints(w).getCenter(O);let U=0;for(let G=0,q=w.length;G<q;G++)U=Math.max(U,O.distanceToSquared(w[G]));return this.radius=Math.sqrt(U),this}copy(w){return this.center.copy(w.center),this.radius=w.radius,this}isEmpty(){return this.radius<0}makeEmpty(){return this.center.set(0,0,0),this.radius=-1,this}containsPoint(w){return w.distanceToSquared(this.center)<=this.radius*this.radius}distanceToPoint(w){return w.distanceTo(this.center)-this.radius}intersectsSphere(w){const D=this.radius+w.radius;return w.center.distanceToSquared(this.center)<=D*D}intersectsBox(w){return w.intersectsSphere(this)}intersectsPlane(w){return Math.abs(w.distanceToPoint(this.center))<=this.radius}clampPoint(w,D){const O=this.center.distanceToSquared(w);return D.copy(w),O>this.radius*this.radius&&(D.sub(this.center).normalize(),D.multiplyScalar(this.radius).add(this.center)),D}getBoundingBox(w){return this.isEmpty()?(w.makeEmpty(),w):(w.set(this.center,this.center),w.expandByScalar(this.radius),w)}applyMatrix4(w){return this.center.applyMatrix4(w),this.radius=this.radius*w.getMaxScaleOnAxis(),this}translate(w){return this.center.add(w),this}expandByPoint(w){if(this.isEmpty())return this.center.copy(w),this.radius=0,this;_v1$6.subVectors(w,this.center);const D=_v1$6.lengthSq();if(D>this.radius*this.radius){const O=Math.sqrt(D),U=(O-this.radius)*.5;this.center.addScaledVector(_v1$6,U/O),this.radius+=U}return this}union(w){return w.isEmpty()?this:this.isEmpty()?(this.copy(w),this):(this.center.equals(w.center)===!0?this.radius=Math.max(this.radius,w.radius):(_v2$3.subVectors(w.center,this.center).setLength(w.radius),this.expandByPoint(_v1$6.copy(w.center).add(_v2$3)),this.expandByPoint(_v1$6.copy(w.center).sub(_v2$3))),this)}equals(w){return w.center.equals(this.center)&&w.radius===this.radius}clone(){return new this.constructor().copy(this)}toJSON(){return{radius:this.radius,center:this.center.toArray()}}fromJSON(w){return this.radius=w.radius,this.center.fromArray(w.center),this}}const _vector$a=new Vector3,_segCenter=new Vector3,_segDir=new Vector3,_diff=new Vector3,_edge1=new Vector3,_edge2=new Vector3,_normal$1=new Vector3;class Ray{constructor(w=new Vector3,D=new Vector3(0,0,-1)){this.origin=w,this.direction=D}set(w,D){return this.origin.copy(w),this.direction.copy(D),this}copy(w){return this.origin.copy(w.origin),this.direction.copy(w.direction),this}at(w,D){return D.copy(this.origin).addScaledVector(this.direction,w)}lookAt(w){return this.direction.copy(w).sub(this.origin).normalize(),this}recast(w){return this.origin.copy(this.at(w,_vector$a)),this}closestPointToPoint(w,D){D.subVectors(w,this.origin);const O=D.dot(this.direction);return O<0?D.copy(this.origin):D.copy(this.origin).addScaledVector(this.direction,O)}distanceToPoint(w){return Math.sqrt(this.distanceSqToPoint(w))}distanceSqToPoint(w){const D=_vector$a.subVectors(w,this.origin).dot(this.direction);return D<0?this.origin.distanceToSquared(w):(_vector$a.copy(this.origin).addScaledVector(this.direction,D),_vector$a.distanceToSquared(w))}distanceSqToSegment(w,D,O,U){_segCenter.copy(w).add(D).multiplyScalar(.5),_segDir.copy(D).sub(w).normalize(),_diff.copy(this.origin).sub(_segCenter);const G=w.distanceTo(D)*.5,q=-this.direction.dot(_segDir),K=_diff.dot(this.direction),ee=-_diff.dot(_segDir),Z=_diff.lengthSq(),ie=Math.abs(1-q*q);let Y,W,ne,se;if(ie>0)if(Y=q*ee-K,W=q*K-ee,se=G*ie,Y>=0)if(W>=-se)if(W<=se){const le=1/ie;Y*=le,W*=le,ne=Y*(Y+q*W+2*K)+W*(q*Y+W+2*ee)+Z}else W=G,Y=Math.max(0,-(q*W+K)),ne=-Y*Y+W*(W+2*ee)+Z;else W=-G,Y=Math.max(0,-(q*W+K)),ne=-Y*Y+W*(W+2*ee)+Z;else W<=-se?(Y=Math.max(0,-(-q*G+K)),W=Y>0?-G:Math.min(Math.max(-G,-ee),G),ne=-Y*Y+W*(W+2*ee)+Z):W<=se?(Y=0,W=Math.min(Math.max(-G,-ee),G),ne=W*(W+2*ee)+Z):(Y=Math.max(0,-(q*G+K)),W=Y>0?G:Math.min(Math.max(-G,-ee),G),ne=-Y*Y+W*(W+2*ee)+Z);else W=q>0?-G:G,Y=Math.max(0,-(q*W+K)),ne=-Y*Y+W*(W+2*ee)+Z;return O&&O.copy(this.origin).addScaledVector(this.direction,Y),U&&U.copy(_segCenter).addScaledVector(_segDir,W),ne}intersectSphere(w,D){_vector$a.subVectors(w.center,this.origin);const O=_vector$a.dot(this.direction),U=_vector$a.dot(_vector$a)-O*O,G=w.radius*w.radius;if(U>G)return null;const q=Math.sqrt(G-U),K=O-q,ee=O+q;return ee<0?null:K<0?this.at(ee,D):this.at(K,D)}intersectsSphere(w){return w.radius<0?!1:this.distanceSqToPoint(w.center)<=w.radius*w.radius}distanceToPlane(w){const D=w.normal.dot(this.direction);if(D===0)return w.distanceToPoint(this.origin)===0?0:null;const O=-(this.origin.dot(w.normal)+w.constant)/D;return O>=0?O:null}intersectPlane(w,D){const O=this.distanceToPlane(w);return O===null?null:this.at(O,D)}intersectsPlane(w){const D=w.distanceToPoint(this.origin);return D===0||w.normal.dot(this.direction)*D<0}intersectBox(w,D){let O,U,G,q,K,ee;const Z=1/this.direction.x,ie=1/this.direction.y,Y=1/this.direction.z,W=this.origin;return Z>=0?(O=(w.min.x-W.x)*Z,U=(w.max.x-W.x)*Z):(O=(w.max.x-W.x)*Z,U=(w.min.x-W.x)*Z),ie>=0?(G=(w.min.y-W.y)*ie,q=(w.max.y-W.y)*ie):(G=(w.max.y-W.y)*ie,q=(w.min.y-W.y)*ie),O>q||G>U||((G>O||isNaN(O))&&(O=G),(q<U||isNaN(U))&&(U=q),Y>=0?(K=(w.min.z-W.z)*Y,ee=(w.max.z-W.z)*Y):(K=(w.max.z-W.z)*Y,ee=(w.min.z-W.z)*Y),O>ee||K>U)||((K>O||O!==O)&&(O=K),(ee<U||U!==U)&&(U=ee),U<0)?null:this.at(O>=0?O:U,D)}intersectsBox(w){return this.intersectBox(w,_vector$a)!==null}intersectTriangle(w,D,O,U,G){_edge1.subVectors(D,w),_edge2.subVectors(O,w),_normal$1.crossVectors(_edge1,_edge2);let q=this.direction.dot(_normal$1),K;if(q>0){if(U)return null;K=1}else if(q<0)K=-1,q=-q;else return null;_diff.subVectors(this.origin,w);const ee=K*this.direction.dot(_edge2.crossVectors(_diff,_edge2));if(ee<0)return null;const Z=K*this.direction.dot(_edge1.cross(_diff));if(Z<0||ee+Z>q)return null;const ie=-K*_diff.dot(_normal$1);return ie<0?null:this.at(ie/q,G)}applyMatrix4(w){return this.origin.applyMatrix4(w),this.direction.transformDirection(w),this}equals(w){return w.origin.equals(this.origin)&&w.direction.equals(this.direction)}clone(){return new this.constructor().copy(this)}}class Matrix4{constructor(w,D,O,U,G,q,K,ee,Z,ie,Y,W,ne,se,le,ce){Matrix4.prototype.isMatrix4=!0,this.elements=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1],w!==void 0&&this.set(w,D,O,U,G,q,K,ee,Z,ie,Y,W,ne,se,le,ce)}set(w,D,O,U,G,q,K,ee,Z,ie,Y,W,ne,se,le,ce){const he=this.elements;return he[0]=w,he[4]=D,he[8]=O,he[12]=U,he[1]=G,he[5]=q,he[9]=K,he[13]=ee,he[2]=Z,he[6]=ie,he[10]=Y,he[14]=W,he[3]=ne,he[7]=se,he[11]=le,he[15]=ce,this}identity(){return this.set(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1),this}clone(){return new Matrix4().fromArray(this.elements)}copy(w){const D=this.elements,O=w.elements;return D[0]=O[0],D[1]=O[1],D[2]=O[2],D[3]=O[3],D[4]=O[4],D[5]=O[5],D[6]=O[6],D[7]=O[7],D[8]=O[8],D[9]=O[9],D[10]=O[10],D[11]=O[11],D[12]=O[12],D[13]=O[13],D[14]=O[14],D[15]=O[15],this}copyPosition(w){const D=this.elements,O=w.elements;return D[12]=O[12],D[13]=O[13],D[14]=O[14],this}setFromMatrix3(w){const D=w.elements;return this.set(D[0],D[3],D[6],0,D[1],D[4],D[7],0,D[2],D[5],D[8],0,0,0,0,1),this}extractBasis(w,D,O){return w.setFromMatrixColumn(this,0),D.setFromMatrixColumn(this,1),O.setFromMatrixColumn(this,2),this}makeBasis(w,D,O){return this.set(w.x,D.x,O.x,0,w.y,D.y,O.y,0,w.z,D.z,O.z,0,0,0,0,1),this}extractRotation(w){const D=this.elements,O=w.elements,U=1/_v1$5.setFromMatrixColumn(w,0).length(),G=1/_v1$5.setFromMatrixColumn(w,1).length(),q=1/_v1$5.setFromMatrixColumn(w,2).length();return D[0]=O[0]*U,D[1]=O[1]*U,D[2]=O[2]*U,D[3]=0,D[4]=O[4]*G,D[5]=O[5]*G,D[6]=O[6]*G,D[7]=0,D[8]=O[8]*q,D[9]=O[9]*q,D[10]=O[10]*q,D[11]=0,D[12]=0,D[13]=0,D[14]=0,D[15]=1,this}makeRotationFromEuler(w){const D=this.elements,O=w.x,U=w.y,G=w.z,q=Math.cos(O),K=Math.sin(O),ee=Math.cos(U),Z=Math.sin(U),ie=Math.cos(G),Y=Math.sin(G);if(w.order==="XYZ"){const W=q*ie,ne=q*Y,se=K*ie,le=K*Y;D[0]=ee*ie,D[4]=-ee*Y,D[8]=Z,D[1]=ne+se*Z,D[5]=W-le*Z,D[9]=-K*ee,D[2]=le-W*Z,D[6]=se+ne*Z,D[10]=q*ee}else if(w.order==="YXZ"){const W=ee*ie,ne=ee*Y,se=Z*ie,le=Z*Y;D[0]=W+le*K,D[4]=se*K-ne,D[8]=q*Z,D[1]=q*Y,D[5]=q*ie,D[9]=-K,D[2]=ne*K-se,D[6]=le+W*K,D[10]=q*ee}else if(w.order==="ZXY"){const W=ee*ie,ne=ee*Y,se=Z*ie,le=Z*Y;D[0]=W-le*K,D[4]=-q*Y,D[8]=se+ne*K,D[1]=ne+se*K,D[5]=q*ie,D[9]=le-W*K,D[2]=-q*Z,D[6]=K,D[10]=q*ee}else if(w.order==="ZYX"){const W=q*ie,ne=q*Y,se=K*ie,le=K*Y;D[0]=ee*ie,D[4]=se*Z-ne,D[8]=W*Z+le,D[1]=ee*Y,D[5]=le*Z+W,D[9]=ne*Z-se,D[2]=-Z,D[6]=K*ee,D[10]=q*ee}else if(w.order==="YZX"){const W=q*ee,ne=q*Z,se=K*ee,le=K*Z;D[0]=ee*ie,D[4]=le-W*Y,D[8]=se*Y+ne,D[1]=Y,D[5]=q*ie,D[9]=-K*ie,D[2]=-Z*ie,D[6]=ne*Y+se,D[10]=W-le*Y}else if(w.order==="XZY"){const W=q*ee,ne=q*Z,se=K*ee,le=K*Z;D[0]=ee*ie,D[4]=-Y,D[8]=Z*ie,D[1]=W*Y+le,D[5]=q*ie,D[9]=ne*Y-se,D[2]=se*Y-ne,D[6]=K*ie,D[10]=le*Y+W}return D[3]=0,D[7]=0,D[11]=0,D[12]=0,D[13]=0,D[14]=0,D[15]=1,this}makeRotationFromQuaternion(w){return this.compose(_zero,w,_one)}lookAt(w,D,O){const U=this.elements;return _z.subVectors(w,D),_z.lengthSq()===0&&(_z.z=1),_z.normalize(),_x.crossVectors(O,_z),_x.lengthSq()===0&&(Math.abs(O.z)===1?_z.x+=1e-4:_z.z+=1e-4,_z.normalize(),_x.crossVectors(O,_z)),_x.normalize(),_y.crossVectors(_z,_x),U[0]=_x.x,U[4]=_y.x,U[8]=_z.x,U[1]=_x.y,U[5]=_y.y,U[9]=_z.y,U[2]=_x.z,U[6]=_y.z,U[10]=_z.z,this}multiply(w){return this.multiplyMatrices(this,w)}premultiply(w){return this.multiplyMatrices(w,this)}multiplyMatrices(w,D){const O=w.elements,U=D.elements,G=this.elements,q=O[0],K=O[4],ee=O[8],Z=O[12],ie=O[1],Y=O[5],W=O[9],ne=O[13],se=O[2],le=O[6],ce=O[10],he=O[14],pe=O[3],me=O[7],be=O[11],ge=O[15],ve=U[0],Se=U[4],Me=U[8],Ee=U[12],we=U[1],Re=U[5],Le=U[9],Ne=U[13],Oe=U[2],Pe=U[6],Ce=U[10],Be=U[14],ze=U[3],Xe=U[7],lt=U[11],ke=U[15];return G[0]=q*ve+K*we+ee*Oe+Z*ze,G[4]=q*Se+K*Re+ee*Pe+Z*Xe,G[8]=q*Me+K*Le+ee*Ce+Z*lt,G[12]=q*Ee+K*Ne+ee*Be+Z*ke,G[1]=ie*ve+Y*we+W*Oe+ne*ze,G[5]=ie*Se+Y*Re+W*Pe+ne*Xe,G[9]=ie*Me+Y*Le+W*Ce+ne*lt,G[13]=ie*Ee+Y*Ne+W*Be+ne*ke,G[2]=se*ve+le*we+ce*Oe+he*ze,G[6]=se*Se+le*Re+ce*Pe+he*Xe,G[10]=se*Me+le*Le+ce*Ce+he*lt,G[14]=se*Ee+le*Ne+ce*Be+he*ke,G[3]=pe*ve+me*we+be*Oe+ge*ze,G[7]=pe*Se+me*Re+be*Pe+ge*Xe,G[11]=pe*Me+me*Le+be*Ce+ge*lt,G[15]=pe*Ee+me*Ne+be*Be+ge*ke,this}multiplyScalar(w){const D=this.elements;return D[0]*=w,D[4]*=w,D[8]*=w,D[12]*=w,D[1]*=w,D[5]*=w,D[9]*=w,D[13]*=w,D[2]*=w,D[6]*=w,D[10]*=w,D[14]*=w,D[3]*=w,D[7]*=w,D[11]*=w,D[15]*=w,this}determinant(){const w=this.elements,D=w[0],O=w[4],U=w[8],G=w[12],q=w[1],K=w[5],ee=w[9],Z=w[13],ie=w[2],Y=w[6],W=w[10],ne=w[14],se=w[3],le=w[7],ce=w[11],he=w[15];return se*(+G*ee*Y-U*Z*Y-G*K*W+O*Z*W+U*K*ne-O*ee*ne)+le*(+D*ee*ne-D*Z*W+G*q*W-U*q*ne+U*Z*ie-G*ee*ie)+ce*(+D*Z*Y-D*K*ne-G*q*Y+O*q*ne+G*K*ie-O*Z*ie)+he*(-U*K*ie-D*ee*Y+D*K*W+U*q*Y-O*q*W+O*ee*ie)}transpose(){const w=this.elements;let D;return D=w[1],w[1]=w[4],w[4]=D,D=w[2],w[2]=w[8],w[8]=D,D=w[6],w[6]=w[9],w[9]=D,D=w[3],w[3]=w[12],w[12]=D,D=w[7],w[7]=w[13],w[13]=D,D=w[11],w[11]=w[14],w[14]=D,this}setPosition(w,D,O){const U=this.elements;return w.isVector3?(U[12]=w.x,U[13]=w.y,U[14]=w.z):(U[12]=w,U[13]=D,U[14]=O),this}invert(){const w=this.elements,D=w[0],O=w[1],U=w[2],G=w[3],q=w[4],K=w[5],ee=w[6],Z=w[7],ie=w[8],Y=w[9],W=w[10],ne=w[11],se=w[12],le=w[13],ce=w[14],he=w[15],pe=Y*ce*Z-le*W*Z+le*ee*ne-K*ce*ne-Y*ee*he+K*W*he,me=se*W*Z-ie*ce*Z-se*ee*ne+q*ce*ne+ie*ee*he-q*W*he,be=ie*le*Z-se*Y*Z+se*K*ne-q*le*ne-ie*K*he+q*Y*he,ge=se*Y*ee-ie*le*ee-se*K*W+q*le*W+ie*K*ce-q*Y*ce,ve=D*pe+O*me+U*be+G*ge;if(ve===0)return this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);const Se=1/ve;return w[0]=pe*Se,w[1]=(le*W*G-Y*ce*G-le*U*ne+O*ce*ne+Y*U*he-O*W*he)*Se,w[2]=(K*ce*G-le*ee*G+le*U*Z-O*ce*Z-K*U*he+O*ee*he)*Se,w[3]=(Y*ee*G-K*W*G-Y*U*Z+O*W*Z+K*U*ne-O*ee*ne)*Se,w[4]=me*Se,w[5]=(ie*ce*G-se*W*G+se*U*ne-D*ce*ne-ie*U*he+D*W*he)*Se,w[6]=(se*ee*G-q*ce*G-se*U*Z+D*ce*Z+q*U*he-D*ee*he)*Se,w[7]=(q*W*G-ie*ee*G+ie*U*Z-D*W*Z-q*U*ne+D*ee*ne)*Se,w[8]=be*Se,w[9]=(se*Y*G-ie*le*G-se*O*ne+D*le*ne+ie*O*he-D*Y*he)*Se,w[10]=(q*le*G-se*K*G+se*O*Z-D*le*Z-q*O*he+D*K*he)*Se,w[11]=(ie*K*G-q*Y*G-ie*O*Z+D*Y*Z+q*O*ne-D*K*ne)*Se,w[12]=ge*Se,w[13]=(ie*le*U-se*Y*U+se*O*W-D*le*W-ie*O*ce+D*Y*ce)*Se,w[14]=(se*K*U-q*le*U-se*O*ee+D*le*ee+q*O*ce-D*K*ce)*Se,w[15]=(q*Y*U-ie*K*U+ie*O*ee-D*Y*ee-q*O*W+D*K*W)*Se,this}scale(w){const D=this.elements,O=w.x,U=w.y,G=w.z;return D[0]*=O,D[4]*=U,D[8]*=G,D[1]*=O,D[5]*=U,D[9]*=G,D[2]*=O,D[6]*=U,D[10]*=G,D[3]*=O,D[7]*=U,D[11]*=G,this}getMaxScaleOnAxis(){const w=this.elements,D=w[0]*w[0]+w[1]*w[1]+w[2]*w[2],O=w[4]*w[4]+w[5]*w[5]+w[6]*w[6],U=w[8]*w[8]+w[9]*w[9]+w[10]*w[10];return Math.sqrt(Math.max(D,O,U))}makeTranslation(w,D,O){return w.isVector3?this.set(1,0,0,w.x,0,1,0,w.y,0,0,1,w.z,0,0,0,1):this.set(1,0,0,w,0,1,0,D,0,0,1,O,0,0,0,1),this}makeRotationX(w){const D=Math.cos(w),O=Math.sin(w);return this.set(1,0,0,0,0,D,-O,0,0,O,D,0,0,0,0,1),this}makeRotationY(w){const D=Math.cos(w),O=Math.sin(w);return this.set(D,0,O,0,0,1,0,0,-O,0,D,0,0,0,0,1),this}makeRotationZ(w){const D=Math.cos(w),O=Math.sin(w);return this.set(D,-O,0,0,O,D,0,0,0,0,1,0,0,0,0,1),this}makeRotationAxis(w,D){const O=Math.cos(D),U=Math.sin(D),G=1-O,q=w.x,K=w.y,ee=w.z,Z=G*q,ie=G*K;return this.set(Z*q+O,Z*K-U*ee,Z*ee+U*K,0,Z*K+U*ee,ie*K+O,ie*ee-U*q,0,Z*ee-U*K,ie*ee+U*q,G*ee*ee+O,0,0,0,0,1),this}makeScale(w,D,O){return this.set(w,0,0,0,0,D,0,0,0,0,O,0,0,0,0,1),this}makeShear(w,D,O,U,G,q){return this.set(1,O,G,0,w,1,q,0,D,U,1,0,0,0,0,1),this}compose(w,D,O){const U=this.elements,G=D._x,q=D._y,K=D._z,ee=D._w,Z=G+G,ie=q+q,Y=K+K,W=G*Z,ne=G*ie,se=G*Y,le=q*ie,ce=q*Y,he=K*Y,pe=ee*Z,me=ee*ie,be=ee*Y,ge=O.x,ve=O.y,Se=O.z;return U[0]=(1-(le+he))*ge,U[1]=(ne+be)*ge,U[2]=(se-me)*ge,U[3]=0,U[4]=(ne-be)*ve,U[5]=(1-(W+he))*ve,U[6]=(ce+pe)*ve,U[7]=0,U[8]=(se+me)*Se,U[9]=(ce-pe)*Se,U[10]=(1-(W+le))*Se,U[11]=0,U[12]=w.x,U[13]=w.y,U[14]=w.z,U[15]=1,this}decompose(w,D,O){const U=this.elements;let G=_v1$5.set(U[0],U[1],U[2]).length();const q=_v1$5.set(U[4],U[5],U[6]).length(),K=_v1$5.set(U[8],U[9],U[10]).length();this.determinant()<0&&(G=-G),w.x=U[12],w.y=U[13],w.z=U[14],_m1$2.copy(this);const Z=1/G,ie=1/q,Y=1/K;return _m1$2.elements[0]*=Z,_m1$2.elements[1]*=Z,_m1$2.elements[2]*=Z,_m1$2.elements[4]*=ie,_m1$2.elements[5]*=ie,_m1$2.elements[6]*=ie,_m1$2.elements[8]*=Y,_m1$2.elements[9]*=Y,_m1$2.elements[10]*=Y,D.setFromRotationMatrix(_m1$2),O.x=G,O.y=q,O.z=K,this}makePerspective(w,D,O,U,G,q,K=WebGLCoordinateSystem,ee=!1){const Z=this.elements,ie=2*G/(D-w),Y=2*G/(O-U),W=(D+w)/(D-w),ne=(O+U)/(O-U);let se,le;if(ee)se=G/(q-G),le=q*G/(q-G);else if(K===WebGLCoordinateSystem)se=-(q+G)/(q-G),le=-2*q*G/(q-G);else if(K===WebGPUCoordinateSystem)se=-q/(q-G),le=-q*G/(q-G);else throw new Error("THREE.Matrix4.makePerspective(): Invalid coordinate system: "+K);return Z[0]=ie,Z[4]=0,Z[8]=W,Z[12]=0,Z[1]=0,Z[5]=Y,Z[9]=ne,Z[13]=0,Z[2]=0,Z[6]=0,Z[10]=se,Z[14]=le,Z[3]=0,Z[7]=0,Z[11]=-1,Z[15]=0,this}makeOrthographic(w,D,O,U,G,q,K=WebGLCoordinateSystem,ee=!1){const Z=this.elements,ie=2/(D-w),Y=2/(O-U),W=-(D+w)/(D-w),ne=-(O+U)/(O-U);let se,le;if(ee)se=1/(q-G),le=q/(q-G);else if(K===WebGLCoordinateSystem)se=-2/(q-G),le=-(q+G)/(q-G);else if(K===WebGPUCoordinateSystem)se=-1/(q-G),le=-G/(q-G);else throw new Error("THREE.Matrix4.makeOrthographic(): Invalid coordinate system: "+K);return Z[0]=ie,Z[4]=0,Z[8]=0,Z[12]=W,Z[1]=0,Z[5]=Y,Z[9]=0,Z[13]=ne,Z[2]=0,Z[6]=0,Z[10]=se,Z[14]=le,Z[3]=0,Z[7]=0,Z[11]=0,Z[15]=1,this}equals(w){const D=this.elements,O=w.elements;for(let U=0;U<16;U++)if(D[U]!==O[U])return!1;return!0}fromArray(w,D=0){for(let O=0;O<16;O++)this.elements[O]=w[O+D];return this}toArray(w=[],D=0){const O=this.elements;return w[D]=O[0],w[D+1]=O[1],w[D+2]=O[2],w[D+3]=O[3],w[D+4]=O[4],w[D+5]=O[5],w[D+6]=O[6],w[D+7]=O[7],w[D+8]=O[8],w[D+9]=O[9],w[D+10]=O[10],w[D+11]=O[11],w[D+12]=O[12],w[D+13]=O[13],w[D+14]=O[14],w[D+15]=O[15],w}}const _v1$5=new Vector3,_m1$2=new Matrix4,_zero=new Vector3(0,0,0),_one=new Vector3(1,1,1),_x=new Vector3,_y=new Vector3,_z=new Vector3,_matrix$2=new Matrix4,_quaternion$3=new Quaternion;class Euler{constructor(w=0,D=0,O=0,U=Euler.DEFAULT_ORDER){this.isEuler=!0,this._x=w,this._y=D,this._z=O,this._order=U}get x(){return this._x}set x(w){this._x=w,this._onChangeCallback()}get y(){return this._y}set y(w){this._y=w,this._onChangeCallback()}get z(){return this._z}set z(w){this._z=w,this._onChangeCallback()}get order(){return this._order}set order(w){this._order=w,this._onChangeCallback()}set(w,D,O,U=this._order){return this._x=w,this._y=D,this._z=O,this._order=U,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._order)}copy(w){return this._x=w._x,this._y=w._y,this._z=w._z,this._order=w._order,this._onChangeCallback(),this}setFromRotationMatrix(w,D=this._order,O=!0){const U=w.elements,G=U[0],q=U[4],K=U[8],ee=U[1],Z=U[5],ie=U[9],Y=U[2],W=U[6],ne=U[10];switch(D){case"XYZ":this._y=Math.asin(clamp$2(K,-1,1)),Math.abs(K)<.9999999?(this._x=Math.atan2(-ie,ne),this._z=Math.atan2(-q,G)):(this._x=Math.atan2(W,Z),this._z=0);break;case"YXZ":this._x=Math.asin(-clamp$2(ie,-1,1)),Math.abs(ie)<.9999999?(this._y=Math.atan2(K,ne),this._z=Math.atan2(ee,Z)):(this._y=Math.atan2(-Y,G),this._z=0);break;case"ZXY":this._x=Math.asin(clamp$2(W,-1,1)),Math.abs(W)<.9999999?(this._y=Math.atan2(-Y,ne),this._z=Math.atan2(-q,Z)):(this._y=0,this._z=Math.atan2(ee,G));break;case"ZYX":this._y=Math.asin(-clamp$2(Y,-1,1)),Math.abs(Y)<.9999999?(this._x=Math.atan2(W,ne),this._z=Math.atan2(ee,G)):(this._x=0,this._z=Math.atan2(-q,Z));break;case"YZX":this._z=Math.asin(clamp$2(ee,-1,1)),Math.abs(ee)<.9999999?(this._x=Math.atan2(-ie,Z),this._y=Math.atan2(-Y,G)):(this._x=0,this._y=Math.atan2(K,ne));break;case"XZY":this._z=Math.asin(-clamp$2(q,-1,1)),Math.abs(q)<.9999999?(this._x=Math.atan2(W,Z),this._y=Math.atan2(K,G)):(this._x=Math.atan2(-ie,ne),this._y=0);break;default:warn("Euler: .setFromRotationMatrix() encountered an unknown order: "+D)}return this._order=D,O===!0&&this._onChangeCallback(),this}setFromQuaternion(w,D,O){return _matrix$2.makeRotationFromQuaternion(w),this.setFromRotationMatrix(_matrix$2,D,O)}setFromVector3(w,D=this._order){return this.set(w.x,w.y,w.z,D)}reorder(w){return _quaternion$3.setFromEuler(this),this.setFromQuaternion(_quaternion$3,w)}equals(w){return w._x===this._x&&w._y===this._y&&w._z===this._z&&w._order===this._order}fromArray(w){return this._x=w[0],this._y=w[1],this._z=w[2],w[3]!==void 0&&(this._order=w[3]),this._onChangeCallback(),this}toArray(w=[],D=0){return w[D]=this._x,w[D+1]=this._y,w[D+2]=this._z,w[D+3]=this._order,w}_onChange(w){return this._onChangeCallback=w,this}_onChangeCallback(){}*[Symbol.iterator](){yield this._x,yield this._y,yield this._z,yield this._order}}Euler.DEFAULT_ORDER="XYZ";class Layers{constructor(){this.mask=1}set(w){this.mask=(1<<w|0)>>>0}enable(w){this.mask|=1<<w|0}enableAll(){this.mask=-1}toggle(w){this.mask^=1<<w|0}disable(w){this.mask&=~(1<<w|0)}disableAll(){this.mask=0}test(w){return(this.mask&w.mask)!==0}isEnabled(w){return(this.mask&(1<<w|0))!==0}}let _object3DId=0;const _v1$4=new Vector3,_q1=new Quaternion,_m1$1$1=new Matrix4,_target=new Vector3,_position$3=new Vector3,_scale$2=new Vector3,_quaternion$2=new Quaternion,_xAxis=new Vector3(1,0,0),_yAxis=new Vector3(0,1,0),_zAxis=new Vector3(0,0,1),_addedEvent={type:"added"},_removedEvent={type:"removed"},_childaddedEvent={type:"childadded",child:null},_childremovedEvent={type:"childremoved",child:null};class Object3D extends EventDispatcher{constructor(){super(),this.isObject3D=!0,Object.defineProperty(this,"id",{value:_object3DId++}),this.uuid=generateUUID(),this.name="",this.type="Object3D",this.parent=null,this.children=[],this.up=Object3D.DEFAULT_UP.clone();const w=new Vector3,D=new Euler,O=new Quaternion,U=new Vector3(1,1,1);function G(){O.setFromEuler(D,!1)}function q(){D.setFromQuaternion(O,void 0,!1)}D._onChange(G),O._onChange(q),Object.defineProperties(this,{position:{configurable:!0,enumerable:!0,value:w},rotation:{configurable:!0,enumerable:!0,value:D},quaternion:{configurable:!0,enumerable:!0,value:O},scale:{configurable:!0,enumerable:!0,value:U},modelViewMatrix:{value:new Matrix4},normalMatrix:{value:new Matrix3}}),this.matrix=new Matrix4,this.matrixWorld=new Matrix4,this.matrixAutoUpdate=Object3D.DEFAULT_MATRIX_AUTO_UPDATE,this.matrixWorldAutoUpdate=Object3D.DEFAULT_MATRIX_WORLD_AUTO_UPDATE,this.matrixWorldNeedsUpdate=!1,this.layers=new Layers,this.visible=!0,this.castShadow=!1,this.receiveShadow=!1,this.frustumCulled=!0,this.renderOrder=0,this.animations=[],this.customDepthMaterial=void 0,this.customDistanceMaterial=void 0,this.userData={}}onBeforeShadow(){}onAfterShadow(){}onBeforeRender(){}onAfterRender(){}applyMatrix4(w){this.matrixAutoUpdate&&this.updateMatrix(),this.matrix.premultiply(w),this.matrix.decompose(this.position,this.quaternion,this.scale)}applyQuaternion(w){return this.quaternion.premultiply(w),this}setRotationFromAxisAngle(w,D){this.quaternion.setFromAxisAngle(w,D)}setRotationFromEuler(w){this.quaternion.setFromEuler(w,!0)}setRotationFromMatrix(w){this.quaternion.setFromRotationMatrix(w)}setRotationFromQuaternion(w){this.quaternion.copy(w)}rotateOnAxis(w,D){return _q1.setFromAxisAngle(w,D),this.quaternion.multiply(_q1),this}rotateOnWorldAxis(w,D){return _q1.setFromAxisAngle(w,D),this.quaternion.premultiply(_q1),this}rotateX(w){return this.rotateOnAxis(_xAxis,w)}rotateY(w){return this.rotateOnAxis(_yAxis,w)}rotateZ(w){return this.rotateOnAxis(_zAxis,w)}translateOnAxis(w,D){return _v1$4.copy(w).applyQuaternion(this.quaternion),this.position.add(_v1$4.multiplyScalar(D)),this}translateX(w){return this.translateOnAxis(_xAxis,w)}translateY(w){return this.translateOnAxis(_yAxis,w)}translateZ(w){return this.translateOnAxis(_zAxis,w)}localToWorld(w){return this.updateWorldMatrix(!0,!1),w.applyMatrix4(this.matrixWorld)}worldToLocal(w){return this.updateWorldMatrix(!0,!1),w.applyMatrix4(_m1$1$1.copy(this.matrixWorld).invert())}lookAt(w,D,O){w.isVector3?_target.copy(w):_target.set(w,D,O);const U=this.parent;this.updateWorldMatrix(!0,!1),_position$3.setFromMatrixPosition(this.matrixWorld),this.isCamera||this.isLight?_m1$1$1.lookAt(_position$3,_target,this.up):_m1$1$1.lookAt(_target,_position$3,this.up),this.quaternion.setFromRotationMatrix(_m1$1$1),U&&(_m1$1$1.extractRotation(U.matrixWorld),_q1.setFromRotationMatrix(_m1$1$1),this.quaternion.premultiply(_q1.invert()))}add(w){if(arguments.length>1){for(let D=0;D<arguments.length;D++)this.add(arguments[D]);return this}return w===this?(error("Object3D.add: object can't be added as a child of itself.",w),this):(w&&w.isObject3D?(w.removeFromParent(),w.parent=this,this.children.push(w),w.dispatchEvent(_addedEvent),_childaddedEvent.child=w,this.dispatchEvent(_childaddedEvent),_childaddedEvent.child=null):error("Object3D.add: object not an instance of THREE.Object3D.",w),this)}remove(w){if(arguments.length>1){for(let O=0;O<arguments.length;O++)this.remove(arguments[O]);return this}const D=this.children.indexOf(w);return D!==-1&&(w.parent=null,this.children.splice(D,1),w.dispatchEvent(_removedEvent),_childremovedEvent.child=w,this.dispatchEvent(_childremovedEvent),_childremovedEvent.child=null),this}removeFromParent(){const w=this.parent;return w!==null&&w.remove(this),this}clear(){return this.remove(...this.children)}attach(w){return this.updateWorldMatrix(!0,!1),_m1$1$1.copy(this.matrixWorld).invert(),w.parent!==null&&(w.parent.updateWorldMatrix(!0,!1),_m1$1$1.multiply(w.parent.matrixWorld)),w.applyMatrix4(_m1$1$1),w.removeFromParent(),w.parent=this,this.children.push(w),w.updateWorldMatrix(!1,!0),w.dispatchEvent(_addedEvent),_childaddedEvent.child=w,this.dispatchEvent(_childaddedEvent),_childaddedEvent.child=null,this}getObjectById(w){return this.getObjectByProperty("id",w)}getObjectByName(w){return this.getObjectByProperty("name",w)}getObjectByProperty(w,D){if(this[w]===D)return this;for(let O=0,U=this.children.length;O<U;O++){const q=this.children[O].getObjectByProperty(w,D);if(q!==void 0)return q}}getObjectsByProperty(w,D,O=[]){this[w]===D&&O.push(this);const U=this.children;for(let G=0,q=U.length;G<q;G++)U[G].getObjectsByProperty(w,D,O);return O}getWorldPosition(w){return this.updateWorldMatrix(!0,!1),w.setFromMatrixPosition(this.matrixWorld)}getWorldQuaternion(w){return this.updateWorldMatrix(!0,!1),this.matrixWorld.decompose(_position$3,w,_scale$2),w}getWorldScale(w){return this.updateWorldMatrix(!0,!1),this.matrixWorld.decompose(_position$3,_quaternion$2,w),w}getWorldDirection(w){this.updateWorldMatrix(!0,!1);const D=this.matrixWorld.elements;return w.set(D[8],D[9],D[10]).normalize()}raycast(){}traverse(w){w(this);const D=this.children;for(let O=0,U=D.length;O<U;O++)D[O].traverse(w)}traverseVisible(w){if(this.visible===!1)return;w(this);const D=this.children;for(let O=0,U=D.length;O<U;O++)D[O].traverseVisible(w)}traverseAncestors(w){const D=this.parent;D!==null&&(w(D),D.traverseAncestors(w))}updateMatrix(){this.matrix.compose(this.position,this.quaternion,this.scale),this.matrixWorldNeedsUpdate=!0}updateMatrixWorld(w){this.matrixAutoUpdate&&this.updateMatrix(),(this.matrixWorldNeedsUpdate||w)&&(this.matrixWorldAutoUpdate===!0&&(this.parent===null?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix)),this.matrixWorldNeedsUpdate=!1,w=!0);const D=this.children;for(let O=0,U=D.length;O<U;O++)D[O].updateMatrixWorld(w)}updateWorldMatrix(w,D){const O=this.parent;if(w===!0&&O!==null&&O.updateWorldMatrix(!0,!1),this.matrixAutoUpdate&&this.updateMatrix(),this.matrixWorldAutoUpdate===!0&&(this.parent===null?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix)),D===!0){const U=this.children;for(let G=0,q=U.length;G<q;G++)U[G].updateWorldMatrix(!1,!0)}}toJSON(w){const D=w===void 0||typeof w=="string",O={};D&&(w={geometries:{},materials:{},textures:{},images:{},shapes:{},skeletons:{},animations:{},nodes:{}},O.metadata={version:4.7,type:"Object",generator:"Object3D.toJSON"});const U={};U.uuid=this.uuid,U.type=this.type,this.name!==""&&(U.name=this.name),this.castShadow===!0&&(U.castShadow=!0),this.receiveShadow===!0&&(U.receiveShadow=!0),this.visible===!1&&(U.visible=!1),this.frustumCulled===!1&&(U.frustumCulled=!1),this.renderOrder!==0&&(U.renderOrder=this.renderOrder),Object.keys(this.userData).length>0&&(U.userData=this.userData),U.layers=this.layers.mask,U.matrix=this.matrix.toArray(),U.up=this.up.toArray(),this.matrixAutoUpdate===!1&&(U.matrixAutoUpdate=!1),this.isInstancedMesh&&(U.type="InstancedMesh",U.count=this.count,U.instanceMatrix=this.instanceMatrix.toJSON(),this.instanceColor!==null&&(U.instanceColor=this.instanceColor.toJSON())),this.isBatchedMesh&&(U.type="BatchedMesh",U.perObjectFrustumCulled=this.perObjectFrustumCulled,U.sortObjects=this.sortObjects,U.drawRanges=this._drawRanges,U.reservedRanges=this._reservedRanges,U.geometryInfo=this._geometryInfo.map(K=>({...K,boundingBox:K.boundingBox?K.boundingBox.toJSON():void 0,boundingSphere:K.boundingSphere?K.boundingSphere.toJSON():void 0})),U.instanceInfo=this._instanceInfo.map(K=>({...K})),U.availableInstanceIds=this._availableInstanceIds.slice(),U.availableGeometryIds=this._availableGeometryIds.slice(),U.nextIndexStart=this._nextIndexStart,U.nextVertexStart=this._nextVertexStart,U.geometryCount=this._geometryCount,U.maxInstanceCount=this._maxInstanceCount,U.maxVertexCount=this._maxVertexCount,U.maxIndexCount=this._maxIndexCount,U.geometryInitialized=this._geometryInitialized,U.matricesTexture=this._matricesTexture.toJSON(w),U.indirectTexture=this._indirectTexture.toJSON(w),this._colorsTexture!==null&&(U.colorsTexture=this._colorsTexture.toJSON(w)),this.boundingSphere!==null&&(U.boundingSphere=this.boundingSphere.toJSON()),this.boundingBox!==null&&(U.boundingBox=this.boundingBox.toJSON()));function G(K,ee){return K[ee.uuid]===void 0&&(K[ee.uuid]=ee.toJSON(w)),ee.uuid}if(this.isScene)this.background&&(this.background.isColor?U.background=this.background.toJSON():this.background.isTexture&&(U.background=this.background.toJSON(w).uuid)),this.environment&&this.environment.isTexture&&this.environment.isRenderTargetTexture!==!0&&(U.environment=this.environment.toJSON(w).uuid);else if(this.isMesh||this.isLine||this.isPoints){U.geometry=G(w.geometries,this.geometry);const K=this.geometry.parameters;if(K!==void 0&&K.shapes!==void 0){const ee=K.shapes;if(Array.isArray(ee))for(let Z=0,ie=ee.length;Z<ie;Z++){const Y=ee[Z];G(w.shapes,Y)}else G(w.shapes,ee)}}if(this.isSkinnedMesh&&(U.bindMode=this.bindMode,U.bindMatrix=this.bindMatrix.toArray(),this.skeleton!==void 0&&(G(w.skeletons,this.skeleton),U.skeleton=this.skeleton.uuid)),this.material!==void 0)if(Array.isArray(this.material)){const K=[];for(let ee=0,Z=this.material.length;ee<Z;ee++)K.push(G(w.materials,this.material[ee]));U.material=K}else U.material=G(w.materials,this.material);if(this.children.length>0){U.children=[];for(let K=0;K<this.children.length;K++)U.children.push(this.children[K].toJSON(w).object)}if(this.animations.length>0){U.animations=[];for(let K=0;K<this.animations.length;K++){const ee=this.animations[K];U.animations.push(G(w.animations,ee))}}if(D){const K=q(w.geometries),ee=q(w.materials),Z=q(w.textures),ie=q(w.images),Y=q(w.shapes),W=q(w.skeletons),ne=q(w.animations),se=q(w.nodes);K.length>0&&(O.geometries=K),ee.length>0&&(O.materials=ee),Z.length>0&&(O.textures=Z),ie.length>0&&(O.images=ie),Y.length>0&&(O.shapes=Y),W.length>0&&(O.skeletons=W),ne.length>0&&(O.animations=ne),se.length>0&&(O.nodes=se)}return O.object=U,O;function q(K){const ee=[];for(const Z in K){const ie=K[Z];delete ie.metadata,ee.push(ie)}return ee}}clone(w){return new this.constructor().copy(this,w)}copy(w,D=!0){if(this.name=w.name,this.up.copy(w.up),this.position.copy(w.position),this.rotation.order=w.rotation.order,this.quaternion.copy(w.quaternion),this.scale.copy(w.scale),this.matrix.copy(w.matrix),this.matrixWorld.copy(w.matrixWorld),this.matrixAutoUpdate=w.matrixAutoUpdate,this.matrixWorldAutoUpdate=w.matrixWorldAutoUpdate,this.matrixWorldNeedsUpdate=w.matrixWorldNeedsUpdate,this.layers.mask=w.layers.mask,this.visible=w.visible,this.castShadow=w.castShadow,this.receiveShadow=w.receiveShadow,this.frustumCulled=w.frustumCulled,this.renderOrder=w.renderOrder,this.animations=w.animations.slice(),this.userData=JSON.parse(JSON.stringify(w.userData)),D===!0)for(let O=0;O<w.children.length;O++){const U=w.children[O];this.add(U.clone())}return this}}Object3D.DEFAULT_UP=new Vector3(0,1,0);Object3D.DEFAULT_MATRIX_AUTO_UPDATE=!0;Object3D.DEFAULT_MATRIX_WORLD_AUTO_UPDATE=!0;const _v0$1=new Vector3,_v1$3=new Vector3,_v2$2=new Vector3,_v3$2=new Vector3,_vab=new Vector3,_vac=new Vector3,_vbc=new Vector3,_vap=new Vector3,_vbp=new Vector3,_vcp=new Vector3,_v40=new Vector4,_v41=new Vector4,_v42=new Vector4;class Triangle{constructor(w=new Vector3,D=new Vector3,O=new Vector3){this.a=w,this.b=D,this.c=O}static getNormal(w,D,O,U){U.subVectors(O,D),_v0$1.subVectors(w,D),U.cross(_v0$1);const G=U.lengthSq();return G>0?U.multiplyScalar(1/Math.sqrt(G)):U.set(0,0,0)}static getBarycoord(w,D,O,U,G){_v0$1.subVectors(U,D),_v1$3.subVectors(O,D),_v2$2.subVectors(w,D);const q=_v0$1.dot(_v0$1),K=_v0$1.dot(_v1$3),ee=_v0$1.dot(_v2$2),Z=_v1$3.dot(_v1$3),ie=_v1$3.dot(_v2$2),Y=q*Z-K*K;if(Y===0)return G.set(0,0,0),null;const W=1/Y,ne=(Z*ee-K*ie)*W,se=(q*ie-K*ee)*W;return G.set(1-ne-se,se,ne)}static containsPoint(w,D,O,U){return this.getBarycoord(w,D,O,U,_v3$2)===null?!1:_v3$2.x>=0&&_v3$2.y>=0&&_v3$2.x+_v3$2.y<=1}static getInterpolation(w,D,O,U,G,q,K,ee){return this.getBarycoord(w,D,O,U,_v3$2)===null?(ee.x=0,ee.y=0,"z"in ee&&(ee.z=0),"w"in ee&&(ee.w=0),null):(ee.setScalar(0),ee.addScaledVector(G,_v3$2.x),ee.addScaledVector(q,_v3$2.y),ee.addScaledVector(K,_v3$2.z),ee)}static getInterpolatedAttribute(w,D,O,U,G,q){return _v40.setScalar(0),_v41.setScalar(0),_v42.setScalar(0),_v40.fromBufferAttribute(w,D),_v41.fromBufferAttribute(w,O),_v42.fromBufferAttribute(w,U),q.setScalar(0),q.addScaledVector(_v40,G.x),q.addScaledVector(_v41,G.y),q.addScaledVector(_v42,G.z),q}static isFrontFacing(w,D,O,U){return _v0$1.subVectors(O,D),_v1$3.subVectors(w,D),_v0$1.cross(_v1$3).dot(U)<0}set(w,D,O){return this.a.copy(w),this.b.copy(D),this.c.copy(O),this}setFromPointsAndIndices(w,D,O,U){return this.a.copy(w[D]),this.b.copy(w[O]),this.c.copy(w[U]),this}setFromAttributeAndIndices(w,D,O,U){return this.a.fromBufferAttribute(w,D),this.b.fromBufferAttribute(w,O),this.c.fromBufferAttribute(w,U),this}clone(){return new this.constructor().copy(this)}copy(w){return this.a.copy(w.a),this.b.copy(w.b),this.c.copy(w.c),this}getArea(){return _v0$1.subVectors(this.c,this.b),_v1$3.subVectors(this.a,this.b),_v0$1.cross(_v1$3).length()*.5}getMidpoint(w){return w.addVectors(this.a,this.b).add(this.c).multiplyScalar(1/3)}getNormal(w){return Triangle.getNormal(this.a,this.b,this.c,w)}getPlane(w){return w.setFromCoplanarPoints(this.a,this.b,this.c)}getBarycoord(w,D){return Triangle.getBarycoord(w,this.a,this.b,this.c,D)}getInterpolation(w,D,O,U,G){return Triangle.getInterpolation(w,this.a,this.b,this.c,D,O,U,G)}containsPoint(w){return Triangle.containsPoint(w,this.a,this.b,this.c)}isFrontFacing(w){return Triangle.isFrontFacing(this.a,this.b,this.c,w)}intersectsBox(w){return w.intersectsTriangle(this)}closestPointToPoint(w,D){const O=this.a,U=this.b,G=this.c;let q,K;_vab.subVectors(U,O),_vac.subVectors(G,O),_vap.subVectors(w,O);const ee=_vab.dot(_vap),Z=_vac.dot(_vap);if(ee<=0&&Z<=0)return D.copy(O);_vbp.subVectors(w,U);const ie=_vab.dot(_vbp),Y=_vac.dot(_vbp);if(ie>=0&&Y<=ie)return D.copy(U);const W=ee*Y-ie*Z;if(W<=0&&ee>=0&&ie<=0)return q=ee/(ee-ie),D.copy(O).addScaledVector(_vab,q);_vcp.subVectors(w,G);const ne=_vab.dot(_vcp),se=_vac.dot(_vcp);if(se>=0&&ne<=se)return D.copy(G);const le=ne*Z-ee*se;if(le<=0&&Z>=0&&se<=0)return K=Z/(Z-se),D.copy(O).addScaledVector(_vac,K);const ce=ie*se-ne*Y;if(ce<=0&&Y-ie>=0&&ne-se>=0)return _vbc.subVectors(G,U),K=(Y-ie)/(Y-ie+(ne-se)),D.copy(U).addScaledVector(_vbc,K);const he=1/(ce+le+W);return q=le*he,K=W*he,D.copy(O).addScaledVector(_vab,q).addScaledVector(_vac,K)}equals(w){return w.a.equals(this.a)&&w.b.equals(this.b)&&w.c.equals(this.c)}}const _colorKeywords={aliceblue:15792383,antiquewhite:16444375,aqua:65535,aquamarine:8388564,azure:15794175,beige:16119260,bisque:16770244,black:0,blanchedalmond:16772045,blue:255,blueviolet:9055202,brown:10824234,burlywood:14596231,cadetblue:6266528,chartreuse:8388352,chocolate:13789470,coral:16744272,cornflowerblue:6591981,cornsilk:16775388,crimson:14423100,cyan:65535,darkblue:139,darkcyan:35723,darkgoldenrod:12092939,darkgray:11119017,darkgreen:25600,darkgrey:11119017,darkkhaki:12433259,darkmagenta:9109643,darkolivegreen:5597999,darkorange:16747520,darkorchid:10040012,darkred:9109504,darksalmon:15308410,darkseagreen:9419919,darkslateblue:4734347,darkslategray:3100495,darkslategrey:3100495,darkturquoise:52945,darkviolet:9699539,deeppink:16716947,deepskyblue:49151,dimgray:6908265,dimgrey:6908265,dodgerblue:2003199,firebrick:11674146,floralwhite:16775920,forestgreen:2263842,fuchsia:16711935,gainsboro:14474460,ghostwhite:16316671,gold:16766720,goldenrod:14329120,gray:8421504,green:32768,greenyellow:11403055,grey:8421504,honeydew:15794160,hotpink:16738740,indianred:13458524,indigo:4915330,ivory:16777200,khaki:15787660,lavender:15132410,lavenderblush:16773365,lawngreen:8190976,lemonchiffon:16775885,lightblue:11393254,lightcoral:15761536,lightcyan:14745599,lightgoldenrodyellow:16448210,lightgray:13882323,lightgreen:9498256,lightgrey:13882323,lightpink:16758465,lightsalmon:16752762,lightseagreen:2142890,lightskyblue:8900346,lightslategray:7833753,lightslategrey:7833753,lightsteelblue:11584734,lightyellow:16777184,lime:65280,limegreen:3329330,linen:16445670,magenta:16711935,maroon:8388608,mediumaquamarine:6737322,mediumblue:205,mediumorchid:12211667,mediumpurple:9662683,mediumseagreen:3978097,mediumslateblue:8087790,mediumspringgreen:64154,mediumturquoise:4772300,mediumvioletred:13047173,midnightblue:1644912,mintcream:16121850,mistyrose:16770273,moccasin:16770229,navajowhite:16768685,navy:128,oldlace:16643558,olive:8421376,olivedrab:7048739,orange:16753920,orangered:16729344,orchid:14315734,palegoldenrod:15657130,palegreen:10025880,paleturquoise:11529966,palevioletred:14381203,papayawhip:16773077,peachpuff:16767673,peru:13468991,pink:16761035,plum:14524637,powderblue:11591910,purple:8388736,rebeccapurple:6697881,red:16711680,rosybrown:12357519,royalblue:4286945,saddlebrown:9127187,salmon:16416882,sandybrown:16032864,seagreen:3050327,seashell:16774638,sienna:10506797,silver:12632256,skyblue:8900331,slateblue:6970061,slategray:7372944,slategrey:7372944,snow:16775930,springgreen:65407,steelblue:4620980,tan:13808780,teal:32896,thistle:14204888,tomato:16737095,turquoise:4251856,violet:15631086,wheat:16113331,white:16777215,whitesmoke:16119285,yellow:16776960,yellowgreen:10145074},_hslA={h:0,s:0,l:0},_hslB={h:0,s:0,l:0};function hue2rgb(F,w,D){return D<0&&(D+=1),D>1&&(D-=1),D<1/6?F+(w-F)*6*D:D<1/2?w:D<2/3?F+(w-F)*6*(2/3-D):F}class Color{constructor(w,D,O){return this.isColor=!0,this.r=1,this.g=1,this.b=1,this.set(w,D,O)}set(w,D,O){if(D===void 0&&O===void 0){const U=w;U&&U.isColor?this.copy(U):typeof U=="number"?this.setHex(U):typeof U=="string"&&this.setStyle(U)}else this.setRGB(w,D,O);return this}setScalar(w){return this.r=w,this.g=w,this.b=w,this}setHex(w,D=SRGBColorSpace){return w=Math.floor(w),this.r=(w>>16&255)/255,this.g=(w>>8&255)/255,this.b=(w&255)/255,ColorManagement.colorSpaceToWorking(this,D),this}setRGB(w,D,O,U=ColorManagement.workingColorSpace){return this.r=w,this.g=D,this.b=O,ColorManagement.colorSpaceToWorking(this,U),this}setHSL(w,D,O,U=ColorManagement.workingColorSpace){if(w=euclideanModulo(w,1),D=clamp$2(D,0,1),O=clamp$2(O,0,1),D===0)this.r=this.g=this.b=O;else{const G=O<=.5?O*(1+D):O+D-O*D,q=2*O-G;this.r=hue2rgb(q,G,w+1/3),this.g=hue2rgb(q,G,w),this.b=hue2rgb(q,G,w-1/3)}return ColorManagement.colorSpaceToWorking(this,U),this}setStyle(w,D=SRGBColorSpace){function O(G){G!==void 0&&parseFloat(G)<1&&warn("Color: Alpha component of "+w+" will be ignored.")}let U;if(U=/^(\w+)\(([^\)]*)\)/.exec(w)){let G;const q=U[1],K=U[2];switch(q){case"rgb":case"rgba":if(G=/^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(K))return O(G[4]),this.setRGB(Math.min(255,parseInt(G[1],10))/255,Math.min(255,parseInt(G[2],10))/255,Math.min(255,parseInt(G[3],10))/255,D);if(G=/^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(K))return O(G[4]),this.setRGB(Math.min(100,parseInt(G[1],10))/100,Math.min(100,parseInt(G[2],10))/100,Math.min(100,parseInt(G[3],10))/100,D);break;case"hsl":case"hsla":if(G=/^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(K))return O(G[4]),this.setHSL(parseFloat(G[1])/360,parseFloat(G[2])/100,parseFloat(G[3])/100,D);break;default:warn("Color: Unknown color model "+w)}}else if(U=/^\#([A-Fa-f\d]+)$/.exec(w)){const G=U[1],q=G.length;if(q===3)return this.setRGB(parseInt(G.charAt(0),16)/15,parseInt(G.charAt(1),16)/15,parseInt(G.charAt(2),16)/15,D);if(q===6)return this.setHex(parseInt(G,16),D);warn("Color: Invalid hex color "+w)}else if(w&&w.length>0)return this.setColorName(w,D);return this}setColorName(w,D=SRGBColorSpace){const O=_colorKeywords[w.toLowerCase()];return O!==void 0?this.setHex(O,D):warn("Color: Unknown color "+w),this}clone(){return new this.constructor(this.r,this.g,this.b)}copy(w){return this.r=w.r,this.g=w.g,this.b=w.b,this}copySRGBToLinear(w){return this.r=SRGBToLinear(w.r),this.g=SRGBToLinear(w.g),this.b=SRGBToLinear(w.b),this}copyLinearToSRGB(w){return this.r=LinearToSRGB(w.r),this.g=LinearToSRGB(w.g),this.b=LinearToSRGB(w.b),this}convertSRGBToLinear(){return this.copySRGBToLinear(this),this}convertLinearToSRGB(){return this.copyLinearToSRGB(this),this}getHex(w=SRGBColorSpace){return ColorManagement.workingToColorSpace(_color.copy(this),w),Math.round(clamp$2(_color.r*255,0,255))*65536+Math.round(clamp$2(_color.g*255,0,255))*256+Math.round(clamp$2(_color.b*255,0,255))}getHexString(w=SRGBColorSpace){return("000000"+this.getHex(w).toString(16)).slice(-6)}getHSL(w,D=ColorManagement.workingColorSpace){ColorManagement.workingToColorSpace(_color.copy(this),D);const O=_color.r,U=_color.g,G=_color.b,q=Math.max(O,U,G),K=Math.min(O,U,G);let ee,Z;const ie=(K+q)/2;if(K===q)ee=0,Z=0;else{const Y=q-K;switch(Z=ie<=.5?Y/(q+K):Y/(2-q-K),q){case O:ee=(U-G)/Y+(U<G?6:0);break;case U:ee=(G-O)/Y+2;break;case G:ee=(O-U)/Y+4;break}ee/=6}return w.h=ee,w.s=Z,w.l=ie,w}getRGB(w,D=ColorManagement.workingColorSpace){return ColorManagement.workingToColorSpace(_color.copy(this),D),w.r=_color.r,w.g=_color.g,w.b=_color.b,w}getStyle(w=SRGBColorSpace){ColorManagement.workingToColorSpace(_color.copy(this),w);const D=_color.r,O=_color.g,U=_color.b;return w!==SRGBColorSpace?`color(${w} ${D.toFixed(3)} ${O.toFixed(3)} ${U.toFixed(3)})`:`rgb(${Math.round(D*255)},${Math.round(O*255)},${Math.round(U*255)})`}offsetHSL(w,D,O){return this.getHSL(_hslA),this.setHSL(_hslA.h+w,_hslA.s+D,_hslA.l+O)}add(w){return this.r+=w.r,this.g+=w.g,this.b+=w.b,this}addColors(w,D){return this.r=w.r+D.r,this.g=w.g+D.g,this.b=w.b+D.b,this}addScalar(w){return this.r+=w,this.g+=w,this.b+=w,this}sub(w){return this.r=Math.max(0,this.r-w.r),this.g=Math.max(0,this.g-w.g),this.b=Math.max(0,this.b-w.b),this}multiply(w){return this.r*=w.r,this.g*=w.g,this.b*=w.b,this}multiplyScalar(w){return this.r*=w,this.g*=w,this.b*=w,this}lerp(w,D){return this.r+=(w.r-this.r)*D,this.g+=(w.g-this.g)*D,this.b+=(w.b-this.b)*D,this}lerpColors(w,D,O){return this.r=w.r+(D.r-w.r)*O,this.g=w.g+(D.g-w.g)*O,this.b=w.b+(D.b-w.b)*O,this}lerpHSL(w,D){this.getHSL(_hslA),w.getHSL(_hslB);const O=lerp$1(_hslA.h,_hslB.h,D),U=lerp$1(_hslA.s,_hslB.s,D),G=lerp$1(_hslA.l,_hslB.l,D);return this.setHSL(O,U,G),this}setFromVector3(w){return this.r=w.x,this.g=w.y,this.b=w.z,this}applyMatrix3(w){const D=this.r,O=this.g,U=this.b,G=w.elements;return this.r=G[0]*D+G[3]*O+G[6]*U,this.g=G[1]*D+G[4]*O+G[7]*U,this.b=G[2]*D+G[5]*O+G[8]*U,this}equals(w){return w.r===this.r&&w.g===this.g&&w.b===this.b}fromArray(w,D=0){return this.r=w[D],this.g=w[D+1],this.b=w[D+2],this}toArray(w=[],D=0){return w[D]=this.r,w[D+1]=this.g,w[D+2]=this.b,w}fromBufferAttribute(w,D){return this.r=w.getX(D),this.g=w.getY(D),this.b=w.getZ(D),this}toJSON(){return this.getHex()}*[Symbol.iterator](){yield this.r,yield this.g,yield this.b}}const _color=new Color;Color.NAMES=_colorKeywords;let _materialId=0,Material$1=class extends EventDispatcher{constructor(){super(),this.isMaterial=!0,Object.defineProperty(this,"id",{value:_materialId++}),this.uuid=generateUUID(),this.name="",this.type="Material",this.blending=NormalBlending,this.side=FrontSide,this.vertexColors=!1,this.opacity=1,this.transparent=!1,this.alphaHash=!1,this.blendSrc=SrcAlphaFactor,this.blendDst=OneMinusSrcAlphaFactor,this.blendEquation=AddEquation,this.blendSrcAlpha=null,this.blendDstAlpha=null,this.blendEquationAlpha=null,this.blendColor=new Color(0,0,0),this.blendAlpha=0,this.depthFunc=LessEqualDepth,this.depthTest=!0,this.depthWrite=!0,this.stencilWriteMask=255,this.stencilFunc=AlwaysStencilFunc,this.stencilRef=0,this.stencilFuncMask=255,this.stencilFail=KeepStencilOp,this.stencilZFail=KeepStencilOp,this.stencilZPass=KeepStencilOp,this.stencilWrite=!1,this.clippingPlanes=null,this.clipIntersection=!1,this.clipShadows=!1,this.shadowSide=null,this.colorWrite=!0,this.precision=null,this.polygonOffset=!1,this.polygonOffsetFactor=0,this.polygonOffsetUnits=0,this.dithering=!1,this.alphaToCoverage=!1,this.premultipliedAlpha=!1,this.forceSinglePass=!1,this.allowOverride=!0,this.visible=!0,this.toneMapped=!0,this.userData={},this.version=0,this._alphaTest=0}get alphaTest(){return this._alphaTest}set alphaTest(w){this._alphaTest>0!=w>0&&this.version++,this._alphaTest=w}onBeforeRender(){}onBeforeCompile(){}customProgramCacheKey(){return this.onBeforeCompile.toString()}setValues(w){if(w!==void 0)for(const D in w){const O=w[D];if(O===void 0){warn(`Material: parameter '${D}' has value of undefined.`);continue}const U=this[D];if(U===void 0){warn(`Material: '${D}' is not a property of THREE.${this.type}.`);continue}U&&U.isColor?U.set(O):U&&U.isVector3&&O&&O.isVector3?U.copy(O):this[D]=O}}toJSON(w){const D=w===void 0||typeof w=="string";D&&(w={textures:{},images:{}});const O={metadata:{version:4.7,type:"Material",generator:"Material.toJSON"}};O.uuid=this.uuid,O.type=this.type,this.name!==""&&(O.name=this.name),this.color&&this.color.isColor&&(O.color=this.color.getHex()),this.roughness!==void 0&&(O.roughness=this.roughness),this.metalness!==void 0&&(O.metalness=this.metalness),this.sheen!==void 0&&(O.sheen=this.sheen),this.sheenColor&&this.sheenColor.isColor&&(O.sheenColor=this.sheenColor.getHex()),this.sheenRoughness!==void 0&&(O.sheenRoughness=this.sheenRoughness),this.emissive&&this.emissive.isColor&&(O.emissive=this.emissive.getHex()),this.emissiveIntensity!==void 0&&this.emissiveIntensity!==1&&(O.emissiveIntensity=this.emissiveIntensity),this.specular&&this.specular.isColor&&(O.specular=this.specular.getHex()),this.specularIntensity!==void 0&&(O.specularIntensity=this.specularIntensity),this.specularColor&&this.specularColor.isColor&&(O.specularColor=this.specularColor.getHex()),this.shininess!==void 0&&(O.shininess=this.shininess),this.clearcoat!==void 0&&(O.clearcoat=this.clearcoat),this.clearcoatRoughness!==void 0&&(O.clearcoatRoughness=this.clearcoatRoughness),this.clearcoatMap&&this.clearcoatMap.isTexture&&(O.clearcoatMap=this.clearcoatMap.toJSON(w).uuid),this.clearcoatRoughnessMap&&this.clearcoatRoughnessMap.isTexture&&(O.clearcoatRoughnessMap=this.clearcoatRoughnessMap.toJSON(w).uuid),this.clearcoatNormalMap&&this.clearcoatNormalMap.isTexture&&(O.clearcoatNormalMap=this.clearcoatNormalMap.toJSON(w).uuid,O.clearcoatNormalScale=this.clearcoatNormalScale.toArray()),this.sheenColorMap&&this.sheenColorMap.isTexture&&(O.sheenColorMap=this.sheenColorMap.toJSON(w).uuid),this.sheenRoughnessMap&&this.sheenRoughnessMap.isTexture&&(O.sheenRoughnessMap=this.sheenRoughnessMap.toJSON(w).uuid),this.dispersion!==void 0&&(O.dispersion=this.dispersion),this.iridescence!==void 0&&(O.iridescence=this.iridescence),this.iridescenceIOR!==void 0&&(O.iridescenceIOR=this.iridescenceIOR),this.iridescenceThicknessRange!==void 0&&(O.iridescenceThicknessRange=this.iridescenceThicknessRange),this.iridescenceMap&&this.iridescenceMap.isTexture&&(O.iridescenceMap=this.iridescenceMap.toJSON(w).uuid),this.iridescenceThicknessMap&&this.iridescenceThicknessMap.isTexture&&(O.iridescenceThicknessMap=this.iridescenceThicknessMap.toJSON(w).uuid),this.anisotropy!==void 0&&(O.anisotropy=this.anisotropy),this.anisotropyRotation!==void 0&&(O.anisotropyRotation=this.anisotropyRotation),this.anisotropyMap&&this.anisotropyMap.isTexture&&(O.anisotropyMap=this.anisotropyMap.toJSON(w).uuid),this.map&&this.map.isTexture&&(O.map=this.map.toJSON(w).uuid),this.matcap&&this.matcap.isTexture&&(O.matcap=this.matcap.toJSON(w).uuid),this.alphaMap&&this.alphaMap.isTexture&&(O.alphaMap=this.alphaMap.toJSON(w).uuid),this.lightMap&&this.lightMap.isTexture&&(O.lightMap=this.lightMap.toJSON(w).uuid,O.lightMapIntensity=this.lightMapIntensity),this.aoMap&&this.aoMap.isTexture&&(O.aoMap=this.aoMap.toJSON(w).uuid,O.aoMapIntensity=this.aoMapIntensity),this.bumpMap&&this.bumpMap.isTexture&&(O.bumpMap=this.bumpMap.toJSON(w).uuid,O.bumpScale=this.bumpScale),this.normalMap&&this.normalMap.isTexture&&(O.normalMap=this.normalMap.toJSON(w).uuid,O.normalMapType=this.normalMapType,O.normalScale=this.normalScale.toArray()),this.displacementMap&&this.displacementMap.isTexture&&(O.displacementMap=this.displacementMap.toJSON(w).uuid,O.displacementScale=this.displacementScale,O.displacementBias=this.displacementBias),this.roughnessMap&&this.roughnessMap.isTexture&&(O.roughnessMap=this.roughnessMap.toJSON(w).uuid),this.metalnessMap&&this.metalnessMap.isTexture&&(O.metalnessMap=this.metalnessMap.toJSON(w).uuid),this.emissiveMap&&this.emissiveMap.isTexture&&(O.emissiveMap=this.emissiveMap.toJSON(w).uuid),this.specularMap&&this.specularMap.isTexture&&(O.specularMap=this.specularMap.toJSON(w).uuid),this.specularIntensityMap&&this.specularIntensityMap.isTexture&&(O.specularIntensityMap=this.specularIntensityMap.toJSON(w).uuid),this.specularColorMap&&this.specularColorMap.isTexture&&(O.specularColorMap=this.specularColorMap.toJSON(w).uuid),this.envMap&&this.envMap.isTexture&&(O.envMap=this.envMap.toJSON(w).uuid,this.combine!==void 0&&(O.combine=this.combine)),this.envMapRotation!==void 0&&(O.envMapRotation=this.envMapRotation.toArray()),this.envMapIntensity!==void 0&&(O.envMapIntensity=this.envMapIntensity),this.reflectivity!==void 0&&(O.reflectivity=this.reflectivity),this.refractionRatio!==void 0&&(O.refractionRatio=this.refractionRatio),this.gradientMap&&this.gradientMap.isTexture&&(O.gradientMap=this.gradientMap.toJSON(w).uuid),this.transmission!==void 0&&(O.transmission=this.transmission),this.transmissionMap&&this.transmissionMap.isTexture&&(O.transmissionMap=this.transmissionMap.toJSON(w).uuid),this.thickness!==void 0&&(O.thickness=this.thickness),this.thicknessMap&&this.thicknessMap.isTexture&&(O.thicknessMap=this.thicknessMap.toJSON(w).uuid),this.attenuationDistance!==void 0&&this.attenuationDistance!==1/0&&(O.attenuationDistance=this.attenuationDistance),this.attenuationColor!==void 0&&(O.attenuationColor=this.attenuationColor.getHex()),this.size!==void 0&&(O.size=this.size),this.shadowSide!==null&&(O.shadowSide=this.shadowSide),this.sizeAttenuation!==void 0&&(O.sizeAttenuation=this.sizeAttenuation),this.blending!==NormalBlending&&(O.blending=this.blending),this.side!==FrontSide&&(O.side=this.side),this.vertexColors===!0&&(O.vertexColors=!0),this.opacity<1&&(O.opacity=this.opacity),this.transparent===!0&&(O.transparent=!0),this.blendSrc!==SrcAlphaFactor&&(O.blendSrc=this.blendSrc),this.blendDst!==OneMinusSrcAlphaFactor&&(O.blendDst=this.blendDst),this.blendEquation!==AddEquation&&(O.blendEquation=this.blendEquation),this.blendSrcAlpha!==null&&(O.blendSrcAlpha=this.blendSrcAlpha),this.blendDstAlpha!==null&&(O.blendDstAlpha=this.blendDstAlpha),this.blendEquationAlpha!==null&&(O.blendEquationAlpha=this.blendEquationAlpha),this.blendColor&&this.blendColor.isColor&&(O.blendColor=this.blendColor.getHex()),this.blendAlpha!==0&&(O.blendAlpha=this.blendAlpha),this.depthFunc!==LessEqualDepth&&(O.depthFunc=this.depthFunc),this.depthTest===!1&&(O.depthTest=this.depthTest),this.depthWrite===!1&&(O.depthWrite=this.depthWrite),this.colorWrite===!1&&(O.colorWrite=this.colorWrite),this.stencilWriteMask!==255&&(O.stencilWriteMask=this.stencilWriteMask),this.stencilFunc!==AlwaysStencilFunc&&(O.stencilFunc=this.stencilFunc),this.stencilRef!==0&&(O.stencilRef=this.stencilRef),this.stencilFuncMask!==255&&(O.stencilFuncMask=this.stencilFuncMask),this.stencilFail!==KeepStencilOp&&(O.stencilFail=this.stencilFail),this.stencilZFail!==KeepStencilOp&&(O.stencilZFail=this.stencilZFail),this.stencilZPass!==KeepStencilOp&&(O.stencilZPass=this.stencilZPass),this.stencilWrite===!0&&(O.stencilWrite=this.stencilWrite),this.rotation!==void 0&&this.rotation!==0&&(O.rotation=this.rotation),this.polygonOffset===!0&&(O.polygonOffset=!0),this.polygonOffsetFactor!==0&&(O.polygonOffsetFactor=this.polygonOffsetFactor),this.polygonOffsetUnits!==0&&(O.polygonOffsetUnits=this.polygonOffsetUnits),this.linewidth!==void 0&&this.linewidth!==1&&(O.linewidth=this.linewidth),this.dashSize!==void 0&&(O.dashSize=this.dashSize),this.gapSize!==void 0&&(O.gapSize=this.gapSize),this.scale!==void 0&&(O.scale=this.scale),this.dithering===!0&&(O.dithering=!0),this.alphaTest>0&&(O.alphaTest=this.alphaTest),this.alphaHash===!0&&(O.alphaHash=!0),this.alphaToCoverage===!0&&(O.alphaToCoverage=!0),this.premultipliedAlpha===!0&&(O.premultipliedAlpha=!0),this.forceSinglePass===!0&&(O.forceSinglePass=!0),this.wireframe===!0&&(O.wireframe=!0),this.wireframeLinewidth>1&&(O.wireframeLinewidth=this.wireframeLinewidth),this.wireframeLinecap!=="round"&&(O.wireframeLinecap=this.wireframeLinecap),this.wireframeLinejoin!=="round"&&(O.wireframeLinejoin=this.wireframeLinejoin),this.flatShading===!0&&(O.flatShading=!0),this.visible===!1&&(O.visible=!1),this.toneMapped===!1&&(O.toneMapped=!1),this.fog===!1&&(O.fog=!1),Object.keys(this.userData).length>0&&(O.userData=this.userData);function U(G){const q=[];for(const K in G){const ee=G[K];delete ee.metadata,q.push(ee)}return q}if(D){const G=U(w.textures),q=U(w.images);G.length>0&&(O.textures=G),q.length>0&&(O.images=q)}return O}clone(){return new this.constructor().copy(this)}copy(w){this.name=w.name,this.blending=w.blending,this.side=w.side,this.vertexColors=w.vertexColors,this.opacity=w.opacity,this.transparent=w.transparent,this.blendSrc=w.blendSrc,this.blendDst=w.blendDst,this.blendEquation=w.blendEquation,this.blendSrcAlpha=w.blendSrcAlpha,this.blendDstAlpha=w.blendDstAlpha,this.blendEquationAlpha=w.blendEquationAlpha,this.blendColor.copy(w.blendColor),this.blendAlpha=w.blendAlpha,this.depthFunc=w.depthFunc,this.depthTest=w.depthTest,this.depthWrite=w.depthWrite,this.stencilWriteMask=w.stencilWriteMask,this.stencilFunc=w.stencilFunc,this.stencilRef=w.stencilRef,this.stencilFuncMask=w.stencilFuncMask,this.stencilFail=w.stencilFail,this.stencilZFail=w.stencilZFail,this.stencilZPass=w.stencilZPass,this.stencilWrite=w.stencilWrite;const D=w.clippingPlanes;let O=null;if(D!==null){const U=D.length;O=new Array(U);for(let G=0;G!==U;++G)O[G]=D[G].clone()}return this.clippingPlanes=O,this.clipIntersection=w.clipIntersection,this.clipShadows=w.clipShadows,this.shadowSide=w.shadowSide,this.colorWrite=w.colorWrite,this.precision=w.precision,this.polygonOffset=w.polygonOffset,this.polygonOffsetFactor=w.polygonOffsetFactor,this.polygonOffsetUnits=w.polygonOffsetUnits,this.dithering=w.dithering,this.alphaTest=w.alphaTest,this.alphaHash=w.alphaHash,this.alphaToCoverage=w.alphaToCoverage,this.premultipliedAlpha=w.premultipliedAlpha,this.forceSinglePass=w.forceSinglePass,this.visible=w.visible,this.toneMapped=w.toneMapped,this.userData=JSON.parse(JSON.stringify(w.userData)),this}dispose(){this.dispatchEvent({type:"dispose"})}set needsUpdate(w){w===!0&&this.version++}};class MeshBasicMaterial extends Material$1{constructor(w){super(),this.isMeshBasicMaterial=!0,this.type="MeshBasicMaterial",this.color=new Color(16777215),this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.envMapRotation=new Euler,this.combine=MultiplyOperation,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.fog=!0,this.setValues(w)}copy(w){return super.copy(w),this.color.copy(w.color),this.map=w.map,this.lightMap=w.lightMap,this.lightMapIntensity=w.lightMapIntensity,this.aoMap=w.aoMap,this.aoMapIntensity=w.aoMapIntensity,this.specularMap=w.specularMap,this.alphaMap=w.alphaMap,this.envMap=w.envMap,this.envMapRotation.copy(w.envMapRotation),this.combine=w.combine,this.reflectivity=w.reflectivity,this.refractionRatio=w.refractionRatio,this.wireframe=w.wireframe,this.wireframeLinewidth=w.wireframeLinewidth,this.wireframeLinecap=w.wireframeLinecap,this.wireframeLinejoin=w.wireframeLinejoin,this.fog=w.fog,this}}const _tables=_generateTables();function _generateTables(){const F=new ArrayBuffer(4),w=new Float32Array(F),D=new Uint32Array(F),O=new Uint32Array(512),U=new Uint32Array(512);for(let ee=0;ee<256;++ee){const Z=ee-127;Z<-27?(O[ee]=0,O[ee|256]=32768,U[ee]=24,U[ee|256]=24):Z<-14?(O[ee]=1024>>-Z-14,O[ee|256]=1024>>-Z-14|32768,U[ee]=-Z-1,U[ee|256]=-Z-1):Z<=15?(O[ee]=Z+15<<10,O[ee|256]=Z+15<<10|32768,U[ee]=13,U[ee|256]=13):Z<128?(O[ee]=31744,O[ee|256]=64512,U[ee]=24,U[ee|256]=24):(O[ee]=31744,O[ee|256]=64512,U[ee]=13,U[ee|256]=13)}const G=new Uint32Array(2048),q=new Uint32Array(64),K=new Uint32Array(64);for(let ee=1;ee<1024;++ee){let Z=ee<<13,ie=0;for(;(Z&8388608)===0;)Z<<=1,ie-=8388608;Z&=-8388609,ie+=947912704,G[ee]=Z|ie}for(let ee=1024;ee<2048;++ee)G[ee]=939524096+(ee-1024<<13);for(let ee=1;ee<31;++ee)q[ee]=ee<<23;q[31]=1199570944,q[32]=2147483648;for(let ee=33;ee<63;++ee)q[ee]=2147483648+(ee-32<<23);q[63]=3347054592;for(let ee=1;ee<64;++ee)ee!==32&&(K[ee]=1024);return{floatView:w,uint32View:D,baseTable:O,shiftTable:U,mantissaTable:G,exponentTable:q,offsetTable:K}}function toHalfFloat(F){Math.abs(F)>65504&&warn("DataUtils.toHalfFloat(): Value out of range."),F=clamp$2(F,-65504,65504),_tables.floatView[0]=F;const w=_tables.uint32View[0],D=w>>23&511;return _tables.baseTable[D]+((w&8388607)>>_tables.shiftTable[D])}function fromHalfFloat(F){const w=F>>10;return _tables.uint32View[0]=_tables.mantissaTable[_tables.offsetTable[w]+(F&1023)]+_tables.exponentTable[w],_tables.floatView[0]}class DataUtils{static toHalfFloat(w){return toHalfFloat(w)}static fromHalfFloat(w){return fromHalfFloat(w)}}const _vector$9=new Vector3,_vector2$1=new Vector2;let _id$2=0;class BufferAttribute{constructor(w,D,O=!1){if(Array.isArray(w))throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");this.isBufferAttribute=!0,Object.defineProperty(this,"id",{value:_id$2++}),this.name="",this.array=w,this.itemSize=D,this.count=w!==void 0?w.length/D:0,this.normalized=O,this.usage=StaticDrawUsage,this.updateRanges=[],this.gpuType=FloatType,this.version=0}onUploadCallback(){}set needsUpdate(w){w===!0&&this.version++}setUsage(w){return this.usage=w,this}addUpdateRange(w,D){this.updateRanges.push({start:w,count:D})}clearUpdateRanges(){this.updateRanges.length=0}copy(w){return this.name=w.name,this.array=new w.array.constructor(w.array),this.itemSize=w.itemSize,this.count=w.count,this.normalized=w.normalized,this.usage=w.usage,this.gpuType=w.gpuType,this}copyAt(w,D,O){w*=this.itemSize,O*=D.itemSize;for(let U=0,G=this.itemSize;U<G;U++)this.array[w+U]=D.array[O+U];return this}copyArray(w){return this.array.set(w),this}applyMatrix3(w){if(this.itemSize===2)for(let D=0,O=this.count;D<O;D++)_vector2$1.fromBufferAttribute(this,D),_vector2$1.applyMatrix3(w),this.setXY(D,_vector2$1.x,_vector2$1.y);else if(this.itemSize===3)for(let D=0,O=this.count;D<O;D++)_vector$9.fromBufferAttribute(this,D),_vector$9.applyMatrix3(w),this.setXYZ(D,_vector$9.x,_vector$9.y,_vector$9.z);return this}applyMatrix4(w){for(let D=0,O=this.count;D<O;D++)_vector$9.fromBufferAttribute(this,D),_vector$9.applyMatrix4(w),this.setXYZ(D,_vector$9.x,_vector$9.y,_vector$9.z);return this}applyNormalMatrix(w){for(let D=0,O=this.count;D<O;D++)_vector$9.fromBufferAttribute(this,D),_vector$9.applyNormalMatrix(w),this.setXYZ(D,_vector$9.x,_vector$9.y,_vector$9.z);return this}transformDirection(w){for(let D=0,O=this.count;D<O;D++)_vector$9.fromBufferAttribute(this,D),_vector$9.transformDirection(w),this.setXYZ(D,_vector$9.x,_vector$9.y,_vector$9.z);return this}set(w,D=0){return this.array.set(w,D),this}getComponent(w,D){let O=this.array[w*this.itemSize+D];return this.normalized&&(O=denormalize(O,this.array)),O}setComponent(w,D,O){return this.normalized&&(O=normalize(O,this.array)),this.array[w*this.itemSize+D]=O,this}getX(w){let D=this.array[w*this.itemSize];return this.normalized&&(D=denormalize(D,this.array)),D}setX(w,D){return this.normalized&&(D=normalize(D,this.array)),this.array[w*this.itemSize]=D,this}getY(w){let D=this.array[w*this.itemSize+1];return this.normalized&&(D=denormalize(D,this.array)),D}setY(w,D){return this.normalized&&(D=normalize(D,this.array)),this.array[w*this.itemSize+1]=D,this}getZ(w){let D=this.array[w*this.itemSize+2];return this.normalized&&(D=denormalize(D,this.array)),D}setZ(w,D){return this.normalized&&(D=normalize(D,this.array)),this.array[w*this.itemSize+2]=D,this}getW(w){let D=this.array[w*this.itemSize+3];return this.normalized&&(D=denormalize(D,this.array)),D}setW(w,D){return this.normalized&&(D=normalize(D,this.array)),this.array[w*this.itemSize+3]=D,this}setXY(w,D,O){return w*=this.itemSize,this.normalized&&(D=normalize(D,this.array),O=normalize(O,this.array)),this.array[w+0]=D,this.array[w+1]=O,this}setXYZ(w,D,O,U){return w*=this.itemSize,this.normalized&&(D=normalize(D,this.array),O=normalize(O,this.array),U=normalize(U,this.array)),this.array[w+0]=D,this.array[w+1]=O,this.array[w+2]=U,this}setXYZW(w,D,O,U,G){return w*=this.itemSize,this.normalized&&(D=normalize(D,this.array),O=normalize(O,this.array),U=normalize(U,this.array),G=normalize(G,this.array)),this.array[w+0]=D,this.array[w+1]=O,this.array[w+2]=U,this.array[w+3]=G,this}onUpload(w){return this.onUploadCallback=w,this}clone(){return new this.constructor(this.array,this.itemSize).copy(this)}toJSON(){const w={itemSize:this.itemSize,type:this.array.constructor.name,array:Array.from(this.array),normalized:this.normalized};return this.name!==""&&(w.name=this.name),this.usage!==StaticDrawUsage&&(w.usage=this.usage),w}}class Uint16BufferAttribute extends BufferAttribute{constructor(w,D,O){super(new Uint16Array(w),D,O)}}class Uint32BufferAttribute extends BufferAttribute{constructor(w,D,O){super(new Uint32Array(w),D,O)}}class Float32BufferAttribute extends BufferAttribute{constructor(w,D,O){super(new Float32Array(w),D,O)}}let _id$1=0;const _m1$3=new Matrix4,_obj=new Object3D,_offset=new Vector3,_box$2=new Box3,_boxMorphTargets=new Box3,_vector$8=new Vector3;class BufferGeometry extends EventDispatcher{constructor(){super(),this.isBufferGeometry=!0,Object.defineProperty(this,"id",{value:_id$1++}),this.uuid=generateUUID(),this.name="",this.type="BufferGeometry",this.index=null,this.indirect=null,this.attributes={},this.morphAttributes={},this.morphTargetsRelative=!1,this.groups=[],this.boundingBox=null,this.boundingSphere=null,this.drawRange={start:0,count:1/0},this.userData={}}getIndex(){return this.index}setIndex(w){return Array.isArray(w)?this.index=new(arrayNeedsUint32(w)?Uint32BufferAttribute:Uint16BufferAttribute)(w,1):this.index=w,this}setIndirect(w){return this.indirect=w,this}getIndirect(){return this.indirect}getAttribute(w){return this.attributes[w]}setAttribute(w,D){return this.attributes[w]=D,this}deleteAttribute(w){return delete this.attributes[w],this}hasAttribute(w){return this.attributes[w]!==void 0}addGroup(w,D,O=0){this.groups.push({start:w,count:D,materialIndex:O})}clearGroups(){this.groups=[]}setDrawRange(w,D){this.drawRange.start=w,this.drawRange.count=D}applyMatrix4(w){const D=this.attributes.position;D!==void 0&&(D.applyMatrix4(w),D.needsUpdate=!0);const O=this.attributes.normal;if(O!==void 0){const G=new Matrix3().getNormalMatrix(w);O.applyNormalMatrix(G),O.needsUpdate=!0}const U=this.attributes.tangent;return U!==void 0&&(U.transformDirection(w),U.needsUpdate=!0),this.boundingBox!==null&&this.computeBoundingBox(),this.boundingSphere!==null&&this.computeBoundingSphere(),this}applyQuaternion(w){return _m1$3.makeRotationFromQuaternion(w),this.applyMatrix4(_m1$3),this}rotateX(w){return _m1$3.makeRotationX(w),this.applyMatrix4(_m1$3),this}rotateY(w){return _m1$3.makeRotationY(w),this.applyMatrix4(_m1$3),this}rotateZ(w){return _m1$3.makeRotationZ(w),this.applyMatrix4(_m1$3),this}translate(w,D,O){return _m1$3.makeTranslation(w,D,O),this.applyMatrix4(_m1$3),this}scale(w,D,O){return _m1$3.makeScale(w,D,O),this.applyMatrix4(_m1$3),this}lookAt(w){return _obj.lookAt(w),_obj.updateMatrix(),this.applyMatrix4(_obj.matrix),this}center(){return this.computeBoundingBox(),this.boundingBox.getCenter(_offset).negate(),this.translate(_offset.x,_offset.y,_offset.z),this}setFromPoints(w){const D=this.getAttribute("position");if(D===void 0){const O=[];for(let U=0,G=w.length;U<G;U++){const q=w[U];O.push(q.x,q.y,q.z||0)}this.setAttribute("position",new Float32BufferAttribute(O,3))}else{const O=Math.min(w.length,D.count);for(let U=0;U<O;U++){const G=w[U];D.setXYZ(U,G.x,G.y,G.z||0)}w.length>D.count&&warn("BufferGeometry: Buffer size too small for points data. Use .dispose() and create a new geometry."),D.needsUpdate=!0}return this}computeBoundingBox(){this.boundingBox===null&&(this.boundingBox=new Box3);const w=this.attributes.position,D=this.morphAttributes.position;if(w&&w.isGLBufferAttribute){error("BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box.",this),this.boundingBox.set(new Vector3(-1/0,-1/0,-1/0),new Vector3(1/0,1/0,1/0));return}if(w!==void 0){if(this.boundingBox.setFromBufferAttribute(w),D)for(let O=0,U=D.length;O<U;O++){const G=D[O];_box$2.setFromBufferAttribute(G),this.morphTargetsRelative?(_vector$8.addVectors(this.boundingBox.min,_box$2.min),this.boundingBox.expandByPoint(_vector$8),_vector$8.addVectors(this.boundingBox.max,_box$2.max),this.boundingBox.expandByPoint(_vector$8)):(this.boundingBox.expandByPoint(_box$2.min),this.boundingBox.expandByPoint(_box$2.max))}}else this.boundingBox.makeEmpty();(isNaN(this.boundingBox.min.x)||isNaN(this.boundingBox.min.y)||isNaN(this.boundingBox.min.z))&&error('BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',this)}computeBoundingSphere(){this.boundingSphere===null&&(this.boundingSphere=new Sphere);const w=this.attributes.position,D=this.morphAttributes.position;if(w&&w.isGLBufferAttribute){error("BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere.",this),this.boundingSphere.set(new Vector3,1/0);return}if(w){const O=this.boundingSphere.center;if(_box$2.setFromBufferAttribute(w),D)for(let G=0,q=D.length;G<q;G++){const K=D[G];_boxMorphTargets.setFromBufferAttribute(K),this.morphTargetsRelative?(_vector$8.addVectors(_box$2.min,_boxMorphTargets.min),_box$2.expandByPoint(_vector$8),_vector$8.addVectors(_box$2.max,_boxMorphTargets.max),_box$2.expandByPoint(_vector$8)):(_box$2.expandByPoint(_boxMorphTargets.min),_box$2.expandByPoint(_boxMorphTargets.max))}_box$2.getCenter(O);let U=0;for(let G=0,q=w.count;G<q;G++)_vector$8.fromBufferAttribute(w,G),U=Math.max(U,O.distanceToSquared(_vector$8));if(D)for(let G=0,q=D.length;G<q;G++){const K=D[G],ee=this.morphTargetsRelative;for(let Z=0,ie=K.count;Z<ie;Z++)_vector$8.fromBufferAttribute(K,Z),ee&&(_offset.fromBufferAttribute(w,Z),_vector$8.add(_offset)),U=Math.max(U,O.distanceToSquared(_vector$8))}this.boundingSphere.radius=Math.sqrt(U),isNaN(this.boundingSphere.radius)&&error('BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',this)}}computeTangents(){const w=this.index,D=this.attributes;if(w===null||D.position===void 0||D.normal===void 0||D.uv===void 0){error("BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");return}const O=D.position,U=D.normal,G=D.uv;this.hasAttribute("tangent")===!1&&this.setAttribute("tangent",new BufferAttribute(new Float32Array(4*O.count),4));const q=this.getAttribute("tangent"),K=[],ee=[];for(let Me=0;Me<O.count;Me++)K[Me]=new Vector3,ee[Me]=new Vector3;const Z=new Vector3,ie=new Vector3,Y=new Vector3,W=new Vector2,ne=new Vector2,se=new Vector2,le=new Vector3,ce=new Vector3;function he(Me,Ee,we){Z.fromBufferAttribute(O,Me),ie.fromBufferAttribute(O,Ee),Y.fromBufferAttribute(O,we),W.fromBufferAttribute(G,Me),ne.fromBufferAttribute(G,Ee),se.fromBufferAttribute(G,we),ie.sub(Z),Y.sub(Z),ne.sub(W),se.sub(W);const Re=1/(ne.x*se.y-se.x*ne.y);isFinite(Re)&&(le.copy(ie).multiplyScalar(se.y).addScaledVector(Y,-ne.y).multiplyScalar(Re),ce.copy(Y).multiplyScalar(ne.x).addScaledVector(ie,-se.x).multiplyScalar(Re),K[Me].add(le),K[Ee].add(le),K[we].add(le),ee[Me].add(ce),ee[Ee].add(ce),ee[we].add(ce))}let pe=this.groups;pe.length===0&&(pe=[{start:0,count:w.count}]);for(let Me=0,Ee=pe.length;Me<Ee;++Me){const we=pe[Me],Re=we.start,Le=we.count;for(let Ne=Re,Oe=Re+Le;Ne<Oe;Ne+=3)he(w.getX(Ne+0),w.getX(Ne+1),w.getX(Ne+2))}const me=new Vector3,be=new Vector3,ge=new Vector3,ve=new Vector3;function Se(Me){ge.fromBufferAttribute(U,Me),ve.copy(ge);const Ee=K[Me];me.copy(Ee),me.sub(ge.multiplyScalar(ge.dot(Ee))).normalize(),be.crossVectors(ve,Ee);const Re=be.dot(ee[Me])<0?-1:1;q.setXYZW(Me,me.x,me.y,me.z,Re)}for(let Me=0,Ee=pe.length;Me<Ee;++Me){const we=pe[Me],Re=we.start,Le=we.count;for(let Ne=Re,Oe=Re+Le;Ne<Oe;Ne+=3)Se(w.getX(Ne+0)),Se(w.getX(Ne+1)),Se(w.getX(Ne+2))}}computeVertexNormals(){const w=this.index,D=this.getAttribute("position");if(D!==void 0){let O=this.getAttribute("normal");if(O===void 0)O=new BufferAttribute(new Float32Array(D.count*3),3),this.setAttribute("normal",O);else for(let W=0,ne=O.count;W<ne;W++)O.setXYZ(W,0,0,0);const U=new Vector3,G=new Vector3,q=new Vector3,K=new Vector3,ee=new Vector3,Z=new Vector3,ie=new Vector3,Y=new Vector3;if(w)for(let W=0,ne=w.count;W<ne;W+=3){const se=w.getX(W+0),le=w.getX(W+1),ce=w.getX(W+2);U.fromBufferAttribute(D,se),G.fromBufferAttribute(D,le),q.fromBufferAttribute(D,ce),ie.subVectors(q,G),Y.subVectors(U,G),ie.cross(Y),K.fromBufferAttribute(O,se),ee.fromBufferAttribute(O,le),Z.fromBufferAttribute(O,ce),K.add(ie),ee.add(ie),Z.add(ie),O.setXYZ(se,K.x,K.y,K.z),O.setXYZ(le,ee.x,ee.y,ee.z),O.setXYZ(ce,Z.x,Z.y,Z.z)}else for(let W=0,ne=D.count;W<ne;W+=3)U.fromBufferAttribute(D,W+0),G.fromBufferAttribute(D,W+1),q.fromBufferAttribute(D,W+2),ie.subVectors(q,G),Y.subVectors(U,G),ie.cross(Y),O.setXYZ(W+0,ie.x,ie.y,ie.z),O.setXYZ(W+1,ie.x,ie.y,ie.z),O.setXYZ(W+2,ie.x,ie.y,ie.z);this.normalizeNormals(),O.needsUpdate=!0}}normalizeNormals(){const w=this.attributes.normal;for(let D=0,O=w.count;D<O;D++)_vector$8.fromBufferAttribute(w,D),_vector$8.normalize(),w.setXYZ(D,_vector$8.x,_vector$8.y,_vector$8.z)}toNonIndexed(){function w(K,ee){const Z=K.array,ie=K.itemSize,Y=K.normalized,W=new Z.constructor(ee.length*ie);let ne=0,se=0;for(let le=0,ce=ee.length;le<ce;le++){K.isInterleavedBufferAttribute?ne=ee[le]*K.data.stride+K.offset:ne=ee[le]*ie;for(let he=0;he<ie;he++)W[se++]=Z[ne++]}return new BufferAttribute(W,ie,Y)}if(this.index===null)return warn("BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."),this;const D=new BufferGeometry,O=this.index.array,U=this.attributes;for(const K in U){const ee=U[K],Z=w(ee,O);D.setAttribute(K,Z)}const G=this.morphAttributes;for(const K in G){const ee=[],Z=G[K];for(let ie=0,Y=Z.length;ie<Y;ie++){const W=Z[ie],ne=w(W,O);ee.push(ne)}D.morphAttributes[K]=ee}D.morphTargetsRelative=this.morphTargetsRelative;const q=this.groups;for(let K=0,ee=q.length;K<ee;K++){const Z=q[K];D.addGroup(Z.start,Z.count,Z.materialIndex)}return D}toJSON(){const w={metadata:{version:4.7,type:"BufferGeometry",generator:"BufferGeometry.toJSON"}};if(w.uuid=this.uuid,w.type=this.type,this.name!==""&&(w.name=this.name),Object.keys(this.userData).length>0&&(w.userData=this.userData),this.parameters!==void 0){const ee=this.parameters;for(const Z in ee)ee[Z]!==void 0&&(w[Z]=ee[Z]);return w}w.data={attributes:{}};const D=this.index;D!==null&&(w.data.index={type:D.array.constructor.name,array:Array.prototype.slice.call(D.array)});const O=this.attributes;for(const ee in O){const Z=O[ee];w.data.attributes[ee]=Z.toJSON(w.data)}const U={};let G=!1;for(const ee in this.morphAttributes){const Z=this.morphAttributes[ee],ie=[];for(let Y=0,W=Z.length;Y<W;Y++){const ne=Z[Y];ie.push(ne.toJSON(w.data))}ie.length>0&&(U[ee]=ie,G=!0)}G&&(w.data.morphAttributes=U,w.data.morphTargetsRelative=this.morphTargetsRelative);const q=this.groups;q.length>0&&(w.data.groups=JSON.parse(JSON.stringify(q)));const K=this.boundingSphere;return K!==null&&(w.data.boundingSphere=K.toJSON()),w}clone(){return new this.constructor().copy(this)}copy(w){this.index=null,this.attributes={},this.morphAttributes={},this.groups=[],this.boundingBox=null,this.boundingSphere=null;const D={};this.name=w.name;const O=w.index;O!==null&&this.setIndex(O.clone());const U=w.attributes;for(const Z in U){const ie=U[Z];this.setAttribute(Z,ie.clone(D))}const G=w.morphAttributes;for(const Z in G){const ie=[],Y=G[Z];for(let W=0,ne=Y.length;W<ne;W++)ie.push(Y[W].clone(D));this.morphAttributes[Z]=ie}this.morphTargetsRelative=w.morphTargetsRelative;const q=w.groups;for(let Z=0,ie=q.length;Z<ie;Z++){const Y=q[Z];this.addGroup(Y.start,Y.count,Y.materialIndex)}const K=w.boundingBox;K!==null&&(this.boundingBox=K.clone());const ee=w.boundingSphere;return ee!==null&&(this.boundingSphere=ee.clone()),this.drawRange.start=w.drawRange.start,this.drawRange.count=w.drawRange.count,this.userData=w.userData,this}dispose(){this.dispatchEvent({type:"dispose"})}}const _inverseMatrix$3=new Matrix4,_ray$3=new Ray,_sphere$6=new Sphere,_sphereHitAt=new Vector3,_vA$1=new Vector3,_vB$1=new Vector3,_vC$1=new Vector3,_tempA=new Vector3,_morphA=new Vector3,_intersectionPoint=new Vector3,_intersectionPointWorld=new Vector3;class Mesh extends Object3D{constructor(w=new BufferGeometry,D=new MeshBasicMaterial){super(),this.isMesh=!0,this.type="Mesh",this.geometry=w,this.material=D,this.morphTargetDictionary=void 0,this.morphTargetInfluences=void 0,this.count=1,this.updateMorphTargets()}copy(w,D){return super.copy(w,D),w.morphTargetInfluences!==void 0&&(this.morphTargetInfluences=w.morphTargetInfluences.slice()),w.morphTargetDictionary!==void 0&&(this.morphTargetDictionary=Object.assign({},w.morphTargetDictionary)),this.material=Array.isArray(w.material)?w.material.slice():w.material,this.geometry=w.geometry,this}updateMorphTargets(){const D=this.geometry.morphAttributes,O=Object.keys(D);if(O.length>0){const U=D[O[0]];if(U!==void 0){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let G=0,q=U.length;G<q;G++){const K=U[G].name||String(G);this.morphTargetInfluences.push(0),this.morphTargetDictionary[K]=G}}}}getVertexPosition(w,D){const O=this.geometry,U=O.attributes.position,G=O.morphAttributes.position,q=O.morphTargetsRelative;D.fromBufferAttribute(U,w);const K=this.morphTargetInfluences;if(G&&K){_morphA.set(0,0,0);for(let ee=0,Z=G.length;ee<Z;ee++){const ie=K[ee],Y=G[ee];ie!==0&&(_tempA.fromBufferAttribute(Y,w),q?_morphA.addScaledVector(_tempA,ie):_morphA.addScaledVector(_tempA.sub(D),ie))}D.add(_morphA)}return D}raycast(w,D){const O=this.geometry,U=this.material,G=this.matrixWorld;U!==void 0&&(O.boundingSphere===null&&O.computeBoundingSphere(),_sphere$6.copy(O.boundingSphere),_sphere$6.applyMatrix4(G),_ray$3.copy(w.ray).recast(w.near),!(_sphere$6.containsPoint(_ray$3.origin)===!1&&(_ray$3.intersectSphere(_sphere$6,_sphereHitAt)===null||_ray$3.origin.distanceToSquared(_sphereHitAt)>(w.far-w.near)**2))&&(_inverseMatrix$3.copy(G).invert(),_ray$3.copy(w.ray).applyMatrix4(_inverseMatrix$3),!(O.boundingBox!==null&&_ray$3.intersectsBox(O.boundingBox)===!1)&&this._computeIntersections(w,D,_ray$3)))}_computeIntersections(w,D,O){let U;const G=this.geometry,q=this.material,K=G.index,ee=G.attributes.position,Z=G.attributes.uv,ie=G.attributes.uv1,Y=G.attributes.normal,W=G.groups,ne=G.drawRange;if(K!==null)if(Array.isArray(q))for(let se=0,le=W.length;se<le;se++){const ce=W[se],he=q[ce.materialIndex],pe=Math.max(ce.start,ne.start),me=Math.min(K.count,Math.min(ce.start+ce.count,ne.start+ne.count));for(let be=pe,ge=me;be<ge;be+=3){const ve=K.getX(be),Se=K.getX(be+1),Me=K.getX(be+2);U=checkGeometryIntersection(this,he,w,O,Z,ie,Y,ve,Se,Me),U&&(U.faceIndex=Math.floor(be/3),U.face.materialIndex=ce.materialIndex,D.push(U))}}else{const se=Math.max(0,ne.start),le=Math.min(K.count,ne.start+ne.count);for(let ce=se,he=le;ce<he;ce+=3){const pe=K.getX(ce),me=K.getX(ce+1),be=K.getX(ce+2);U=checkGeometryIntersection(this,q,w,O,Z,ie,Y,pe,me,be),U&&(U.faceIndex=Math.floor(ce/3),D.push(U))}}else if(ee!==void 0)if(Array.isArray(q))for(let se=0,le=W.length;se<le;se++){const ce=W[se],he=q[ce.materialIndex],pe=Math.max(ce.start,ne.start),me=Math.min(ee.count,Math.min(ce.start+ce.count,ne.start+ne.count));for(let be=pe,ge=me;be<ge;be+=3){const ve=be,Se=be+1,Me=be+2;U=checkGeometryIntersection(this,he,w,O,Z,ie,Y,ve,Se,Me),U&&(U.faceIndex=Math.floor(be/3),U.face.materialIndex=ce.materialIndex,D.push(U))}}else{const se=Math.max(0,ne.start),le=Math.min(ee.count,ne.start+ne.count);for(let ce=se,he=le;ce<he;ce+=3){const pe=ce,me=ce+1,be=ce+2;U=checkGeometryIntersection(this,q,w,O,Z,ie,Y,pe,me,be),U&&(U.faceIndex=Math.floor(ce/3),D.push(U))}}}}function checkIntersection$1(F,w,D,O,U,G,q,K){let ee;if(w.side===BackSide?ee=O.intersectTriangle(q,G,U,!0,K):ee=O.intersectTriangle(U,G,q,w.side===FrontSide,K),ee===null)return null;_intersectionPointWorld.copy(K),_intersectionPointWorld.applyMatrix4(F.matrixWorld);const Z=D.ray.origin.distanceTo(_intersectionPointWorld);return Z<D.near||Z>D.far?null:{distance:Z,point:_intersectionPointWorld.clone(),object:F}}function checkGeometryIntersection(F,w,D,O,U,G,q,K,ee,Z){F.getVertexPosition(K,_vA$1),F.getVertexPosition(ee,_vB$1),F.getVertexPosition(Z,_vC$1);const ie=checkIntersection$1(F,w,D,O,_vA$1,_vB$1,_vC$1,_intersectionPoint);if(ie){const Y=new Vector3;Triangle.getBarycoord(_intersectionPoint,_vA$1,_vB$1,_vC$1,Y),U&&(ie.uv=Triangle.getInterpolatedAttribute(U,K,ee,Z,Y,new Vector2)),G&&(ie.uv1=Triangle.getInterpolatedAttribute(G,K,ee,Z,Y,new Vector2)),q&&(ie.normal=Triangle.getInterpolatedAttribute(q,K,ee,Z,Y,new Vector3),ie.normal.dot(O.direction)>0&&ie.normal.multiplyScalar(-1));const W={a:K,b:ee,c:Z,normal:new Vector3,materialIndex:0};Triangle.getNormal(_vA$1,_vB$1,_vC$1,W.normal),ie.face=W,ie.barycoord=Y}return ie}class BoxGeometry extends BufferGeometry{constructor(w=1,D=1,O=1,U=1,G=1,q=1){super(),this.type="BoxGeometry",this.parameters={width:w,height:D,depth:O,widthSegments:U,heightSegments:G,depthSegments:q};const K=this;U=Math.floor(U),G=Math.floor(G),q=Math.floor(q);const ee=[],Z=[],ie=[],Y=[];let W=0,ne=0;se("z","y","x",-1,-1,O,D,w,q,G,0),se("z","y","x",1,-1,O,D,-w,q,G,1),se("x","z","y",1,1,w,O,D,U,q,2),se("x","z","y",1,-1,w,O,-D,U,q,3),se("x","y","z",1,-1,w,D,O,U,G,4),se("x","y","z",-1,-1,w,D,-O,U,G,5),this.setIndex(ee),this.setAttribute("position",new Float32BufferAttribute(Z,3)),this.setAttribute("normal",new Float32BufferAttribute(ie,3)),this.setAttribute("uv",new Float32BufferAttribute(Y,2));function se(le,ce,he,pe,me,be,ge,ve,Se,Me,Ee){const we=be/Se,Re=ge/Me,Le=be/2,Ne=ge/2,Oe=ve/2,Pe=Se+1,Ce=Me+1;let Be=0,ze=0;const Xe=new Vector3;for(let lt=0;lt<Ce;lt++){const ke=lt*Re-Ne;for(let rt=0;rt<Pe;rt++){const St=rt*we-Le;Xe[le]=St*pe,Xe[ce]=ke*me,Xe[he]=Oe,Z.push(Xe.x,Xe.y,Xe.z),Xe[le]=0,Xe[ce]=0,Xe[he]=ve>0?1:-1,ie.push(Xe.x,Xe.y,Xe.z),Y.push(rt/Se),Y.push(1-lt/Me),Be+=1}}for(let lt=0;lt<Me;lt++)for(let ke=0;ke<Se;ke++){const rt=W+ke+Pe*lt,St=W+ke+Pe*(lt+1),Lt=W+(ke+1)+Pe*(lt+1),$t=W+(ke+1)+Pe*lt;ee.push(rt,St,$t),ee.push(St,Lt,$t),ze+=6}K.addGroup(ne,ze,Ee),ne+=ze,W+=Be}}copy(w){return super.copy(w),this.parameters=Object.assign({},w.parameters),this}static fromJSON(w){return new BoxGeometry(w.width,w.height,w.depth,w.widthSegments,w.heightSegments,w.depthSegments)}}function cloneUniforms(F){const w={};for(const D in F){w[D]={};for(const O in F[D]){const U=F[D][O];U&&(U.isColor||U.isMatrix3||U.isMatrix4||U.isVector2||U.isVector3||U.isVector4||U.isTexture||U.isQuaternion)?U.isRenderTargetTexture?(warn("UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms()."),w[D][O]=null):w[D][O]=U.clone():Array.isArray(U)?w[D][O]=U.slice():w[D][O]=U}}return w}function mergeUniforms(F){const w={};for(let D=0;D<F.length;D++){const O=cloneUniforms(F[D]);for(const U in O)w[U]=O[U]}return w}function cloneUniformsGroups(F){const w=[];for(let D=0;D<F.length;D++)w.push(F[D].clone());return w}function getUnlitUniformColorSpace(F){const w=F.getRenderTarget();return w===null?F.outputColorSpace:w.isXRRenderTarget===!0?w.texture.colorSpace:ColorManagement.workingColorSpace}const UniformsUtils={clone:cloneUniforms,merge:mergeUniforms};var default_vertex=`void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`,default_fragment=`void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}`;class ShaderMaterial extends Material$1{constructor(w){super(),this.isShaderMaterial=!0,this.type="ShaderMaterial",this.defines={},this.uniforms={},this.uniformsGroups=[],this.vertexShader=default_vertex,this.fragmentShader=default_fragment,this.linewidth=1,this.wireframe=!1,this.wireframeLinewidth=1,this.fog=!1,this.lights=!1,this.clipping=!1,this.forceSinglePass=!0,this.extensions={clipCullDistance:!1,multiDraw:!1},this.defaultAttributeValues={color:[1,1,1],uv:[0,0],uv1:[0,0]},this.index0AttributeName=void 0,this.uniformsNeedUpdate=!1,this.glslVersion=null,w!==void 0&&this.setValues(w)}copy(w){return super.copy(w),this.fragmentShader=w.fragmentShader,this.vertexShader=w.vertexShader,this.uniforms=cloneUniforms(w.uniforms),this.uniformsGroups=cloneUniformsGroups(w.uniformsGroups),this.defines=Object.assign({},w.defines),this.wireframe=w.wireframe,this.wireframeLinewidth=w.wireframeLinewidth,this.fog=w.fog,this.lights=w.lights,this.clipping=w.clipping,this.extensions=Object.assign({},w.extensions),this.glslVersion=w.glslVersion,this}toJSON(w){const D=super.toJSON(w);D.glslVersion=this.glslVersion,D.uniforms={};for(const U in this.uniforms){const q=this.uniforms[U].value;q&&q.isTexture?D.uniforms[U]={type:"t",value:q.toJSON(w).uuid}:q&&q.isColor?D.uniforms[U]={type:"c",value:q.getHex()}:q&&q.isVector2?D.uniforms[U]={type:"v2",value:q.toArray()}:q&&q.isVector3?D.uniforms[U]={type:"v3",value:q.toArray()}:q&&q.isVector4?D.uniforms[U]={type:"v4",value:q.toArray()}:q&&q.isMatrix3?D.uniforms[U]={type:"m3",value:q.toArray()}:q&&q.isMatrix4?D.uniforms[U]={type:"m4",value:q.toArray()}:D.uniforms[U]={value:q}}Object.keys(this.defines).length>0&&(D.defines=this.defines),D.vertexShader=this.vertexShader,D.fragmentShader=this.fragmentShader,D.lights=this.lights,D.clipping=this.clipping;const O={};for(const U in this.extensions)this.extensions[U]===!0&&(O[U]=!0);return Object.keys(O).length>0&&(D.extensions=O),D}}let Camera$1=class extends Object3D{constructor(){super(),this.isCamera=!0,this.type="Camera",this.matrixWorldInverse=new Matrix4,this.projectionMatrix=new Matrix4,this.projectionMatrixInverse=new Matrix4,this.coordinateSystem=WebGLCoordinateSystem,this._reversedDepth=!1}get reversedDepth(){return this._reversedDepth}copy(w,D){return super.copy(w,D),this.matrixWorldInverse.copy(w.matrixWorldInverse),this.projectionMatrix.copy(w.projectionMatrix),this.projectionMatrixInverse.copy(w.projectionMatrixInverse),this.coordinateSystem=w.coordinateSystem,this}getWorldDirection(w){return super.getWorldDirection(w).negate()}updateMatrixWorld(w){super.updateMatrixWorld(w),this.matrixWorldInverse.copy(this.matrixWorld).invert()}updateWorldMatrix(w,D){super.updateWorldMatrix(w,D),this.matrixWorldInverse.copy(this.matrixWorld).invert()}clone(){return new this.constructor().copy(this)}};const _v3$1=new Vector3,_minTarget=new Vector2,_maxTarget=new Vector2;class PerspectiveCamera extends Camera$1{constructor(w=50,D=1,O=.1,U=2e3){super(),this.isPerspectiveCamera=!0,this.type="PerspectiveCamera",this.fov=w,this.zoom=1,this.near=O,this.far=U,this.focus=10,this.aspect=D,this.view=null,this.filmGauge=35,this.filmOffset=0,this.updateProjectionMatrix()}copy(w,D){return super.copy(w,D),this.fov=w.fov,this.zoom=w.zoom,this.near=w.near,this.far=w.far,this.focus=w.focus,this.aspect=w.aspect,this.view=w.view===null?null:Object.assign({},w.view),this.filmGauge=w.filmGauge,this.filmOffset=w.filmOffset,this}setFocalLength(w){const D=.5*this.getFilmHeight()/w;this.fov=RAD2DEG*2*Math.atan(D),this.updateProjectionMatrix()}getFocalLength(){const w=Math.tan(DEG2RAD*.5*this.fov);return .5*this.getFilmHeight()/w}getEffectiveFOV(){return RAD2DEG*2*Math.atan(Math.tan(DEG2RAD*.5*this.fov)/this.zoom)}getFilmWidth(){return this.filmGauge*Math.min(this.aspect,1)}getFilmHeight(){return this.filmGauge/Math.max(this.aspect,1)}getViewBounds(w,D,O){_v3$1.set(-1,-1,.5).applyMatrix4(this.projectionMatrixInverse),D.set(_v3$1.x,_v3$1.y).multiplyScalar(-w/_v3$1.z),_v3$1.set(1,1,.5).applyMatrix4(this.projectionMatrixInverse),O.set(_v3$1.x,_v3$1.y).multiplyScalar(-w/_v3$1.z)}getViewSize(w,D){return this.getViewBounds(w,_minTarget,_maxTarget),D.subVectors(_maxTarget,_minTarget)}setViewOffset(w,D,O,U,G,q){this.aspect=w/D,this.view===null&&(this.view={enabled:!0,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1}),this.view.enabled=!0,this.view.fullWidth=w,this.view.fullHeight=D,this.view.offsetX=O,this.view.offsetY=U,this.view.width=G,this.view.height=q,this.updateProjectionMatrix()}clearViewOffset(){this.view!==null&&(this.view.enabled=!1),this.updateProjectionMatrix()}updateProjectionMatrix(){const w=this.near;let D=w*Math.tan(DEG2RAD*.5*this.fov)/this.zoom,O=2*D,U=this.aspect*O,G=-.5*U;const q=this.view;if(this.view!==null&&this.view.enabled){const ee=q.fullWidth,Z=q.fullHeight;G+=q.offsetX*U/ee,D-=q.offsetY*O/Z,U*=q.width/ee,O*=q.height/Z}const K=this.filmOffset;K!==0&&(G+=w*K/this.getFilmWidth()),this.projectionMatrix.makePerspective(G,G+U,D,D-O,w,this.far,this.coordinateSystem,this.reversedDepth),this.projectionMatrixInverse.copy(this.projectionMatrix).invert()}toJSON(w){const D=super.toJSON(w);return D.object.fov=this.fov,D.object.zoom=this.zoom,D.object.near=this.near,D.object.far=this.far,D.object.focus=this.focus,D.object.aspect=this.aspect,this.view!==null&&(D.object.view=Object.assign({},this.view)),D.object.filmGauge=this.filmGauge,D.object.filmOffset=this.filmOffset,D}}const fov=-90,aspect=1;class CubeCamera extends Object3D{constructor(w,D,O){super(),this.type="CubeCamera",this.renderTarget=O,this.coordinateSystem=null,this.activeMipmapLevel=0;const U=new PerspectiveCamera(fov,aspect,w,D);U.layers=this.layers,this.add(U);const G=new PerspectiveCamera(fov,aspect,w,D);G.layers=this.layers,this.add(G);const q=new PerspectiveCamera(fov,aspect,w,D);q.layers=this.layers,this.add(q);const K=new PerspectiveCamera(fov,aspect,w,D);K.layers=this.layers,this.add(K);const ee=new PerspectiveCamera(fov,aspect,w,D);ee.layers=this.layers,this.add(ee);const Z=new PerspectiveCamera(fov,aspect,w,D);Z.layers=this.layers,this.add(Z)}updateCoordinateSystem(){const w=this.coordinateSystem,D=this.children.concat(),[O,U,G,q,K,ee]=D;for(const Z of D)this.remove(Z);if(w===WebGLCoordinateSystem)O.up.set(0,1,0),O.lookAt(1,0,0),U.up.set(0,1,0),U.lookAt(-1,0,0),G.up.set(0,0,-1),G.lookAt(0,1,0),q.up.set(0,0,1),q.lookAt(0,-1,0),K.up.set(0,1,0),K.lookAt(0,0,1),ee.up.set(0,1,0),ee.lookAt(0,0,-1);else if(w===WebGPUCoordinateSystem)O.up.set(0,-1,0),O.lookAt(-1,0,0),U.up.set(0,-1,0),U.lookAt(1,0,0),G.up.set(0,0,1),G.lookAt(0,1,0),q.up.set(0,0,-1),q.lookAt(0,-1,0),K.up.set(0,-1,0),K.lookAt(0,0,1),ee.up.set(0,-1,0),ee.lookAt(0,0,-1);else throw new Error("THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: "+w);for(const Z of D)this.add(Z),Z.updateMatrixWorld()}update(w,D){this.parent===null&&this.updateMatrixWorld();const{renderTarget:O,activeMipmapLevel:U}=this;this.coordinateSystem!==w.coordinateSystem&&(this.coordinateSystem=w.coordinateSystem,this.updateCoordinateSystem());const[G,q,K,ee,Z,ie]=this.children,Y=w.getRenderTarget(),W=w.getActiveCubeFace(),ne=w.getActiveMipmapLevel(),se=w.xr.enabled;w.xr.enabled=!1;const le=O.texture.generateMipmaps;O.texture.generateMipmaps=!1,w.setRenderTarget(O,0,U),w.render(D,G),w.setRenderTarget(O,1,U),w.render(D,q),w.setRenderTarget(O,2,U),w.render(D,K),w.setRenderTarget(O,3,U),w.render(D,ee),w.setRenderTarget(O,4,U),w.render(D,Z),O.texture.generateMipmaps=le,w.setRenderTarget(O,5,U),w.render(D,ie),w.setRenderTarget(Y,W,ne),w.xr.enabled=se,O.texture.needsPMREMUpdate=!0}}class CubeTexture extends Texture$1{constructor(w=[],D=CubeReflectionMapping,O,U,G,q,K,ee,Z,ie){super(w,D,O,U,G,q,K,ee,Z,ie),this.isCubeTexture=!0,this.flipY=!1}get images(){return this.image}set images(w){this.image=w}}class WebGLCubeRenderTarget extends WebGLRenderTarget{constructor(w=1,D={}){super(w,w,D),this.isWebGLCubeRenderTarget=!0;const O={width:w,height:w,depth:1},U=[O,O,O,O,O,O];this.texture=new CubeTexture(U),this._setTextureOptions(D),this.texture.isRenderTargetTexture=!0}fromEquirectangularTexture(w,D){this.texture.type=D.type,this.texture.colorSpace=D.colorSpace,this.texture.generateMipmaps=D.generateMipmaps,this.texture.minFilter=D.minFilter,this.texture.magFilter=D.magFilter;const O={uniforms:{tEquirect:{value:null}},vertexShader:`

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,fragmentShader:`

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`},U=new BoxGeometry(5,5,5),G=new ShaderMaterial({name:"CubemapFromEquirect",uniforms:cloneUniforms(O.uniforms),vertexShader:O.vertexShader,fragmentShader:O.fragmentShader,side:BackSide,blending:NoBlending});G.uniforms.tEquirect.value=D;const q=new Mesh(U,G),K=D.minFilter;return D.minFilter===LinearMipmapLinearFilter&&(D.minFilter=LinearFilter),new CubeCamera(1,10,this).update(w,q),D.minFilter=K,q.geometry.dispose(),q.material.dispose(),this}clear(w,D=!0,O=!0,U=!0){const G=w.getRenderTarget();for(let q=0;q<6;q++)w.setRenderTarget(this,q),w.clear(D,O,U);w.setRenderTarget(G)}}class Group extends Object3D{constructor(){super(),this.isGroup=!0,this.type="Group"}}const _moveEvent={type:"move"};class WebXRController{constructor(){this._targetRay=null,this._grip=null,this._hand=null}getHandSpace(){return this._hand===null&&(this._hand=new Group,this._hand.matrixAutoUpdate=!1,this._hand.visible=!1,this._hand.joints={},this._hand.inputState={pinching:!1}),this._hand}getTargetRaySpace(){return this._targetRay===null&&(this._targetRay=new Group,this._targetRay.matrixAutoUpdate=!1,this._targetRay.visible=!1,this._targetRay.hasLinearVelocity=!1,this._targetRay.linearVelocity=new Vector3,this._targetRay.hasAngularVelocity=!1,this._targetRay.angularVelocity=new Vector3),this._targetRay}getGripSpace(){return this._grip===null&&(this._grip=new Group,this._grip.matrixAutoUpdate=!1,this._grip.visible=!1,this._grip.hasLinearVelocity=!1,this._grip.linearVelocity=new Vector3,this._grip.hasAngularVelocity=!1,this._grip.angularVelocity=new Vector3),this._grip}dispatchEvent(w){return this._targetRay!==null&&this._targetRay.dispatchEvent(w),this._grip!==null&&this._grip.dispatchEvent(w),this._hand!==null&&this._hand.dispatchEvent(w),this}connect(w){if(w&&w.hand){const D=this._hand;if(D)for(const O of w.hand.values())this._getHandJoint(D,O)}return this.dispatchEvent({type:"connected",data:w}),this}disconnect(w){return this.dispatchEvent({type:"disconnected",data:w}),this._targetRay!==null&&(this._targetRay.visible=!1),this._grip!==null&&(this._grip.visible=!1),this._hand!==null&&(this._hand.visible=!1),this}update(w,D,O){let U=null,G=null,q=null;const K=this._targetRay,ee=this._grip,Z=this._hand;if(w&&D.session.visibilityState!=="visible-blurred"){if(Z&&w.hand){q=!0;for(const le of w.hand.values()){const ce=D.getJointPose(le,O),he=this._getHandJoint(Z,le);ce!==null&&(he.matrix.fromArray(ce.transform.matrix),he.matrix.decompose(he.position,he.rotation,he.scale),he.matrixWorldNeedsUpdate=!0,he.jointRadius=ce.radius),he.visible=ce!==null}const ie=Z.joints["index-finger-tip"],Y=Z.joints["thumb-tip"],W=ie.position.distanceTo(Y.position),ne=.02,se=.005;Z.inputState.pinching&&W>ne+se?(Z.inputState.pinching=!1,this.dispatchEvent({type:"pinchend",handedness:w.handedness,target:this})):!Z.inputState.pinching&&W<=ne-se&&(Z.inputState.pinching=!0,this.dispatchEvent({type:"pinchstart",handedness:w.handedness,target:this}))}else ee!==null&&w.gripSpace&&(G=D.getPose(w.gripSpace,O),G!==null&&(ee.matrix.fromArray(G.transform.matrix),ee.matrix.decompose(ee.position,ee.rotation,ee.scale),ee.matrixWorldNeedsUpdate=!0,G.linearVelocity?(ee.hasLinearVelocity=!0,ee.linearVelocity.copy(G.linearVelocity)):ee.hasLinearVelocity=!1,G.angularVelocity?(ee.hasAngularVelocity=!0,ee.angularVelocity.copy(G.angularVelocity)):ee.hasAngularVelocity=!1));K!==null&&(U=D.getPose(w.targetRaySpace,O),U===null&&G!==null&&(U=G),U!==null&&(K.matrix.fromArray(U.transform.matrix),K.matrix.decompose(K.position,K.rotation,K.scale),K.matrixWorldNeedsUpdate=!0,U.linearVelocity?(K.hasLinearVelocity=!0,K.linearVelocity.copy(U.linearVelocity)):K.hasLinearVelocity=!1,U.angularVelocity?(K.hasAngularVelocity=!0,K.angularVelocity.copy(U.angularVelocity)):K.hasAngularVelocity=!1,this.dispatchEvent(_moveEvent)))}return K!==null&&(K.visible=U!==null),ee!==null&&(ee.visible=G!==null),Z!==null&&(Z.visible=q!==null),this}_getHandJoint(w,D){if(w.joints[D.jointName]===void 0){const O=new Group;O.matrixAutoUpdate=!1,O.visible=!1,w.joints[D.jointName]=O,w.add(O)}return w.joints[D.jointName]}}class Scene extends Object3D{constructor(){super(),this.isScene=!0,this.type="Scene",this.background=null,this.environment=null,this.fog=null,this.backgroundBlurriness=0,this.backgroundIntensity=1,this.backgroundRotation=new Euler,this.environmentIntensity=1,this.environmentRotation=new Euler,this.overrideMaterial=null,typeof __THREE_DEVTOOLS__<"u"&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{detail:this}))}copy(w,D){return super.copy(w,D),w.background!==null&&(this.background=w.background.clone()),w.environment!==null&&(this.environment=w.environment.clone()),w.fog!==null&&(this.fog=w.fog.clone()),this.backgroundBlurriness=w.backgroundBlurriness,this.backgroundIntensity=w.backgroundIntensity,this.backgroundRotation.copy(w.backgroundRotation),this.environmentIntensity=w.environmentIntensity,this.environmentRotation.copy(w.environmentRotation),w.overrideMaterial!==null&&(this.overrideMaterial=w.overrideMaterial.clone()),this.matrixAutoUpdate=w.matrixAutoUpdate,this}toJSON(w){const D=super.toJSON(w);return this.fog!==null&&(D.object.fog=this.fog.toJSON()),this.backgroundBlurriness>0&&(D.object.backgroundBlurriness=this.backgroundBlurriness),this.backgroundIntensity!==1&&(D.object.backgroundIntensity=this.backgroundIntensity),D.object.backgroundRotation=this.backgroundRotation.toArray(),this.environmentIntensity!==1&&(D.object.environmentIntensity=this.environmentIntensity),D.object.environmentRotation=this.environmentRotation.toArray(),D}}class InterleavedBuffer{constructor(w,D){this.isInterleavedBuffer=!0,this.array=w,this.stride=D,this.count=w!==void 0?w.length/D:0,this.usage=StaticDrawUsage,this.updateRanges=[],this.version=0,this.uuid=generateUUID()}onUploadCallback(){}set needsUpdate(w){w===!0&&this.version++}setUsage(w){return this.usage=w,this}addUpdateRange(w,D){this.updateRanges.push({start:w,count:D})}clearUpdateRanges(){this.updateRanges.length=0}copy(w){return this.array=new w.array.constructor(w.array),this.count=w.count,this.stride=w.stride,this.usage=w.usage,this}copyAt(w,D,O){w*=this.stride,O*=D.stride;for(let U=0,G=this.stride;U<G;U++)this.array[w+U]=D.array[O+U];return this}set(w,D=0){return this.array.set(w,D),this}clone(w){w.arrayBuffers===void 0&&(w.arrayBuffers={}),this.array.buffer._uuid===void 0&&(this.array.buffer._uuid=generateUUID()),w.arrayBuffers[this.array.buffer._uuid]===void 0&&(w.arrayBuffers[this.array.buffer._uuid]=this.array.slice(0).buffer);const D=new this.array.constructor(w.arrayBuffers[this.array.buffer._uuid]),O=new this.constructor(D,this.stride);return O.setUsage(this.usage),O}onUpload(w){return this.onUploadCallback=w,this}toJSON(w){return w.arrayBuffers===void 0&&(w.arrayBuffers={}),this.array.buffer._uuid===void 0&&(this.array.buffer._uuid=generateUUID()),w.arrayBuffers[this.array.buffer._uuid]===void 0&&(w.arrayBuffers[this.array.buffer._uuid]=Array.from(new Uint32Array(this.array.buffer))),{uuid:this.uuid,buffer:this.array.buffer._uuid,type:this.array.constructor.name,stride:this.stride}}}const _vector$7=new Vector3;class InterleavedBufferAttribute{constructor(w,D,O,U=!1){this.isInterleavedBufferAttribute=!0,this.name="",this.data=w,this.itemSize=D,this.offset=O,this.normalized=U}get count(){return this.data.count}get array(){return this.data.array}set needsUpdate(w){this.data.needsUpdate=w}applyMatrix4(w){for(let D=0,O=this.data.count;D<O;D++)_vector$7.fromBufferAttribute(this,D),_vector$7.applyMatrix4(w),this.setXYZ(D,_vector$7.x,_vector$7.y,_vector$7.z);return this}applyNormalMatrix(w){for(let D=0,O=this.count;D<O;D++)_vector$7.fromBufferAttribute(this,D),_vector$7.applyNormalMatrix(w),this.setXYZ(D,_vector$7.x,_vector$7.y,_vector$7.z);return this}transformDirection(w){for(let D=0,O=this.count;D<O;D++)_vector$7.fromBufferAttribute(this,D),_vector$7.transformDirection(w),this.setXYZ(D,_vector$7.x,_vector$7.y,_vector$7.z);return this}getComponent(w,D){let O=this.array[w*this.data.stride+this.offset+D];return this.normalized&&(O=denormalize(O,this.array)),O}setComponent(w,D,O){return this.normalized&&(O=normalize(O,this.array)),this.data.array[w*this.data.stride+this.offset+D]=O,this}setX(w,D){return this.normalized&&(D=normalize(D,this.array)),this.data.array[w*this.data.stride+this.offset]=D,this}setY(w,D){return this.normalized&&(D=normalize(D,this.array)),this.data.array[w*this.data.stride+this.offset+1]=D,this}setZ(w,D){return this.normalized&&(D=normalize(D,this.array)),this.data.array[w*this.data.stride+this.offset+2]=D,this}setW(w,D){return this.normalized&&(D=normalize(D,this.array)),this.data.array[w*this.data.stride+this.offset+3]=D,this}getX(w){let D=this.data.array[w*this.data.stride+this.offset];return this.normalized&&(D=denormalize(D,this.array)),D}getY(w){let D=this.data.array[w*this.data.stride+this.offset+1];return this.normalized&&(D=denormalize(D,this.array)),D}getZ(w){let D=this.data.array[w*this.data.stride+this.offset+2];return this.normalized&&(D=denormalize(D,this.array)),D}getW(w){let D=this.data.array[w*this.data.stride+this.offset+3];return this.normalized&&(D=denormalize(D,this.array)),D}setXY(w,D,O){return w=w*this.data.stride+this.offset,this.normalized&&(D=normalize(D,this.array),O=normalize(O,this.array)),this.data.array[w+0]=D,this.data.array[w+1]=O,this}setXYZ(w,D,O,U){return w=w*this.data.stride+this.offset,this.normalized&&(D=normalize(D,this.array),O=normalize(O,this.array),U=normalize(U,this.array)),this.data.array[w+0]=D,this.data.array[w+1]=O,this.data.array[w+2]=U,this}setXYZW(w,D,O,U,G){return w=w*this.data.stride+this.offset,this.normalized&&(D=normalize(D,this.array),O=normalize(O,this.array),U=normalize(U,this.array),G=normalize(G,this.array)),this.data.array[w+0]=D,this.data.array[w+1]=O,this.data.array[w+2]=U,this.data.array[w+3]=G,this}clone(w){if(w===void 0){log("InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will de-interleave buffer data.");const D=[];for(let O=0;O<this.count;O++){const U=O*this.data.stride+this.offset;for(let G=0;G<this.itemSize;G++)D.push(this.data.array[U+G])}return new BufferAttribute(new this.array.constructor(D),this.itemSize,this.normalized)}else return w.interleavedBuffers===void 0&&(w.interleavedBuffers={}),w.interleavedBuffers[this.data.uuid]===void 0&&(w.interleavedBuffers[this.data.uuid]=this.data.clone(w)),new InterleavedBufferAttribute(w.interleavedBuffers[this.data.uuid],this.itemSize,this.offset,this.normalized)}toJSON(w){if(w===void 0){log("InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will de-interleave buffer data.");const D=[];for(let O=0;O<this.count;O++){const U=O*this.data.stride+this.offset;for(let G=0;G<this.itemSize;G++)D.push(this.data.array[U+G])}return{itemSize:this.itemSize,type:this.array.constructor.name,array:D,normalized:this.normalized}}else return w.interleavedBuffers===void 0&&(w.interleavedBuffers={}),w.interleavedBuffers[this.data.uuid]===void 0&&(w.interleavedBuffers[this.data.uuid]=this.data.toJSON(w)),{isInterleavedBufferAttribute:!0,itemSize:this.itemSize,data:this.data.uuid,offset:this.offset,normalized:this.normalized}}}const _basePosition=new Vector3,_skinIndex=new Vector4,_skinWeight=new Vector4,_vector3=new Vector3,_matrix4=new Matrix4,_vertex=new Vector3,_sphere$5=new Sphere,_inverseMatrix$2=new Matrix4,_ray$2=new Ray;class SkinnedMesh extends Mesh{constructor(w,D){super(w,D),this.isSkinnedMesh=!0,this.type="SkinnedMesh",this.bindMode=AttachedBindMode,this.bindMatrix=new Matrix4,this.bindMatrixInverse=new Matrix4,this.boundingBox=null,this.boundingSphere=null}computeBoundingBox(){const w=this.geometry;this.boundingBox===null&&(this.boundingBox=new Box3),this.boundingBox.makeEmpty();const D=w.getAttribute("position");for(let O=0;O<D.count;O++)this.getVertexPosition(O,_vertex),this.boundingBox.expandByPoint(_vertex)}computeBoundingSphere(){const w=this.geometry;this.boundingSphere===null&&(this.boundingSphere=new Sphere),this.boundingSphere.makeEmpty();const D=w.getAttribute("position");for(let O=0;O<D.count;O++)this.getVertexPosition(O,_vertex),this.boundingSphere.expandByPoint(_vertex)}copy(w,D){return super.copy(w,D),this.bindMode=w.bindMode,this.bindMatrix.copy(w.bindMatrix),this.bindMatrixInverse.copy(w.bindMatrixInverse),this.skeleton=w.skeleton,w.boundingBox!==null&&(this.boundingBox=w.boundingBox.clone()),w.boundingSphere!==null&&(this.boundingSphere=w.boundingSphere.clone()),this}raycast(w,D){const O=this.material,U=this.matrixWorld;O!==void 0&&(this.boundingSphere===null&&this.computeBoundingSphere(),_sphere$5.copy(this.boundingSphere),_sphere$5.applyMatrix4(U),w.ray.intersectsSphere(_sphere$5)!==!1&&(_inverseMatrix$2.copy(U).invert(),_ray$2.copy(w.ray).applyMatrix4(_inverseMatrix$2),!(this.boundingBox!==null&&_ray$2.intersectsBox(this.boundingBox)===!1)&&this._computeIntersections(w,D,_ray$2)))}getVertexPosition(w,D){return super.getVertexPosition(w,D),this.applyBoneTransform(w,D),D}bind(w,D){this.skeleton=w,D===void 0&&(this.updateMatrixWorld(!0),this.skeleton.calculateInverses(),D=this.matrixWorld),this.bindMatrix.copy(D),this.bindMatrixInverse.copy(D).invert()}pose(){this.skeleton.pose()}normalizeSkinWeights(){const w=new Vector4,D=this.geometry.attributes.skinWeight;for(let O=0,U=D.count;O<U;O++){w.fromBufferAttribute(D,O);const G=1/w.manhattanLength();G!==1/0?w.multiplyScalar(G):w.set(1,0,0,0),D.setXYZW(O,w.x,w.y,w.z,w.w)}}updateMatrixWorld(w){super.updateMatrixWorld(w),this.bindMode===AttachedBindMode?this.bindMatrixInverse.copy(this.matrixWorld).invert():this.bindMode===DetachedBindMode?this.bindMatrixInverse.copy(this.bindMatrix).invert():warn("SkinnedMesh: Unrecognized bindMode: "+this.bindMode)}applyBoneTransform(w,D){const O=this.skeleton,U=this.geometry;_skinIndex.fromBufferAttribute(U.attributes.skinIndex,w),_skinWeight.fromBufferAttribute(U.attributes.skinWeight,w),_basePosition.copy(D).applyMatrix4(this.bindMatrix),D.set(0,0,0);for(let G=0;G<4;G++){const q=_skinWeight.getComponent(G);if(q!==0){const K=_skinIndex.getComponent(G);_matrix4.multiplyMatrices(O.bones[K].matrixWorld,O.boneInverses[K]),D.addScaledVector(_vector3.copy(_basePosition).applyMatrix4(_matrix4),q)}}return D.applyMatrix4(this.bindMatrixInverse)}}class Bone extends Object3D{constructor(){super(),this.isBone=!0,this.type="Bone"}}class DataTexture extends Texture$1{constructor(w=null,D=1,O=1,U,G,q,K,ee,Z=NearestFilter,ie=NearestFilter,Y,W){super(null,q,K,ee,Z,ie,U,G,Y,W),this.isDataTexture=!0,this.image={data:w,width:D,height:O},this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1}}const _offsetMatrix=new Matrix4,_identityMatrix$1=new Matrix4;class Skeleton{constructor(w=[],D=[]){this.uuid=generateUUID(),this.bones=w.slice(0),this.boneInverses=D,this.boneMatrices=null,this.boneTexture=null,this.init()}init(){const w=this.bones,D=this.boneInverses;if(this.boneMatrices=new Float32Array(w.length*16),D.length===0)this.calculateInverses();else if(w.length!==D.length){warn("Skeleton: Number of inverse bone matrices does not match amount of bones."),this.boneInverses=[];for(let O=0,U=this.bones.length;O<U;O++)this.boneInverses.push(new Matrix4)}}calculateInverses(){this.boneInverses.length=0;for(let w=0,D=this.bones.length;w<D;w++){const O=new Matrix4;this.bones[w]&&O.copy(this.bones[w].matrixWorld).invert(),this.boneInverses.push(O)}}pose(){for(let w=0,D=this.bones.length;w<D;w++){const O=this.bones[w];O&&O.matrixWorld.copy(this.boneInverses[w]).invert()}for(let w=0,D=this.bones.length;w<D;w++){const O=this.bones[w];O&&(O.parent&&O.parent.isBone?(O.matrix.copy(O.parent.matrixWorld).invert(),O.matrix.multiply(O.matrixWorld)):O.matrix.copy(O.matrixWorld),O.matrix.decompose(O.position,O.quaternion,O.scale))}}update(){const w=this.bones,D=this.boneInverses,O=this.boneMatrices,U=this.boneTexture;for(let G=0,q=w.length;G<q;G++){const K=w[G]?w[G].matrixWorld:_identityMatrix$1;_offsetMatrix.multiplyMatrices(K,D[G]),_offsetMatrix.toArray(O,G*16)}U!==null&&(U.needsUpdate=!0)}clone(){return new Skeleton(this.bones,this.boneInverses)}computeBoneTexture(){let w=Math.sqrt(this.bones.length*4);w=Math.ceil(w/4)*4,w=Math.max(w,4);const D=new Float32Array(w*w*4);D.set(this.boneMatrices);const O=new DataTexture(D,w,w,RGBAFormat,FloatType);return O.needsUpdate=!0,this.boneMatrices=D,this.boneTexture=O,this}getBoneByName(w){for(let D=0,O=this.bones.length;D<O;D++){const U=this.bones[D];if(U.name===w)return U}}dispose(){this.boneTexture!==null&&(this.boneTexture.dispose(),this.boneTexture=null)}fromJSON(w,D){this.uuid=w.uuid;for(let O=0,U=w.bones.length;O<U;O++){const G=w.bones[O];let q=D[G];q===void 0&&(warn("Skeleton: No bone found with UUID:",G),q=new Bone),this.bones.push(q),this.boneInverses.push(new Matrix4().fromArray(w.boneInverses[O]))}return this.init(),this}toJSON(){const w={metadata:{version:4.7,type:"Skeleton",generator:"Skeleton.toJSON"},bones:[],boneInverses:[]};w.uuid=this.uuid;const D=this.bones,O=this.boneInverses;for(let U=0,G=D.length;U<G;U++){const q=D[U];w.bones.push(q.uuid);const K=O[U];w.boneInverses.push(K.toArray())}return w}}class InstancedBufferAttribute extends BufferAttribute{constructor(w,D,O,U=1){super(w,D,O),this.isInstancedBufferAttribute=!0,this.meshPerAttribute=U}copy(w){return super.copy(w),this.meshPerAttribute=w.meshPerAttribute,this}toJSON(){const w=super.toJSON();return w.meshPerAttribute=this.meshPerAttribute,w.isInstancedBufferAttribute=!0,w}}const _instanceLocalMatrix=new Matrix4,_instanceWorldMatrix=new Matrix4,_instanceIntersects=[],_box3=new Box3,_identity=new Matrix4,_mesh$1=new Mesh,_sphere$4=new Sphere;class InstancedMesh extends Mesh{constructor(w,D,O){super(w,D),this.isInstancedMesh=!0,this.instanceMatrix=new InstancedBufferAttribute(new Float32Array(O*16),16),this.instanceColor=null,this.morphTexture=null,this.count=O,this.boundingBox=null,this.boundingSphere=null;for(let U=0;U<O;U++)this.setMatrixAt(U,_identity)}computeBoundingBox(){const w=this.geometry,D=this.count;this.boundingBox===null&&(this.boundingBox=new Box3),w.boundingBox===null&&w.computeBoundingBox(),this.boundingBox.makeEmpty();for(let O=0;O<D;O++)this.getMatrixAt(O,_instanceLocalMatrix),_box3.copy(w.boundingBox).applyMatrix4(_instanceLocalMatrix),this.boundingBox.union(_box3)}computeBoundingSphere(){const w=this.geometry,D=this.count;this.boundingSphere===null&&(this.boundingSphere=new Sphere),w.boundingSphere===null&&w.computeBoundingSphere(),this.boundingSphere.makeEmpty();for(let O=0;O<D;O++)this.getMatrixAt(O,_instanceLocalMatrix),_sphere$4.copy(w.boundingSphere).applyMatrix4(_instanceLocalMatrix),this.boundingSphere.union(_sphere$4)}copy(w,D){return super.copy(w,D),this.instanceMatrix.copy(w.instanceMatrix),w.morphTexture!==null&&(this.morphTexture=w.morphTexture.clone()),w.instanceColor!==null&&(this.instanceColor=w.instanceColor.clone()),this.count=w.count,w.boundingBox!==null&&(this.boundingBox=w.boundingBox.clone()),w.boundingSphere!==null&&(this.boundingSphere=w.boundingSphere.clone()),this}getColorAt(w,D){D.fromArray(this.instanceColor.array,w*3)}getMatrixAt(w,D){D.fromArray(this.instanceMatrix.array,w*16)}getMorphAt(w,D){const O=D.morphTargetInfluences,U=this.morphTexture.source.data.data,G=O.length+1,q=w*G+1;for(let K=0;K<O.length;K++)O[K]=U[q+K]}raycast(w,D){const O=this.matrixWorld,U=this.count;if(_mesh$1.geometry=this.geometry,_mesh$1.material=this.material,_mesh$1.material!==void 0&&(this.boundingSphere===null&&this.computeBoundingSphere(),_sphere$4.copy(this.boundingSphere),_sphere$4.applyMatrix4(O),w.ray.intersectsSphere(_sphere$4)!==!1))for(let G=0;G<U;G++){this.getMatrixAt(G,_instanceLocalMatrix),_instanceWorldMatrix.multiplyMatrices(O,_instanceLocalMatrix),_mesh$1.matrixWorld=_instanceWorldMatrix,_mesh$1.raycast(w,_instanceIntersects);for(let q=0,K=_instanceIntersects.length;q<K;q++){const ee=_instanceIntersects[q];ee.instanceId=G,ee.object=this,D.push(ee)}_instanceIntersects.length=0}}setColorAt(w,D){this.instanceColor===null&&(this.instanceColor=new InstancedBufferAttribute(new Float32Array(this.instanceMatrix.count*3).fill(1),3)),D.toArray(this.instanceColor.array,w*3)}setMatrixAt(w,D){D.toArray(this.instanceMatrix.array,w*16)}setMorphAt(w,D){const O=D.morphTargetInfluences,U=O.length+1;this.morphTexture===null&&(this.morphTexture=new DataTexture(new Float32Array(U*this.count),U,this.count,RedFormat,FloatType));const G=this.morphTexture.source.data.data;let q=0;for(let Z=0;Z<O.length;Z++)q+=O[Z];const K=this.geometry.morphTargetsRelative?1:1-q,ee=U*w;G[ee]=K,G.set(O,ee+1)}updateMorphTargets(){}dispose(){this.dispatchEvent({type:"dispose"}),this.morphTexture!==null&&(this.morphTexture.dispose(),this.morphTexture=null)}}const _vector1=new Vector3,_vector2=new Vector3,_normalMatrix=new Matrix3;class Plane{constructor(w=new Vector3(1,0,0),D=0){this.isPlane=!0,this.normal=w,this.constant=D}set(w,D){return this.normal.copy(w),this.constant=D,this}setComponents(w,D,O,U){return this.normal.set(w,D,O),this.constant=U,this}setFromNormalAndCoplanarPoint(w,D){return this.normal.copy(w),this.constant=-D.dot(this.normal),this}setFromCoplanarPoints(w,D,O){const U=_vector1.subVectors(O,D).cross(_vector2.subVectors(w,D)).normalize();return this.setFromNormalAndCoplanarPoint(U,w),this}copy(w){return this.normal.copy(w.normal),this.constant=w.constant,this}normalize(){const w=1/this.normal.length();return this.normal.multiplyScalar(w),this.constant*=w,this}negate(){return this.constant*=-1,this.normal.negate(),this}distanceToPoint(w){return this.normal.dot(w)+this.constant}distanceToSphere(w){return this.distanceToPoint(w.center)-w.radius}projectPoint(w,D){return D.copy(w).addScaledVector(this.normal,-this.distanceToPoint(w))}intersectLine(w,D){const O=w.delta(_vector1),U=this.normal.dot(O);if(U===0)return this.distanceToPoint(w.start)===0?D.copy(w.start):null;const G=-(w.start.dot(this.normal)+this.constant)/U;return G<0||G>1?null:D.copy(w.start).addScaledVector(O,G)}intersectsLine(w){const D=this.distanceToPoint(w.start),O=this.distanceToPoint(w.end);return D<0&&O>0||O<0&&D>0}intersectsBox(w){return w.intersectsPlane(this)}intersectsSphere(w){return w.intersectsPlane(this)}coplanarPoint(w){return w.copy(this.normal).multiplyScalar(-this.constant)}applyMatrix4(w,D){const O=D||_normalMatrix.getNormalMatrix(w),U=this.coplanarPoint(_vector1).applyMatrix4(w),G=this.normal.applyMatrix3(O).normalize();return this.constant=-U.dot(G),this}translate(w){return this.constant-=w.dot(this.normal),this}equals(w){return w.normal.equals(this.normal)&&w.constant===this.constant}clone(){return new this.constructor().copy(this)}}const _sphere$3=new Sphere,_defaultSpriteCenter=new Vector2(.5,.5),_vector$6=new Vector3;class Frustum{constructor(w=new Plane,D=new Plane,O=new Plane,U=new Plane,G=new Plane,q=new Plane){this.planes=[w,D,O,U,G,q]}set(w,D,O,U,G,q){const K=this.planes;return K[0].copy(w),K[1].copy(D),K[2].copy(O),K[3].copy(U),K[4].copy(G),K[5].copy(q),this}copy(w){const D=this.planes;for(let O=0;O<6;O++)D[O].copy(w.planes[O]);return this}setFromProjectionMatrix(w,D=WebGLCoordinateSystem,O=!1){const U=this.planes,G=w.elements,q=G[0],K=G[1],ee=G[2],Z=G[3],ie=G[4],Y=G[5],W=G[6],ne=G[7],se=G[8],le=G[9],ce=G[10],he=G[11],pe=G[12],me=G[13],be=G[14],ge=G[15];if(U[0].setComponents(Z-q,ne-ie,he-se,ge-pe).normalize(),U[1].setComponents(Z+q,ne+ie,he+se,ge+pe).normalize(),U[2].setComponents(Z+K,ne+Y,he+le,ge+me).normalize(),U[3].setComponents(Z-K,ne-Y,he-le,ge-me).normalize(),O)U[4].setComponents(ee,W,ce,be).normalize(),U[5].setComponents(Z-ee,ne-W,he-ce,ge-be).normalize();else if(U[4].setComponents(Z-ee,ne-W,he-ce,ge-be).normalize(),D===WebGLCoordinateSystem)U[5].setComponents(Z+ee,ne+W,he+ce,ge+be).normalize();else if(D===WebGPUCoordinateSystem)U[5].setComponents(ee,W,ce,be).normalize();else throw new Error("THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: "+D);return this}intersectsObject(w){if(w.boundingSphere!==void 0)w.boundingSphere===null&&w.computeBoundingSphere(),_sphere$3.copy(w.boundingSphere).applyMatrix4(w.matrixWorld);else{const D=w.geometry;D.boundingSphere===null&&D.computeBoundingSphere(),_sphere$3.copy(D.boundingSphere).applyMatrix4(w.matrixWorld)}return this.intersectsSphere(_sphere$3)}intersectsSprite(w){_sphere$3.center.set(0,0,0);const D=_defaultSpriteCenter.distanceTo(w.center);return _sphere$3.radius=.7071067811865476+D,_sphere$3.applyMatrix4(w.matrixWorld),this.intersectsSphere(_sphere$3)}intersectsSphere(w){const D=this.planes,O=w.center,U=-w.radius;for(let G=0;G<6;G++)if(D[G].distanceToPoint(O)<U)return!1;return!0}intersectsBox(w){const D=this.planes;for(let O=0;O<6;O++){const U=D[O];if(_vector$6.x=U.normal.x>0?w.max.x:w.min.x,_vector$6.y=U.normal.y>0?w.max.y:w.min.y,_vector$6.z=U.normal.z>0?w.max.z:w.min.z,U.distanceToPoint(_vector$6)<0)return!1}return!0}containsPoint(w){const D=this.planes;for(let O=0;O<6;O++)if(D[O].distanceToPoint(w)<0)return!1;return!0}clone(){return new this.constructor().copy(this)}}class LineBasicMaterial extends Material$1{constructor(w){super(),this.isLineBasicMaterial=!0,this.type="LineBasicMaterial",this.color=new Color(16777215),this.map=null,this.linewidth=1,this.linecap="round",this.linejoin="round",this.fog=!0,this.setValues(w)}copy(w){return super.copy(w),this.color.copy(w.color),this.map=w.map,this.linewidth=w.linewidth,this.linecap=w.linecap,this.linejoin=w.linejoin,this.fog=w.fog,this}}const _vStart=new Vector3,_vEnd=new Vector3,_inverseMatrix$1=new Matrix4,_ray$1=new Ray,_sphere$1=new Sphere,_intersectPointOnRay=new Vector3,_intersectPointOnSegment=new Vector3;class Line extends Object3D{constructor(w=new BufferGeometry,D=new LineBasicMaterial){super(),this.isLine=!0,this.type="Line",this.geometry=w,this.material=D,this.morphTargetDictionary=void 0,this.morphTargetInfluences=void 0,this.updateMorphTargets()}copy(w,D){return super.copy(w,D),this.material=Array.isArray(w.material)?w.material.slice():w.material,this.geometry=w.geometry,this}computeLineDistances(){const w=this.geometry;if(w.index===null){const D=w.attributes.position,O=[0];for(let U=1,G=D.count;U<G;U++)_vStart.fromBufferAttribute(D,U-1),_vEnd.fromBufferAttribute(D,U),O[U]=O[U-1],O[U]+=_vStart.distanceTo(_vEnd);w.setAttribute("lineDistance",new Float32BufferAttribute(O,1))}else warn("Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");return this}raycast(w,D){const O=this.geometry,U=this.matrixWorld,G=w.params.Line.threshold,q=O.drawRange;if(O.boundingSphere===null&&O.computeBoundingSphere(),_sphere$1.copy(O.boundingSphere),_sphere$1.applyMatrix4(U),_sphere$1.radius+=G,w.ray.intersectsSphere(_sphere$1)===!1)return;_inverseMatrix$1.copy(U).invert(),_ray$1.copy(w.ray).applyMatrix4(_inverseMatrix$1);const K=G/((this.scale.x+this.scale.y+this.scale.z)/3),ee=K*K,Z=this.isLineSegments?2:1,ie=O.index,W=O.attributes.position;if(ie!==null){const ne=Math.max(0,q.start),se=Math.min(ie.count,q.start+q.count);for(let le=ne,ce=se-1;le<ce;le+=Z){const he=ie.getX(le),pe=ie.getX(le+1),me=checkIntersection(this,w,_ray$1,ee,he,pe,le);me&&D.push(me)}if(this.isLineLoop){const le=ie.getX(se-1),ce=ie.getX(ne),he=checkIntersection(this,w,_ray$1,ee,le,ce,se-1);he&&D.push(he)}}else{const ne=Math.max(0,q.start),se=Math.min(W.count,q.start+q.count);for(let le=ne,ce=se-1;le<ce;le+=Z){const he=checkIntersection(this,w,_ray$1,ee,le,le+1,le);he&&D.push(he)}if(this.isLineLoop){const le=checkIntersection(this,w,_ray$1,ee,se-1,ne,se-1);le&&D.push(le)}}}updateMorphTargets(){const D=this.geometry.morphAttributes,O=Object.keys(D);if(O.length>0){const U=D[O[0]];if(U!==void 0){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let G=0,q=U.length;G<q;G++){const K=U[G].name||String(G);this.morphTargetInfluences.push(0),this.morphTargetDictionary[K]=G}}}}}function checkIntersection(F,w,D,O,U,G,q){const K=F.geometry.attributes.position;if(_vStart.fromBufferAttribute(K,U),_vEnd.fromBufferAttribute(K,G),D.distanceSqToSegment(_vStart,_vEnd,_intersectPointOnRay,_intersectPointOnSegment)>O)return;_intersectPointOnRay.applyMatrix4(F.matrixWorld);const Z=w.ray.origin.distanceTo(_intersectPointOnRay);if(!(Z<w.near||Z>w.far))return{distance:Z,point:_intersectPointOnSegment.clone().applyMatrix4(F.matrixWorld),index:q,face:null,faceIndex:null,barycoord:null,object:F}}const _start=new Vector3,_end=new Vector3;class LineSegments extends Line{constructor(w,D){super(w,D),this.isLineSegments=!0,this.type="LineSegments"}computeLineDistances(){const w=this.geometry;if(w.index===null){const D=w.attributes.position,O=[];for(let U=0,G=D.count;U<G;U+=2)_start.fromBufferAttribute(D,U),_end.fromBufferAttribute(D,U+1),O[U]=U===0?0:O[U-1],O[U+1]=O[U]+_start.distanceTo(_end);w.setAttribute("lineDistance",new Float32BufferAttribute(O,1))}else warn("LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");return this}}class LineLoop extends Line{constructor(w,D){super(w,D),this.isLineLoop=!0,this.type="LineLoop"}}class PointsMaterial extends Material$1{constructor(w){super(),this.isPointsMaterial=!0,this.type="PointsMaterial",this.color=new Color(16777215),this.map=null,this.alphaMap=null,this.size=1,this.sizeAttenuation=!0,this.fog=!0,this.setValues(w)}copy(w){return super.copy(w),this.color.copy(w.color),this.map=w.map,this.alphaMap=w.alphaMap,this.size=w.size,this.sizeAttenuation=w.sizeAttenuation,this.fog=w.fog,this}}const _inverseMatrix=new Matrix4,_ray=new Ray,_sphere=new Sphere,_position$2=new Vector3;class Points extends Object3D{constructor(w=new BufferGeometry,D=new PointsMaterial){super(),this.isPoints=!0,this.type="Points",this.geometry=w,this.material=D,this.morphTargetDictionary=void 0,this.morphTargetInfluences=void 0,this.updateMorphTargets()}copy(w,D){return super.copy(w,D),this.material=Array.isArray(w.material)?w.material.slice():w.material,this.geometry=w.geometry,this}raycast(w,D){const O=this.geometry,U=this.matrixWorld,G=w.params.Points.threshold,q=O.drawRange;if(O.boundingSphere===null&&O.computeBoundingSphere(),_sphere.copy(O.boundingSphere),_sphere.applyMatrix4(U),_sphere.radius+=G,w.ray.intersectsSphere(_sphere)===!1)return;_inverseMatrix.copy(U).invert(),_ray.copy(w.ray).applyMatrix4(_inverseMatrix);const K=G/((this.scale.x+this.scale.y+this.scale.z)/3),ee=K*K,Z=O.index,Y=O.attributes.position;if(Z!==null){const W=Math.max(0,q.start),ne=Math.min(Z.count,q.start+q.count);for(let se=W,le=ne;se<le;se++){const ce=Z.getX(se);_position$2.fromBufferAttribute(Y,ce),testPoint(_position$2,ce,ee,U,w,D,this)}}else{const W=Math.max(0,q.start),ne=Math.min(Y.count,q.start+q.count);for(let se=W,le=ne;se<le;se++)_position$2.fromBufferAttribute(Y,se),testPoint(_position$2,se,ee,U,w,D,this)}}updateMorphTargets(){const D=this.geometry.morphAttributes,O=Object.keys(D);if(O.length>0){const U=D[O[0]];if(U!==void 0){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let G=0,q=U.length;G<q;G++){const K=U[G].name||String(G);this.morphTargetInfluences.push(0),this.morphTargetDictionary[K]=G}}}}}function testPoint(F,w,D,O,U,G,q){const K=_ray.distanceSqToPoint(F);if(K<D){const ee=new Vector3;_ray.closestPointToPoint(F,ee),ee.applyMatrix4(O);const Z=U.ray.origin.distanceTo(ee);if(Z<U.near||Z>U.far)return;G.push({distance:Z,distanceToRay:Math.sqrt(K),point:ee,index:w,face:null,faceIndex:null,barycoord:null,object:q})}}class VideoTexture extends Texture$1{constructor(w,D,O,U,G=LinearFilter,q=LinearFilter,K,ee,Z){super(w,D,O,U,G,q,K,ee,Z),this.isVideoTexture=!0,this.generateMipmaps=!1,this._requestVideoFrameCallbackId=0;const ie=this;function Y(){ie.needsUpdate=!0,ie._requestVideoFrameCallbackId=w.requestVideoFrameCallback(Y)}"requestVideoFrameCallback"in w&&(this._requestVideoFrameCallbackId=w.requestVideoFrameCallback(Y))}clone(){return new this.constructor(this.image).copy(this)}update(){const w=this.image;"requestVideoFrameCallback"in w===!1&&w.readyState>=w.HAVE_CURRENT_DATA&&(this.needsUpdate=!0)}dispose(){this._requestVideoFrameCallbackId!==0&&(this.source.data.cancelVideoFrameCallback(this._requestVideoFrameCallbackId),this._requestVideoFrameCallbackId=0),super.dispose()}}class CompressedTexture extends Texture$1{constructor(w,D,O,U,G,q,K,ee,Z,ie,Y,W){super(null,q,K,ee,Z,ie,U,G,Y,W),this.isCompressedTexture=!0,this.image={width:D,height:O},this.mipmaps=w,this.flipY=!1,this.generateMipmaps=!1}}class CompressedArrayTexture extends CompressedTexture{constructor(w,D,O,U,G,q){super(w,D,O,G,q),this.isCompressedArrayTexture=!0,this.image.depth=U,this.wrapR=ClampToEdgeWrapping,this.layerUpdates=new Set}addLayerUpdate(w){this.layerUpdates.add(w)}clearLayerUpdates(){this.layerUpdates.clear()}}class CompressedCubeTexture extends CompressedTexture{constructor(w,D,O){super(void 0,w[0].width,w[0].height,D,O,CubeReflectionMapping),this.isCompressedCubeTexture=!0,this.isCubeTexture=!0,this.image=w}}class CanvasTexture extends Texture$1{constructor(w,D,O,U,G,q,K,ee,Z){super(w,D,O,U,G,q,K,ee,Z),this.isCanvasTexture=!0,this.needsUpdate=!0}}class DepthTexture extends Texture$1{constructor(w,D,O=UnsignedIntType,U,G,q,K=NearestFilter,ee=NearestFilter,Z,ie=DepthFormat,Y=1){if(ie!==DepthFormat&&ie!==DepthStencilFormat)throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");const W={width:w,height:D,depth:Y};super(W,U,G,q,K,ee,ie,O,Z),this.isDepthTexture=!0,this.flipY=!1,this.generateMipmaps=!1,this.compareFunction=null}copy(w){return super.copy(w),this.source=new Source(Object.assign({},w.image)),this.compareFunction=w.compareFunction,this}toJSON(w){const D=super.toJSON(w);return this.compareFunction!==null&&(D.compareFunction=this.compareFunction),D}}class ExternalTexture extends Texture$1{constructor(w=null){super(),this.sourceTexture=w,this.isExternalTexture=!0}copy(w){return super.copy(w),this.sourceTexture=w.sourceTexture,this}}class PlaneGeometry extends BufferGeometry{constructor(w=1,D=1,O=1,U=1){super(),this.type="PlaneGeometry",this.parameters={width:w,height:D,widthSegments:O,heightSegments:U};const G=w/2,q=D/2,K=Math.floor(O),ee=Math.floor(U),Z=K+1,ie=ee+1,Y=w/K,W=D/ee,ne=[],se=[],le=[],ce=[];for(let he=0;he<ie;he++){const pe=he*W-q;for(let me=0;me<Z;me++){const be=me*Y-G;se.push(be,-pe,0),le.push(0,0,1),ce.push(me/K),ce.push(1-he/ee)}}for(let he=0;he<ee;he++)for(let pe=0;pe<K;pe++){const me=pe+Z*he,be=pe+Z*(he+1),ge=pe+1+Z*(he+1),ve=pe+1+Z*he;ne.push(me,be,ve),ne.push(be,ge,ve)}this.setIndex(ne),this.setAttribute("position",new Float32BufferAttribute(se,3)),this.setAttribute("normal",new Float32BufferAttribute(le,3)),this.setAttribute("uv",new Float32BufferAttribute(ce,2))}copy(w){return super.copy(w),this.parameters=Object.assign({},w.parameters),this}static fromJSON(w){return new PlaneGeometry(w.width,w.height,w.widthSegments,w.heightSegments)}}class SphereGeometry extends BufferGeometry{constructor(w=1,D=32,O=16,U=0,G=Math.PI*2,q=0,K=Math.PI){super(),this.type="SphereGeometry",this.parameters={radius:w,widthSegments:D,heightSegments:O,phiStart:U,phiLength:G,thetaStart:q,thetaLength:K},D=Math.max(3,Math.floor(D)),O=Math.max(2,Math.floor(O));const ee=Math.min(q+K,Math.PI);let Z=0;const ie=[],Y=new Vector3,W=new Vector3,ne=[],se=[],le=[],ce=[];for(let he=0;he<=O;he++){const pe=[],me=he/O;let be=0;he===0&&q===0?be=.5/D:he===O&&ee===Math.PI&&(be=-.5/D);for(let ge=0;ge<=D;ge++){const ve=ge/D;Y.x=-w*Math.cos(U+ve*G)*Math.sin(q+me*K),Y.y=w*Math.cos(q+me*K),Y.z=w*Math.sin(U+ve*G)*Math.sin(q+me*K),se.push(Y.x,Y.y,Y.z),W.copy(Y).normalize(),le.push(W.x,W.y,W.z),ce.push(ve+be,1-me),pe.push(Z++)}ie.push(pe)}for(let he=0;he<O;he++)for(let pe=0;pe<D;pe++){const me=ie[he][pe+1],be=ie[he][pe],ge=ie[he+1][pe],ve=ie[he+1][pe+1];(he!==0||q>0)&&ne.push(me,be,ve),(he!==O-1||ee<Math.PI)&&ne.push(be,ge,ve)}this.setIndex(ne),this.setAttribute("position",new Float32BufferAttribute(se,3)),this.setAttribute("normal",new Float32BufferAttribute(le,3)),this.setAttribute("uv",new Float32BufferAttribute(ce,2))}copy(w){return super.copy(w),this.parameters=Object.assign({},w.parameters),this}static fromJSON(w){return new SphereGeometry(w.radius,w.widthSegments,w.heightSegments,w.phiStart,w.phiLength,w.thetaStart,w.thetaLength)}}class MeshStandardMaterial extends Material$1{constructor(w){super(),this.isMeshStandardMaterial=!0,this.type="MeshStandardMaterial",this.defines={STANDARD:""},this.color=new Color(16777215),this.roughness=1,this.metalness=0,this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new Color(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=TangentSpaceNormalMap,this.normalScale=new Vector2(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.roughnessMap=null,this.metalnessMap=null,this.alphaMap=null,this.envMap=null,this.envMapRotation=new Euler,this.envMapIntensity=1,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.flatShading=!1,this.fog=!0,this.setValues(w)}copy(w){return super.copy(w),this.defines={STANDARD:""},this.color.copy(w.color),this.roughness=w.roughness,this.metalness=w.metalness,this.map=w.map,this.lightMap=w.lightMap,this.lightMapIntensity=w.lightMapIntensity,this.aoMap=w.aoMap,this.aoMapIntensity=w.aoMapIntensity,this.emissive.copy(w.emissive),this.emissiveMap=w.emissiveMap,this.emissiveIntensity=w.emissiveIntensity,this.bumpMap=w.bumpMap,this.bumpScale=w.bumpScale,this.normalMap=w.normalMap,this.normalMapType=w.normalMapType,this.normalScale.copy(w.normalScale),this.displacementMap=w.displacementMap,this.displacementScale=w.displacementScale,this.displacementBias=w.displacementBias,this.roughnessMap=w.roughnessMap,this.metalnessMap=w.metalnessMap,this.alphaMap=w.alphaMap,this.envMap=w.envMap,this.envMapRotation.copy(w.envMapRotation),this.envMapIntensity=w.envMapIntensity,this.wireframe=w.wireframe,this.wireframeLinewidth=w.wireframeLinewidth,this.wireframeLinecap=w.wireframeLinecap,this.wireframeLinejoin=w.wireframeLinejoin,this.flatShading=w.flatShading,this.fog=w.fog,this}}class MeshPhysicalMaterial extends MeshStandardMaterial{constructor(w){super(),this.isMeshPhysicalMaterial=!0,this.defines={STANDARD:"",PHYSICAL:""},this.type="MeshPhysicalMaterial",this.anisotropyRotation=0,this.anisotropyMap=null,this.clearcoatMap=null,this.clearcoatRoughness=0,this.clearcoatRoughnessMap=null,this.clearcoatNormalScale=new Vector2(1,1),this.clearcoatNormalMap=null,this.ior=1.5,Object.defineProperty(this,"reflectivity",{get:function(){return clamp$2(2.5*(this.ior-1)/(this.ior+1),0,1)},set:function(D){this.ior=(1+.4*D)/(1-.4*D)}}),this.iridescenceMap=null,this.iridescenceIOR=1.3,this.iridescenceThicknessRange=[100,400],this.iridescenceThicknessMap=null,this.sheenColor=new Color(0),this.sheenColorMap=null,this.sheenRoughness=1,this.sheenRoughnessMap=null,this.transmissionMap=null,this.thickness=0,this.thicknessMap=null,this.attenuationDistance=1/0,this.attenuationColor=new Color(1,1,1),this.specularIntensity=1,this.specularIntensityMap=null,this.specularColor=new Color(1,1,1),this.specularColorMap=null,this._anisotropy=0,this._clearcoat=0,this._dispersion=0,this._iridescence=0,this._sheen=0,this._transmission=0,this.setValues(w)}get anisotropy(){return this._anisotropy}set anisotropy(w){this._anisotropy>0!=w>0&&this.version++,this._anisotropy=w}get clearcoat(){return this._clearcoat}set clearcoat(w){this._clearcoat>0!=w>0&&this.version++,this._clearcoat=w}get iridescence(){return this._iridescence}set iridescence(w){this._iridescence>0!=w>0&&this.version++,this._iridescence=w}get dispersion(){return this._dispersion}set dispersion(w){this._dispersion>0!=w>0&&this.version++,this._dispersion=w}get sheen(){return this._sheen}set sheen(w){this._sheen>0!=w>0&&this.version++,this._sheen=w}get transmission(){return this._transmission}set transmission(w){this._transmission>0!=w>0&&this.version++,this._transmission=w}copy(w){return super.copy(w),this.defines={STANDARD:"",PHYSICAL:""},this.anisotropy=w.anisotropy,this.anisotropyRotation=w.anisotropyRotation,this.anisotropyMap=w.anisotropyMap,this.clearcoat=w.clearcoat,this.clearcoatMap=w.clearcoatMap,this.clearcoatRoughness=w.clearcoatRoughness,this.clearcoatRoughnessMap=w.clearcoatRoughnessMap,this.clearcoatNormalMap=w.clearcoatNormalMap,this.clearcoatNormalScale.copy(w.clearcoatNormalScale),this.dispersion=w.dispersion,this.ior=w.ior,this.iridescence=w.iridescence,this.iridescenceMap=w.iridescenceMap,this.iridescenceIOR=w.iridescenceIOR,this.iridescenceThicknessRange=[...w.iridescenceThicknessRange],this.iridescenceThicknessMap=w.iridescenceThicknessMap,this.sheen=w.sheen,this.sheenColor.copy(w.sheenColor),this.sheenColorMap=w.sheenColorMap,this.sheenRoughness=w.sheenRoughness,this.sheenRoughnessMap=w.sheenRoughnessMap,this.transmission=w.transmission,this.transmissionMap=w.transmissionMap,this.thickness=w.thickness,this.thicknessMap=w.thicknessMap,this.attenuationDistance=w.attenuationDistance,this.attenuationColor.copy(w.attenuationColor),this.specularIntensity=w.specularIntensity,this.specularIntensityMap=w.specularIntensityMap,this.specularColor.copy(w.specularColor),this.specularColorMap=w.specularColorMap,this}}class MeshDepthMaterial extends Material$1{constructor(w){super(),this.isMeshDepthMaterial=!0,this.type="MeshDepthMaterial",this.depthPacking=BasicDepthPacking,this.map=null,this.alphaMap=null,this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.wireframe=!1,this.wireframeLinewidth=1,this.setValues(w)}copy(w){return super.copy(w),this.depthPacking=w.depthPacking,this.map=w.map,this.alphaMap=w.alphaMap,this.displacementMap=w.displacementMap,this.displacementScale=w.displacementScale,this.displacementBias=w.displacementBias,this.wireframe=w.wireframe,this.wireframeLinewidth=w.wireframeLinewidth,this}}class MeshDistanceMaterial extends Material$1{constructor(w){super(),this.isMeshDistanceMaterial=!0,this.type="MeshDistanceMaterial",this.map=null,this.alphaMap=null,this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.setValues(w)}copy(w){return super.copy(w),this.map=w.map,this.alphaMap=w.alphaMap,this.displacementMap=w.displacementMap,this.displacementScale=w.displacementScale,this.displacementBias=w.displacementBias,this}}function convertArray(F,w){return!F||F.constructor===w?F:typeof w.BYTES_PER_ELEMENT=="number"?new w(F):Array.prototype.slice.call(F)}function isTypedArray$1(F){return ArrayBuffer.isView(F)&&!(F instanceof DataView)}function getKeyframeOrder(F){function w(U,G){return F[U]-F[G]}const D=F.length,O=new Array(D);for(let U=0;U!==D;++U)O[U]=U;return O.sort(w),O}function sortedArray(F,w,D){const O=F.length,U=new F.constructor(O);for(let G=0,q=0;q!==O;++G){const K=D[G]*w;for(let ee=0;ee!==w;++ee)U[q++]=F[K+ee]}return U}function flattenJSON(F,w,D,O){let U=1,G=F[0];for(;G!==void 0&&G[O]===void 0;)G=F[U++];if(G===void 0)return;let q=G[O];if(q!==void 0)if(Array.isArray(q))do q=G[O],q!==void 0&&(w.push(G.time),D.push(...q)),G=F[U++];while(G!==void 0);else if(q.toArray!==void 0)do q=G[O],q!==void 0&&(w.push(G.time),q.toArray(D,D.length)),G=F[U++];while(G!==void 0);else do q=G[O],q!==void 0&&(w.push(G.time),D.push(q)),G=F[U++];while(G!==void 0)}class Interpolant{constructor(w,D,O,U){this.parameterPositions=w,this._cachedIndex=0,this.resultBuffer=U!==void 0?U:new D.constructor(O),this.sampleValues=D,this.valueSize=O,this.settings=null,this.DefaultSettings_={}}evaluate(w){const D=this.parameterPositions;let O=this._cachedIndex,U=D[O],G=D[O-1];e:{t:{let q;n:{i:if(!(w<U)){for(let K=O+2;;){if(U===void 0){if(w<G)break i;return O=D.length,this._cachedIndex=O,this.copySampleValue_(O-1)}if(O===K)break;if(G=U,U=D[++O],w<U)break t}q=D.length;break n}if(!(w>=G)){const K=D[1];w<K&&(O=2,G=K);for(let ee=O-2;;){if(G===void 0)return this._cachedIndex=0,this.copySampleValue_(0);if(O===ee)break;if(U=G,G=D[--O-1],w>=G)break t}q=O,O=0;break n}break e}for(;O<q;){const K=O+q>>>1;w<D[K]?q=K:O=K+1}if(U=D[O],G=D[O-1],G===void 0)return this._cachedIndex=0,this.copySampleValue_(0);if(U===void 0)return O=D.length,this._cachedIndex=O,this.copySampleValue_(O-1)}this._cachedIndex=O,this.intervalChanged_(O,G,U)}return this.interpolate_(O,G,w,U)}getSettings_(){return this.settings||this.DefaultSettings_}copySampleValue_(w){const D=this.resultBuffer,O=this.sampleValues,U=this.valueSize,G=w*U;for(let q=0;q!==U;++q)D[q]=O[G+q];return D}interpolate_(){throw new Error("call to abstract method")}intervalChanged_(){}}class CubicInterpolant extends Interpolant{constructor(w,D,O,U){super(w,D,O,U),this._weightPrev=-0,this._offsetPrev=-0,this._weightNext=-0,this._offsetNext=-0,this.DefaultSettings_={endingStart:ZeroCurvatureEnding,endingEnd:ZeroCurvatureEnding}}intervalChanged_(w,D,O){const U=this.parameterPositions;let G=w-2,q=w+1,K=U[G],ee=U[q];if(K===void 0)switch(this.getSettings_().endingStart){case ZeroSlopeEnding:G=w,K=2*D-O;break;case WrapAroundEnding:G=U.length-2,K=D+U[G]-U[G+1];break;default:G=w,K=O}if(ee===void 0)switch(this.getSettings_().endingEnd){case ZeroSlopeEnding:q=w,ee=2*O-D;break;case WrapAroundEnding:q=1,ee=O+U[1]-U[0];break;default:q=w-1,ee=D}const Z=(O-D)*.5,ie=this.valueSize;this._weightPrev=Z/(D-K),this._weightNext=Z/(ee-O),this._offsetPrev=G*ie,this._offsetNext=q*ie}interpolate_(w,D,O,U){const G=this.resultBuffer,q=this.sampleValues,K=this.valueSize,ee=w*K,Z=ee-K,ie=this._offsetPrev,Y=this._offsetNext,W=this._weightPrev,ne=this._weightNext,se=(O-D)/(U-D),le=se*se,ce=le*se,he=-W*ce+2*W*le-W*se,pe=(1+W)*ce+(-1.5-2*W)*le+(-.5+W)*se+1,me=(-1-ne)*ce+(1.5+ne)*le+.5*se,be=ne*ce-ne*le;for(let ge=0;ge!==K;++ge)G[ge]=he*q[ie+ge]+pe*q[Z+ge]+me*q[ee+ge]+be*q[Y+ge];return G}}class LinearInterpolant extends Interpolant{constructor(w,D,O,U){super(w,D,O,U)}interpolate_(w,D,O,U){const G=this.resultBuffer,q=this.sampleValues,K=this.valueSize,ee=w*K,Z=ee-K,ie=(O-D)/(U-D),Y=1-ie;for(let W=0;W!==K;++W)G[W]=q[Z+W]*Y+q[ee+W]*ie;return G}}class DiscreteInterpolant extends Interpolant{constructor(w,D,O,U){super(w,D,O,U)}interpolate_(w){return this.copySampleValue_(w-1)}}class KeyframeTrack{constructor(w,D,O,U){if(w===void 0)throw new Error("THREE.KeyframeTrack: track name is undefined");if(D===void 0||D.length===0)throw new Error("THREE.KeyframeTrack: no keyframes in track named "+w);this.name=w,this.times=convertArray(D,this.TimeBufferType),this.values=convertArray(O,this.ValueBufferType),this.setInterpolation(U||this.DefaultInterpolation)}static toJSON(w){const D=w.constructor;let O;if(D.toJSON!==this.toJSON)O=D.toJSON(w);else{O={name:w.name,times:convertArray(w.times,Array),values:convertArray(w.values,Array)};const U=w.getInterpolation();U!==w.DefaultInterpolation&&(O.interpolation=U)}return O.type=w.ValueTypeName,O}InterpolantFactoryMethodDiscrete(w){return new DiscreteInterpolant(this.times,this.values,this.getValueSize(),w)}InterpolantFactoryMethodLinear(w){return new LinearInterpolant(this.times,this.values,this.getValueSize(),w)}InterpolantFactoryMethodSmooth(w){return new CubicInterpolant(this.times,this.values,this.getValueSize(),w)}setInterpolation(w){let D;switch(w){case InterpolateDiscrete:D=this.InterpolantFactoryMethodDiscrete;break;case InterpolateLinear:D=this.InterpolantFactoryMethodLinear;break;case InterpolateSmooth:D=this.InterpolantFactoryMethodSmooth;break}if(D===void 0){const O="unsupported interpolation for "+this.ValueTypeName+" keyframe track named "+this.name;if(this.createInterpolant===void 0)if(w!==this.DefaultInterpolation)this.setInterpolation(this.DefaultInterpolation);else throw new Error(O);return warn("KeyframeTrack:",O),this}return this.createInterpolant=D,this}getInterpolation(){switch(this.createInterpolant){case this.InterpolantFactoryMethodDiscrete:return InterpolateDiscrete;case this.InterpolantFactoryMethodLinear:return InterpolateLinear;case this.InterpolantFactoryMethodSmooth:return InterpolateSmooth}}getValueSize(){return this.values.length/this.times.length}shift(w){if(w!==0){const D=this.times;for(let O=0,U=D.length;O!==U;++O)D[O]+=w}return this}scale(w){if(w!==1){const D=this.times;for(let O=0,U=D.length;O!==U;++O)D[O]*=w}return this}trim(w,D){const O=this.times,U=O.length;let G=0,q=U-1;for(;G!==U&&O[G]<w;)++G;for(;q!==-1&&O[q]>D;)--q;if(++q,G!==0||q!==U){G>=q&&(q=Math.max(q,1),G=q-1);const K=this.getValueSize();this.times=O.slice(G,q),this.values=this.values.slice(G*K,q*K)}return this}validate(){let w=!0;const D=this.getValueSize();D-Math.floor(D)!==0&&(error("KeyframeTrack: Invalid value size in track.",this),w=!1);const O=this.times,U=this.values,G=O.length;G===0&&(error("KeyframeTrack: Track is empty.",this),w=!1);let q=null;for(let K=0;K!==G;K++){const ee=O[K];if(typeof ee=="number"&&isNaN(ee)){error("KeyframeTrack: Time is not a valid number.",this,K,ee),w=!1;break}if(q!==null&&q>ee){error("KeyframeTrack: Out of order keys.",this,K,ee,q),w=!1;break}q=ee}if(U!==void 0&&isTypedArray$1(U))for(let K=0,ee=U.length;K!==ee;++K){const Z=U[K];if(isNaN(Z)){error("KeyframeTrack: Value is not a valid number.",this,K,Z),w=!1;break}}return w}optimize(){const w=this.times.slice(),D=this.values.slice(),O=this.getValueSize(),U=this.getInterpolation()===InterpolateSmooth,G=w.length-1;let q=1;for(let K=1;K<G;++K){let ee=!1;const Z=w[K],ie=w[K+1];if(Z!==ie&&(K!==1||Z!==w[0]))if(U)ee=!0;else{const Y=K*O,W=Y-O,ne=Y+O;for(let se=0;se!==O;++se){const le=D[Y+se];if(le!==D[W+se]||le!==D[ne+se]){ee=!0;break}}}if(ee){if(K!==q){w[q]=w[K];const Y=K*O,W=q*O;for(let ne=0;ne!==O;++ne)D[W+ne]=D[Y+ne]}++q}}if(G>0){w[q]=w[G];for(let K=G*O,ee=q*O,Z=0;Z!==O;++Z)D[ee+Z]=D[K+Z];++q}return q!==w.length?(this.times=w.slice(0,q),this.values=D.slice(0,q*O)):(this.times=w,this.values=D),this}clone(){const w=this.times.slice(),D=this.values.slice(),O=this.constructor,U=new O(this.name,w,D);return U.createInterpolant=this.createInterpolant,U}}KeyframeTrack.prototype.ValueTypeName="";KeyframeTrack.prototype.TimeBufferType=Float32Array;KeyframeTrack.prototype.ValueBufferType=Float32Array;KeyframeTrack.prototype.DefaultInterpolation=InterpolateLinear;class BooleanKeyframeTrack extends KeyframeTrack{constructor(w,D,O){super(w,D,O)}}BooleanKeyframeTrack.prototype.ValueTypeName="bool";BooleanKeyframeTrack.prototype.ValueBufferType=Array;BooleanKeyframeTrack.prototype.DefaultInterpolation=InterpolateDiscrete;BooleanKeyframeTrack.prototype.InterpolantFactoryMethodLinear=void 0;BooleanKeyframeTrack.prototype.InterpolantFactoryMethodSmooth=void 0;class ColorKeyframeTrack extends KeyframeTrack{constructor(w,D,O,U){super(w,D,O,U)}}ColorKeyframeTrack.prototype.ValueTypeName="color";class NumberKeyframeTrack extends KeyframeTrack{constructor(w,D,O,U){super(w,D,O,U)}}NumberKeyframeTrack.prototype.ValueTypeName="number";class QuaternionLinearInterpolant extends Interpolant{constructor(w,D,O,U){super(w,D,O,U)}interpolate_(w,D,O,U){const G=this.resultBuffer,q=this.sampleValues,K=this.valueSize,ee=(O-D)/(U-D);let Z=w*K;for(let ie=Z+K;Z!==ie;Z+=4)Quaternion.slerpFlat(G,0,q,Z-K,q,Z,ee);return G}}class QuaternionKeyframeTrack extends KeyframeTrack{constructor(w,D,O,U){super(w,D,O,U)}InterpolantFactoryMethodLinear(w){return new QuaternionLinearInterpolant(this.times,this.values,this.getValueSize(),w)}}QuaternionKeyframeTrack.prototype.ValueTypeName="quaternion";QuaternionKeyframeTrack.prototype.InterpolantFactoryMethodSmooth=void 0;class StringKeyframeTrack extends KeyframeTrack{constructor(w,D,O){super(w,D,O)}}StringKeyframeTrack.prototype.ValueTypeName="string";StringKeyframeTrack.prototype.ValueBufferType=Array;StringKeyframeTrack.prototype.DefaultInterpolation=InterpolateDiscrete;StringKeyframeTrack.prototype.InterpolantFactoryMethodLinear=void 0;StringKeyframeTrack.prototype.InterpolantFactoryMethodSmooth=void 0;class VectorKeyframeTrack extends KeyframeTrack{constructor(w,D,O,U){super(w,D,O,U)}}VectorKeyframeTrack.prototype.ValueTypeName="vector";class AnimationClip{constructor(w="",D=-1,O=[],U=NormalAnimationBlendMode){this.name=w,this.tracks=O,this.duration=D,this.blendMode=U,this.uuid=generateUUID(),this.userData={},this.duration<0&&this.resetDuration()}static parse(w){const D=[],O=w.tracks,U=1/(w.fps||1);for(let q=0,K=O.length;q!==K;++q)D.push(parseKeyframeTrack(O[q]).scale(U));const G=new this(w.name,w.duration,D,w.blendMode);return G.uuid=w.uuid,G.userData=JSON.parse(w.userData||"{}"),G}static toJSON(w){const D=[],O=w.tracks,U={name:w.name,duration:w.duration,tracks:D,uuid:w.uuid,blendMode:w.blendMode,userData:JSON.stringify(w.userData)};for(let G=0,q=O.length;G!==q;++G)D.push(KeyframeTrack.toJSON(O[G]));return U}static CreateFromMorphTargetSequence(w,D,O,U){const G=D.length,q=[];for(let K=0;K<G;K++){let ee=[],Z=[];ee.push((K+G-1)%G,K,(K+1)%G),Z.push(0,1,0);const ie=getKeyframeOrder(ee);ee=sortedArray(ee,1,ie),Z=sortedArray(Z,1,ie),!U&&ee[0]===0&&(ee.push(G),Z.push(Z[0])),q.push(new NumberKeyframeTrack(".morphTargetInfluences["+D[K].name+"]",ee,Z).scale(1/O))}return new this(w,-1,q)}static findByName(w,D){let O=w;if(!Array.isArray(w)){const U=w;O=U.geometry&&U.geometry.animations||U.animations}for(let U=0;U<O.length;U++)if(O[U].name===D)return O[U];return null}static CreateClipsFromMorphTargetSequences(w,D,O){const U={},G=/^([\w-]*?)([\d]+)$/;for(let K=0,ee=w.length;K<ee;K++){const Z=w[K],ie=Z.name.match(G);if(ie&&ie.length>1){const Y=ie[1];let W=U[Y];W||(U[Y]=W=[]),W.push(Z)}}const q=[];for(const K in U)q.push(this.CreateFromMorphTargetSequence(K,U[K],D,O));return q}static parseAnimation(w,D){if(warn("AnimationClip: parseAnimation() is deprecated and will be removed with r185"),!w)return error("AnimationClip: No animation in JSONLoader data."),null;const O=function(Y,W,ne,se,le){if(ne.length!==0){const ce=[],he=[];flattenJSON(ne,ce,he,se),ce.length!==0&&le.push(new Y(W,ce,he))}},U=[],G=w.name||"default",q=w.fps||30,K=w.blendMode;let ee=w.length||-1;const Z=w.hierarchy||[];for(let Y=0;Y<Z.length;Y++){const W=Z[Y].keys;if(!(!W||W.length===0))if(W[0].morphTargets){const ne={};let se;for(se=0;se<W.length;se++)if(W[se].morphTargets)for(let le=0;le<W[se].morphTargets.length;le++)ne[W[se].morphTargets[le]]=-1;for(const le in ne){const ce=[],he=[];for(let pe=0;pe!==W[se].morphTargets.length;++pe){const me=W[se];ce.push(me.time),he.push(me.morphTarget===le?1:0)}U.push(new NumberKeyframeTrack(".morphTargetInfluence["+le+"]",ce,he))}ee=ne.length*q}else{const ne=".bones["+D[Y].name+"]";O(VectorKeyframeTrack,ne+".position",W,"pos",U),O(QuaternionKeyframeTrack,ne+".quaternion",W,"rot",U),O(VectorKeyframeTrack,ne+".scale",W,"scl",U)}}return U.length===0?null:new this(G,ee,U,K)}resetDuration(){const w=this.tracks;let D=0;for(let O=0,U=w.length;O!==U;++O){const G=this.tracks[O];D=Math.max(D,G.times[G.times.length-1])}return this.duration=D,this}trim(){for(let w=0;w<this.tracks.length;w++)this.tracks[w].trim(0,this.duration);return this}validate(){let w=!0;for(let D=0;D<this.tracks.length;D++)w=w&&this.tracks[D].validate();return w}optimize(){for(let w=0;w<this.tracks.length;w++)this.tracks[w].optimize();return this}clone(){const w=[];for(let O=0;O<this.tracks.length;O++)w.push(this.tracks[O].clone());const D=new this.constructor(this.name,this.duration,w,this.blendMode);return D.userData=JSON.parse(JSON.stringify(this.userData)),D}toJSON(){return this.constructor.toJSON(this)}}function getTrackTypeForValueTypeName(F){switch(F.toLowerCase()){case"scalar":case"double":case"float":case"number":case"integer":return NumberKeyframeTrack;case"vector":case"vector2":case"vector3":case"vector4":return VectorKeyframeTrack;case"color":return ColorKeyframeTrack;case"quaternion":return QuaternionKeyframeTrack;case"bool":case"boolean":return BooleanKeyframeTrack;case"string":return StringKeyframeTrack}throw new Error("THREE.KeyframeTrack: Unsupported typeName: "+F)}function parseKeyframeTrack(F){if(F.type===void 0)throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");const w=getTrackTypeForValueTypeName(F.type);if(F.times===void 0){const D=[],O=[];flattenJSON(F.keys,D,O,"value"),F.times=D,F.values=O}return w.parse!==void 0?w.parse(F):new w(F.name,F.times,F.values,F.interpolation)}const Cache={enabled:!1,files:{},add:function(F,w){this.enabled!==!1&&(this.files[F]=w)},get:function(F){if(this.enabled!==!1)return this.files[F]},remove:function(F){delete this.files[F]},clear:function(){this.files={}}};class LoadingManager{constructor(w,D,O){const U=this;let G=!1,q=0,K=0,ee;const Z=[];this.onStart=void 0,this.onLoad=w,this.onProgress=D,this.onError=O,this._abortController=null,this.itemStart=function(ie){K++,G===!1&&U.onStart!==void 0&&U.onStart(ie,q,K),G=!0},this.itemEnd=function(ie){q++,U.onProgress!==void 0&&U.onProgress(ie,q,K),q===K&&(G=!1,U.onLoad!==void 0&&U.onLoad())},this.itemError=function(ie){U.onError!==void 0&&U.onError(ie)},this.resolveURL=function(ie){return ee?ee(ie):ie},this.setURLModifier=function(ie){return ee=ie,this},this.addHandler=function(ie,Y){return Z.push(ie,Y),this},this.removeHandler=function(ie){const Y=Z.indexOf(ie);return Y!==-1&&Z.splice(Y,2),this},this.getHandler=function(ie){for(let Y=0,W=Z.length;Y<W;Y+=2){const ne=Z[Y],se=Z[Y+1];if(ne.global&&(ne.lastIndex=0),ne.test(ie))return se}return null},this.abort=function(){return this.abortController.abort(),this._abortController=null,this}}get abortController(){return this._abortController||(this._abortController=new AbortController),this._abortController}}const DefaultLoadingManager=new LoadingManager;class Loader{constructor(w){this.manager=w!==void 0?w:DefaultLoadingManager,this.crossOrigin="anonymous",this.withCredentials=!1,this.path="",this.resourcePath="",this.requestHeader={}}load(){}loadAsync(w,D){const O=this;return new Promise(function(U,G){O.load(w,U,D,G)})}parse(){}setCrossOrigin(w){return this.crossOrigin=w,this}setWithCredentials(w){return this.withCredentials=w,this}setPath(w){return this.path=w,this}setResourcePath(w){return this.resourcePath=w,this}setRequestHeader(w){return this.requestHeader=w,this}abort(){return this}}Loader.DEFAULT_MATERIAL_NAME="__DEFAULT";const loading={};class HttpError extends Error{constructor(w,D){super(w),this.response=D}}class FileLoader extends Loader{constructor(w){super(w),this.mimeType="",this.responseType="",this._abortController=new AbortController}load(w,D,O,U){w===void 0&&(w=""),this.path!==void 0&&(w=this.path+w),w=this.manager.resolveURL(w);const G=Cache.get(`file:${w}`);if(G!==void 0)return this.manager.itemStart(w),setTimeout(()=>{D&&D(G),this.manager.itemEnd(w)},0),G;if(loading[w]!==void 0){loading[w].push({onLoad:D,onProgress:O,onError:U});return}loading[w]=[],loading[w].push({onLoad:D,onProgress:O,onError:U});const q=new Request(w,{headers:new Headers(this.requestHeader),credentials:this.withCredentials?"include":"same-origin",signal:typeof AbortSignal.any=="function"?AbortSignal.any([this._abortController.signal,this.manager.abortController.signal]):this._abortController.signal}),K=this.mimeType,ee=this.responseType;fetch(q).then(Z=>{if(Z.status===200||Z.status===0){if(Z.status===0&&warn("FileLoader: HTTP Status 0 received."),typeof ReadableStream>"u"||Z.body===void 0||Z.body.getReader===void 0)return Z;const ie=loading[w],Y=Z.body.getReader(),W=Z.headers.get("X-File-Size")||Z.headers.get("Content-Length"),ne=W?parseInt(W):0,se=ne!==0;let le=0;const ce=new ReadableStream({start(he){pe();function pe(){Y.read().then(({done:me,value:be})=>{if(me)he.close();else{le+=be.byteLength;const ge=new ProgressEvent("progress",{lengthComputable:se,loaded:le,total:ne});for(let ve=0,Se=ie.length;ve<Se;ve++){const Me=ie[ve];Me.onProgress&&Me.onProgress(ge)}he.enqueue(be),pe()}},me=>{he.error(me)})}}});return new Response(ce)}else throw new HttpError(`fetch for "${Z.url}" responded with ${Z.status}: ${Z.statusText}`,Z)}).then(Z=>{switch(ee){case"arraybuffer":return Z.arrayBuffer();case"blob":return Z.blob();case"document":return Z.text().then(ie=>new DOMParser().parseFromString(ie,K));case"json":return Z.json();default:if(K==="")return Z.text();{const Y=/charset="?([^;"\s]*)"?/i.exec(K),W=Y&&Y[1]?Y[1].toLowerCase():void 0,ne=new TextDecoder(W);return Z.arrayBuffer().then(se=>ne.decode(se))}}}).then(Z=>{Cache.add(`file:${w}`,Z);const ie=loading[w];delete loading[w];for(let Y=0,W=ie.length;Y<W;Y++){const ne=ie[Y];ne.onLoad&&ne.onLoad(Z)}}).catch(Z=>{const ie=loading[w];if(ie===void 0)throw this.manager.itemError(w),Z;delete loading[w];for(let Y=0,W=ie.length;Y<W;Y++){const ne=ie[Y];ne.onError&&ne.onError(Z)}this.manager.itemError(w)}).finally(()=>{this.manager.itemEnd(w)}),this.manager.itemStart(w)}setResponseType(w){return this.responseType=w,this}setMimeType(w){return this.mimeType=w,this}abort(){return this._abortController.abort(),this._abortController=new AbortController,this}}const _loading=new WeakMap;class ImageLoader extends Loader{constructor(w){super(w)}load(w,D,O,U){this.path!==void 0&&(w=this.path+w),w=this.manager.resolveURL(w);const G=this,q=Cache.get(`image:${w}`);if(q!==void 0){if(q.complete===!0)G.manager.itemStart(w),setTimeout(function(){D&&D(q),G.manager.itemEnd(w)},0);else{let Y=_loading.get(q);Y===void 0&&(Y=[],_loading.set(q,Y)),Y.push({onLoad:D,onError:U})}return q}const K=createElementNS("img");function ee(){ie(),D&&D(this);const Y=_loading.get(this)||[];for(let W=0;W<Y.length;W++){const ne=Y[W];ne.onLoad&&ne.onLoad(this)}_loading.delete(this),G.manager.itemEnd(w)}function Z(Y){ie(),U&&U(Y),Cache.remove(`image:${w}`);const W=_loading.get(this)||[];for(let ne=0;ne<W.length;ne++){const se=W[ne];se.onError&&se.onError(Y)}_loading.delete(this),G.manager.itemError(w),G.manager.itemEnd(w)}function ie(){K.removeEventListener("load",ee,!1),K.removeEventListener("error",Z,!1)}return K.addEventListener("load",ee,!1),K.addEventListener("error",Z,!1),w.slice(0,5)!=="data:"&&this.crossOrigin!==void 0&&(K.crossOrigin=this.crossOrigin),Cache.add(`image:${w}`,K),G.manager.itemStart(w),K.src=w,K}}class DataTextureLoader extends Loader{constructor(w){super(w)}load(w,D,O,U){const G=this,q=new DataTexture,K=new FileLoader(this.manager);return K.setResponseType("arraybuffer"),K.setRequestHeader(this.requestHeader),K.setPath(this.path),K.setWithCredentials(G.withCredentials),K.load(w,function(ee){let Z;try{Z=G.parse(ee)}catch(ie){if(U!==void 0)U(ie);else{ie(ie);return}}Z.image!==void 0?q.image=Z.image:Z.data!==void 0&&(q.image.width=Z.width,q.image.height=Z.height,q.image.data=Z.data),q.wrapS=Z.wrapS!==void 0?Z.wrapS:ClampToEdgeWrapping,q.wrapT=Z.wrapT!==void 0?Z.wrapT:ClampToEdgeWrapping,q.magFilter=Z.magFilter!==void 0?Z.magFilter:LinearFilter,q.minFilter=Z.minFilter!==void 0?Z.minFilter:LinearFilter,q.anisotropy=Z.anisotropy!==void 0?Z.anisotropy:1,Z.colorSpace!==void 0&&(q.colorSpace=Z.colorSpace),Z.flipY!==void 0&&(q.flipY=Z.flipY),Z.format!==void 0&&(q.format=Z.format),Z.type!==void 0&&(q.type=Z.type),Z.mipmaps!==void 0&&(q.mipmaps=Z.mipmaps,q.minFilter=LinearMipmapLinearFilter),Z.mipmapCount===1&&(q.minFilter=LinearFilter),Z.generateMipmaps!==void 0&&(q.generateMipmaps=Z.generateMipmaps),q.needsUpdate=!0,D&&D(q,Z)},O,U),q}}class TextureLoader extends Loader{constructor(w){super(w)}load(w,D,O,U){const G=new Texture$1,q=new ImageLoader(this.manager);return q.setCrossOrigin(this.crossOrigin),q.setPath(this.path),q.load(w,function(K){G.image=K,G.needsUpdate=!0,D!==void 0&&D(G)},O,U),G}}class Light extends Object3D{constructor(w,D=1){super(),this.isLight=!0,this.type="Light",this.color=new Color(w),this.intensity=D}dispose(){}copy(w,D){return super.copy(w,D),this.color.copy(w.color),this.intensity=w.intensity,this}toJSON(w){const D=super.toJSON(w);return D.object.color=this.color.getHex(),D.object.intensity=this.intensity,this.groundColor!==void 0&&(D.object.groundColor=this.groundColor.getHex()),this.distance!==void 0&&(D.object.distance=this.distance),this.angle!==void 0&&(D.object.angle=this.angle),this.decay!==void 0&&(D.object.decay=this.decay),this.penumbra!==void 0&&(D.object.penumbra=this.penumbra),this.shadow!==void 0&&(D.object.shadow=this.shadow.toJSON()),this.target!==void 0&&(D.object.target=this.target.uuid),D}}const _projScreenMatrix$1=new Matrix4,_lightPositionWorld$1=new Vector3,_lookTarget$1=new Vector3;class LightShadow{constructor(w){this.camera=w,this.intensity=1,this.bias=0,this.normalBias=0,this.radius=1,this.blurSamples=8,this.mapSize=new Vector2(512,512),this.mapType=UnsignedByteType,this.map=null,this.mapPass=null,this.matrix=new Matrix4,this.autoUpdate=!0,this.needsUpdate=!1,this._frustum=new Frustum,this._frameExtents=new Vector2(1,1),this._viewportCount=1,this._viewports=[new Vector4(0,0,1,1)]}getViewportCount(){return this._viewportCount}getFrustum(){return this._frustum}updateMatrices(w){const D=this.camera,O=this.matrix;_lightPositionWorld$1.setFromMatrixPosition(w.matrixWorld),D.position.copy(_lightPositionWorld$1),_lookTarget$1.setFromMatrixPosition(w.target.matrixWorld),D.lookAt(_lookTarget$1),D.updateMatrixWorld(),_projScreenMatrix$1.multiplyMatrices(D.projectionMatrix,D.matrixWorldInverse),this._frustum.setFromProjectionMatrix(_projScreenMatrix$1,D.coordinateSystem,D.reversedDepth),D.reversedDepth?O.set(.5,0,0,.5,0,.5,0,.5,0,0,1,0,0,0,0,1):O.set(.5,0,0,.5,0,.5,0,.5,0,0,.5,.5,0,0,0,1),O.multiply(_projScreenMatrix$1)}getViewport(w){return this._viewports[w]}getFrameExtents(){return this._frameExtents}dispose(){this.map&&this.map.dispose(),this.mapPass&&this.mapPass.dispose()}copy(w){return this.camera=w.camera.clone(),this.intensity=w.intensity,this.bias=w.bias,this.radius=w.radius,this.autoUpdate=w.autoUpdate,this.needsUpdate=w.needsUpdate,this.normalBias=w.normalBias,this.blurSamples=w.blurSamples,this.mapSize.copy(w.mapSize),this}clone(){return new this.constructor().copy(this)}toJSON(){const w={};return this.intensity!==1&&(w.intensity=this.intensity),this.bias!==0&&(w.bias=this.bias),this.normalBias!==0&&(w.normalBias=this.normalBias),this.radius!==1&&(w.radius=this.radius),(this.mapSize.x!==512||this.mapSize.y!==512)&&(w.mapSize=this.mapSize.toArray()),w.camera=this.camera.toJSON(!1).object,delete w.camera.matrix,w}}class SpotLightShadow extends LightShadow{constructor(){super(new PerspectiveCamera(50,1,.5,500)),this.isSpotLightShadow=!0,this.focus=1,this.aspect=1}updateMatrices(w){const D=this.camera,O=RAD2DEG*2*w.angle*this.focus,U=this.mapSize.width/this.mapSize.height*this.aspect,G=w.distance||D.far;(O!==D.fov||U!==D.aspect||G!==D.far)&&(D.fov=O,D.aspect=U,D.far=G,D.updateProjectionMatrix()),super.updateMatrices(w)}copy(w){return super.copy(w),this.focus=w.focus,this}}class SpotLight extends Light{constructor(w,D,O=0,U=Math.PI/3,G=0,q=2){super(w,D),this.isSpotLight=!0,this.type="SpotLight",this.position.copy(Object3D.DEFAULT_UP),this.updateMatrix(),this.target=new Object3D,this.distance=O,this.angle=U,this.penumbra=G,this.decay=q,this.map=null,this.shadow=new SpotLightShadow}get power(){return this.intensity*Math.PI}set power(w){this.intensity=w/Math.PI}dispose(){this.shadow.dispose()}copy(w,D){return super.copy(w,D),this.distance=w.distance,this.angle=w.angle,this.penumbra=w.penumbra,this.decay=w.decay,this.target=w.target.clone(),this.shadow=w.shadow.clone(),this}}const _projScreenMatrix=new Matrix4,_lightPositionWorld=new Vector3,_lookTarget=new Vector3;class PointLightShadow extends LightShadow{constructor(){super(new PerspectiveCamera(90,1,.5,500)),this.isPointLightShadow=!0,this._frameExtents=new Vector2(4,2),this._viewportCount=6,this._viewports=[new Vector4(2,1,1,1),new Vector4(0,1,1,1),new Vector4(3,1,1,1),new Vector4(1,1,1,1),new Vector4(3,0,1,1),new Vector4(1,0,1,1)],this._cubeDirections=[new Vector3(1,0,0),new Vector3(-1,0,0),new Vector3(0,0,1),new Vector3(0,0,-1),new Vector3(0,1,0),new Vector3(0,-1,0)],this._cubeUps=[new Vector3(0,1,0),new Vector3(0,1,0),new Vector3(0,1,0),new Vector3(0,1,0),new Vector3(0,0,1),new Vector3(0,0,-1)]}updateMatrices(w,D=0){const O=this.camera,U=this.matrix,G=w.distance||O.far;G!==O.far&&(O.far=G,O.updateProjectionMatrix()),_lightPositionWorld.setFromMatrixPosition(w.matrixWorld),O.position.copy(_lightPositionWorld),_lookTarget.copy(O.position),_lookTarget.add(this._cubeDirections[D]),O.up.copy(this._cubeUps[D]),O.lookAt(_lookTarget),O.updateMatrixWorld(),U.makeTranslation(-_lightPositionWorld.x,-_lightPositionWorld.y,-_lightPositionWorld.z),_projScreenMatrix.multiplyMatrices(O.projectionMatrix,O.matrixWorldInverse),this._frustum.setFromProjectionMatrix(_projScreenMatrix,O.coordinateSystem,O.reversedDepth)}}class PointLight extends Light{constructor(w,D,O=0,U=2){super(w,D),this.isPointLight=!0,this.type="PointLight",this.distance=O,this.decay=U,this.shadow=new PointLightShadow}get power(){return this.intensity*4*Math.PI}set power(w){this.intensity=w/(4*Math.PI)}dispose(){this.shadow.dispose()}copy(w,D){return super.copy(w,D),this.distance=w.distance,this.decay=w.decay,this.shadow=w.shadow.clone(),this}}class OrthographicCamera extends Camera$1{constructor(w=-1,D=1,O=1,U=-1,G=.1,q=2e3){super(),this.isOrthographicCamera=!0,this.type="OrthographicCamera",this.zoom=1,this.view=null,this.left=w,this.right=D,this.top=O,this.bottom=U,this.near=G,this.far=q,this.updateProjectionMatrix()}copy(w,D){return super.copy(w,D),this.left=w.left,this.right=w.right,this.top=w.top,this.bottom=w.bottom,this.near=w.near,this.far=w.far,this.zoom=w.zoom,this.view=w.view===null?null:Object.assign({},w.view),this}setViewOffset(w,D,O,U,G,q){this.view===null&&(this.view={enabled:!0,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1}),this.view.enabled=!0,this.view.fullWidth=w,this.view.fullHeight=D,this.view.offsetX=O,this.view.offsetY=U,this.view.width=G,this.view.height=q,this.updateProjectionMatrix()}clearViewOffset(){this.view!==null&&(this.view.enabled=!1),this.updateProjectionMatrix()}updateProjectionMatrix(){const w=(this.right-this.left)/(2*this.zoom),D=(this.top-this.bottom)/(2*this.zoom),O=(this.right+this.left)/2,U=(this.top+this.bottom)/2;let G=O-w,q=O+w,K=U+D,ee=U-D;if(this.view!==null&&this.view.enabled){const Z=(this.right-this.left)/this.view.fullWidth/this.zoom,ie=(this.top-this.bottom)/this.view.fullHeight/this.zoom;G+=Z*this.view.offsetX,q=G+Z*this.view.width,K-=ie*this.view.offsetY,ee=K-ie*this.view.height}this.projectionMatrix.makeOrthographic(G,q,K,ee,this.near,this.far,this.coordinateSystem,this.reversedDepth),this.projectionMatrixInverse.copy(this.projectionMatrix).invert()}toJSON(w){const D=super.toJSON(w);return D.object.zoom=this.zoom,D.object.left=this.left,D.object.right=this.right,D.object.top=this.top,D.object.bottom=this.bottom,D.object.near=this.near,D.object.far=this.far,this.view!==null&&(D.object.view=Object.assign({},this.view)),D}}class DirectionalLightShadow extends LightShadow{constructor(){super(new OrthographicCamera(-5,5,5,-5,.5,500)),this.isDirectionalLightShadow=!0}}class DirectionalLight extends Light{constructor(w,D){super(w,D),this.isDirectionalLight=!0,this.type="DirectionalLight",this.position.copy(Object3D.DEFAULT_UP),this.updateMatrix(),this.target=new Object3D,this.shadow=new DirectionalLightShadow}dispose(){this.shadow.dispose()}copy(w){return super.copy(w),this.target=w.target.clone(),this.shadow=w.shadow.clone(),this}}class SphericalHarmonics3{constructor(){this.isSphericalHarmonics3=!0,this.coefficients=[];for(let w=0;w<9;w++)this.coefficients.push(new Vector3)}set(w){for(let D=0;D<9;D++)this.coefficients[D].copy(w[D]);return this}zero(){for(let w=0;w<9;w++)this.coefficients[w].set(0,0,0);return this}getAt(w,D){const O=w.x,U=w.y,G=w.z,q=this.coefficients;return D.copy(q[0]).multiplyScalar(.282095),D.addScaledVector(q[1],.488603*U),D.addScaledVector(q[2],.488603*G),D.addScaledVector(q[3],.488603*O),D.addScaledVector(q[4],1.092548*(O*U)),D.addScaledVector(q[5],1.092548*(U*G)),D.addScaledVector(q[6],.315392*(3*G*G-1)),D.addScaledVector(q[7],1.092548*(O*G)),D.addScaledVector(q[8],.546274*(O*O-U*U)),D}getIrradianceAt(w,D){const O=w.x,U=w.y,G=w.z,q=this.coefficients;return D.copy(q[0]).multiplyScalar(.886227),D.addScaledVector(q[1],2*.511664*U),D.addScaledVector(q[2],2*.511664*G),D.addScaledVector(q[3],2*.511664*O),D.addScaledVector(q[4],2*.429043*O*U),D.addScaledVector(q[5],2*.429043*U*G),D.addScaledVector(q[6],.743125*G*G-.247708),D.addScaledVector(q[7],2*.429043*O*G),D.addScaledVector(q[8],.429043*(O*O-U*U)),D}add(w){for(let D=0;D<9;D++)this.coefficients[D].add(w.coefficients[D]);return this}addScaledSH(w,D){for(let O=0;O<9;O++)this.coefficients[O].addScaledVector(w.coefficients[O],D);return this}scale(w){for(let D=0;D<9;D++)this.coefficients[D].multiplyScalar(w);return this}lerp(w,D){for(let O=0;O<9;O++)this.coefficients[O].lerp(w.coefficients[O],D);return this}equals(w){for(let D=0;D<9;D++)if(!this.coefficients[D].equals(w.coefficients[D]))return!1;return!0}copy(w){return this.set(w.coefficients)}clone(){return new this.constructor().copy(this)}fromArray(w,D=0){const O=this.coefficients;for(let U=0;U<9;U++)O[U].fromArray(w,D+U*3);return this}toArray(w=[],D=0){const O=this.coefficients;for(let U=0;U<9;U++)O[U].toArray(w,D+U*3);return w}static getBasisAt(w,D){const O=w.x,U=w.y,G=w.z;D[0]=.282095,D[1]=.488603*U,D[2]=.488603*G,D[3]=.488603*O,D[4]=1.092548*O*U,D[5]=1.092548*U*G,D[6]=.315392*(3*G*G-1),D[7]=1.092548*O*G,D[8]=.546274*(O*O-U*U)}}class LightProbe extends Light{constructor(w=new SphericalHarmonics3,D=1){super(void 0,D),this.isLightProbe=!0,this.sh=w}copy(w){return super.copy(w),this.sh.copy(w.sh),this}fromJSON(w){return this.intensity=w.intensity,this.sh.fromArray(w.sh),this}toJSON(w){const D=super.toJSON(w);return D.object.sh=this.sh.toArray(),D}}class LoaderUtils{static extractUrlBase(w){const D=w.lastIndexOf("/");return D===-1?"./":w.slice(0,D+1)}static resolveURL(w,D){return typeof w!="string"||w===""?"":(/^https?:\/\//i.test(D)&&/^\//.test(w)&&(D=D.replace(/(^https?:\/\/[^\/]+).*/i,"$1")),/^(https?:)?\/\//i.test(w)||/^data:.*,.*$/i.test(w)||/^blob:.*$/i.test(w)?w:D+w)}}const _errorMap=new WeakMap;class ImageBitmapLoader extends Loader{constructor(w){super(w),this.isImageBitmapLoader=!0,typeof createImageBitmap>"u"&&warn("ImageBitmapLoader: createImageBitmap() not supported."),typeof fetch>"u"&&warn("ImageBitmapLoader: fetch() not supported."),this.options={premultiplyAlpha:"none"},this._abortController=new AbortController}setOptions(w){return this.options=w,this}load(w,D,O,U){w===void 0&&(w=""),this.path!==void 0&&(w=this.path+w),w=this.manager.resolveURL(w);const G=this,q=Cache.get(`image-bitmap:${w}`);if(q!==void 0){if(G.manager.itemStart(w),q.then){q.then(Z=>{if(_errorMap.has(q)===!0)U&&U(_errorMap.get(q)),G.manager.itemError(w),G.manager.itemEnd(w);else return D&&D(Z),G.manager.itemEnd(w),Z});return}return setTimeout(function(){D&&D(q),G.manager.itemEnd(w)},0),q}const K={};K.credentials=this.crossOrigin==="anonymous"?"same-origin":"include",K.headers=this.requestHeader,K.signal=typeof AbortSignal.any=="function"?AbortSignal.any([this._abortController.signal,this.manager.abortController.signal]):this._abortController.signal;const ee=fetch(w,K).then(function(Z){return Z.blob()}).then(function(Z){return createImageBitmap(Z,Object.assign(G.options,{colorSpaceConversion:"none"}))}).then(function(Z){return Cache.add(`image-bitmap:${w}`,Z),D&&D(Z),G.manager.itemEnd(w),Z}).catch(function(Z){U&&U(Z),_errorMap.set(ee,Z),Cache.remove(`image-bitmap:${w}`),G.manager.itemError(w),G.manager.itemEnd(w)});Cache.add(`image-bitmap:${w}`,ee),G.manager.itemStart(w)}abort(){return this._abortController.abort(),this._abortController=new AbortController,this}}class ArrayCamera extends PerspectiveCamera{constructor(w=[]){super(),this.isArrayCamera=!0,this.isMultiViewCamera=!1,this.cameras=w}}class PropertyMixer{constructor(w,D,O){this.binding=w,this.valueSize=O;let U,G,q;switch(D){case"quaternion":U=this._slerp,G=this._slerpAdditive,q=this._setAdditiveIdentityQuaternion,this.buffer=new Float64Array(O*6),this._workIndex=5;break;case"string":case"bool":U=this._select,G=this._select,q=this._setAdditiveIdentityOther,this.buffer=new Array(O*5);break;default:U=this._lerp,G=this._lerpAdditive,q=this._setAdditiveIdentityNumeric,this.buffer=new Float64Array(O*5)}this._mixBufferRegion=U,this._mixBufferRegionAdditive=G,this._setIdentity=q,this._origIndex=3,this._addIndex=4,this.cumulativeWeight=0,this.cumulativeWeightAdditive=0,this.useCount=0,this.referenceCount=0}accumulate(w,D){const O=this.buffer,U=this.valueSize,G=w*U+U;let q=this.cumulativeWeight;if(q===0){for(let K=0;K!==U;++K)O[G+K]=O[K];q=D}else{q+=D;const K=D/q;this._mixBufferRegion(O,G,0,K,U)}this.cumulativeWeight=q}accumulateAdditive(w){const D=this.buffer,O=this.valueSize,U=O*this._addIndex;this.cumulativeWeightAdditive===0&&this._setIdentity(),this._mixBufferRegionAdditive(D,U,0,w,O),this.cumulativeWeightAdditive+=w}apply(w){const D=this.valueSize,O=this.buffer,U=w*D+D,G=this.cumulativeWeight,q=this.cumulativeWeightAdditive,K=this.binding;if(this.cumulativeWeight=0,this.cumulativeWeightAdditive=0,G<1){const ee=D*this._origIndex;this._mixBufferRegion(O,U,ee,1-G,D)}q>0&&this._mixBufferRegionAdditive(O,U,this._addIndex*D,1,D);for(let ee=D,Z=D+D;ee!==Z;++ee)if(O[ee]!==O[ee+D]){K.setValue(O,U);break}}saveOriginalState(){const w=this.binding,D=this.buffer,O=this.valueSize,U=O*this._origIndex;w.getValue(D,U);for(let G=O,q=U;G!==q;++G)D[G]=D[U+G%O];this._setIdentity(),this.cumulativeWeight=0,this.cumulativeWeightAdditive=0}restoreOriginalState(){const w=this.valueSize*3;this.binding.setValue(this.buffer,w)}_setAdditiveIdentityNumeric(){const w=this._addIndex*this.valueSize,D=w+this.valueSize;for(let O=w;O<D;O++)this.buffer[O]=0}_setAdditiveIdentityQuaternion(){this._setAdditiveIdentityNumeric(),this.buffer[this._addIndex*this.valueSize+3]=1}_setAdditiveIdentityOther(){const w=this._origIndex*this.valueSize,D=this._addIndex*this.valueSize;for(let O=0;O<this.valueSize;O++)this.buffer[D+O]=this.buffer[w+O]}_select(w,D,O,U,G){if(U>=.5)for(let q=0;q!==G;++q)w[D+q]=w[O+q]}_slerp(w,D,O,U){Quaternion.slerpFlat(w,D,w,D,w,O,U)}_slerpAdditive(w,D,O,U,G){const q=this._workIndex*G;Quaternion.multiplyQuaternionsFlat(w,q,w,D,w,O),Quaternion.slerpFlat(w,D,w,D,w,q,U)}_lerp(w,D,O,U,G){const q=1-U;for(let K=0;K!==G;++K){const ee=D+K;w[ee]=w[ee]*q+w[O+K]*U}}_lerpAdditive(w,D,O,U,G){for(let q=0;q!==G;++q){const K=D+q;w[K]=w[K]+w[O+q]*U}}}const _RESERVED_CHARS_RE="\\[\\]\\.:\\/",_reservedRe=new RegExp("["+_RESERVED_CHARS_RE+"]","g"),_wordChar="[^"+_RESERVED_CHARS_RE+"]",_wordCharOrDot="[^"+_RESERVED_CHARS_RE.replace("\\.","")+"]",_directoryRe=/((?:WC+[\/:])*)/.source.replace("WC",_wordChar),_nodeRe=/(WCOD+)?/.source.replace("WCOD",_wordCharOrDot),_objectRe=/(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC",_wordChar),_propertyRe=/\.(WC+)(?:\[(.+)\])?/.source.replace("WC",_wordChar),_trackRe=new RegExp("^"+_directoryRe+_nodeRe+_objectRe+_propertyRe+"$"),_supportedObjectNames=["material","materials","bones","map"];class Composite{constructor(w,D,O){const U=O||PropertyBinding.parseTrackName(D);this._targetGroup=w,this._bindings=w.subscribe_(D,U)}getValue(w,D){this.bind();const O=this._targetGroup.nCachedObjects_,U=this._bindings[O];U!==void 0&&U.getValue(w,D)}setValue(w,D){const O=this._bindings;for(let U=this._targetGroup.nCachedObjects_,G=O.length;U!==G;++U)O[U].setValue(w,D)}bind(){const w=this._bindings;for(let D=this._targetGroup.nCachedObjects_,O=w.length;D!==O;++D)w[D].bind()}unbind(){const w=this._bindings;for(let D=this._targetGroup.nCachedObjects_,O=w.length;D!==O;++D)w[D].unbind()}}class PropertyBinding{constructor(w,D,O){this.path=D,this.parsedPath=O||PropertyBinding.parseTrackName(D),this.node=PropertyBinding.findNode(w,this.parsedPath.nodeName),this.rootNode=w,this.getValue=this._getValue_unbound,this.setValue=this._setValue_unbound}static create(w,D,O){return w&&w.isAnimationObjectGroup?new PropertyBinding.Composite(w,D,O):new PropertyBinding(w,D,O)}static sanitizeNodeName(w){return w.replace(/\s/g,"_").replace(_reservedRe,"")}static parseTrackName(w){const D=_trackRe.exec(w);if(D===null)throw new Error("PropertyBinding: Cannot parse trackName: "+w);const O={nodeName:D[2],objectName:D[3],objectIndex:D[4],propertyName:D[5],propertyIndex:D[6]},U=O.nodeName&&O.nodeName.lastIndexOf(".");if(U!==void 0&&U!==-1){const G=O.nodeName.substring(U+1);_supportedObjectNames.indexOf(G)!==-1&&(O.nodeName=O.nodeName.substring(0,U),O.objectName=G)}if(O.propertyName===null||O.propertyName.length===0)throw new Error("PropertyBinding: can not parse propertyName from trackName: "+w);return O}static findNode(w,D){if(D===void 0||D===""||D==="."||D===-1||D===w.name||D===w.uuid)return w;if(w.skeleton){const O=w.skeleton.getBoneByName(D);if(O!==void 0)return O}if(w.children){const O=function(G){for(let q=0;q<G.length;q++){const K=G[q];if(K.name===D||K.uuid===D)return K;const ee=O(K.children);if(ee)return ee}return null},U=O(w.children);if(U)return U}return null}_getValue_unavailable(){}_setValue_unavailable(){}_getValue_direct(w,D){w[D]=this.targetObject[this.propertyName]}_getValue_array(w,D){const O=this.resolvedProperty;for(let U=0,G=O.length;U!==G;++U)w[D++]=O[U]}_getValue_arrayElement(w,D){w[D]=this.resolvedProperty[this.propertyIndex]}_getValue_toArray(w,D){this.resolvedProperty.toArray(w,D)}_setValue_direct(w,D){this.targetObject[this.propertyName]=w[D]}_setValue_direct_setNeedsUpdate(w,D){this.targetObject[this.propertyName]=w[D],this.targetObject.needsUpdate=!0}_setValue_direct_setMatrixWorldNeedsUpdate(w,D){this.targetObject[this.propertyName]=w[D],this.targetObject.matrixWorldNeedsUpdate=!0}_setValue_array(w,D){const O=this.resolvedProperty;for(let U=0,G=O.length;U!==G;++U)O[U]=w[D++]}_setValue_array_setNeedsUpdate(w,D){const O=this.resolvedProperty;for(let U=0,G=O.length;U!==G;++U)O[U]=w[D++];this.targetObject.needsUpdate=!0}_setValue_array_setMatrixWorldNeedsUpdate(w,D){const O=this.resolvedProperty;for(let U=0,G=O.length;U!==G;++U)O[U]=w[D++];this.targetObject.matrixWorldNeedsUpdate=!0}_setValue_arrayElement(w,D){this.resolvedProperty[this.propertyIndex]=w[D]}_setValue_arrayElement_setNeedsUpdate(w,D){this.resolvedProperty[this.propertyIndex]=w[D],this.targetObject.needsUpdate=!0}_setValue_arrayElement_setMatrixWorldNeedsUpdate(w,D){this.resolvedProperty[this.propertyIndex]=w[D],this.targetObject.matrixWorldNeedsUpdate=!0}_setValue_fromArray(w,D){this.resolvedProperty.fromArray(w,D)}_setValue_fromArray_setNeedsUpdate(w,D){this.resolvedProperty.fromArray(w,D),this.targetObject.needsUpdate=!0}_setValue_fromArray_setMatrixWorldNeedsUpdate(w,D){this.resolvedProperty.fromArray(w,D),this.targetObject.matrixWorldNeedsUpdate=!0}_getValue_unbound(w,D){this.bind(),this.getValue(w,D)}_setValue_unbound(w,D){this.bind(),this.setValue(w,D)}bind(){let w=this.node;const D=this.parsedPath,O=D.objectName,U=D.propertyName;let G=D.propertyIndex;if(w||(w=PropertyBinding.findNode(this.rootNode,D.nodeName),this.node=w),this.getValue=this._getValue_unavailable,this.setValue=this._setValue_unavailable,!w){warn("PropertyBinding: No target node found for track: "+this.path+".");return}if(O){let Z=D.objectIndex;switch(O){case"materials":if(!w.material){error("PropertyBinding: Can not bind to material as node does not have a material.",this);return}if(!w.material.materials){error("PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.",this);return}w=w.material.materials;break;case"bones":if(!w.skeleton){error("PropertyBinding: Can not bind to bones as node does not have a skeleton.",this);return}w=w.skeleton.bones;for(let ie=0;ie<w.length;ie++)if(w[ie].name===Z){Z=ie;break}break;case"map":if("map"in w){w=w.map;break}if(!w.material){error("PropertyBinding: Can not bind to material as node does not have a material.",this);return}if(!w.material.map){error("PropertyBinding: Can not bind to material.map as node.material does not have a map.",this);return}w=w.material.map;break;default:if(w[O]===void 0){error("PropertyBinding: Can not bind to objectName of node undefined.",this);return}w=w[O]}if(Z!==void 0){if(w[Z]===void 0){error("PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.",this,w);return}w=w[Z]}}const q=w[U];if(q===void 0){const Z=D.nodeName;error("PropertyBinding: Trying to update property for track: "+Z+"."+U+" but it wasn't found.",w);return}let K=this.Versioning.None;this.targetObject=w,w.isMaterial===!0?K=this.Versioning.NeedsUpdate:w.isObject3D===!0&&(K=this.Versioning.MatrixWorldNeedsUpdate);let ee=this.BindingType.Direct;if(G!==void 0){if(U==="morphTargetInfluences"){if(!w.geometry){error("PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.",this);return}if(!w.geometry.morphAttributes){error("PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.",this);return}w.morphTargetDictionary[G]!==void 0&&(G=w.morphTargetDictionary[G])}ee=this.BindingType.ArrayElement,this.resolvedProperty=q,this.propertyIndex=G}else q.fromArray!==void 0&&q.toArray!==void 0?(ee=this.BindingType.HasFromToArray,this.resolvedProperty=q):Array.isArray(q)?(ee=this.BindingType.EntireArray,this.resolvedProperty=q):this.propertyName=U;this.getValue=this.GetterByBindingType[ee],this.setValue=this.SetterByBindingTypeAndVersioning[ee][K]}unbind(){this.node=null,this.getValue=this._getValue_unbound,this.setValue=this._setValue_unbound}}PropertyBinding.Composite=Composite;PropertyBinding.prototype.BindingType={Direct:0,EntireArray:1,ArrayElement:2,HasFromToArray:3};PropertyBinding.prototype.Versioning={None:0,NeedsUpdate:1,MatrixWorldNeedsUpdate:2};PropertyBinding.prototype.GetterByBindingType=[PropertyBinding.prototype._getValue_direct,PropertyBinding.prototype._getValue_array,PropertyBinding.prototype._getValue_arrayElement,PropertyBinding.prototype._getValue_toArray];PropertyBinding.prototype.SetterByBindingTypeAndVersioning=[[PropertyBinding.prototype._setValue_direct,PropertyBinding.prototype._setValue_direct_setNeedsUpdate,PropertyBinding.prototype._setValue_direct_setMatrixWorldNeedsUpdate],[PropertyBinding.prototype._setValue_array,PropertyBinding.prototype._setValue_array_setNeedsUpdate,PropertyBinding.prototype._setValue_array_setMatrixWorldNeedsUpdate],[PropertyBinding.prototype._setValue_arrayElement,PropertyBinding.prototype._setValue_arrayElement_setNeedsUpdate,PropertyBinding.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate],[PropertyBinding.prototype._setValue_fromArray,PropertyBinding.prototype._setValue_fromArray_setNeedsUpdate,PropertyBinding.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate]];class AnimationAction{constructor(w,D,O=null,U=D.blendMode){this._mixer=w,this._clip=D,this._localRoot=O,this.blendMode=U;const G=D.tracks,q=G.length,K=new Array(q),ee={endingStart:ZeroCurvatureEnding,endingEnd:ZeroCurvatureEnding};for(let Z=0;Z!==q;++Z){const ie=G[Z].createInterpolant(null);K[Z]=ie,ie.settings=ee}this._interpolantSettings=ee,this._interpolants=K,this._propertyBindings=new Array(q),this._cacheIndex=null,this._byClipCacheIndex=null,this._timeScaleInterpolant=null,this._weightInterpolant=null,this.loop=LoopRepeat,this._loopCount=-1,this._startTime=null,this.time=0,this.timeScale=1,this._effectiveTimeScale=1,this.weight=1,this._effectiveWeight=1,this.repetitions=1/0,this.paused=!1,this.enabled=!0,this.clampWhenFinished=!1,this.zeroSlopeAtStart=!0,this.zeroSlopeAtEnd=!0}play(){return this._mixer._activateAction(this),this}stop(){return this._mixer._deactivateAction(this),this.reset()}reset(){return this.paused=!1,this.enabled=!0,this.time=0,this._loopCount=-1,this._startTime=null,this.stopFading().stopWarping()}isRunning(){return this.enabled&&!this.paused&&this.timeScale!==0&&this._startTime===null&&this._mixer._isActiveAction(this)}isScheduled(){return this._mixer._isActiveAction(this)}startAt(w){return this._startTime=w,this}setLoop(w,D){return this.loop=w,this.repetitions=D,this}setEffectiveWeight(w){return this.weight=w,this._effectiveWeight=this.enabled?w:0,this.stopFading()}getEffectiveWeight(){return this._effectiveWeight}fadeIn(w){return this._scheduleFading(w,0,1)}fadeOut(w){return this._scheduleFading(w,1,0)}crossFadeFrom(w,D,O=!1){if(w.fadeOut(D),this.fadeIn(D),O===!0){const U=this._clip.duration,G=w._clip.duration,q=G/U,K=U/G;w.warp(1,q,D),this.warp(K,1,D)}return this}crossFadeTo(w,D,O=!1){return w.crossFadeFrom(this,D,O)}stopFading(){const w=this._weightInterpolant;return w!==null&&(this._weightInterpolant=null,this._mixer._takeBackControlInterpolant(w)),this}setEffectiveTimeScale(w){return this.timeScale=w,this._effectiveTimeScale=this.paused?0:w,this.stopWarping()}getEffectiveTimeScale(){return this._effectiveTimeScale}setDuration(w){return this.timeScale=this._clip.duration/w,this.stopWarping()}syncWith(w){return this.time=w.time,this.timeScale=w.timeScale,this.stopWarping()}halt(w){return this.warp(this._effectiveTimeScale,0,w)}warp(w,D,O){const U=this._mixer,G=U.time,q=this.timeScale;let K=this._timeScaleInterpolant;K===null&&(K=U._lendControlInterpolant(),this._timeScaleInterpolant=K);const ee=K.parameterPositions,Z=K.sampleValues;return ee[0]=G,ee[1]=G+O,Z[0]=w/q,Z[1]=D/q,this}stopWarping(){const w=this._timeScaleInterpolant;return w!==null&&(this._timeScaleInterpolant=null,this._mixer._takeBackControlInterpolant(w)),this}getMixer(){return this._mixer}getClip(){return this._clip}getRoot(){return this._localRoot||this._mixer._root}_update(w,D,O,U){if(!this.enabled){this._updateWeight(w);return}const G=this._startTime;if(G!==null){const ee=(w-G)*O;ee<0||O===0?D=0:(this._startTime=null,D=O*ee)}D*=this._updateTimeScale(w);const q=this._updateTime(D),K=this._updateWeight(w);if(K>0){const ee=this._interpolants,Z=this._propertyBindings;switch(this.blendMode){case AdditiveAnimationBlendMode:for(let ie=0,Y=ee.length;ie!==Y;++ie)ee[ie].evaluate(q),Z[ie].accumulateAdditive(K);break;case NormalAnimationBlendMode:default:for(let ie=0,Y=ee.length;ie!==Y;++ie)ee[ie].evaluate(q),Z[ie].accumulate(U,K)}}}_updateWeight(w){let D=0;if(this.enabled){D=this.weight;const O=this._weightInterpolant;if(O!==null){const U=O.evaluate(w)[0];D*=U,w>O.parameterPositions[1]&&(this.stopFading(),U===0&&(this.enabled=!1))}}return this._effectiveWeight=D,D}_updateTimeScale(w){let D=0;if(!this.paused){D=this.timeScale;const O=this._timeScaleInterpolant;if(O!==null){const U=O.evaluate(w)[0];D*=U,w>O.parameterPositions[1]&&(this.stopWarping(),D===0?this.paused=!0:this.timeScale=D)}}return this._effectiveTimeScale=D,D}_updateTime(w){const D=this._clip.duration,O=this.loop;let U=this.time+w,G=this._loopCount;const q=O===LoopPingPong;if(w===0)return G===-1?U:q&&(G&1)===1?D-U:U;if(O===LoopOnce){G===-1&&(this._loopCount=0,this._setEndings(!0,!0,!1));e:{if(U>=D)U=D;else if(U<0)U=0;else{this.time=U;break e}this.clampWhenFinished?this.paused=!0:this.enabled=!1,this.time=U,this._mixer.dispatchEvent({type:"finished",action:this,direction:w<0?-1:1})}}else{if(G===-1&&(w>=0?(G=0,this._setEndings(!0,this.repetitions===0,q)):this._setEndings(this.repetitions===0,!0,q)),U>=D||U<0){const K=Math.floor(U/D);U-=D*K,G+=Math.abs(K);const ee=this.repetitions-G;if(ee<=0)this.clampWhenFinished?this.paused=!0:this.enabled=!1,U=w>0?D:0,this.time=U,this._mixer.dispatchEvent({type:"finished",action:this,direction:w>0?1:-1});else{if(ee===1){const Z=w<0;this._setEndings(Z,!Z,q)}else this._setEndings(!1,!1,q);this._loopCount=G,this.time=U,this._mixer.dispatchEvent({type:"loop",action:this,loopDelta:K})}}else this.time=U;if(q&&(G&1)===1)return D-U}return U}_setEndings(w,D,O){const U=this._interpolantSettings;O?(U.endingStart=ZeroSlopeEnding,U.endingEnd=ZeroSlopeEnding):(w?U.endingStart=this.zeroSlopeAtStart?ZeroSlopeEnding:ZeroCurvatureEnding:U.endingStart=WrapAroundEnding,D?U.endingEnd=this.zeroSlopeAtEnd?ZeroSlopeEnding:ZeroCurvatureEnding:U.endingEnd=WrapAroundEnding)}_scheduleFading(w,D,O){const U=this._mixer,G=U.time;let q=this._weightInterpolant;q===null&&(q=U._lendControlInterpolant(),this._weightInterpolant=q);const K=q.parameterPositions,ee=q.sampleValues;return K[0]=G,ee[0]=D,K[1]=G+w,ee[1]=O,this}}const _controlInterpolantsResultBuffer=new Float32Array(1);class AnimationMixer extends EventDispatcher{constructor(w){super(),this._root=w,this._initMemoryManager(),this._accuIndex=0,this.time=0,this.timeScale=1}_bindAction(w,D){const O=w._localRoot||this._root,U=w._clip.tracks,G=U.length,q=w._propertyBindings,K=w._interpolants,ee=O.uuid,Z=this._bindingsByRootAndName;let ie=Z[ee];ie===void 0&&(ie={},Z[ee]=ie);for(let Y=0;Y!==G;++Y){const W=U[Y],ne=W.name;let se=ie[ne];if(se!==void 0)++se.referenceCount,q[Y]=se;else{if(se=q[Y],se!==void 0){se._cacheIndex===null&&(++se.referenceCount,this._addInactiveBinding(se,ee,ne));continue}const le=D&&D._propertyBindings[Y].binding.parsedPath;se=new PropertyMixer(PropertyBinding.create(O,ne,le),W.ValueTypeName,W.getValueSize()),++se.referenceCount,this._addInactiveBinding(se,ee,ne),q[Y]=se}K[Y].resultBuffer=se.buffer}}_activateAction(w){if(!this._isActiveAction(w)){if(w._cacheIndex===null){const O=(w._localRoot||this._root).uuid,U=w._clip.uuid,G=this._actionsByClip[U];this._bindAction(w,G&&G.knownActions[0]),this._addInactiveAction(w,U,O)}const D=w._propertyBindings;for(let O=0,U=D.length;O!==U;++O){const G=D[O];G.useCount++===0&&(this._lendBinding(G),G.saveOriginalState())}this._lendAction(w)}}_deactivateAction(w){if(this._isActiveAction(w)){const D=w._propertyBindings;for(let O=0,U=D.length;O!==U;++O){const G=D[O];--G.useCount===0&&(G.restoreOriginalState(),this._takeBackBinding(G))}this._takeBackAction(w)}}_initMemoryManager(){this._actions=[],this._nActiveActions=0,this._actionsByClip={},this._bindings=[],this._nActiveBindings=0,this._bindingsByRootAndName={},this._controlInterpolants=[],this._nActiveControlInterpolants=0;const w=this;this.stats={actions:{get total(){return w._actions.length},get inUse(){return w._nActiveActions}},bindings:{get total(){return w._bindings.length},get inUse(){return w._nActiveBindings}},controlInterpolants:{get total(){return w._controlInterpolants.length},get inUse(){return w._nActiveControlInterpolants}}}}_isActiveAction(w){const D=w._cacheIndex;return D!==null&&D<this._nActiveActions}_addInactiveAction(w,D,O){const U=this._actions,G=this._actionsByClip;let q=G[D];if(q===void 0)q={knownActions:[w],actionByRoot:{}},w._byClipCacheIndex=0,G[D]=q;else{const K=q.knownActions;w._byClipCacheIndex=K.length,K.push(w)}w._cacheIndex=U.length,U.push(w),q.actionByRoot[O]=w}_removeInactiveAction(w){const D=this._actions,O=D[D.length-1],U=w._cacheIndex;O._cacheIndex=U,D[U]=O,D.pop(),w._cacheIndex=null;const G=w._clip.uuid,q=this._actionsByClip,K=q[G],ee=K.knownActions,Z=ee[ee.length-1],ie=w._byClipCacheIndex;Z._byClipCacheIndex=ie,ee[ie]=Z,ee.pop(),w._byClipCacheIndex=null;const Y=K.actionByRoot,W=(w._localRoot||this._root).uuid;delete Y[W],ee.length===0&&delete q[G],this._removeInactiveBindingsForAction(w)}_removeInactiveBindingsForAction(w){const D=w._propertyBindings;for(let O=0,U=D.length;O!==U;++O){const G=D[O];--G.referenceCount===0&&this._removeInactiveBinding(G)}}_lendAction(w){const D=this._actions,O=w._cacheIndex,U=this._nActiveActions++,G=D[U];w._cacheIndex=U,D[U]=w,G._cacheIndex=O,D[O]=G}_takeBackAction(w){const D=this._actions,O=w._cacheIndex,U=--this._nActiveActions,G=D[U];w._cacheIndex=U,D[U]=w,G._cacheIndex=O,D[O]=G}_addInactiveBinding(w,D,O){const U=this._bindingsByRootAndName,G=this._bindings;let q=U[D];q===void 0&&(q={},U[D]=q),q[O]=w,w._cacheIndex=G.length,G.push(w)}_removeInactiveBinding(w){const D=this._bindings,O=w.binding,U=O.rootNode.uuid,G=O.path,q=this._bindingsByRootAndName,K=q[U],ee=D[D.length-1],Z=w._cacheIndex;ee._cacheIndex=Z,D[Z]=ee,D.pop(),delete K[G],Object.keys(K).length===0&&delete q[U]}_lendBinding(w){const D=this._bindings,O=w._cacheIndex,U=this._nActiveBindings++,G=D[U];w._cacheIndex=U,D[U]=w,G._cacheIndex=O,D[O]=G}_takeBackBinding(w){const D=this._bindings,O=w._cacheIndex,U=--this._nActiveBindings,G=D[U];w._cacheIndex=U,D[U]=w,G._cacheIndex=O,D[O]=G}_lendControlInterpolant(){const w=this._controlInterpolants,D=this._nActiveControlInterpolants++;let O=w[D];return O===void 0&&(O=new LinearInterpolant(new Float32Array(2),new Float32Array(2),1,_controlInterpolantsResultBuffer),O.__cacheIndex=D,w[D]=O),O}_takeBackControlInterpolant(w){const D=this._controlInterpolants,O=w.__cacheIndex,U=--this._nActiveControlInterpolants,G=D[U];w.__cacheIndex=U,D[U]=w,G.__cacheIndex=O,D[O]=G}clipAction(w,D,O){const U=D||this._root,G=U.uuid;let q=typeof w=="string"?AnimationClip.findByName(U,w):w;const K=q!==null?q.uuid:w,ee=this._actionsByClip[K];let Z=null;if(O===void 0&&(q!==null?O=q.blendMode:O=NormalAnimationBlendMode),ee!==void 0){const Y=ee.actionByRoot[G];if(Y!==void 0&&Y.blendMode===O)return Y;Z=ee.knownActions[0],q===null&&(q=Z._clip)}if(q===null)return null;const ie=new AnimationAction(this,q,D,O);return this._bindAction(ie,Z),this._addInactiveAction(ie,K,G),ie}existingAction(w,D){const O=D||this._root,U=O.uuid,G=typeof w=="string"?AnimationClip.findByName(O,w):w,q=G?G.uuid:w,K=this._actionsByClip[q];return K!==void 0&&K.actionByRoot[U]||null}stopAllAction(){const w=this._actions,D=this._nActiveActions;for(let O=D-1;O>=0;--O)w[O].stop();return this}update(w){w*=this.timeScale;const D=this._actions,O=this._nActiveActions,U=this.time+=w,G=Math.sign(w),q=this._accuIndex^=1;for(let Z=0;Z!==O;++Z)D[Z]._update(U,w,G,q);const K=this._bindings,ee=this._nActiveBindings;for(let Z=0;Z!==ee;++Z)K[Z].apply(q);return this}setTime(w){this.time=0;for(let D=0;D<this._actions.length;D++)this._actions[D].time=0;return this.update(w)}getRoot(){return this._root}uncacheClip(w){const D=this._actions,O=w.uuid,U=this._actionsByClip,G=U[O];if(G!==void 0){const q=G.knownActions;for(let K=0,ee=q.length;K!==ee;++K){const Z=q[K];this._deactivateAction(Z);const ie=Z._cacheIndex,Y=D[D.length-1];Z._cacheIndex=null,Z._byClipCacheIndex=null,Y._cacheIndex=ie,D[ie]=Y,D.pop(),this._removeInactiveBindingsForAction(Z)}delete U[O]}}uncacheRoot(w){const D=w.uuid,O=this._actionsByClip;for(const q in O){const K=O[q].actionByRoot,ee=K[D];ee!==void 0&&(this._deactivateAction(ee),this._removeInactiveAction(ee))}const U=this._bindingsByRootAndName,G=U[D];if(G!==void 0)for(const q in G){const K=G[q];K.restoreOriginalState(),this._removeInactiveBinding(K)}}uncacheAction(w,D){const O=this.existingAction(w,D);O!==null&&(this._deactivateAction(O),this._removeInactiveAction(O))}}const _matrix=new Matrix4;class Raycaster{constructor(w,D,O=0,U=1/0){this.ray=new Ray(w,D),this.near=O,this.far=U,this.camera=null,this.layers=new Layers,this.params={Mesh:{},Line:{threshold:1},LOD:{},Points:{threshold:1},Sprite:{}}}set(w,D){this.ray.set(w,D)}setFromCamera(w,D){D.isPerspectiveCamera?(this.ray.origin.setFromMatrixPosition(D.matrixWorld),this.ray.direction.set(w.x,w.y,.5).unproject(D).sub(this.ray.origin).normalize(),this.camera=D):D.isOrthographicCamera?(this.ray.origin.set(w.x,w.y,(D.near+D.far)/(D.near-D.far)).unproject(D),this.ray.direction.set(0,0,-1).transformDirection(D.matrixWorld),this.camera=D):error("Raycaster: Unsupported camera type: "+D.type)}setFromXRController(w){return _matrix.identity().extractRotation(w.matrixWorld),this.ray.origin.setFromMatrixPosition(w.matrixWorld),this.ray.direction.set(0,0,-1).applyMatrix4(_matrix),this}intersectObject(w,D=!0,O=[]){return intersect(w,this,O,D),O.sort(ascSort),O}intersectObjects(w,D=!0,O=[]){for(let U=0,G=w.length;U<G;U++)intersect(w[U],this,O,D);return O.sort(ascSort),O}}function ascSort(F,w){return F.distance-w.distance}function intersect(F,w,D,O){let U=!0;if(F.layers.test(w.layers)&&F.raycast(w,D)===!1&&(U=!1),U===!0&&O===!0){const G=F.children;for(let q=0,K=G.length;q<K;q++)intersect(G[q],w,D,!0)}}class Spherical{constructor(w=1,D=0,O=0){this.radius=w,this.phi=D,this.theta=O}set(w,D,O){return this.radius=w,this.phi=D,this.theta=O,this}copy(w){return this.radius=w.radius,this.phi=w.phi,this.theta=w.theta,this}makeSafe(){return this.phi=clamp$2(this.phi,1e-6,Math.PI-1e-6),this}setFromVector3(w){return this.setFromCartesianCoords(w.x,w.y,w.z)}setFromCartesianCoords(w,D,O){return this.radius=Math.sqrt(w*w+D*D+O*O),this.radius===0?(this.theta=0,this.phi=0):(this.theta=Math.atan2(w,O),this.phi=Math.acos(clamp$2(D/this.radius,-1,1))),this}clone(){return new this.constructor().copy(this)}}function getByteLength(F,w,D,O){const U=getTextureTypeByteLength(O);switch(D){case AlphaFormat:return F*w;case RedFormat:return F*w/U.components*U.byteLength;case RedIntegerFormat:return F*w/U.components*U.byteLength;case RGFormat:return F*w*2/U.components*U.byteLength;case RGIntegerFormat:return F*w*2/U.components*U.byteLength;case RGBFormat:return F*w*3/U.components*U.byteLength;case RGBAFormat:return F*w*4/U.components*U.byteLength;case RGBAIntegerFormat:return F*w*4/U.components*U.byteLength;case RGB_S3TC_DXT1_Format:case RGBA_S3TC_DXT1_Format:return Math.floor((F+3)/4)*Math.floor((w+3)/4)*8;case RGBA_S3TC_DXT3_Format:case RGBA_S3TC_DXT5_Format:return Math.floor((F+3)/4)*Math.floor((w+3)/4)*16;case RGB_PVRTC_2BPPV1_Format:case RGBA_PVRTC_2BPPV1_Format:return Math.max(F,16)*Math.max(w,8)/4;case RGB_PVRTC_4BPPV1_Format:case RGBA_PVRTC_4BPPV1_Format:return Math.max(F,8)*Math.max(w,8)/2;case RGB_ETC1_Format:case RGB_ETC2_Format:return Math.floor((F+3)/4)*Math.floor((w+3)/4)*8;case RGBA_ETC2_EAC_Format:return Math.floor((F+3)/4)*Math.floor((w+3)/4)*16;case RGBA_ASTC_4x4_Format:return Math.floor((F+3)/4)*Math.floor((w+3)/4)*16;case RGBA_ASTC_5x4_Format:return Math.floor((F+4)/5)*Math.floor((w+3)/4)*16;case RGBA_ASTC_5x5_Format:return Math.floor((F+4)/5)*Math.floor((w+4)/5)*16;case RGBA_ASTC_6x5_Format:return Math.floor((F+5)/6)*Math.floor((w+4)/5)*16;case RGBA_ASTC_6x6_Format:return Math.floor((F+5)/6)*Math.floor((w+5)/6)*16;case RGBA_ASTC_8x5_Format:return Math.floor((F+7)/8)*Math.floor((w+4)/5)*16;case RGBA_ASTC_8x6_Format:return Math.floor((F+7)/8)*Math.floor((w+5)/6)*16;case RGBA_ASTC_8x8_Format:return Math.floor((F+7)/8)*Math.floor((w+7)/8)*16;case RGBA_ASTC_10x5_Format:return Math.floor((F+9)/10)*Math.floor((w+4)/5)*16;case RGBA_ASTC_10x6_Format:return Math.floor((F+9)/10)*Math.floor((w+5)/6)*16;case RGBA_ASTC_10x8_Format:return Math.floor((F+9)/10)*Math.floor((w+7)/8)*16;case RGBA_ASTC_10x10_Format:return Math.floor((F+9)/10)*Math.floor((w+9)/10)*16;case RGBA_ASTC_12x10_Format:return Math.floor((F+11)/12)*Math.floor((w+9)/10)*16;case RGBA_ASTC_12x12_Format:return Math.floor((F+11)/12)*Math.floor((w+11)/12)*16;case RGBA_BPTC_Format:case RGB_BPTC_SIGNED_Format:case RGB_BPTC_UNSIGNED_Format:return Math.ceil(F/4)*Math.ceil(w/4)*16;case RED_RGTC1_Format:case SIGNED_RED_RGTC1_Format:return Math.ceil(F/4)*Math.ceil(w/4)*8;case RED_GREEN_RGTC2_Format:case SIGNED_RED_GREEN_RGTC2_Format:return Math.ceil(F/4)*Math.ceil(w/4)*16}throw new Error(`Unable to determine texture byte length for ${D} format.`)}function getTextureTypeByteLength(F){switch(F){case UnsignedByteType:case ByteType:return{byteLength:1,components:1};case UnsignedShortType:case ShortType:case HalfFloatType:return{byteLength:2,components:1};case UnsignedShort4444Type:case UnsignedShort5551Type:return{byteLength:2,components:4};case UnsignedIntType:case IntType:case FloatType:return{byteLength:4,components:1};case UnsignedInt5999Type:case UnsignedInt101111Type:return{byteLength:4,components:3}}throw new Error(`Unknown texture type ${F}.`)}typeof __THREE_DEVTOOLS__<"u"&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register",{detail:{revision:REVISION}}));typeof window<"u"&&(window.__THREE__?warn("WARNING: Multiple instances of Three.js being imported."):window.__THREE__=REVISION);/**
 * @license
 * Copyright 2010-2025 Three.js Authors
 * SPDX-License-Identifier: MIT
 */function WebGLAnimation(){let F=null,w=!1,D=null,O=null;function U(G,q){D(G,q),O=F.requestAnimationFrame(U)}return{start:function(){w!==!0&&D!==null&&(O=F.requestAnimationFrame(U),w=!0)},stop:function(){F.cancelAnimationFrame(O),w=!1},setAnimationLoop:function(G){D=G},setContext:function(G){F=G}}}function WebGLAttributes(F){const w=new WeakMap;function D(K,ee){const Z=K.array,ie=K.usage,Y=Z.byteLength,W=F.createBuffer();F.bindBuffer(ee,W),F.bufferData(ee,Z,ie),K.onUploadCallback();let ne;if(Z instanceof Float32Array)ne=F.FLOAT;else if(typeof Float16Array<"u"&&Z instanceof Float16Array)ne=F.HALF_FLOAT;else if(Z instanceof Uint16Array)K.isFloat16BufferAttribute?ne=F.HALF_FLOAT:ne=F.UNSIGNED_SHORT;else if(Z instanceof Int16Array)ne=F.SHORT;else if(Z instanceof Uint32Array)ne=F.UNSIGNED_INT;else if(Z instanceof Int32Array)ne=F.INT;else if(Z instanceof Int8Array)ne=F.BYTE;else if(Z instanceof Uint8Array)ne=F.UNSIGNED_BYTE;else if(Z instanceof Uint8ClampedArray)ne=F.UNSIGNED_BYTE;else throw new Error("THREE.WebGLAttributes: Unsupported buffer data format: "+Z);return{buffer:W,type:ne,bytesPerElement:Z.BYTES_PER_ELEMENT,version:K.version,size:Y}}function O(K,ee,Z){const ie=ee.array,Y=ee.updateRanges;if(F.bindBuffer(Z,K),Y.length===0)F.bufferSubData(Z,0,ie);else{Y.sort((ne,se)=>ne.start-se.start);let W=0;for(let ne=1;ne<Y.length;ne++){const se=Y[W],le=Y[ne];le.start<=se.start+se.count+1?se.count=Math.max(se.count,le.start+le.count-se.start):(++W,Y[W]=le)}Y.length=W+1;for(let ne=0,se=Y.length;ne<se;ne++){const le=Y[ne];F.bufferSubData(Z,le.start*ie.BYTES_PER_ELEMENT,ie,le.start,le.count)}ee.clearUpdateRanges()}ee.onUploadCallback()}function U(K){return K.isInterleavedBufferAttribute&&(K=K.data),w.get(K)}function G(K){K.isInterleavedBufferAttribute&&(K=K.data);const ee=w.get(K);ee&&(F.deleteBuffer(ee.buffer),w.delete(K))}function q(K,ee){if(K.isInterleavedBufferAttribute&&(K=K.data),K.isGLBufferAttribute){const ie=w.get(K);(!ie||ie.version<K.version)&&w.set(K,{buffer:K.buffer,type:K.type,bytesPerElement:K.elementSize,version:K.version});return}const Z=w.get(K);if(Z===void 0)w.set(K,D(K,ee));else if(Z.version<K.version){if(Z.size!==K.array.byteLength)throw new Error("THREE.WebGLAttributes: The size of the buffer attribute's array buffer does not match the original size. Resizing buffer attributes is not supported.");O(Z.buffer,K,ee),Z.version=K.version}}return{get:U,remove:G,update:q}}var alphahash_fragment=`#ifdef USE_ALPHAHASH
	if ( diffuseColor.a < getAlphaHashThreshold( vPosition ) ) discard;
#endif`,alphahash_pars_fragment=`#ifdef USE_ALPHAHASH
	const float ALPHA_HASH_SCALE = 0.05;
	float hash2D( vec2 value ) {
		return fract( 1.0e4 * sin( 17.0 * value.x + 0.1 * value.y ) * ( 0.1 + abs( sin( 13.0 * value.y + value.x ) ) ) );
	}
	float hash3D( vec3 value ) {
		return hash2D( vec2( hash2D( value.xy ), value.z ) );
	}
	float getAlphaHashThreshold( vec3 position ) {
		float maxDeriv = max(
			length( dFdx( position.xyz ) ),
			length( dFdy( position.xyz ) )
		);
		float pixScale = 1.0 / ( ALPHA_HASH_SCALE * maxDeriv );
		vec2 pixScales = vec2(
			exp2( floor( log2( pixScale ) ) ),
			exp2( ceil( log2( pixScale ) ) )
		);
		vec2 alpha = vec2(
			hash3D( floor( pixScales.x * position.xyz ) ),
			hash3D( floor( pixScales.y * position.xyz ) )
		);
		float lerpFactor = fract( log2( pixScale ) );
		float x = ( 1.0 - lerpFactor ) * alpha.x + lerpFactor * alpha.y;
		float a = min( lerpFactor, 1.0 - lerpFactor );
		vec3 cases = vec3(
			x * x / ( 2.0 * a * ( 1.0 - a ) ),
			( x - 0.5 * a ) / ( 1.0 - a ),
			1.0 - ( ( 1.0 - x ) * ( 1.0 - x ) / ( 2.0 * a * ( 1.0 - a ) ) )
		);
		float threshold = ( x < ( 1.0 - a ) )
			? ( ( x < a ) ? cases.x : cases.y )
			: cases.z;
		return clamp( threshold , 1.0e-6, 1.0 );
	}
#endif`,alphamap_fragment=`#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, vAlphaMapUv ).g;
#endif`,alphamap_pars_fragment=`#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,alphatest_fragment=`#ifdef USE_ALPHATEST
	#ifdef ALPHA_TO_COVERAGE
	diffuseColor.a = smoothstep( alphaTest, alphaTest + fwidth( diffuseColor.a ), diffuseColor.a );
	if ( diffuseColor.a == 0.0 ) discard;
	#else
	if ( diffuseColor.a < alphaTest ) discard;
	#endif
#endif`,alphatest_pars_fragment=`#ifdef USE_ALPHATEST
	uniform float alphaTest;
#endif`,aomap_fragment=`#ifdef USE_AOMAP
	float ambientOcclusion = ( texture2D( aoMap, vAoMapUv ).r - 1.0 ) * aoMapIntensity + 1.0;
	reflectedLight.indirectDiffuse *= ambientOcclusion;
	#if defined( USE_CLEARCOAT ) 
		clearcoatSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_SHEEN ) 
		sheenSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD )
		float dotNV = saturate( dot( geometryNormal, geometryViewDir ) );
		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );
	#endif
#endif`,aomap_pars_fragment=`#ifdef USE_AOMAP
	uniform sampler2D aoMap;
	uniform float aoMapIntensity;
#endif`,batching_pars_vertex=`#ifdef USE_BATCHING
	#if ! defined( GL_ANGLE_multi_draw )
	#define gl_DrawID _gl_DrawID
	uniform int _gl_DrawID;
	#endif
	uniform highp sampler2D batchingTexture;
	uniform highp usampler2D batchingIdTexture;
	mat4 getBatchingMatrix( const in float i ) {
		int size = textureSize( batchingTexture, 0 ).x;
		int j = int( i ) * 4;
		int x = j % size;
		int y = j / size;
		vec4 v1 = texelFetch( batchingTexture, ivec2( x, y ), 0 );
		vec4 v2 = texelFetch( batchingTexture, ivec2( x + 1, y ), 0 );
		vec4 v3 = texelFetch( batchingTexture, ivec2( x + 2, y ), 0 );
		vec4 v4 = texelFetch( batchingTexture, ivec2( x + 3, y ), 0 );
		return mat4( v1, v2, v3, v4 );
	}
	float getIndirectIndex( const in int i ) {
		int size = textureSize( batchingIdTexture, 0 ).x;
		int x = i % size;
		int y = i / size;
		return float( texelFetch( batchingIdTexture, ivec2( x, y ), 0 ).r );
	}
#endif
#ifdef USE_BATCHING_COLOR
	uniform sampler2D batchingColorTexture;
	vec3 getBatchingColor( const in float i ) {
		int size = textureSize( batchingColorTexture, 0 ).x;
		int j = int( i );
		int x = j % size;
		int y = j / size;
		return texelFetch( batchingColorTexture, ivec2( x, y ), 0 ).rgb;
	}
#endif`,batching_vertex=`#ifdef USE_BATCHING
	mat4 batchingMatrix = getBatchingMatrix( getIndirectIndex( gl_DrawID ) );
#endif`,begin_vertex=`vec3 transformed = vec3( position );
#ifdef USE_ALPHAHASH
	vPosition = vec3( position );
#endif`,beginnormal_vertex=`vec3 objectNormal = vec3( normal );
#ifdef USE_TANGENT
	vec3 objectTangent = vec3( tangent.xyz );
#endif`,bsdfs=`float G_BlinnPhong_Implicit( ) {
	return 0.25;
}
float D_BlinnPhong( const in float shininess, const in float dotNH ) {
	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );
}
vec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( specularColor, 1.0, dotVH );
	float G = G_BlinnPhong_Implicit( );
	float D = D_BlinnPhong( shininess, dotNH );
	return F * ( G * D );
} // validated`,iridescence_fragment=`#ifdef USE_IRIDESCENCE
	const mat3 XYZ_TO_REC709 = mat3(
		 3.2404542, -0.9692660,  0.0556434,
		-1.5371385,  1.8760108, -0.2040259,
		-0.4985314,  0.0415560,  1.0572252
	);
	vec3 Fresnel0ToIor( vec3 fresnel0 ) {
		vec3 sqrtF0 = sqrt( fresnel0 );
		return ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );
	}
	vec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );
	}
	float IorToFresnel0( float transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));
	}
	vec3 evalSensitivity( float OPD, vec3 shift ) {
		float phase = 2.0 * PI * OPD * 1.0e-9;
		vec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );
		vec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );
		vec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );
		vec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );
		xyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );
		xyz /= 1.0685e-7;
		vec3 rgb = XYZ_TO_REC709 * xyz;
		return rgb;
	}
	vec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {
		vec3 I;
		float iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );
		float sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );
		float cosTheta2Sq = 1.0 - sinTheta2Sq;
		if ( cosTheta2Sq < 0.0 ) {
			return vec3( 1.0 );
		}
		float cosTheta2 = sqrt( cosTheta2Sq );
		float R0 = IorToFresnel0( iridescenceIOR, outsideIOR );
		float R12 = F_Schlick( R0, 1.0, cosTheta1 );
		float T121 = 1.0 - R12;
		float phi12 = 0.0;
		if ( iridescenceIOR < outsideIOR ) phi12 = PI;
		float phi21 = PI - phi12;
		vec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );		vec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );
		vec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );
		vec3 phi23 = vec3( 0.0 );
		if ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;
		if ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;
		if ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;
		float OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;
		vec3 phi = vec3( phi21 ) + phi23;
		vec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );
		vec3 r123 = sqrt( R123 );
		vec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );
		vec3 C0 = R12 + Rs;
		I = C0;
		vec3 Cm = Rs - T121;
		for ( int m = 1; m <= 2; ++ m ) {
			Cm *= r123;
			vec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );
			I += Cm * Sm;
		}
		return max( I, vec3( 0.0 ) );
	}
#endif`,bumpmap_pars_fragment=`#ifdef USE_BUMPMAP
	uniform sampler2D bumpMap;
	uniform float bumpScale;
	vec2 dHdxy_fwd() {
		vec2 dSTdx = dFdx( vBumpMapUv );
		vec2 dSTdy = dFdy( vBumpMapUv );
		float Hll = bumpScale * texture2D( bumpMap, vBumpMapUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdy ).x - Hll;
		return vec2( dBx, dBy );
	}
	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {
		vec3 vSigmaX = normalize( dFdx( surf_pos.xyz ) );
		vec3 vSigmaY = normalize( dFdy( surf_pos.xyz ) );
		vec3 vN = surf_norm;
		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );
		float fDet = dot( vSigmaX, R1 ) * faceDirection;
		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );
	}
#endif`,clipping_planes_fragment=`#if NUM_CLIPPING_PLANES > 0
	vec4 plane;
	#ifdef ALPHA_TO_COVERAGE
		float distanceToPlane, distanceGradient;
		float clipOpacity = 1.0;
		#pragma unroll_loop_start
		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;
			distanceGradient = fwidth( distanceToPlane ) / 2.0;
			clipOpacity *= smoothstep( - distanceGradient, distanceGradient, distanceToPlane );
			if ( clipOpacity == 0.0 ) discard;
		}
		#pragma unroll_loop_end
		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
			float unionClipOpacity = 1.0;
			#pragma unroll_loop_start
			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
				plane = clippingPlanes[ i ];
				distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;
				distanceGradient = fwidth( distanceToPlane ) / 2.0;
				unionClipOpacity *= 1.0 - smoothstep( - distanceGradient, distanceGradient, distanceToPlane );
			}
			#pragma unroll_loop_end
			clipOpacity *= 1.0 - unionClipOpacity;
		#endif
		diffuseColor.a *= clipOpacity;
		if ( diffuseColor.a == 0.0 ) discard;
	#else
		#pragma unroll_loop_start
		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;
		}
		#pragma unroll_loop_end
		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
			bool clipped = true;
			#pragma unroll_loop_start
			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
				plane = clippingPlanes[ i ];
				clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;
			}
			#pragma unroll_loop_end
			if ( clipped ) discard;
		#endif
	#endif
#endif`,clipping_planes_pars_fragment=`#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];
#endif`,clipping_planes_pars_vertex=`#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
#endif`,clipping_planes_vertex=`#if NUM_CLIPPING_PLANES > 0
	vClipPosition = - mvPosition.xyz;
#endif`,color_fragment=`#if defined( USE_COLOR_ALPHA )
	diffuseColor *= vColor;
#elif defined( USE_COLOR )
	diffuseColor.rgb *= vColor;
#endif`,color_pars_fragment=`#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR )
	varying vec3 vColor;
#endif`,color_pars_vertex=`#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )
	varying vec3 vColor;
#endif`,color_vertex=`#if defined( USE_COLOR_ALPHA )
	vColor = vec4( 1.0 );
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )
	vColor = vec3( 1.0 );
#endif
#ifdef USE_COLOR
	vColor *= color;
#endif
#ifdef USE_INSTANCING_COLOR
	vColor.xyz *= instanceColor.xyz;
#endif
#ifdef USE_BATCHING_COLOR
	vec3 batchingColor = getBatchingColor( getIndirectIndex( gl_DrawID ) );
	vColor.xyz *= batchingColor.xyz;
#endif`,common=`#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6
#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement( a ) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
vec3 pow2( const in vec3 x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }
float average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }
highp float rand( const in vec2 uv ) {
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
	return fract( sin( sn ) * c );
}
#ifdef HIGH_PRECISION
	float precisionSafeLength( vec3 v ) { return length( v ); }
#else
	float precisionSafeLength( vec3 v ) {
		float maxComponent = max3( abs( v ) );
		return length( v / maxComponent ) * maxComponent;
	}
#endif
struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};
struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};
#ifdef USE_ALPHAHASH
	varying vec3 vPosition;
#endif
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
bool isPerspectiveMatrix( mat4 m ) {
	return m[ 2 ][ 3 ] == - 1.0;
}
vec2 equirectUv( in vec3 dir ) {
	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;
	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
	return vec2( u, v );
}
vec3 BRDF_Lambert( const in vec3 diffuseColor ) {
	return RECIPROCAL_PI * diffuseColor;
}
vec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
float F_Schlick( const in float f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
} // validated`,cube_uv_reflection_fragment=`#ifdef ENVMAP_TYPE_CUBE_UV
	#define cubeUV_minMipLevel 4.0
	#define cubeUV_minTileSize 16.0
	float getFace( vec3 direction ) {
		vec3 absDirection = abs( direction );
		float face = - 1.0;
		if ( absDirection.x > absDirection.z ) {
			if ( absDirection.x > absDirection.y )
				face = direction.x > 0.0 ? 0.0 : 3.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		} else {
			if ( absDirection.z > absDirection.y )
				face = direction.z > 0.0 ? 2.0 : 5.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		}
		return face;
	}
	vec2 getUV( vec3 direction, float face ) {
		vec2 uv;
		if ( face == 0.0 ) {
			uv = vec2( direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 1.0 ) {
			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );
		} else if ( face == 2.0 ) {
			uv = vec2( - direction.x, direction.y ) / abs( direction.z );
		} else if ( face == 3.0 ) {
			uv = vec2( - direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 4.0 ) {
			uv = vec2( - direction.x, direction.z ) / abs( direction.y );
		} else {
			uv = vec2( direction.x, direction.y ) / abs( direction.z );
		}
		return 0.5 * ( uv + 1.0 );
	}
	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {
		float face = getFace( direction );
		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );
		mipInt = max( mipInt, cubeUV_minMipLevel );
		float faceSize = exp2( mipInt );
		highp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;
		if ( face > 2.0 ) {
			uv.y += faceSize;
			face -= 3.0;
		}
		uv.x += face * faceSize;
		uv.x += filterInt * 3.0 * cubeUV_minTileSize;
		uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );
		uv.x *= CUBEUV_TEXEL_WIDTH;
		uv.y *= CUBEUV_TEXEL_HEIGHT;
		#ifdef texture2DGradEXT
			return texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;
		#else
			return texture2D( envMap, uv ).rgb;
		#endif
	}
	#define cubeUV_r0 1.0
	#define cubeUV_m0 - 2.0
	#define cubeUV_r1 0.8
	#define cubeUV_m1 - 1.0
	#define cubeUV_r4 0.4
	#define cubeUV_m4 2.0
	#define cubeUV_r5 0.305
	#define cubeUV_m5 3.0
	#define cubeUV_r6 0.21
	#define cubeUV_m6 4.0
	float roughnessToMip( float roughness ) {
		float mip = 0.0;
		if ( roughness >= cubeUV_r1 ) {
			mip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;
		} else if ( roughness >= cubeUV_r4 ) {
			mip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;
		} else if ( roughness >= cubeUV_r5 ) {
			mip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;
		} else if ( roughness >= cubeUV_r6 ) {
			mip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;
		} else {
			mip = - 2.0 * log2( 1.16 * roughness );		}
		return mip;
	}
	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {
		float mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );
		float mipF = fract( mip );
		float mipInt = floor( mip );
		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );
		if ( mipF == 0.0 ) {
			return vec4( color0, 1.0 );
		} else {
			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );
			return vec4( mix( color0, color1, mipF ), 1.0 );
		}
	}
#endif`,defaultnormal_vertex=`vec3 transformedNormal = objectNormal;
#ifdef USE_TANGENT
	vec3 transformedTangent = objectTangent;
#endif
#ifdef USE_BATCHING
	mat3 bm = mat3( batchingMatrix );
	transformedNormal /= vec3( dot( bm[ 0 ], bm[ 0 ] ), dot( bm[ 1 ], bm[ 1 ] ), dot( bm[ 2 ], bm[ 2 ] ) );
	transformedNormal = bm * transformedNormal;
	#ifdef USE_TANGENT
		transformedTangent = bm * transformedTangent;
	#endif
#endif
#ifdef USE_INSTANCING
	mat3 im = mat3( instanceMatrix );
	transformedNormal /= vec3( dot( im[ 0 ], im[ 0 ] ), dot( im[ 1 ], im[ 1 ] ), dot( im[ 2 ], im[ 2 ] ) );
	transformedNormal = im * transformedNormal;
	#ifdef USE_TANGENT
		transformedTangent = im * transformedTangent;
	#endif
#endif
transformedNormal = normalMatrix * transformedNormal;
#ifdef FLIP_SIDED
	transformedNormal = - transformedNormal;
#endif
#ifdef USE_TANGENT
	transformedTangent = ( modelViewMatrix * vec4( transformedTangent, 0.0 ) ).xyz;
	#ifdef FLIP_SIDED
		transformedTangent = - transformedTangent;
	#endif
#endif`,displacementmap_pars_vertex=`#ifdef USE_DISPLACEMENTMAP
	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;
#endif`,displacementmap_vertex=`#ifdef USE_DISPLACEMENTMAP
	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vDisplacementMapUv ).x * displacementScale + displacementBias );
#endif`,emissivemap_fragment=`#ifdef USE_EMISSIVEMAP
	vec4 emissiveColor = texture2D( emissiveMap, vEmissiveMapUv );
	#ifdef DECODE_VIDEO_TEXTURE_EMISSIVE
		emissiveColor = sRGBTransferEOTF( emissiveColor );
	#endif
	totalEmissiveRadiance *= emissiveColor.rgb;
#endif`,emissivemap_pars_fragment=`#ifdef USE_EMISSIVEMAP
	uniform sampler2D emissiveMap;
#endif`,colorspace_fragment="gl_FragColor = linearToOutputTexel( gl_FragColor );",colorspace_pars_fragment=`vec4 LinearTransferOETF( in vec4 value ) {
	return value;
}
vec4 sRGBTransferEOTF( in vec4 value ) {
	return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );
}
vec4 sRGBTransferOETF( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}`,envmap_fragment=`#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vec3 cameraToFrag;
		if ( isOrthographic ) {
			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToFrag = normalize( vWorldPosition - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( cameraToFrag, worldNormal );
		#else
			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );
		#endif
	#else
		vec3 reflectVec = vReflect;
	#endif
	#ifdef ENVMAP_TYPE_CUBE
		vec4 envColor = textureCube( envMap, envMapRotation * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
	#else
		vec4 envColor = vec4( 0.0 );
	#endif
	#ifdef ENVMAP_BLENDING_MULTIPLY
		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_MIX )
		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_ADD )
		outgoingLight += envColor.xyz * specularStrength * reflectivity;
	#endif
#endif`,envmap_common_pars_fragment=`#ifdef USE_ENVMAP
	uniform float envMapIntensity;
	uniform float flipEnvMap;
	uniform mat3 envMapRotation;
	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif
#endif`,envmap_pars_fragment=`#ifdef USE_ENVMAP
	uniform float reflectivity;
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		varying vec3 vWorldPosition;
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif
#endif`,envmap_pars_vertex=`#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		
		varying vec3 vWorldPosition;
	#else
		varying vec3 vReflect;
		uniform float refractionRatio;
	#endif
#endif`,envmap_vertex=`#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vWorldPosition = worldPosition.xyz;
	#else
		vec3 cameraToVertex;
		if ( isOrthographic ) {
			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vReflect = reflect( cameraToVertex, worldNormal );
		#else
			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
		#endif
	#endif
#endif`,fog_vertex=`#ifdef USE_FOG
	vFogDepth = - mvPosition.z;
#endif`,fog_pars_vertex=`#ifdef USE_FOG
	varying float vFogDepth;
#endif`,fog_fragment=`#ifdef USE_FOG
	#ifdef FOG_EXP2
		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );
	#else
		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );
	#endif
	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif`,fog_pars_fragment=`#ifdef USE_FOG
	uniform vec3 fogColor;
	varying float vFogDepth;
	#ifdef FOG_EXP2
		uniform float fogDensity;
	#else
		uniform float fogNear;
		uniform float fogFar;
	#endif
#endif`,gradientmap_pars_fragment=`#ifdef USE_GRADIENTMAP
	uniform sampler2D gradientMap;
#endif
vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {
	float dotNL = dot( normal, lightDirection );
	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );
	#ifdef USE_GRADIENTMAP
		return vec3( texture2D( gradientMap, coord ).r );
	#else
		vec2 fw = fwidth( coord ) * 0.5;
		return mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );
	#endif
}`,lightmap_pars_fragment=`#ifdef USE_LIGHTMAP
	uniform sampler2D lightMap;
	uniform float lightMapIntensity;
#endif`,lights_lambert_fragment=`LambertMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularStrength = specularStrength;`,lights_lambert_pars_fragment=`varying vec3 vViewPosition;
struct LambertMaterial {
	vec3 diffuseColor;
	float specularStrength;
};
void RE_Direct_Lambert( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Lambert
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Lambert`,lights_pars_begin=`uniform bool receiveShadow;
uniform vec3 ambientLightColor;
#if defined( USE_LIGHT_PROBES )
	uniform vec3 lightProbe[ 9 ];
#endif
vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {
	float x = normal.x, y = normal.y, z = normal.z;
	vec3 result = shCoefficients[ 0 ] * 0.886227;
	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;
	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );
	return result;
}
vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {
	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );
	return irradiance;
}
vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {
	vec3 irradiance = ambientLightColor;
	return irradiance;
}
float getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {
	float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );
	if ( cutoffDistance > 0.0 ) {
		distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );
	}
	return distanceFalloff;
}
float getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {
	return smoothstep( coneCosine, penumbraCosine, angleCosine );
}
#if NUM_DIR_LIGHTS > 0
	struct DirectionalLight {
		vec3 direction;
		vec3 color;
	};
	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];
	void getDirectionalLightInfo( const in DirectionalLight directionalLight, out IncidentLight light ) {
		light.color = directionalLight.color;
		light.direction = directionalLight.direction;
		light.visible = true;
	}
#endif
#if NUM_POINT_LIGHTS > 0
	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
	};
	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];
	void getPointLightInfo( const in PointLight pointLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = pointLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float lightDistance = length( lVector );
		light.color = pointLight.color;
		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );
		light.visible = ( light.color != vec3( 0.0 ) );
	}
#endif
#if NUM_SPOT_LIGHTS > 0
	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
	};
	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];
	void getSpotLightInfo( const in SpotLight spotLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = spotLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float angleCos = dot( light.direction, spotLight.direction );
		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );
		if ( spotAttenuation > 0.0 ) {
			float lightDistance = length( lVector );
			light.color = spotLight.color * spotAttenuation;
			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );
			light.visible = ( light.color != vec3( 0.0 ) );
		} else {
			light.color = vec3( 0.0 );
			light.visible = false;
		}
	}
#endif
#if NUM_RECT_AREA_LIGHTS > 0
	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};
	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;
	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];
#endif
#if NUM_HEMI_LIGHTS > 0
	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};
	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];
	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {
		float dotNL = dot( normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;
		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );
		return irradiance;
	}
#endif`,envmap_physical_pars_fragment=`#ifdef USE_ENVMAP
	vec3 getIBLIrradiance( const in vec3 normal ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, envMapRotation * worldNormal, 1.0 );
			return PI * envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 reflectVec = reflect( - viewDir, normal );
			reflectVec = normalize( mix( reflectVec, normal, pow4( roughness ) ) );
			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, envMapRotation * reflectVec, roughness );
			return envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	#ifdef USE_ANISOTROPY
		vec3 getIBLAnisotropyRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in vec3 bitangent, const in float anisotropy ) {
			#ifdef ENVMAP_TYPE_CUBE_UV
				vec3 bentNormal = cross( bitangent, viewDir );
				bentNormal = normalize( cross( bentNormal, bitangent ) );
				bentNormal = normalize( mix( bentNormal, normal, pow2( pow2( 1.0 - anisotropy * ( 1.0 - roughness ) ) ) ) );
				return getIBLRadiance( viewDir, bentNormal, roughness );
			#else
				return vec3( 0.0 );
			#endif
		}
	#endif
#endif`,lights_toon_fragment=`ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;`,lights_toon_pars_fragment=`varying vec3 vViewPosition;
struct ToonMaterial {
	vec3 diffuseColor;
};
void RE_Direct_Toon( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	vec3 irradiance = getGradientIrradiance( geometryNormal, directLight.direction ) * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Toon
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon`,lights_phong_fragment=`BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;`,lights_phong_pars_fragment=`varying vec3 vViewPosition;
struct BlinnPhongMaterial {
	vec3 diffuseColor;
	vec3 specularColor;
	float specularShininess;
	float specularStrength;
};
void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometryViewDir, geometryNormal, material.specularColor, material.specularShininess ) * material.specularStrength;
}
void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong`,lights_physical_fragment=`PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );
vec3 dxy = max( abs( dFdx( nonPerturbedNormal ) ), abs( dFdy( nonPerturbedNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );
material.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;
material.roughness = min( material.roughness, 1.0 );
#ifdef IOR
	material.ior = ior;
	#ifdef USE_SPECULAR
		float specularIntensityFactor = specularIntensity;
		vec3 specularColorFactor = specularColor;
		#ifdef USE_SPECULAR_COLORMAP
			specularColorFactor *= texture2D( specularColorMap, vSpecularColorMapUv ).rgb;
		#endif
		#ifdef USE_SPECULAR_INTENSITYMAP
			specularIntensityFactor *= texture2D( specularIntensityMap, vSpecularIntensityMapUv ).a;
		#endif
		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );
	#else
		float specularIntensityFactor = 1.0;
		vec3 specularColorFactor = vec3( 1.0 );
		material.specularF90 = 1.0;
	#endif
	material.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );
#else
	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );
	material.specularF90 = 1.0;
#endif
#ifdef USE_CLEARCOAT
	material.clearcoat = clearcoat;
	material.clearcoatRoughness = clearcoatRoughness;
	material.clearcoatF0 = vec3( 0.04 );
	material.clearcoatF90 = 1.0;
	#ifdef USE_CLEARCOATMAP
		material.clearcoat *= texture2D( clearcoatMap, vClearcoatMapUv ).x;
	#endif
	#ifdef USE_CLEARCOAT_ROUGHNESSMAP
		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vClearcoatRoughnessMapUv ).y;
	#endif
	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );
	material.clearcoatRoughness += geometryRoughness;
	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );
#endif
#ifdef USE_DISPERSION
	material.dispersion = dispersion;
#endif
#ifdef USE_IRIDESCENCE
	material.iridescence = iridescence;
	material.iridescenceIOR = iridescenceIOR;
	#ifdef USE_IRIDESCENCEMAP
		material.iridescence *= texture2D( iridescenceMap, vIridescenceMapUv ).r;
	#endif
	#ifdef USE_IRIDESCENCE_THICKNESSMAP
		material.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vIridescenceThicknessMapUv ).g + iridescenceThicknessMinimum;
	#else
		material.iridescenceThickness = iridescenceThicknessMaximum;
	#endif
#endif
#ifdef USE_SHEEN
	material.sheenColor = sheenColor;
	#ifdef USE_SHEEN_COLORMAP
		material.sheenColor *= texture2D( sheenColorMap, vSheenColorMapUv ).rgb;
	#endif
	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );
	#ifdef USE_SHEEN_ROUGHNESSMAP
		material.sheenRoughness *= texture2D( sheenRoughnessMap, vSheenRoughnessMapUv ).a;
	#endif
#endif
#ifdef USE_ANISOTROPY
	#ifdef USE_ANISOTROPYMAP
		mat2 anisotropyMat = mat2( anisotropyVector.x, anisotropyVector.y, - anisotropyVector.y, anisotropyVector.x );
		vec3 anisotropyPolar = texture2D( anisotropyMap, vAnisotropyMapUv ).rgb;
		vec2 anisotropyV = anisotropyMat * normalize( 2.0 * anisotropyPolar.rg - vec2( 1.0 ) ) * anisotropyPolar.b;
	#else
		vec2 anisotropyV = anisotropyVector;
	#endif
	material.anisotropy = length( anisotropyV );
	if( material.anisotropy == 0.0 ) {
		anisotropyV = vec2( 1.0, 0.0 );
	} else {
		anisotropyV /= material.anisotropy;
		material.anisotropy = saturate( material.anisotropy );
	}
	material.alphaT = mix( pow2( material.roughness ), 1.0, pow2( material.anisotropy ) );
	material.anisotropyT = tbn[ 0 ] * anisotropyV.x + tbn[ 1 ] * anisotropyV.y;
	material.anisotropyB = tbn[ 1 ] * anisotropyV.x - tbn[ 0 ] * anisotropyV.y;
#endif`,lights_physical_pars_fragment=`uniform sampler2D dfgLUT;
struct PhysicalMaterial {
	vec3 diffuseColor;
	float roughness;
	vec3 specularColor;
	float specularF90;
	float dispersion;
	#ifdef USE_CLEARCOAT
		float clearcoat;
		float clearcoatRoughness;
		vec3 clearcoatF0;
		float clearcoatF90;
	#endif
	#ifdef USE_IRIDESCENCE
		float iridescence;
		float iridescenceIOR;
		float iridescenceThickness;
		vec3 iridescenceFresnel;
		vec3 iridescenceF0;
	#endif
	#ifdef USE_SHEEN
		vec3 sheenColor;
		float sheenRoughness;
	#endif
	#ifdef IOR
		float ior;
	#endif
	#ifdef USE_TRANSMISSION
		float transmission;
		float transmissionAlpha;
		float thickness;
		float attenuationDistance;
		vec3 attenuationColor;
	#endif
	#ifdef USE_ANISOTROPY
		float anisotropy;
		float alphaT;
		vec3 anisotropyT;
		vec3 anisotropyB;
	#endif
};
vec3 clearcoatSpecularDirect = vec3( 0.0 );
vec3 clearcoatSpecularIndirect = vec3( 0.0 );
vec3 sheenSpecularDirect = vec3( 0.0 );
vec3 sheenSpecularIndirect = vec3(0.0 );
vec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {
    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );
    float x2 = x * x;
    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );
    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );
}
float V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	return 0.5 / max( gv + gl, EPSILON );
}
float D_GGX( const in float alpha, const in float dotNH ) {
	float a2 = pow2( alpha );
	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;
	return RECIPROCAL_PI * a2 / pow2( denom );
}
#ifdef USE_ANISOTROPY
	float V_GGX_SmithCorrelated_Anisotropic( const in float alphaT, const in float alphaB, const in float dotTV, const in float dotBV, const in float dotTL, const in float dotBL, const in float dotNV, const in float dotNL ) {
		float gv = dotNL * length( vec3( alphaT * dotTV, alphaB * dotBV, dotNV ) );
		float gl = dotNV * length( vec3( alphaT * dotTL, alphaB * dotBL, dotNL ) );
		float v = 0.5 / ( gv + gl );
		return saturate(v);
	}
	float D_GGX_Anisotropic( const in float alphaT, const in float alphaB, const in float dotNH, const in float dotTH, const in float dotBH ) {
		float a2 = alphaT * alphaB;
		highp vec3 v = vec3( alphaB * dotTH, alphaT * dotBH, a2 * dotNH );
		highp float v2 = dot( v, v );
		float w2 = a2 / v2;
		return RECIPROCAL_PI * a2 * pow2 ( w2 );
	}
#endif
#ifdef USE_CLEARCOAT
	vec3 BRDF_GGX_Clearcoat( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material) {
		vec3 f0 = material.clearcoatF0;
		float f90 = material.clearcoatF90;
		float roughness = material.clearcoatRoughness;
		float alpha = pow2( roughness );
		vec3 halfDir = normalize( lightDir + viewDir );
		float dotNL = saturate( dot( normal, lightDir ) );
		float dotNV = saturate( dot( normal, viewDir ) );
		float dotNH = saturate( dot( normal, halfDir ) );
		float dotVH = saturate( dot( viewDir, halfDir ) );
		vec3 F = F_Schlick( f0, f90, dotVH );
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
		return F * ( V * D );
	}
#endif
vec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {
	vec3 f0 = material.specularColor;
	float f90 = material.specularF90;
	float roughness = material.roughness;
	float alpha = pow2( roughness );
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( f0, f90, dotVH );
	#ifdef USE_IRIDESCENCE
		F = mix( F, material.iridescenceFresnel, material.iridescence );
	#endif
	#ifdef USE_ANISOTROPY
		float dotTL = dot( material.anisotropyT, lightDir );
		float dotTV = dot( material.anisotropyT, viewDir );
		float dotTH = dot( material.anisotropyT, halfDir );
		float dotBL = dot( material.anisotropyB, lightDir );
		float dotBV = dot( material.anisotropyB, viewDir );
		float dotBH = dot( material.anisotropyB, halfDir );
		float V = V_GGX_SmithCorrelated_Anisotropic( material.alphaT, alpha, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL );
		float D = D_GGX_Anisotropic( material.alphaT, alpha, dotNH, dotTH, dotBH );
	#else
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
	#endif
	return F * ( V * D );
}
vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;
	float dotNV = saturate( dot( N, V ) );
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
	uv = uv * LUT_SCALE + LUT_BIAS;
	return uv;
}
float LTC_ClippedSphereFormFactor( const in vec3 f ) {
	float l = length( f );
	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}
vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
	float x = dot( v1, v2 );
	float y = abs( x );
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;
	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
	return cross( v1, v2 ) * theta_sintheta;
}
vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );
	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 );
	mat3 mat = mInv * transpose( mat3( T1, T2, N ) );
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );
	return vec3( result );
}
#if defined( USE_SHEEN )
float D_Charlie( float roughness, float dotNH ) {
	float alpha = pow2( roughness );
	float invAlpha = 1.0 / alpha;
	float cos2h = dotNH * dotNH;
	float sin2h = max( 1.0 - cos2h, 0.0078125 );
	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );
}
float V_Neubelt( float dotNV, float dotNL ) {
	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );
}
vec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float D = D_Charlie( sheenRoughness, dotNH );
	float V = V_Neubelt( dotNV, dotNL );
	return sheenColor * ( D * V );
}
#endif
float IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	float r2 = roughness * roughness;
	float a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;
	float b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;
	float DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );
	return saturate( DG * RECIPROCAL_PI );
}
vec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	vec2 uv = vec2( roughness, dotNV );
	return texture2D( dfgLUT, uv ).rg;
}
vec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	return specularColor * fab.x + specularF90 * fab.y;
}
#ifdef USE_IRIDESCENCE
void computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#else
void computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#endif
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	#ifdef USE_IRIDESCENCE
		vec3 Fr = mix( specularColor, iridescenceF0, iridescence );
	#else
		vec3 Fr = specularColor;
	#endif
	vec3 FssEss = Fr * fab.x + specularF90 * fab.y;
	float Ess = fab.x + fab.y;
	float Ems = 1.0 - Ess;
	vec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );
	singleScatter += FssEss;
	multiScatter += Fms * Ems;
}
vec3 BRDF_GGX_Multiscatter( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {
	vec3 singleScatter = BRDF_GGX( lightDir, viewDir, normal, material );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	vec2 dfgV = DFGApprox( vec3(0.0, 0.0, 1.0), vec3(sqrt(1.0 - dotNV * dotNV), 0.0, dotNV), material.roughness );
	vec2 dfgL = DFGApprox( vec3(0.0, 0.0, 1.0), vec3(sqrt(1.0 - dotNL * dotNL), 0.0, dotNL), material.roughness );
	vec3 FssEss_V = material.specularColor * dfgV.x + material.specularF90 * dfgV.y;
	vec3 FssEss_L = material.specularColor * dfgL.x + material.specularF90 * dfgL.y;
	float Ess_V = dfgV.x + dfgV.y;
	float Ess_L = dfgL.x + dfgL.y;
	float Ems_V = 1.0 - Ess_V;
	float Ems_L = 1.0 - Ess_L;
	vec3 Favg = material.specularColor + ( 1.0 - material.specularColor ) * 0.047619;
	vec3 Fms = FssEss_V * FssEss_L * Favg / ( 1.0 - Ems_V * Ems_L * Favg * Favg + EPSILON );
	float compensationFactor = Ems_V * Ems_L;
	vec3 multiScatter = Fms * compensationFactor;
	return singleScatter + multiScatter;
}
#if NUM_RECT_AREA_LIGHTS > 0
	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
		vec3 normal = geometryNormal;
		vec3 viewDir = geometryViewDir;
		vec3 position = geometryPosition;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.roughness;
		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;
		vec2 uv = LTC_Uv( normal, viewDir, roughness );
		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );
		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);
		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );
		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );
		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );
	}
#endif
void RE_Direct_Physical( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifdef USE_CLEARCOAT
		float dotNLcc = saturate( dot( geometryClearcoatNormal, directLight.direction ) );
		vec3 ccIrradiance = dotNLcc * directLight.color;
		clearcoatSpecularDirect += ccIrradiance * BRDF_GGX_Clearcoat( directLight.direction, geometryViewDir, geometryClearcoatNormal, material );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularDirect += irradiance * BRDF_Sheen( directLight.direction, geometryViewDir, geometryNormal, material.sheenColor, material.sheenRoughness );
	#endif
	reflectedLight.directSpecular += irradiance * BRDF_GGX_Multiscatter( directLight.direction, geometryViewDir, geometryNormal, material );
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {
	#ifdef USE_CLEARCOAT
		clearcoatSpecularIndirect += clearcoatRadiance * EnvironmentBRDF( geometryClearcoatNormal, geometryViewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularIndirect += irradiance * material.sheenColor * IBLSheenBRDF( geometryNormal, geometryViewDir, material.sheenRoughness );
	#endif
	vec3 singleScattering = vec3( 0.0 );
	vec3 multiScattering = vec3( 0.0 );
	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;
	#ifdef USE_IRIDESCENCE
		computeMultiscatteringIridescence( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );
	#else
		computeMultiscattering( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );
	#endif
	vec3 totalScattering = singleScattering + multiScattering;
	vec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );
	reflectedLight.indirectSpecular += radiance * singleScattering;
	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;
	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;
}
#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {
	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );
}`,lights_fragment_begin=`
vec3 geometryPosition = - vViewPosition;
vec3 geometryNormal = normal;
vec3 geometryViewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );
vec3 geometryClearcoatNormal = vec3( 0.0 );
#ifdef USE_CLEARCOAT
	geometryClearcoatNormal = clearcoatNormal;
#endif
#ifdef USE_IRIDESCENCE
	float dotNVi = saturate( dot( normal, geometryViewDir ) );
	if ( material.iridescenceThickness == 0.0 ) {
		material.iridescence = 0.0;
	} else {
		material.iridescence = saturate( material.iridescence );
	}
	if ( material.iridescence > 0.0 ) {
		material.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );
		material.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );
	}
#endif
IncidentLight directLight;
#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )
	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		pointLight = pointLights[ i ];
		getPointLightInfo( pointLight, geometryPosition, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowIntensity, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )
	SpotLight spotLight;
	vec4 spotColor;
	vec3 spotLightCoord;
	bool inSpotLightMap;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		spotLight = spotLights[ i ];
		getSpotLightInfo( spotLight, geometryPosition, directLight );
		#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX
		#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS
		#else
		#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#endif
		#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )
			spotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;
			inSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );
			spotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );
			directLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;
		#endif
		#undef SPOT_LIGHT_MAP_INDEX
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowIntensity, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )
	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		directionalLight = directionalLights[ i ];
		getDirectionalLightInfo( directionalLight, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowIntensity, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )
	RectAreaLight rectAreaLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {
		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if defined( RE_IndirectDiffuse )
	vec3 iblIrradiance = vec3( 0.0 );
	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );
	#if defined( USE_LIGHT_PROBES )
		irradiance += getLightProbeIrradiance( lightProbe, geometryNormal );
	#endif
	#if ( NUM_HEMI_LIGHTS > 0 )
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometryNormal );
		}
		#pragma unroll_loop_end
	#endif
#endif
#if defined( RE_IndirectSpecular )
	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );
#endif`,lights_fragment_maps=`#if defined( RE_IndirectDiffuse )
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
		irradiance += lightMapIrradiance;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )
		iblIrradiance += getIBLIrradiance( geometryNormal );
	#endif
#endif
#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )
	#ifdef USE_ANISOTROPY
		radiance += getIBLAnisotropyRadiance( geometryViewDir, geometryNormal, material.roughness, material.anisotropyB, material.anisotropy );
	#else
		radiance += getIBLRadiance( geometryViewDir, geometryNormal, material.roughness );
	#endif
	#ifdef USE_CLEARCOAT
		clearcoatRadiance += getIBLRadiance( geometryViewDir, geometryClearcoatNormal, material.clearcoatRoughness );
	#endif
#endif`,lights_fragment_end=`#if defined( RE_IndirectDiffuse )
	RE_IndirectDiffuse( irradiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif
#if defined( RE_IndirectSpecular )
	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif`,logdepthbuf_fragment=`#if defined( USE_LOGARITHMIC_DEPTH_BUFFER )
	gl_FragDepth = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;
#endif`,logdepthbuf_pars_fragment=`#if defined( USE_LOGARITHMIC_DEPTH_BUFFER )
	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`,logdepthbuf_pars_vertex=`#ifdef USE_LOGARITHMIC_DEPTH_BUFFER
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`,logdepthbuf_vertex=`#ifdef USE_LOGARITHMIC_DEPTH_BUFFER
	vFragDepth = 1.0 + gl_Position.w;
	vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );
#endif`,map_fragment=`#ifdef USE_MAP
	vec4 sampledDiffuseColor = texture2D( map, vMapUv );
	#ifdef DECODE_VIDEO_TEXTURE
		sampledDiffuseColor = sRGBTransferEOTF( sampledDiffuseColor );
	#endif
	diffuseColor *= sampledDiffuseColor;
#endif`,map_pars_fragment=`#ifdef USE_MAP
	uniform sampler2D map;
#endif`,map_particle_fragment=`#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	#if defined( USE_POINTS_UV )
		vec2 uv = vUv;
	#else
		vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;
	#endif
#endif
#ifdef USE_MAP
	diffuseColor *= texture2D( map, uv );
#endif
#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, uv ).g;
#endif`,map_particle_pars_fragment=`#if defined( USE_POINTS_UV )
	varying vec2 vUv;
#else
	#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
		uniform mat3 uvTransform;
	#endif
#endif
#ifdef USE_MAP
	uniform sampler2D map;
#endif
#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,metalnessmap_fragment=`float metalnessFactor = metalness;
#ifdef USE_METALNESSMAP
	vec4 texelMetalness = texture2D( metalnessMap, vMetalnessMapUv );
	metalnessFactor *= texelMetalness.b;
#endif`,metalnessmap_pars_fragment=`#ifdef USE_METALNESSMAP
	uniform sampler2D metalnessMap;
#endif`,morphinstance_vertex=`#ifdef USE_INSTANCING_MORPH
	float morphTargetInfluences[ MORPHTARGETS_COUNT ];
	float morphTargetBaseInfluence = texelFetch( morphTexture, ivec2( 0, gl_InstanceID ), 0 ).r;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		morphTargetInfluences[i] =  texelFetch( morphTexture, ivec2( i + 1, gl_InstanceID ), 0 ).r;
	}
#endif`,morphcolor_vertex=`#if defined( USE_MORPHCOLORS )
	vColor *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		#if defined( USE_COLOR_ALPHA )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];
		#elif defined( USE_COLOR )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];
		#endif
	}
#endif`,morphnormal_vertex=`#ifdef USE_MORPHNORMALS
	objectNormal *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		if ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];
	}
#endif`,morphtarget_pars_vertex=`#ifdef USE_MORPHTARGETS
	#ifndef USE_INSTANCING_MORPH
		uniform float morphTargetBaseInfluence;
		uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];
	#endif
	uniform sampler2DArray morphTargetsTexture;
	uniform ivec2 morphTargetsTextureSize;
	vec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {
		int texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;
		int y = texelIndex / morphTargetsTextureSize.x;
		int x = texelIndex - y * morphTargetsTextureSize.x;
		ivec3 morphUV = ivec3( x, y, morphTargetIndex );
		return texelFetch( morphTargetsTexture, morphUV, 0 );
	}
#endif`,morphtarget_vertex=`#ifdef USE_MORPHTARGETS
	transformed *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];
	}
#endif`,normal_fragment_begin=`float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;
#ifdef FLAT_SHADED
	vec3 fdx = dFdx( vViewPosition );
	vec3 fdy = dFdy( vViewPosition );
	vec3 normal = normalize( cross( fdx, fdy ) );
#else
	vec3 normal = normalize( vNormal );
	#ifdef DOUBLE_SIDED
		normal *= faceDirection;
	#endif
#endif
#if defined( USE_NORMALMAP_TANGENTSPACE ) || defined( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY )
	#ifdef USE_TANGENT
		mat3 tbn = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn = getTangentFrame( - vViewPosition, normal,
		#if defined( USE_NORMALMAP )
			vNormalMapUv
		#elif defined( USE_CLEARCOAT_NORMALMAP )
			vClearcoatNormalMapUv
		#else
			vUv
		#endif
		);
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn[0] *= faceDirection;
		tbn[1] *= faceDirection;
	#endif
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	#ifdef USE_TANGENT
		mat3 tbn2 = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn2 = getTangentFrame( - vViewPosition, normal, vClearcoatNormalMapUv );
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn2[0] *= faceDirection;
		tbn2[1] *= faceDirection;
	#endif
#endif
vec3 nonPerturbedNormal = normal;`,normal_fragment_maps=`#ifdef USE_NORMALMAP_OBJECTSPACE
	normal = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	#ifdef FLIP_SIDED
		normal = - normal;
	#endif
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	normal = normalize( normalMatrix * normal );
#elif defined( USE_NORMALMAP_TANGENTSPACE )
	vec3 mapN = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	mapN.xy *= normalScale;
	normal = normalize( tbn * mapN );
#elif defined( USE_BUMPMAP )
	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );
#endif`,normal_pars_fragment=`#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,normal_pars_vertex=`#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,normal_vertex=`#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif`,normalmap_pars_fragment=`#ifdef USE_NORMALMAP
	uniform sampler2D normalMap;
	uniform vec2 normalScale;
#endif
#ifdef USE_NORMALMAP_OBJECTSPACE
	uniform mat3 normalMatrix;
#endif
#if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY ) )
	mat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {
		vec3 q0 = dFdx( eye_pos.xyz );
		vec3 q1 = dFdy( eye_pos.xyz );
		vec2 st0 = dFdx( uv.st );
		vec2 st1 = dFdy( uv.st );
		vec3 N = surf_norm;
		vec3 q1perp = cross( q1, N );
		vec3 q0perp = cross( N, q0 );
		vec3 T = q1perp * st0.x + q0perp * st1.x;
		vec3 B = q1perp * st0.y + q0perp * st1.y;
		float det = max( dot( T, T ), dot( B, B ) );
		float scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );
		return mat3( T * scale, B * scale, N );
	}
#endif`,clearcoat_normal_fragment_begin=`#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal = nonPerturbedNormal;
#endif`,clearcoat_normal_fragment_maps=`#ifdef USE_CLEARCOAT_NORMALMAP
	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vClearcoatNormalMapUv ).xyz * 2.0 - 1.0;
	clearcoatMapN.xy *= clearcoatNormalScale;
	clearcoatNormal = normalize( tbn2 * clearcoatMapN );
#endif`,clearcoat_pars_fragment=`#ifdef USE_CLEARCOATMAP
	uniform sampler2D clearcoatMap;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform sampler2D clearcoatNormalMap;
	uniform vec2 clearcoatNormalScale;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform sampler2D clearcoatRoughnessMap;
#endif`,iridescence_pars_fragment=`#ifdef USE_IRIDESCENCEMAP
	uniform sampler2D iridescenceMap;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform sampler2D iridescenceThicknessMap;
#endif`,opaque_fragment=`#ifdef OPAQUE
diffuseColor.a = 1.0;
#endif
#ifdef USE_TRANSMISSION
diffuseColor.a *= material.transmissionAlpha;
#endif
gl_FragColor = vec4( outgoingLight, diffuseColor.a );`,packing=`vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}
vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}
const float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;const float ShiftRight8 = 1. / 256.;
const float Inv255 = 1. / 255.;
const vec4 PackFactors = vec4( 1.0, 256.0, 256.0 * 256.0, 256.0 * 256.0 * 256.0 );
const vec2 UnpackFactors2 = vec2( UnpackDownscale, 1.0 / PackFactors.g );
const vec3 UnpackFactors3 = vec3( UnpackDownscale / PackFactors.rg, 1.0 / PackFactors.b );
const vec4 UnpackFactors4 = vec4( UnpackDownscale / PackFactors.rgb, 1.0 / PackFactors.a );
vec4 packDepthToRGBA( const in float v ) {
	if( v <= 0.0 )
		return vec4( 0., 0., 0., 0. );
	if( v >= 1.0 )
		return vec4( 1., 1., 1., 1. );
	float vuf;
	float af = modf( v * PackFactors.a, vuf );
	float bf = modf( vuf * ShiftRight8, vuf );
	float gf = modf( vuf * ShiftRight8, vuf );
	return vec4( vuf * Inv255, gf * PackUpscale, bf * PackUpscale, af );
}
vec3 packDepthToRGB( const in float v ) {
	if( v <= 0.0 )
		return vec3( 0., 0., 0. );
	if( v >= 1.0 )
		return vec3( 1., 1., 1. );
	float vuf;
	float bf = modf( v * PackFactors.b, vuf );
	float gf = modf( vuf * ShiftRight8, vuf );
	return vec3( vuf * Inv255, gf * PackUpscale, bf );
}
vec2 packDepthToRG( const in float v ) {
	if( v <= 0.0 )
		return vec2( 0., 0. );
	if( v >= 1.0 )
		return vec2( 1., 1. );
	float vuf;
	float gf = modf( v * 256., vuf );
	return vec2( vuf * Inv255, gf );
}
float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors4 );
}
float unpackRGBToDepth( const in vec3 v ) {
	return dot( v, UnpackFactors3 );
}
float unpackRGToDepth( const in vec2 v ) {
	return v.r * UnpackFactors2.r + v.g * UnpackFactors2.g;
}
vec4 pack2HalfToRGBA( const in vec2 v ) {
	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );
	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );
}
vec2 unpackRGBATo2Half( const in vec4 v ) {
	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}
float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return depth * ( near - far ) - near;
}
float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * depth - far );
}`,premultiplied_alpha_fragment=`#ifdef PREMULTIPLIED_ALPHA
	gl_FragColor.rgb *= gl_FragColor.a;
#endif`,project_vertex=`vec4 mvPosition = vec4( transformed, 1.0 );
#ifdef USE_BATCHING
	mvPosition = batchingMatrix * mvPosition;
#endif
#ifdef USE_INSTANCING
	mvPosition = instanceMatrix * mvPosition;
#endif
mvPosition = modelViewMatrix * mvPosition;
gl_Position = projectionMatrix * mvPosition;`,dithering_fragment=`#ifdef DITHERING
	gl_FragColor.rgb = dithering( gl_FragColor.rgb );
#endif`,dithering_pars_fragment=`#ifdef DITHERING
	vec3 dithering( vec3 color ) {
		float grid_position = rand( gl_FragCoord.xy );
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );
		return color + dither_shift_RGB;
	}
#endif`,roughnessmap_fragment=`float roughnessFactor = roughness;
#ifdef USE_ROUGHNESSMAP
	vec4 texelRoughness = texture2D( roughnessMap, vRoughnessMapUv );
	roughnessFactor *= texelRoughness.g;
#endif`,roughnessmap_pars_fragment=`#ifdef USE_ROUGHNESSMAP
	uniform sampler2D roughnessMap;
#endif`,shadowmap_pars_fragment=`#if NUM_SPOT_LIGHT_COORDS > 0
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#if NUM_SPOT_LIGHT_MAPS > 0
	uniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {
		float depth = unpackRGBAToDepth( texture2D( depths, uv ) );
		#ifdef USE_REVERSED_DEPTH_BUFFER
			return step( depth, compare );
		#else
			return step( compare, depth );
		#endif
	}
	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {
		return unpackRGBATo2Half( texture2D( shadow, uv ) );
	}
	float VSMShadow( sampler2D shadow, vec2 uv, float compare ) {
		float occlusion = 1.0;
		vec2 distribution = texture2DDistribution( shadow, uv );
		#ifdef USE_REVERSED_DEPTH_BUFFER
			float hard_shadow = step( distribution.x, compare );
		#else
			float hard_shadow = step( compare, distribution.x );
		#endif
		if ( hard_shadow != 1.0 ) {
			float distance = compare - distribution.x;
			float variance = max( 0.00000, distribution.y * distribution.y );
			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );
		}
		return occlusion;
	}
	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
		float shadow = 1.0;
		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;
		bool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;
		bool frustumTest = inFrustum && shadowCoord.z <= 1.0;
		if ( frustumTest ) {
		#if defined( SHADOWMAP_TYPE_PCF )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			float dx2 = dx0 / 2.0;
			float dy2 = dy0 / 2.0;
			float dx3 = dx1 / 2.0;
			float dy3 = dy1 / 2.0;
			shadow = (
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 17.0 );
		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx = texelSize.x;
			float dy = texelSize.y;
			vec2 uv = shadowCoord.xy;
			vec2 f = fract( uv * shadowMapSize + 0.5 );
			uv -= f * texelSize;
			shadow = (
				texture2DCompare( shadowMap, uv, shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
						  f.x ),
					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
						  f.x ),
					 f.y )
			) * ( 1.0 / 9.0 );
		#elif defined( SHADOWMAP_TYPE_VSM )
			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );
		#else
			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );
		#endif
		}
		return mix( 1.0, shadow, shadowIntensity );
	}
	vec2 cubeToUV( vec3 v, float texelSizeY ) {
		vec3 absV = abs( v );
		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );
		vec2 planar = v.xy;
		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;
		if ( absV.z >= almostOne ) {
			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;
		} else if ( absV.x >= almostOne ) {
			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;
		} else if ( absV.y >= almostOne ) {
			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;
		}
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );
	}
	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
		float shadow = 1.0;
		vec3 lightToPosition = shadowCoord.xyz;
		
		float lightToPositionLength = length( lightToPosition );
		if ( lightToPositionLength - shadowCameraFar <= 0.0 && lightToPositionLength - shadowCameraNear >= 0.0 ) {
			float dp = ( lightToPositionLength - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );			dp += shadowBias;
			vec3 bd3D = normalize( lightToPosition );
			vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );
			#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )
				vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;
				shadow = (
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
				) * ( 1.0 / 9.0 );
			#else
				shadow = texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );
			#endif
		}
		return mix( 1.0, shadow, shadowIntensity );
	}
#endif`,shadowmap_pars_vertex=`#if NUM_SPOT_LIGHT_COORDS > 0
	uniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		struct SpotLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
#endif`,shadowmap_vertex=`#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )
	vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
	vec4 shadowWorldPosition;
#endif
#if defined( USE_SHADOWMAP )
	#if NUM_DIR_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
			vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
			vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
#endif
#if NUM_SPOT_LIGHT_COORDS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {
		shadowWorldPosition = worldPosition;
		#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
			shadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;
		#endif
		vSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
#endif`,shadowmask_pars_fragment=`float getShadowMask() {
	float shadow = 1.0;
	#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		directionalLight = directionalLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowIntensity, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		spotLight = spotLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowIntensity, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		pointLight = pointLightShadows[ i ];
		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowIntensity, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#endif
	return shadow;
}`,skinbase_vertex=`#ifdef USE_SKINNING
	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );
#endif`,skinning_pars_vertex=`#ifdef USE_SKINNING
	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;
	uniform highp sampler2D boneTexture;
	mat4 getBoneMatrix( const in float i ) {
		int size = textureSize( boneTexture, 0 ).x;
		int j = int( i ) * 4;
		int x = j % size;
		int y = j / size;
		vec4 v1 = texelFetch( boneTexture, ivec2( x, y ), 0 );
		vec4 v2 = texelFetch( boneTexture, ivec2( x + 1, y ), 0 );
		vec4 v3 = texelFetch( boneTexture, ivec2( x + 2, y ), 0 );
		vec4 v4 = texelFetch( boneTexture, ivec2( x + 3, y ), 0 );
		return mat4( v1, v2, v3, v4 );
	}
#endif`,skinning_vertex=`#ifdef USE_SKINNING
	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;
	transformed = ( bindMatrixInverse * skinned ).xyz;
#endif`,skinnormal_vertex=`#ifdef USE_SKINNING
	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;
	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;
	#ifdef USE_TANGENT
		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#endif
#endif`,specularmap_fragment=`float specularStrength;
#ifdef USE_SPECULARMAP
	vec4 texelSpecular = texture2D( specularMap, vSpecularMapUv );
	specularStrength = texelSpecular.r;
#else
	specularStrength = 1.0;
#endif`,specularmap_pars_fragment=`#ifdef USE_SPECULARMAP
	uniform sampler2D specularMap;
#endif`,tonemapping_fragment=`#if defined( TONE_MAPPING )
	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
#endif`,tonemapping_pars_fragment=`#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
uniform float toneMappingExposure;
vec3 LinearToneMapping( vec3 color ) {
	return saturate( toneMappingExposure * color );
}
vec3 ReinhardToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );
}
vec3 CineonToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}
vec3 RRTAndODTFit( vec3 v ) {
	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
	return a / b;
}
vec3 ACESFilmicToneMapping( vec3 color ) {
	const mat3 ACESInputMat = mat3(
		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),
		vec3( 0.04823, 0.01566, 0.83777 )
	);
	const mat3 ACESOutputMat = mat3(
		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),
		vec3( -0.07367, -0.00605,  1.07602 )
	);
	color *= toneMappingExposure / 0.6;
	color = ACESInputMat * color;
	color = RRTAndODTFit( color );
	color = ACESOutputMat * color;
	return saturate( color );
}
const mat3 LINEAR_REC2020_TO_LINEAR_SRGB = mat3(
	vec3( 1.6605, - 0.1246, - 0.0182 ),
	vec3( - 0.5876, 1.1329, - 0.1006 ),
	vec3( - 0.0728, - 0.0083, 1.1187 )
);
const mat3 LINEAR_SRGB_TO_LINEAR_REC2020 = mat3(
	vec3( 0.6274, 0.0691, 0.0164 ),
	vec3( 0.3293, 0.9195, 0.0880 ),
	vec3( 0.0433, 0.0113, 0.8956 )
);
vec3 agxDefaultContrastApprox( vec3 x ) {
	vec3 x2 = x * x;
	vec3 x4 = x2 * x2;
	return + 15.5 * x4 * x2
		- 40.14 * x4 * x
		+ 31.96 * x4
		- 6.868 * x2 * x
		+ 0.4298 * x2
		+ 0.1191 * x
		- 0.00232;
}
vec3 AgXToneMapping( vec3 color ) {
	const mat3 AgXInsetMatrix = mat3(
		vec3( 0.856627153315983, 0.137318972929847, 0.11189821299995 ),
		vec3( 0.0951212405381588, 0.761241990602591, 0.0767994186031903 ),
		vec3( 0.0482516061458583, 0.101439036467562, 0.811302368396859 )
	);
	const mat3 AgXOutsetMatrix = mat3(
		vec3( 1.1271005818144368, - 0.1413297634984383, - 0.14132976349843826 ),
		vec3( - 0.11060664309660323, 1.157823702216272, - 0.11060664309660294 ),
		vec3( - 0.016493938717834573, - 0.016493938717834257, 1.2519364065950405 )
	);
	const float AgxMinEv = - 12.47393;	const float AgxMaxEv = 4.026069;
	color *= toneMappingExposure;
	color = LINEAR_SRGB_TO_LINEAR_REC2020 * color;
	color = AgXInsetMatrix * color;
	color = max( color, 1e-10 );	color = log2( color );
	color = ( color - AgxMinEv ) / ( AgxMaxEv - AgxMinEv );
	color = clamp( color, 0.0, 1.0 );
	color = agxDefaultContrastApprox( color );
	color = AgXOutsetMatrix * color;
	color = pow( max( vec3( 0.0 ), color ), vec3( 2.2 ) );
	color = LINEAR_REC2020_TO_LINEAR_SRGB * color;
	color = clamp( color, 0.0, 1.0 );
	return color;
}
vec3 NeutralToneMapping( vec3 color ) {
	const float StartCompression = 0.8 - 0.04;
	const float Desaturation = 0.15;
	color *= toneMappingExposure;
	float x = min( color.r, min( color.g, color.b ) );
	float offset = x < 0.08 ? x - 6.25 * x * x : 0.04;
	color -= offset;
	float peak = max( color.r, max( color.g, color.b ) );
	if ( peak < StartCompression ) return color;
	float d = 1. - StartCompression;
	float newPeak = 1. - d * d / ( peak + d - StartCompression );
	color *= newPeak / peak;
	float g = 1. - 1. / ( Desaturation * ( peak - newPeak ) + 1. );
	return mix( color, vec3( newPeak ), g );
}
vec3 CustomToneMapping( vec3 color ) { return color; }`,transmission_fragment=`#ifdef USE_TRANSMISSION
	material.transmission = transmission;
	material.transmissionAlpha = 1.0;
	material.thickness = thickness;
	material.attenuationDistance = attenuationDistance;
	material.attenuationColor = attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		material.transmission *= texture2D( transmissionMap, vTransmissionMapUv ).r;
	#endif
	#ifdef USE_THICKNESSMAP
		material.thickness *= texture2D( thicknessMap, vThicknessMapUv ).g;
	#endif
	vec3 pos = vWorldPosition;
	vec3 v = normalize( cameraPosition - pos );
	vec3 n = inverseTransformDirection( normal, viewMatrix );
	vec4 transmitted = getIBLVolumeRefraction(
		n, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,
		pos, modelMatrix, viewMatrix, projectionMatrix, material.dispersion, material.ior, material.thickness,
		material.attenuationColor, material.attenuationDistance );
	material.transmissionAlpha = mix( material.transmissionAlpha, transmitted.a, material.transmission );
	totalDiffuse = mix( totalDiffuse, transmitted.rgb, material.transmission );
#endif`,transmission_pars_fragment=`#ifdef USE_TRANSMISSION
	uniform float transmission;
	uniform float thickness;
	uniform float attenuationDistance;
	uniform vec3 attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		uniform sampler2D transmissionMap;
	#endif
	#ifdef USE_THICKNESSMAP
		uniform sampler2D thicknessMap;
	#endif
	uniform vec2 transmissionSamplerSize;
	uniform sampler2D transmissionSamplerMap;
	uniform mat4 modelMatrix;
	uniform mat4 projectionMatrix;
	varying vec3 vWorldPosition;
	float w0( float a ) {
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );
	}
	float w1( float a ) {
		return ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );
	}
	float w2( float a ){
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );
	}
	float w3( float a ) {
		return ( 1.0 / 6.0 ) * ( a * a * a );
	}
	float g0( float a ) {
		return w0( a ) + w1( a );
	}
	float g1( float a ) {
		return w2( a ) + w3( a );
	}
	float h0( float a ) {
		return - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );
	}
	float h1( float a ) {
		return 1.0 + w3( a ) / ( w2( a ) + w3( a ) );
	}
	vec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, float lod ) {
		uv = uv * texelSize.zw + 0.5;
		vec2 iuv = floor( uv );
		vec2 fuv = fract( uv );
		float g0x = g0( fuv.x );
		float g1x = g1( fuv.x );
		float h0x = h0( fuv.x );
		float h1x = h1( fuv.x );
		float h0y = h0( fuv.y );
		float h1y = h1( fuv.y );
		vec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		vec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		return g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) +
			g1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );
	}
	vec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {
		vec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );
		vec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );
		vec2 fLodSizeInv = 1.0 / fLodSize;
		vec2 cLodSizeInv = 1.0 / cLodSize;
		vec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );
		vec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );
		return mix( fSample, cSample, fract( lod ) );
	}
	vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {
		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );
		vec3 modelScale;
		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );
		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );
		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );
		return normalize( refractionVector ) * thickness * modelScale;
	}
	float applyIorToRoughness( const in float roughness, const in float ior ) {
		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );
	}
	vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {
		float lod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );
		return textureBicubic( transmissionSamplerMap, fragCoord.xy, lod );
	}
	vec3 volumeAttenuation( const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {
		if ( isinf( attenuationDistance ) ) {
			return vec3( 1.0 );
		} else {
			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;
			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance;
		}
	}
	vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,
		const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,
		const in mat4 viewMatrix, const in mat4 projMatrix, const in float dispersion, const in float ior, const in float thickness,
		const in vec3 attenuationColor, const in float attenuationDistance ) {
		vec4 transmittedLight;
		vec3 transmittance;
		#ifdef USE_DISPERSION
			float halfSpread = ( ior - 1.0 ) * 0.025 * dispersion;
			vec3 iors = vec3( ior - halfSpread, ior, ior + halfSpread );
			for ( int i = 0; i < 3; i ++ ) {
				vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, iors[ i ], modelMatrix );
				vec3 refractedRayExit = position + transmissionRay;
				vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
				vec2 refractionCoords = ndcPos.xy / ndcPos.w;
				refractionCoords += 1.0;
				refractionCoords /= 2.0;
				vec4 transmissionSample = getTransmissionSample( refractionCoords, roughness, iors[ i ] );
				transmittedLight[ i ] = transmissionSample[ i ];
				transmittedLight.a += transmissionSample.a;
				transmittance[ i ] = diffuseColor[ i ] * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance )[ i ];
			}
			transmittedLight.a /= 3.0;
		#else
			vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );
			vec3 refractedRayExit = position + transmissionRay;
			vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
			vec2 refractionCoords = ndcPos.xy / ndcPos.w;
			refractionCoords += 1.0;
			refractionCoords /= 2.0;
			transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );
			transmittance = diffuseColor * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance );
		#endif
		vec3 attenuatedColor = transmittance * transmittedLight.rgb;
		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );
		float transmittanceFactor = ( transmittance.r + transmittance.g + transmittance.b ) / 3.0;
		return vec4( ( 1.0 - F ) * attenuatedColor, 1.0 - ( 1.0 - transmittedLight.a ) * transmittanceFactor );
	}
#endif`,uv_pars_fragment=`#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_SPECULARMAP
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`,uv_pars_vertex=`#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	uniform mat3 mapTransform;
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	uniform mat3 alphaMapTransform;
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	uniform mat3 lightMapTransform;
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	uniform mat3 aoMapTransform;
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	uniform mat3 bumpMapTransform;
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	uniform mat3 normalMapTransform;
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_DISPLACEMENTMAP
	uniform mat3 displacementMapTransform;
	varying vec2 vDisplacementMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	uniform mat3 emissiveMapTransform;
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	uniform mat3 metalnessMapTransform;
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	uniform mat3 roughnessMapTransform;
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	uniform mat3 anisotropyMapTransform;
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	uniform mat3 clearcoatMapTransform;
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform mat3 clearcoatNormalMapTransform;
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform mat3 clearcoatRoughnessMapTransform;
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	uniform mat3 sheenColorMapTransform;
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	uniform mat3 sheenRoughnessMapTransform;
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	uniform mat3 iridescenceMapTransform;
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform mat3 iridescenceThicknessMapTransform;
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SPECULARMAP
	uniform mat3 specularMapTransform;
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	uniform mat3 specularColorMapTransform;
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	uniform mat3 specularIntensityMapTransform;
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`,uv_vertex=`#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	vUv = vec3( uv, 1 ).xy;
#endif
#ifdef USE_MAP
	vMapUv = ( mapTransform * vec3( MAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ALPHAMAP
	vAlphaMapUv = ( alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_LIGHTMAP
	vLightMapUv = ( lightMapTransform * vec3( LIGHTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_AOMAP
	vAoMapUv = ( aoMapTransform * vec3( AOMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_BUMPMAP
	vBumpMapUv = ( bumpMapTransform * vec3( BUMPMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_NORMALMAP
	vNormalMapUv = ( normalMapTransform * vec3( NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_DISPLACEMENTMAP
	vDisplacementMapUv = ( displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_EMISSIVEMAP
	vEmissiveMapUv = ( emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_METALNESSMAP
	vMetalnessMapUv = ( metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ROUGHNESSMAP
	vRoughnessMapUv = ( roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ANISOTROPYMAP
	vAnisotropyMapUv = ( anisotropyMapTransform * vec3( ANISOTROPYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOATMAP
	vClearcoatMapUv = ( clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	vClearcoatNormalMapUv = ( clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	vClearcoatRoughnessMapUv = ( clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCEMAP
	vIridescenceMapUv = ( iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	vIridescenceThicknessMapUv = ( iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_COLORMAP
	vSheenColorMapUv = ( sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	vSheenRoughnessMapUv = ( sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULARMAP
	vSpecularMapUv = ( specularMapTransform * vec3( SPECULARMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_COLORMAP
	vSpecularColorMapUv = ( specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	vSpecularIntensityMapUv = ( specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_TRANSMISSIONMAP
	vTransmissionMapUv = ( transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_THICKNESSMAP
	vThicknessMapUv = ( thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) ).xy;
#endif`,worldpos_vertex=`#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0
	vec4 worldPosition = vec4( transformed, 1.0 );
	#ifdef USE_BATCHING
		worldPosition = batchingMatrix * worldPosition;
	#endif
	#ifdef USE_INSTANCING
		worldPosition = instanceMatrix * worldPosition;
	#endif
	worldPosition = modelMatrix * worldPosition;
#endif`;const vertex$h=`varying vec2 vUv;
uniform mat3 uvTransform;
void main() {
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	gl_Position = vec4( position.xy, 1.0, 1.0 );
}`,fragment$h=`uniform sampler2D t2D;
uniform float backgroundIntensity;
varying vec2 vUv;
void main() {
	vec4 texColor = texture2D( t2D, vUv );
	#ifdef DECODE_VIDEO_TEXTURE
		texColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,vertex$g=`varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`,fragment$g=`#ifdef ENVMAP_TYPE_CUBE
	uniform samplerCube envMap;
#elif defined( ENVMAP_TYPE_CUBE_UV )
	uniform sampler2D envMap;
#endif
uniform float flipEnvMap;
uniform float backgroundBlurriness;
uniform float backgroundIntensity;
uniform mat3 backgroundRotation;
varying vec3 vWorldDirection;
#include <cube_uv_reflection_fragment>
void main() {
	#ifdef ENVMAP_TYPE_CUBE
		vec4 texColor = textureCube( envMap, backgroundRotation * vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );
	#elif defined( ENVMAP_TYPE_CUBE_UV )
		vec4 texColor = textureCubeUV( envMap, backgroundRotation * vWorldDirection, backgroundBlurriness );
	#else
		vec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,vertex$f=`varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`,fragment$f=`uniform samplerCube tCube;
uniform float tFlip;
uniform float opacity;
varying vec3 vWorldDirection;
void main() {
	vec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );
	gl_FragColor = texColor;
	gl_FragColor.a *= opacity;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,vertex$e=`#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
varying vec2 vHighPrecisionZW;
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <skinbase_vertex>
	#include <morphinstance_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vHighPrecisionZW = gl_Position.zw;
}`,fragment$e=`#if DEPTH_PACKING == 3200
	uniform float opacity;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
varying vec2 vHighPrecisionZW;
void main() {
	vec4 diffuseColor = vec4( 1.0 );
	#include <clipping_planes_fragment>
	#if DEPTH_PACKING == 3200
		diffuseColor.a = opacity;
	#endif
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <logdepthbuf_fragment>
	#ifdef USE_REVERSED_DEPTH_BUFFER
		float fragCoordZ = vHighPrecisionZW[ 0 ] / vHighPrecisionZW[ 1 ];
	#else
		float fragCoordZ = 0.5 * vHighPrecisionZW[ 0 ] / vHighPrecisionZW[ 1 ] + 0.5;
	#endif
	#if DEPTH_PACKING == 3200
		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );
	#elif DEPTH_PACKING == 3201
		gl_FragColor = packDepthToRGBA( fragCoordZ );
	#elif DEPTH_PACKING == 3202
		gl_FragColor = vec4( packDepthToRGB( fragCoordZ ), 1.0 );
	#elif DEPTH_PACKING == 3203
		gl_FragColor = vec4( packDepthToRG( fragCoordZ ), 0.0, 1.0 );
	#endif
}`,vertex$d=`#define DISTANCE
varying vec3 vWorldPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <skinbase_vertex>
	#include <morphinstance_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	vWorldPosition = worldPosition.xyz;
}`,fragment$d=`#define DISTANCE
uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <clipping_planes_pars_fragment>
void main () {
	vec4 diffuseColor = vec4( 1.0 );
	#include <clipping_planes_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist );
	gl_FragColor = packDepthToRGBA( dist );
}`,vertex$c=`varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
}`,fragment$c=`uniform sampler2D tEquirect;
varying vec3 vWorldDirection;
#include <common>
void main() {
	vec3 direction = normalize( vWorldDirection );
	vec2 sampleUV = equirectUv( direction );
	gl_FragColor = texture2D( tEquirect, sampleUV );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,vertex$b=`uniform float scale;
attribute float lineDistance;
varying float vLineDistance;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	vLineDistance = scale * lineDistance;
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,fragment$b=`uniform vec3 diffuse;
uniform float opacity;
uniform float dashSize;
uniform float totalSize;
varying float vLineDistance;
#include <common>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	if ( mod( vLineDistance, totalSize ) > dashSize ) {
		discard;
	}
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,vertex$a=`#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinbase_vertex>
		#include <skinnormal_vertex>
		#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}`,fragment$a=`uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,vertex$9=`#define LAMBERT
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,fragment$9=`#define LAMBERT
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_lambert_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_lambert_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,vertex$8=`#define MATCAP
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
	vViewPosition = - mvPosition.xyz;
}`,fragment$8=`#define MATCAP
uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;
varying vec3 vViewPosition;
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;
	#ifdef USE_MATCAP
		vec4 matcapColor = texture2D( matcap, uv );
	#else
		vec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );
	#endif
	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,vertex$7=`#define NORMAL
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	vViewPosition = - mvPosition.xyz;
#endif
}`,fragment$7=`#define NORMAL
uniform float opacity;
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <packing>
#include <uv_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( 0.0, 0.0, 0.0, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	gl_FragColor = vec4( packNormalToRGB( normal ), diffuseColor.a );
	#ifdef OPAQUE
		gl_FragColor.a = 1.0;
	#endif
}`,vertex$6=`#define PHONG
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,fragment$6=`#define PHONG
uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,vertex$5=`#define STANDARD
varying vec3 vViewPosition;
#ifdef USE_TRANSMISSION
	varying vec3 vWorldPosition;
#endif
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
#ifdef USE_TRANSMISSION
	vWorldPosition = worldPosition.xyz;
#endif
}`,fragment$5=`#define STANDARD
#ifdef PHYSICAL
	#define IOR
	#define USE_SPECULAR
#endif
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;
#ifdef IOR
	uniform float ior;
#endif
#ifdef USE_SPECULAR
	uniform float specularIntensity;
	uniform vec3 specularColor;
	#ifdef USE_SPECULAR_COLORMAP
		uniform sampler2D specularColorMap;
	#endif
	#ifdef USE_SPECULAR_INTENSITYMAP
		uniform sampler2D specularIntensityMap;
	#endif
#endif
#ifdef USE_CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif
#ifdef USE_DISPERSION
	uniform float dispersion;
#endif
#ifdef USE_IRIDESCENCE
	uniform float iridescence;
	uniform float iridescenceIOR;
	uniform float iridescenceThicknessMinimum;
	uniform float iridescenceThicknessMaximum;
#endif
#ifdef USE_SHEEN
	uniform vec3 sheenColor;
	uniform float sheenRoughness;
	#ifdef USE_SHEEN_COLORMAP
		uniform sampler2D sheenColorMap;
	#endif
	#ifdef USE_SHEEN_ROUGHNESSMAP
		uniform sampler2D sheenRoughnessMap;
	#endif
#endif
#ifdef USE_ANISOTROPY
	uniform vec2 anisotropyVector;
	#ifdef USE_ANISOTROPYMAP
		uniform sampler2D anisotropyMap;
	#endif
#endif
varying vec3 vViewPosition;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <iridescence_fragment>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_physical_pars_fragment>
#include <transmission_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <iridescence_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;
	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;
	#include <transmission_fragment>
	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;
	#ifdef USE_SHEEN
		float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );
		outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecularDirect + sheenSpecularIndirect;
	#endif
	#ifdef USE_CLEARCOAT
		float dotNVcc = saturate( dot( geometryClearcoatNormal, geometryViewDir ) );
		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );
		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + ( clearcoatSpecularDirect + clearcoatSpecularIndirect ) * material.clearcoat;
	#endif
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,vertex$4=`#define TOON
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,fragment$4=`#define TOON
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_toon_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,vertex$3=`uniform float size;
uniform float scale;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
#ifdef USE_POINTS_UV
	varying vec2 vUv;
	uniform mat3 uvTransform;
#endif
void main() {
	#ifdef USE_POINTS_UV
		vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	#endif
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	gl_PointSize = size;
	#ifdef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );
	#endif
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>
}`,fragment$3=`uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,vertex$2=`#include <common>
#include <batching_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <shadowmap_pars_vertex>
void main() {
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,fragment$2=`uniform vec3 color;
uniform float opacity;
#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <logdepthbuf_pars_fragment>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
void main() {
	#include <logdepthbuf_fragment>
	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`,vertex$1=`uniform float rotation;
uniform vec2 center;
#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	vec4 mvPosition = modelViewMatrix[ 3 ];
	vec2 scale = vec2( length( modelMatrix[ 0 ].xyz ), length( modelMatrix[ 1 ].xyz ) );
	#ifndef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) scale *= - mvPosition.z;
	#endif
	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;
	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
	mvPosition.xy += rotatedPosition;
	gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,fragment$1=`uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`,ShaderChunk={alphahash_fragment,alphahash_pars_fragment,alphamap_fragment,alphamap_pars_fragment,alphatest_fragment,alphatest_pars_fragment,aomap_fragment,aomap_pars_fragment,batching_pars_vertex,batching_vertex,begin_vertex,beginnormal_vertex,bsdfs,iridescence_fragment,bumpmap_pars_fragment,clipping_planes_fragment,clipping_planes_pars_fragment,clipping_planes_pars_vertex,clipping_planes_vertex,color_fragment,color_pars_fragment,color_pars_vertex,color_vertex,common,cube_uv_reflection_fragment,defaultnormal_vertex,displacementmap_pars_vertex,displacementmap_vertex,emissivemap_fragment,emissivemap_pars_fragment,colorspace_fragment,colorspace_pars_fragment,envmap_fragment,envmap_common_pars_fragment,envmap_pars_fragment,envmap_pars_vertex,envmap_physical_pars_fragment,envmap_vertex,fog_vertex,fog_pars_vertex,fog_fragment,fog_pars_fragment,gradientmap_pars_fragment,lightmap_pars_fragment,lights_lambert_fragment,lights_lambert_pars_fragment,lights_pars_begin,lights_toon_fragment,lights_toon_pars_fragment,lights_phong_fragment,lights_phong_pars_fragment,lights_physical_fragment,lights_physical_pars_fragment,lights_fragment_begin,lights_fragment_maps,lights_fragment_end,logdepthbuf_fragment,logdepthbuf_pars_fragment,logdepthbuf_pars_vertex,logdepthbuf_vertex,map_fragment,map_pars_fragment,map_particle_fragment,map_particle_pars_fragment,metalnessmap_fragment,metalnessmap_pars_fragment,morphinstance_vertex,morphcolor_vertex,morphnormal_vertex,morphtarget_pars_vertex,morphtarget_vertex,normal_fragment_begin,normal_fragment_maps,normal_pars_fragment,normal_pars_vertex,normal_vertex,normalmap_pars_fragment,clearcoat_normal_fragment_begin,clearcoat_normal_fragment_maps,clearcoat_pars_fragment,iridescence_pars_fragment,opaque_fragment,packing,premultiplied_alpha_fragment,project_vertex,dithering_fragment,dithering_pars_fragment,roughnessmap_fragment,roughnessmap_pars_fragment,shadowmap_pars_fragment,shadowmap_pars_vertex,shadowmap_vertex,shadowmask_pars_fragment,skinbase_vertex,skinning_pars_vertex,skinning_vertex,skinnormal_vertex,specularmap_fragment,specularmap_pars_fragment,tonemapping_fragment,tonemapping_pars_fragment,transmission_fragment,transmission_pars_fragment,uv_pars_fragment,uv_pars_vertex,uv_vertex,worldpos_vertex,background_vert:vertex$h,background_frag:fragment$h,backgroundCube_vert:vertex$g,backgroundCube_frag:fragment$g,cube_vert:vertex$f,cube_frag:fragment$f,depth_vert:vertex$e,depth_frag:fragment$e,distanceRGBA_vert:vertex$d,distanceRGBA_frag:fragment$d,equirect_vert:vertex$c,equirect_frag:fragment$c,linedashed_vert:vertex$b,linedashed_frag:fragment$b,meshbasic_vert:vertex$a,meshbasic_frag:fragment$a,meshlambert_vert:vertex$9,meshlambert_frag:fragment$9,meshmatcap_vert:vertex$8,meshmatcap_frag:fragment$8,meshnormal_vert:vertex$7,meshnormal_frag:fragment$7,meshphong_vert:vertex$6,meshphong_frag:fragment$6,meshphysical_vert:vertex$5,meshphysical_frag:fragment$5,meshtoon_vert:vertex$4,meshtoon_frag:fragment$4,points_vert:vertex$3,points_frag:fragment$3,shadow_vert:vertex$2,shadow_frag:fragment$2,sprite_vert:vertex$1,sprite_frag:fragment$1},UniformsLib={common:{diffuse:{value:new Color(16777215)},opacity:{value:1},map:{value:null},mapTransform:{value:new Matrix3},alphaMap:{value:null},alphaMapTransform:{value:new Matrix3},alphaTest:{value:0}},specularmap:{specularMap:{value:null},specularMapTransform:{value:new Matrix3}},envmap:{envMap:{value:null},envMapRotation:{value:new Matrix3},flipEnvMap:{value:-1},reflectivity:{value:1},ior:{value:1.5},refractionRatio:{value:.98},dfgLUT:{value:null}},aomap:{aoMap:{value:null},aoMapIntensity:{value:1},aoMapTransform:{value:new Matrix3}},lightmap:{lightMap:{value:null},lightMapIntensity:{value:1},lightMapTransform:{value:new Matrix3}},bumpmap:{bumpMap:{value:null},bumpMapTransform:{value:new Matrix3},bumpScale:{value:1}},normalmap:{normalMap:{value:null},normalMapTransform:{value:new Matrix3},normalScale:{value:new Vector2(1,1)}},displacementmap:{displacementMap:{value:null},displacementMapTransform:{value:new Matrix3},displacementScale:{value:1},displacementBias:{value:0}},emissivemap:{emissiveMap:{value:null},emissiveMapTransform:{value:new Matrix3}},metalnessmap:{metalnessMap:{value:null},metalnessMapTransform:{value:new Matrix3}},roughnessmap:{roughnessMap:{value:null},roughnessMapTransform:{value:new Matrix3}},gradientmap:{gradientMap:{value:null}},fog:{fogDensity:{value:25e-5},fogNear:{value:1},fogFar:{value:2e3},fogColor:{value:new Color(16777215)}},lights:{ambientLightColor:{value:[]},lightProbe:{value:[]},directionalLights:{value:[],properties:{direction:{},color:{}}},directionalLightShadows:{value:[],properties:{shadowIntensity:1,shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{}}},directionalShadowMap:{value:[]},directionalShadowMatrix:{value:[]},spotLights:{value:[],properties:{color:{},position:{},direction:{},distance:{},coneCos:{},penumbraCos:{},decay:{}}},spotLightShadows:{value:[],properties:{shadowIntensity:1,shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{}}},spotLightMap:{value:[]},spotShadowMap:{value:[]},spotLightMatrix:{value:[]},pointLights:{value:[],properties:{color:{},position:{},decay:{},distance:{}}},pointLightShadows:{value:[],properties:{shadowIntensity:1,shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{},shadowCameraNear:{},shadowCameraFar:{}}},pointShadowMap:{value:[]},pointShadowMatrix:{value:[]},hemisphereLights:{value:[],properties:{direction:{},skyColor:{},groundColor:{}}},rectAreaLights:{value:[],properties:{color:{},position:{},width:{},height:{}}},ltc_1:{value:null},ltc_2:{value:null}},points:{diffuse:{value:new Color(16777215)},opacity:{value:1},size:{value:1},scale:{value:1},map:{value:null},alphaMap:{value:null},alphaMapTransform:{value:new Matrix3},alphaTest:{value:0},uvTransform:{value:new Matrix3}},sprite:{diffuse:{value:new Color(16777215)},opacity:{value:1},center:{value:new Vector2(.5,.5)},rotation:{value:0},map:{value:null},mapTransform:{value:new Matrix3},alphaMap:{value:null},alphaMapTransform:{value:new Matrix3},alphaTest:{value:0}}},ShaderLib={basic:{uniforms:mergeUniforms([UniformsLib.common,UniformsLib.specularmap,UniformsLib.envmap,UniformsLib.aomap,UniformsLib.lightmap,UniformsLib.fog]),vertexShader:ShaderChunk.meshbasic_vert,fragmentShader:ShaderChunk.meshbasic_frag},lambert:{uniforms:mergeUniforms([UniformsLib.common,UniformsLib.specularmap,UniformsLib.envmap,UniformsLib.aomap,UniformsLib.lightmap,UniformsLib.emissivemap,UniformsLib.bumpmap,UniformsLib.normalmap,UniformsLib.displacementmap,UniformsLib.fog,UniformsLib.lights,{emissive:{value:new Color(0)}}]),vertexShader:ShaderChunk.meshlambert_vert,fragmentShader:ShaderChunk.meshlambert_frag},phong:{uniforms:mergeUniforms([UniformsLib.common,UniformsLib.specularmap,UniformsLib.envmap,UniformsLib.aomap,UniformsLib.lightmap,UniformsLib.emissivemap,UniformsLib.bumpmap,UniformsLib.normalmap,UniformsLib.displacementmap,UniformsLib.fog,UniformsLib.lights,{emissive:{value:new Color(0)},specular:{value:new Color(1118481)},shininess:{value:30}}]),vertexShader:ShaderChunk.meshphong_vert,fragmentShader:ShaderChunk.meshphong_frag},standard:{uniforms:mergeUniforms([UniformsLib.common,UniformsLib.envmap,UniformsLib.aomap,UniformsLib.lightmap,UniformsLib.emissivemap,UniformsLib.bumpmap,UniformsLib.normalmap,UniformsLib.displacementmap,UniformsLib.roughnessmap,UniformsLib.metalnessmap,UniformsLib.fog,UniformsLib.lights,{emissive:{value:new Color(0)},roughness:{value:1},metalness:{value:0},envMapIntensity:{value:1}}]),vertexShader:ShaderChunk.meshphysical_vert,fragmentShader:ShaderChunk.meshphysical_frag},toon:{uniforms:mergeUniforms([UniformsLib.common,UniformsLib.aomap,UniformsLib.lightmap,UniformsLib.emissivemap,UniformsLib.bumpmap,UniformsLib.normalmap,UniformsLib.displacementmap,UniformsLib.gradientmap,UniformsLib.fog,UniformsLib.lights,{emissive:{value:new Color(0)}}]),vertexShader:ShaderChunk.meshtoon_vert,fragmentShader:ShaderChunk.meshtoon_frag},matcap:{uniforms:mergeUniforms([UniformsLib.common,UniformsLib.bumpmap,UniformsLib.normalmap,UniformsLib.displacementmap,UniformsLib.fog,{matcap:{value:null}}]),vertexShader:ShaderChunk.meshmatcap_vert,fragmentShader:ShaderChunk.meshmatcap_frag},points:{uniforms:mergeUniforms([UniformsLib.points,UniformsLib.fog]),vertexShader:ShaderChunk.points_vert,fragmentShader:ShaderChunk.points_frag},dashed:{uniforms:mergeUniforms([UniformsLib.common,UniformsLib.fog,{scale:{value:1},dashSize:{value:1},totalSize:{value:2}}]),vertexShader:ShaderChunk.linedashed_vert,fragmentShader:ShaderChunk.linedashed_frag},depth:{uniforms:mergeUniforms([UniformsLib.common,UniformsLib.displacementmap]),vertexShader:ShaderChunk.depth_vert,fragmentShader:ShaderChunk.depth_frag},normal:{uniforms:mergeUniforms([UniformsLib.common,UniformsLib.bumpmap,UniformsLib.normalmap,UniformsLib.displacementmap,{opacity:{value:1}}]),vertexShader:ShaderChunk.meshnormal_vert,fragmentShader:ShaderChunk.meshnormal_frag},sprite:{uniforms:mergeUniforms([UniformsLib.sprite,UniformsLib.fog]),vertexShader:ShaderChunk.sprite_vert,fragmentShader:ShaderChunk.sprite_frag},background:{uniforms:{uvTransform:{value:new Matrix3},t2D:{value:null},backgroundIntensity:{value:1}},vertexShader:ShaderChunk.background_vert,fragmentShader:ShaderChunk.background_frag},backgroundCube:{uniforms:{envMap:{value:null},flipEnvMap:{value:-1},backgroundBlurriness:{value:0},backgroundIntensity:{value:1},backgroundRotation:{value:new Matrix3}},vertexShader:ShaderChunk.backgroundCube_vert,fragmentShader:ShaderChunk.backgroundCube_frag},cube:{uniforms:{tCube:{value:null},tFlip:{value:-1},opacity:{value:1}},vertexShader:ShaderChunk.cube_vert,fragmentShader:ShaderChunk.cube_frag},equirect:{uniforms:{tEquirect:{value:null}},vertexShader:ShaderChunk.equirect_vert,fragmentShader:ShaderChunk.equirect_frag},distanceRGBA:{uniforms:mergeUniforms([UniformsLib.common,UniformsLib.displacementmap,{referencePosition:{value:new Vector3},nearDistance:{value:1},farDistance:{value:1e3}}]),vertexShader:ShaderChunk.distanceRGBA_vert,fragmentShader:ShaderChunk.distanceRGBA_frag},shadow:{uniforms:mergeUniforms([UniformsLib.lights,UniformsLib.fog,{color:{value:new Color(0)},opacity:{value:1}}]),vertexShader:ShaderChunk.shadow_vert,fragmentShader:ShaderChunk.shadow_frag}};ShaderLib.physical={uniforms:mergeUniforms([ShaderLib.standard.uniforms,{clearcoat:{value:0},clearcoatMap:{value:null},clearcoatMapTransform:{value:new Matrix3},clearcoatNormalMap:{value:null},clearcoatNormalMapTransform:{value:new Matrix3},clearcoatNormalScale:{value:new Vector2(1,1)},clearcoatRoughness:{value:0},clearcoatRoughnessMap:{value:null},clearcoatRoughnessMapTransform:{value:new Matrix3},dispersion:{value:0},iridescence:{value:0},iridescenceMap:{value:null},iridescenceMapTransform:{value:new Matrix3},iridescenceIOR:{value:1.3},iridescenceThicknessMinimum:{value:100},iridescenceThicknessMaximum:{value:400},iridescenceThicknessMap:{value:null},iridescenceThicknessMapTransform:{value:new Matrix3},sheen:{value:0},sheenColor:{value:new Color(0)},sheenColorMap:{value:null},sheenColorMapTransform:{value:new Matrix3},sheenRoughness:{value:1},sheenRoughnessMap:{value:null},sheenRoughnessMapTransform:{value:new Matrix3},transmission:{value:0},transmissionMap:{value:null},transmissionMapTransform:{value:new Matrix3},transmissionSamplerSize:{value:new Vector2},transmissionSamplerMap:{value:null},thickness:{value:0},thicknessMap:{value:null},thicknessMapTransform:{value:new Matrix3},attenuationDistance:{value:0},attenuationColor:{value:new Color(0)},specularColor:{value:new Color(1,1,1)},specularColorMap:{value:null},specularColorMapTransform:{value:new Matrix3},specularIntensity:{value:1},specularIntensityMap:{value:null},specularIntensityMapTransform:{value:new Matrix3},anisotropyVector:{value:new Vector2},anisotropyMap:{value:null},anisotropyMapTransform:{value:new Matrix3}}]),vertexShader:ShaderChunk.meshphysical_vert,fragmentShader:ShaderChunk.meshphysical_frag};const _rgb={r:0,b:0,g:0},_e1$1=new Euler,_m1$1=new Matrix4;function WebGLBackground(F,w,D,O,U,G,q){const K=new Color(0);let ee=G===!0?0:1,Z,ie,Y=null,W=0,ne=null;function se(me){let be=me.isScene===!0?me.background:null;return be&&be.isTexture&&(be=(me.backgroundBlurriness>0?D:w).get(be)),be}function le(me){let be=!1;const ge=se(me);ge===null?he(K,ee):ge&&ge.isColor&&(he(ge,1),be=!0);const ve=F.xr.getEnvironmentBlendMode();ve==="additive"?O.buffers.color.setClear(0,0,0,1,q):ve==="alpha-blend"&&O.buffers.color.setClear(0,0,0,0,q),(F.autoClear||be)&&(O.buffers.depth.setTest(!0),O.buffers.depth.setMask(!0),O.buffers.color.setMask(!0),F.clear(F.autoClearColor,F.autoClearDepth,F.autoClearStencil))}function ce(me,be){const ge=se(be);ge&&(ge.isCubeTexture||ge.mapping===CubeUVReflectionMapping)?(ie===void 0&&(ie=new Mesh(new BoxGeometry(1,1,1),new ShaderMaterial({name:"BackgroundCubeMaterial",uniforms:cloneUniforms(ShaderLib.backgroundCube.uniforms),vertexShader:ShaderLib.backgroundCube.vertexShader,fragmentShader:ShaderLib.backgroundCube.fragmentShader,side:BackSide,depthTest:!1,depthWrite:!1,fog:!1,allowOverride:!1})),ie.geometry.deleteAttribute("normal"),ie.geometry.deleteAttribute("uv"),ie.onBeforeRender=function(ve,Se,Me){this.matrixWorld.copyPosition(Me.matrixWorld)},Object.defineProperty(ie.material,"envMap",{get:function(){return this.uniforms.envMap.value}}),U.update(ie)),_e1$1.copy(be.backgroundRotation),_e1$1.x*=-1,_e1$1.y*=-1,_e1$1.z*=-1,ge.isCubeTexture&&ge.isRenderTargetTexture===!1&&(_e1$1.y*=-1,_e1$1.z*=-1),ie.material.uniforms.envMap.value=ge,ie.material.uniforms.flipEnvMap.value=ge.isCubeTexture&&ge.isRenderTargetTexture===!1?-1:1,ie.material.uniforms.backgroundBlurriness.value=be.backgroundBlurriness,ie.material.uniforms.backgroundIntensity.value=be.backgroundIntensity,ie.material.uniforms.backgroundRotation.value.setFromMatrix4(_m1$1.makeRotationFromEuler(_e1$1)),ie.material.toneMapped=ColorManagement.getTransfer(ge.colorSpace)!==SRGBTransfer,(Y!==ge||W!==ge.version||ne!==F.toneMapping)&&(ie.material.needsUpdate=!0,Y=ge,W=ge.version,ne=F.toneMapping),ie.layers.enableAll(),me.unshift(ie,ie.geometry,ie.material,0,0,null)):ge&&ge.isTexture&&(Z===void 0&&(Z=new Mesh(new PlaneGeometry(2,2),new ShaderMaterial({name:"BackgroundMaterial",uniforms:cloneUniforms(ShaderLib.background.uniforms),vertexShader:ShaderLib.background.vertexShader,fragmentShader:ShaderLib.background.fragmentShader,side:FrontSide,depthTest:!1,depthWrite:!1,fog:!1,allowOverride:!1})),Z.geometry.deleteAttribute("normal"),Object.defineProperty(Z.material,"map",{get:function(){return this.uniforms.t2D.value}}),U.update(Z)),Z.material.uniforms.t2D.value=ge,Z.material.uniforms.backgroundIntensity.value=be.backgroundIntensity,Z.material.toneMapped=ColorManagement.getTransfer(ge.colorSpace)!==SRGBTransfer,ge.matrixAutoUpdate===!0&&ge.updateMatrix(),Z.material.uniforms.uvTransform.value.copy(ge.matrix),(Y!==ge||W!==ge.version||ne!==F.toneMapping)&&(Z.material.needsUpdate=!0,Y=ge,W=ge.version,ne=F.toneMapping),Z.layers.enableAll(),me.unshift(Z,Z.geometry,Z.material,0,0,null))}function he(me,be){me.getRGB(_rgb,getUnlitUniformColorSpace(F)),O.buffers.color.setClear(_rgb.r,_rgb.g,_rgb.b,be,q)}function pe(){ie!==void 0&&(ie.geometry.dispose(),ie.material.dispose(),ie=void 0),Z!==void 0&&(Z.geometry.dispose(),Z.material.dispose(),Z=void 0)}return{getClearColor:function(){return K},setClearColor:function(me,be=1){K.set(me),ee=be,he(K,ee)},getClearAlpha:function(){return ee},setClearAlpha:function(me){ee=me,he(K,ee)},render:le,addToRenderList:ce,dispose:pe}}function WebGLBindingStates(F,w){const D=F.getParameter(F.MAX_VERTEX_ATTRIBS),O={},U=W(null);let G=U,q=!1;function K(we,Re,Le,Ne,Oe){let Pe=!1;const Ce=Y(Ne,Le,Re);G!==Ce&&(G=Ce,Z(G.object)),Pe=ne(we,Ne,Le,Oe),Pe&&se(we,Ne,Le,Oe),Oe!==null&&w.update(Oe,F.ELEMENT_ARRAY_BUFFER),(Pe||q)&&(q=!1,be(we,Re,Le,Ne),Oe!==null&&F.bindBuffer(F.ELEMENT_ARRAY_BUFFER,w.get(Oe).buffer))}function ee(){return F.createVertexArray()}function Z(we){return F.bindVertexArray(we)}function ie(we){return F.deleteVertexArray(we)}function Y(we,Re,Le){const Ne=Le.wireframe===!0;let Oe=O[we.id];Oe===void 0&&(Oe={},O[we.id]=Oe);let Pe=Oe[Re.id];Pe===void 0&&(Pe={},Oe[Re.id]=Pe);let Ce=Pe[Ne];return Ce===void 0&&(Ce=W(ee()),Pe[Ne]=Ce),Ce}function W(we){const Re=[],Le=[],Ne=[];for(let Oe=0;Oe<D;Oe++)Re[Oe]=0,Le[Oe]=0,Ne[Oe]=0;return{geometry:null,program:null,wireframe:!1,newAttributes:Re,enabledAttributes:Le,attributeDivisors:Ne,object:we,attributes:{},index:null}}function ne(we,Re,Le,Ne){const Oe=G.attributes,Pe=Re.attributes;let Ce=0;const Be=Le.getAttributes();for(const ze in Be)if(Be[ze].location>=0){const lt=Oe[ze];let ke=Pe[ze];if(ke===void 0&&(ze==="instanceMatrix"&&we.instanceMatrix&&(ke=we.instanceMatrix),ze==="instanceColor"&&we.instanceColor&&(ke=we.instanceColor)),lt===void 0||lt.attribute!==ke||ke&&lt.data!==ke.data)return!0;Ce++}return G.attributesNum!==Ce||G.index!==Ne}function se(we,Re,Le,Ne){const Oe={},Pe=Re.attributes;let Ce=0;const Be=Le.getAttributes();for(const ze in Be)if(Be[ze].location>=0){let lt=Pe[ze];lt===void 0&&(ze==="instanceMatrix"&&we.instanceMatrix&&(lt=we.instanceMatrix),ze==="instanceColor"&&we.instanceColor&&(lt=we.instanceColor));const ke={};ke.attribute=lt,lt&&lt.data&&(ke.data=lt.data),Oe[ze]=ke,Ce++}G.attributes=Oe,G.attributesNum=Ce,G.index=Ne}function le(){const we=G.newAttributes;for(let Re=0,Le=we.length;Re<Le;Re++)we[Re]=0}function ce(we){he(we,0)}function he(we,Re){const Le=G.newAttributes,Ne=G.enabledAttributes,Oe=G.attributeDivisors;Le[we]=1,Ne[we]===0&&(F.enableVertexAttribArray(we),Ne[we]=1),Oe[we]!==Re&&(F.vertexAttribDivisor(we,Re),Oe[we]=Re)}function pe(){const we=G.newAttributes,Re=G.enabledAttributes;for(let Le=0,Ne=Re.length;Le<Ne;Le++)Re[Le]!==we[Le]&&(F.disableVertexAttribArray(Le),Re[Le]=0)}function me(we,Re,Le,Ne,Oe,Pe,Ce){Ce===!0?F.vertexAttribIPointer(we,Re,Le,Oe,Pe):F.vertexAttribPointer(we,Re,Le,Ne,Oe,Pe)}function be(we,Re,Le,Ne){le();const Oe=Ne.attributes,Pe=Le.getAttributes(),Ce=Re.defaultAttributeValues;for(const Be in Pe){const ze=Pe[Be];if(ze.location>=0){let Xe=Oe[Be];if(Xe===void 0&&(Be==="instanceMatrix"&&we.instanceMatrix&&(Xe=we.instanceMatrix),Be==="instanceColor"&&we.instanceColor&&(Xe=we.instanceColor)),Xe!==void 0){const lt=Xe.normalized,ke=Xe.itemSize,rt=w.get(Xe);if(rt===void 0)continue;const St=rt.buffer,Lt=rt.type,$t=rt.bytesPerElement,mt=Lt===F.INT||Lt===F.UNSIGNED_INT||Xe.gpuType===IntType;if(Xe.isInterleavedBufferAttribute){const bt=Xe.data,Xt=bt.stride,hn=Xe.offset;if(bt.isInstancedInterleavedBuffer){for(let Jt=0;Jt<ze.locationSize;Jt++)he(ze.location+Jt,bt.meshPerAttribute);we.isInstancedMesh!==!0&&Ne._maxInstanceCount===void 0&&(Ne._maxInstanceCount=bt.meshPerAttribute*bt.count)}else for(let Jt=0;Jt<ze.locationSize;Jt++)ce(ze.location+Jt);F.bindBuffer(F.ARRAY_BUFFER,St);for(let Jt=0;Jt<ze.locationSize;Jt++)me(ze.location+Jt,ke/ze.locationSize,Lt,lt,Xt*$t,(hn+ke/ze.locationSize*Jt)*$t,mt)}else{if(Xe.isInstancedBufferAttribute){for(let bt=0;bt<ze.locationSize;bt++)he(ze.location+bt,Xe.meshPerAttribute);we.isInstancedMesh!==!0&&Ne._maxInstanceCount===void 0&&(Ne._maxInstanceCount=Xe.meshPerAttribute*Xe.count)}else for(let bt=0;bt<ze.locationSize;bt++)ce(ze.location+bt);F.bindBuffer(F.ARRAY_BUFFER,St);for(let bt=0;bt<ze.locationSize;bt++)me(ze.location+bt,ke/ze.locationSize,Lt,lt,ke*$t,ke/ze.locationSize*bt*$t,mt)}}else if(Ce!==void 0){const lt=Ce[Be];if(lt!==void 0)switch(lt.length){case 2:F.vertexAttrib2fv(ze.location,lt);break;case 3:F.vertexAttrib3fv(ze.location,lt);break;case 4:F.vertexAttrib4fv(ze.location,lt);break;default:F.vertexAttrib1fv(ze.location,lt)}}}}pe()}function ge(){Me();for(const we in O){const Re=O[we];for(const Le in Re){const Ne=Re[Le];for(const Oe in Ne)ie(Ne[Oe].object),delete Ne[Oe];delete Re[Le]}delete O[we]}}function ve(we){if(O[we.id]===void 0)return;const Re=O[we.id];for(const Le in Re){const Ne=Re[Le];for(const Oe in Ne)ie(Ne[Oe].object),delete Ne[Oe];delete Re[Le]}delete O[we.id]}function Se(we){for(const Re in O){const Le=O[Re];if(Le[we.id]===void 0)continue;const Ne=Le[we.id];for(const Oe in Ne)ie(Ne[Oe].object),delete Ne[Oe];delete Le[we.id]}}function Me(){Ee(),q=!0,G!==U&&(G=U,Z(G.object))}function Ee(){U.geometry=null,U.program=null,U.wireframe=!1}return{setup:K,reset:Me,resetDefaultState:Ee,dispose:ge,releaseStatesOfGeometry:ve,releaseStatesOfProgram:Se,initAttributes:le,enableAttribute:ce,disableUnusedAttributes:pe}}function WebGLBufferRenderer(F,w,D){let O;function U(Z){O=Z}function G(Z,ie){F.drawArrays(O,Z,ie),D.update(ie,O,1)}function q(Z,ie,Y){Y!==0&&(F.drawArraysInstanced(O,Z,ie,Y),D.update(ie,O,Y))}function K(Z,ie,Y){if(Y===0)return;w.get("WEBGL_multi_draw").multiDrawArraysWEBGL(O,Z,0,ie,0,Y);let ne=0;for(let se=0;se<Y;se++)ne+=ie[se];D.update(ne,O,1)}function ee(Z,ie,Y,W){if(Y===0)return;const ne=w.get("WEBGL_multi_draw");if(ne===null)for(let se=0;se<Z.length;se++)q(Z[se],ie[se],W[se]);else{ne.multiDrawArraysInstancedWEBGL(O,Z,0,ie,0,W,0,Y);let se=0;for(let le=0;le<Y;le++)se+=ie[le]*W[le];D.update(se,O,1)}}this.setMode=U,this.render=G,this.renderInstances=q,this.renderMultiDraw=K,this.renderMultiDrawInstances=ee}function WebGLCapabilities(F,w,D,O){let U;function G(){if(U!==void 0)return U;if(w.has("EXT_texture_filter_anisotropic")===!0){const Se=w.get("EXT_texture_filter_anisotropic");U=F.getParameter(Se.MAX_TEXTURE_MAX_ANISOTROPY_EXT)}else U=0;return U}function q(Se){return!(Se!==RGBAFormat&&O.convert(Se)!==F.getParameter(F.IMPLEMENTATION_COLOR_READ_FORMAT))}function K(Se){const Me=Se===HalfFloatType&&(w.has("EXT_color_buffer_half_float")||w.has("EXT_color_buffer_float"));return!(Se!==UnsignedByteType&&O.convert(Se)!==F.getParameter(F.IMPLEMENTATION_COLOR_READ_TYPE)&&Se!==FloatType&&!Me)}function ee(Se){if(Se==="highp"){if(F.getShaderPrecisionFormat(F.VERTEX_SHADER,F.HIGH_FLOAT).precision>0&&F.getShaderPrecisionFormat(F.FRAGMENT_SHADER,F.HIGH_FLOAT).precision>0)return"highp";Se="mediump"}return Se==="mediump"&&F.getShaderPrecisionFormat(F.VERTEX_SHADER,F.MEDIUM_FLOAT).precision>0&&F.getShaderPrecisionFormat(F.FRAGMENT_SHADER,F.MEDIUM_FLOAT).precision>0?"mediump":"lowp"}let Z=D.precision!==void 0?D.precision:"highp";const ie=ee(Z);ie!==Z&&(warn("WebGLRenderer:",Z,"not supported, using",ie,"instead."),Z=ie);const Y=D.logarithmicDepthBuffer===!0,W=D.reversedDepthBuffer===!0&&w.has("EXT_clip_control"),ne=F.getParameter(F.MAX_TEXTURE_IMAGE_UNITS),se=F.getParameter(F.MAX_VERTEX_TEXTURE_IMAGE_UNITS),le=F.getParameter(F.MAX_TEXTURE_SIZE),ce=F.getParameter(F.MAX_CUBE_MAP_TEXTURE_SIZE),he=F.getParameter(F.MAX_VERTEX_ATTRIBS),pe=F.getParameter(F.MAX_VERTEX_UNIFORM_VECTORS),me=F.getParameter(F.MAX_VARYING_VECTORS),be=F.getParameter(F.MAX_FRAGMENT_UNIFORM_VECTORS),ge=se>0,ve=F.getParameter(F.MAX_SAMPLES);return{isWebGL2:!0,getMaxAnisotropy:G,getMaxPrecision:ee,textureFormatReadable:q,textureTypeReadable:K,precision:Z,logarithmicDepthBuffer:Y,reversedDepthBuffer:W,maxTextures:ne,maxVertexTextures:se,maxTextureSize:le,maxCubemapSize:ce,maxAttributes:he,maxVertexUniforms:pe,maxVaryings:me,maxFragmentUniforms:be,vertexTextures:ge,maxSamples:ve}}function WebGLClipping(F){const w=this;let D=null,O=0,U=!1,G=!1;const q=new Plane,K=new Matrix3,ee={value:null,needsUpdate:!1};this.uniform=ee,this.numPlanes=0,this.numIntersection=0,this.init=function(Y,W){const ne=Y.length!==0||W||O!==0||U;return U=W,O=Y.length,ne},this.beginShadows=function(){G=!0,ie(null)},this.endShadows=function(){G=!1},this.setGlobalState=function(Y,W){D=ie(Y,W,0)},this.setState=function(Y,W,ne){const se=Y.clippingPlanes,le=Y.clipIntersection,ce=Y.clipShadows,he=F.get(Y);if(!U||se===null||se.length===0||G&&!ce)G?ie(null):Z();else{const pe=G?0:O,me=pe*4;let be=he.clippingState||null;ee.value=be,be=ie(se,W,me,ne);for(let ge=0;ge!==me;++ge)be[ge]=D[ge];he.clippingState=be,this.numIntersection=le?this.numPlanes:0,this.numPlanes+=pe}};function Z(){ee.value!==D&&(ee.value=D,ee.needsUpdate=O>0),w.numPlanes=O,w.numIntersection=0}function ie(Y,W,ne,se){const le=Y!==null?Y.length:0;let ce=null;if(le!==0){if(ce=ee.value,se!==!0||ce===null){const he=ne+le*4,pe=W.matrixWorldInverse;K.getNormalMatrix(pe),(ce===null||ce.length<he)&&(ce=new Float32Array(he));for(let me=0,be=ne;me!==le;++me,be+=4)q.copy(Y[me]).applyMatrix4(pe,K),q.normal.toArray(ce,be),ce[be+3]=q.constant}ee.value=ce,ee.needsUpdate=!0}return w.numPlanes=le,w.numIntersection=0,ce}}function WebGLCubeMaps(F){let w=new WeakMap;function D(q,K){return K===EquirectangularReflectionMapping?q.mapping=CubeReflectionMapping:K===EquirectangularRefractionMapping&&(q.mapping=CubeRefractionMapping),q}function O(q){if(q&&q.isTexture){const K=q.mapping;if(K===EquirectangularReflectionMapping||K===EquirectangularRefractionMapping)if(w.has(q)){const ee=w.get(q).texture;return D(ee,q.mapping)}else{const ee=q.image;if(ee&&ee.height>0){const Z=new WebGLCubeRenderTarget(ee.height);return Z.fromEquirectangularTexture(F,q),w.set(q,Z),q.addEventListener("dispose",U),D(Z.texture,q.mapping)}else return null}}return q}function U(q){const K=q.target;K.removeEventListener("dispose",U);const ee=w.get(K);ee!==void 0&&(w.delete(K),ee.dispose())}function G(){w=new WeakMap}return{get:O,dispose:G}}const LOD_MIN=4,EXTRA_LOD_SIGMA=[.125,.215,.35,.446,.526,.582],MAX_SAMPLES$1=20,GGX_SAMPLES=512,_flatCamera=new OrthographicCamera,_clearColor=new Color;let _oldTarget=null,_oldActiveCubeFace=0,_oldActiveMipmapLevel=0,_oldXrEnabled=!1;const _origin=new Vector3;class PMREMGenerator{constructor(w){this._renderer=w,this._pingPongRenderTarget=null,this._lodMax=0,this._cubeSize=0,this._sizeLods=[],this._sigmas=[],this._lodMeshes=[],this._backgroundBox=null,this._cubemapMaterial=null,this._equirectMaterial=null,this._blurMaterial=null,this._ggxMaterial=null}fromScene(w,D=0,O=.1,U=100,G={}){const{size:q=256,position:K=_origin}=G;_oldTarget=this._renderer.getRenderTarget(),_oldActiveCubeFace=this._renderer.getActiveCubeFace(),_oldActiveMipmapLevel=this._renderer.getActiveMipmapLevel(),_oldXrEnabled=this._renderer.xr.enabled,this._renderer.xr.enabled=!1,this._setSize(q);const ee=this._allocateTargets();return ee.depthBuffer=!0,this._sceneToCubeUV(w,O,U,ee,K),D>0&&this._blur(ee,0,0,D),this._applyPMREM(ee),this._cleanup(ee),ee}fromEquirectangular(w,D=null){return this._fromTexture(w,D)}fromCubemap(w,D=null){return this._fromTexture(w,D)}compileCubemapShader(){this._cubemapMaterial===null&&(this._cubemapMaterial=_getCubemapMaterial(),this._compileMaterial(this._cubemapMaterial))}compileEquirectangularShader(){this._equirectMaterial===null&&(this._equirectMaterial=_getEquirectMaterial(),this._compileMaterial(this._equirectMaterial))}dispose(){this._dispose(),this._cubemapMaterial!==null&&this._cubemapMaterial.dispose(),this._equirectMaterial!==null&&this._equirectMaterial.dispose(),this._backgroundBox!==null&&(this._backgroundBox.geometry.dispose(),this._backgroundBox.material.dispose())}_setSize(w){this._lodMax=Math.floor(Math.log2(w)),this._cubeSize=Math.pow(2,this._lodMax)}_dispose(){this._blurMaterial!==null&&this._blurMaterial.dispose(),this._ggxMaterial!==null&&this._ggxMaterial.dispose(),this._pingPongRenderTarget!==null&&this._pingPongRenderTarget.dispose();for(let w=0;w<this._lodMeshes.length;w++)this._lodMeshes[w].geometry.dispose()}_cleanup(w){this._renderer.setRenderTarget(_oldTarget,_oldActiveCubeFace,_oldActiveMipmapLevel),this._renderer.xr.enabled=_oldXrEnabled,w.scissorTest=!1,_setViewport(w,0,0,w.width,w.height)}_fromTexture(w,D){w.mapping===CubeReflectionMapping||w.mapping===CubeRefractionMapping?this._setSize(w.image.length===0?16:w.image[0].width||w.image[0].image.width):this._setSize(w.image.width/4),_oldTarget=this._renderer.getRenderTarget(),_oldActiveCubeFace=this._renderer.getActiveCubeFace(),_oldActiveMipmapLevel=this._renderer.getActiveMipmapLevel(),_oldXrEnabled=this._renderer.xr.enabled,this._renderer.xr.enabled=!1;const O=D||this._allocateTargets();return this._textureToCubeUV(w,O),this._applyPMREM(O),this._cleanup(O),O}_allocateTargets(){const w=3*Math.max(this._cubeSize,112),D=4*this._cubeSize,O={magFilter:LinearFilter,minFilter:LinearFilter,generateMipmaps:!1,type:HalfFloatType,format:RGBAFormat,colorSpace:LinearSRGBColorSpace,depthBuffer:!1},U=_createRenderTarget(w,D,O);if(this._pingPongRenderTarget===null||this._pingPongRenderTarget.width!==w||this._pingPongRenderTarget.height!==D){this._pingPongRenderTarget!==null&&this._dispose(),this._pingPongRenderTarget=_createRenderTarget(w,D,O);const{_lodMax:G}=this;({lodMeshes:this._lodMeshes,sizeLods:this._sizeLods,sigmas:this._sigmas}=_createPlanes(G)),this._blurMaterial=_getBlurShader(G,w,D)}return U}_compileMaterial(w){const D=new Mesh(new BufferGeometry,w);this._renderer.compile(D,_flatCamera)}_sceneToCubeUV(w,D,O,U,G){const ee=new PerspectiveCamera(90,1,D,O),Z=[1,-1,1,1,1,1],ie=[1,1,1,-1,-1,-1],Y=this._renderer,W=Y.autoClear,ne=Y.toneMapping;Y.getClearColor(_clearColor),Y.toneMapping=NoToneMapping,Y.autoClear=!1,Y.state.buffers.depth.getReversed()&&(Y.setRenderTarget(U),Y.clearDepth(),Y.setRenderTarget(null)),this._backgroundBox===null&&(this._backgroundBox=new Mesh(new BoxGeometry,new MeshBasicMaterial({name:"PMREM.Background",side:BackSide,depthWrite:!1,depthTest:!1})));const le=this._backgroundBox,ce=le.material;let he=!1;const pe=w.background;pe?pe.isColor&&(ce.color.copy(pe),w.background=null,he=!0):(ce.color.copy(_clearColor),he=!0);for(let me=0;me<6;me++){const be=me%3;be===0?(ee.up.set(0,Z[me],0),ee.position.set(G.x,G.y,G.z),ee.lookAt(G.x+ie[me],G.y,G.z)):be===1?(ee.up.set(0,0,Z[me]),ee.position.set(G.x,G.y,G.z),ee.lookAt(G.x,G.y+ie[me],G.z)):(ee.up.set(0,Z[me],0),ee.position.set(G.x,G.y,G.z),ee.lookAt(G.x,G.y,G.z+ie[me]));const ge=this._cubeSize;_setViewport(U,be*ge,me>2?ge:0,ge,ge),Y.setRenderTarget(U),he&&Y.render(le,ee),Y.render(w,ee)}Y.toneMapping=ne,Y.autoClear=W,w.background=pe}_textureToCubeUV(w,D){const O=this._renderer,U=w.mapping===CubeReflectionMapping||w.mapping===CubeRefractionMapping;U?(this._cubemapMaterial===null&&(this._cubemapMaterial=_getCubemapMaterial()),this._cubemapMaterial.uniforms.flipEnvMap.value=w.isRenderTargetTexture===!1?-1:1):this._equirectMaterial===null&&(this._equirectMaterial=_getEquirectMaterial());const G=U?this._cubemapMaterial:this._equirectMaterial,q=this._lodMeshes[0];q.material=G;const K=G.uniforms;K.envMap.value=w;const ee=this._cubeSize;_setViewport(D,0,0,3*ee,2*ee),O.setRenderTarget(D),O.render(q,_flatCamera)}_applyPMREM(w){const D=this._renderer,O=D.autoClear;D.autoClear=!1;const U=this._lodMeshes.length;for(let G=1;G<U;G++)this._applyGGXFilter(w,G-1,G);D.autoClear=O}_applyGGXFilter(w,D,O){const U=this._renderer,G=this._pingPongRenderTarget;if(this._ggxMaterial===null){const pe=3*Math.max(this._cubeSize,16),me=4*this._cubeSize;this._ggxMaterial=_getGGXShader(this._lodMax,pe,me)}const q=this._ggxMaterial,K=this._lodMeshes[O];K.material=q;const ee=q.uniforms,Z=O/(this._lodMeshes.length-1),ie=D/(this._lodMeshes.length-1),Y=Math.sqrt(Z*Z-ie*ie),W=.05+Z*.95,ne=Y*W,{_lodMax:se}=this,le=this._sizeLods[O],ce=3*le*(O>se-LOD_MIN?O-se+LOD_MIN:0),he=4*(this._cubeSize-le);ee.envMap.value=w.texture,ee.roughness.value=ne,ee.mipInt.value=se-D,_setViewport(G,ce,he,3*le,2*le),U.setRenderTarget(G),U.render(K,_flatCamera),ee.envMap.value=G.texture,ee.roughness.value=0,ee.mipInt.value=se-O,_setViewport(w,ce,he,3*le,2*le),U.setRenderTarget(w),U.render(K,_flatCamera)}_blur(w,D,O,U,G){const q=this._pingPongRenderTarget;this._halfBlur(w,q,D,O,U,"latitudinal",G),this._halfBlur(q,w,O,O,U,"longitudinal",G)}_halfBlur(w,D,O,U,G,q,K){const ee=this._renderer,Z=this._blurMaterial;q!=="latitudinal"&&q!=="longitudinal"&&error("blur direction must be either latitudinal or longitudinal!");const ie=3,Y=this._lodMeshes[U];Y.material=Z;const W=Z.uniforms,ne=this._sizeLods[O]-1,se=isFinite(G)?Math.PI/(2*ne):2*Math.PI/(2*MAX_SAMPLES$1-1),le=G/se,ce=isFinite(G)?1+Math.floor(ie*le):MAX_SAMPLES$1;ce>MAX_SAMPLES$1&&warn(`sigmaRadians, ${G}, is too large and will clip, as it requested ${ce} samples when the maximum is set to ${MAX_SAMPLES$1}`);const he=[];let pe=0;for(let Se=0;Se<MAX_SAMPLES$1;++Se){const Me=Se/le,Ee=Math.exp(-Me*Me/2);he.push(Ee),Se===0?pe+=Ee:Se<ce&&(pe+=2*Ee)}for(let Se=0;Se<he.length;Se++)he[Se]=he[Se]/pe;W.envMap.value=w.texture,W.samples.value=ce,W.weights.value=he,W.latitudinal.value=q==="latitudinal",K&&(W.poleAxis.value=K);const{_lodMax:me}=this;W.dTheta.value=se,W.mipInt.value=me-O;const be=this._sizeLods[U],ge=3*be*(U>me-LOD_MIN?U-me+LOD_MIN:0),ve=4*(this._cubeSize-be);_setViewport(D,ge,ve,3*be,2*be),ee.setRenderTarget(D),ee.render(Y,_flatCamera)}}function _createPlanes(F){const w=[],D=[],O=[];let U=F;const G=F-LOD_MIN+1+EXTRA_LOD_SIGMA.length;for(let q=0;q<G;q++){const K=Math.pow(2,U);w.push(K);let ee=1/K;q>F-LOD_MIN?ee=EXTRA_LOD_SIGMA[q-F+LOD_MIN-1]:q===0&&(ee=0),D.push(ee);const Z=1/(K-2),ie=-Z,Y=1+Z,W=[ie,ie,Y,ie,Y,Y,ie,ie,Y,Y,ie,Y],ne=6,se=6,le=3,ce=2,he=1,pe=new Float32Array(le*se*ne),me=new Float32Array(ce*se*ne),be=new Float32Array(he*se*ne);for(let ve=0;ve<ne;ve++){const Se=ve%3*2/3-1,Me=ve>2?0:-1,Ee=[Se,Me,0,Se+2/3,Me,0,Se+2/3,Me+1,0,Se,Me,0,Se+2/3,Me+1,0,Se,Me+1,0];pe.set(Ee,le*se*ve),me.set(W,ce*se*ve);const we=[ve,ve,ve,ve,ve,ve];be.set(we,he*se*ve)}const ge=new BufferGeometry;ge.setAttribute("position",new BufferAttribute(pe,le)),ge.setAttribute("uv",new BufferAttribute(me,ce)),ge.setAttribute("faceIndex",new BufferAttribute(be,he)),O.push(new Mesh(ge,null)),U>LOD_MIN&&U--}return{lodMeshes:O,sizeLods:w,sigmas:D}}function _createRenderTarget(F,w,D){const O=new WebGLRenderTarget(F,w,D);return O.texture.mapping=CubeUVReflectionMapping,O.texture.name="PMREM.cubeUv",O.scissorTest=!0,O}function _setViewport(F,w,D,O,U){F.viewport.set(w,D,O,U),F.scissor.set(w,D,O,U)}function _getGGXShader(F,w,D){return new ShaderMaterial({name:"PMREMGGXConvolution",defines:{GGX_SAMPLES,CUBEUV_TEXEL_WIDTH:1/w,CUBEUV_TEXEL_HEIGHT:1/D,CUBEUV_MAX_MIP:`${F}.0`},uniforms:{envMap:{value:null},roughness:{value:0},mipInt:{value:0}},vertexShader:_getCommonVertexShader(),fragmentShader:`

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform float roughness;
			uniform float mipInt;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			#define PI 3.14159265359

			// Van der Corput radical inverse
			float radicalInverse_VdC(uint bits) {
				bits = (bits << 16u) | (bits >> 16u);
				bits = ((bits & 0x55555555u) << 1u) | ((bits & 0xAAAAAAAAu) >> 1u);
				bits = ((bits & 0x33333333u) << 2u) | ((bits & 0xCCCCCCCCu) >> 2u);
				bits = ((bits & 0x0F0F0F0Fu) << 4u) | ((bits & 0xF0F0F0F0u) >> 4u);
				bits = ((bits & 0x00FF00FFu) << 8u) | ((bits & 0xFF00FF00u) >> 8u);
				return float(bits) * 2.3283064365386963e-10; // / 0x100000000
			}

			// Hammersley sequence
			vec2 hammersley(uint i, uint N) {
				return vec2(float(i) / float(N), radicalInverse_VdC(i));
			}

			// GGX VNDF importance sampling (Eric Heitz 2018)
			// "Sampling the GGX Distribution of Visible Normals"
			// https://jcgt.org/published/0007/04/01/
			vec3 importanceSampleGGX_VNDF(vec2 Xi, vec3 V, float roughness) {
				float alpha = roughness * roughness;

				// Section 3.2: Transform view direction to hemisphere configuration
				vec3 Vh = normalize(vec3(alpha * V.x, alpha * V.y, V.z));

				// Section 4.1: Orthonormal basis
				float lensq = Vh.x * Vh.x + Vh.y * Vh.y;
				vec3 T1 = lensq > 0.0 ? vec3(-Vh.y, Vh.x, 0.0) / sqrt(lensq) : vec3(1.0, 0.0, 0.0);
				vec3 T2 = cross(Vh, T1);

				// Section 4.2: Parameterization of projected area
				float r = sqrt(Xi.x);
				float phi = 2.0 * PI * Xi.y;
				float t1 = r * cos(phi);
				float t2 = r * sin(phi);
				float s = 0.5 * (1.0 + Vh.z);
				t2 = (1.0 - s) * sqrt(1.0 - t1 * t1) + s * t2;

				// Section 4.3: Reprojection onto hemisphere
				vec3 Nh = t1 * T1 + t2 * T2 + sqrt(max(0.0, 1.0 - t1 * t1 - t2 * t2)) * Vh;

				// Section 3.4: Transform back to ellipsoid configuration
				return normalize(vec3(alpha * Nh.x, alpha * Nh.y, max(0.0, Nh.z)));
			}

			void main() {
				vec3 N = normalize(vOutputDirection);
				vec3 V = N; // Assume view direction equals normal for pre-filtering

				vec3 prefilteredColor = vec3(0.0);
				float totalWeight = 0.0;

				// For very low roughness, just sample the environment directly
				if (roughness < 0.001) {
					gl_FragColor = vec4(bilinearCubeUV(envMap, N, mipInt), 1.0);
					return;
				}

				// Tangent space basis for VNDF sampling
				vec3 up = abs(N.z) < 0.999 ? vec3(0.0, 0.0, 1.0) : vec3(1.0, 0.0, 0.0);
				vec3 tangent = normalize(cross(up, N));
				vec3 bitangent = cross(N, tangent);

				for(uint i = 0u; i < uint(GGX_SAMPLES); i++) {
					vec2 Xi = hammersley(i, uint(GGX_SAMPLES));

					// For PMREM, V = N, so in tangent space V is always (0, 0, 1)
					vec3 H_tangent = importanceSampleGGX_VNDF(Xi, vec3(0.0, 0.0, 1.0), roughness);

					// Transform H back to world space
					vec3 H = normalize(tangent * H_tangent.x + bitangent * H_tangent.y + N * H_tangent.z);
					vec3 L = normalize(2.0 * dot(V, H) * H - V);

					float NdotL = max(dot(N, L), 0.0);

					if(NdotL > 0.0) {
						// Sample environment at fixed mip level
						// VNDF importance sampling handles the distribution filtering
						vec3 sampleColor = bilinearCubeUV(envMap, L, mipInt);

						// Weight by NdotL for the split-sum approximation
						// VNDF PDF naturally accounts for the visible microfacet distribution
						prefilteredColor += sampleColor * NdotL;
						totalWeight += NdotL;
					}
				}

				if (totalWeight > 0.0) {
					prefilteredColor = prefilteredColor / totalWeight;
				}

				gl_FragColor = vec4(prefilteredColor, 1.0);
			}
		`,blending:NoBlending,depthTest:!1,depthWrite:!1})}function _getBlurShader(F,w,D){const O=new Float32Array(MAX_SAMPLES$1),U=new Vector3(0,1,0);return new ShaderMaterial({name:"SphericalGaussianBlur",defines:{n:MAX_SAMPLES$1,CUBEUV_TEXEL_WIDTH:1/w,CUBEUV_TEXEL_HEIGHT:1/D,CUBEUV_MAX_MIP:`${F}.0`},uniforms:{envMap:{value:null},samples:{value:1},weights:{value:O},latitudinal:{value:!1},dTheta:{value:0},mipInt:{value:0},poleAxis:{value:U}},vertexShader:_getCommonVertexShader(),fragmentShader:`

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`,blending:NoBlending,depthTest:!1,depthWrite:!1})}function _getEquirectMaterial(){return new ShaderMaterial({name:"EquirectangularToCubeUV",uniforms:{envMap:{value:null}},vertexShader:_getCommonVertexShader(),fragmentShader:`

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;

			#include <common>

			void main() {

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );

			}
		`,blending:NoBlending,depthTest:!1,depthWrite:!1})}function _getCubemapMaterial(){return new ShaderMaterial({name:"CubemapToCubeUV",uniforms:{envMap:{value:null},flipEnvMap:{value:-1}},vertexShader:_getCommonVertexShader(),fragmentShader:`

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`,blending:NoBlending,depthTest:!1,depthWrite:!1})}function _getCommonVertexShader(){return`

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`}function WebGLCubeUVMaps(F){let w=new WeakMap,D=null;function O(K){if(K&&K.isTexture){const ee=K.mapping,Z=ee===EquirectangularReflectionMapping||ee===EquirectangularRefractionMapping,ie=ee===CubeReflectionMapping||ee===CubeRefractionMapping;if(Z||ie){let Y=w.get(K);const W=Y!==void 0?Y.texture.pmremVersion:0;if(K.isRenderTargetTexture&&K.pmremVersion!==W)return D===null&&(D=new PMREMGenerator(F)),Y=Z?D.fromEquirectangular(K,Y):D.fromCubemap(K,Y),Y.texture.pmremVersion=K.pmremVersion,w.set(K,Y),Y.texture;if(Y!==void 0)return Y.texture;{const ne=K.image;return Z&&ne&&ne.height>0||ie&&ne&&U(ne)?(D===null&&(D=new PMREMGenerator(F)),Y=Z?D.fromEquirectangular(K):D.fromCubemap(K),Y.texture.pmremVersion=K.pmremVersion,w.set(K,Y),K.addEventListener("dispose",G),Y.texture):null}}}return K}function U(K){let ee=0;const Z=6;for(let ie=0;ie<Z;ie++)K[ie]!==void 0&&ee++;return ee===Z}function G(K){const ee=K.target;ee.removeEventListener("dispose",G);const Z=w.get(ee);Z!==void 0&&(w.delete(ee),Z.dispose())}function q(){w=new WeakMap,D!==null&&(D.dispose(),D=null)}return{get:O,dispose:q}}function WebGLExtensions(F){const w={};function D(O){if(w[O]!==void 0)return w[O];const U=F.getExtension(O);return w[O]=U,U}return{has:function(O){return D(O)!==null},init:function(){D("EXT_color_buffer_float"),D("WEBGL_clip_cull_distance"),D("OES_texture_float_linear"),D("EXT_color_buffer_half_float"),D("WEBGL_multisampled_render_to_texture"),D("WEBGL_render_shared_exponent")},get:function(O){const U=D(O);return U===null&&warnOnce("WebGLRenderer: "+O+" extension not supported."),U}}}function WebGLGeometries(F,w,D,O){const U={},G=new WeakMap;function q(Y){const W=Y.target;W.index!==null&&w.remove(W.index);for(const se in W.attributes)w.remove(W.attributes[se]);W.removeEventListener("dispose",q),delete U[W.id];const ne=G.get(W);ne&&(w.remove(ne),G.delete(W)),O.releaseStatesOfGeometry(W),W.isInstancedBufferGeometry===!0&&delete W._maxInstanceCount,D.memory.geometries--}function K(Y,W){return U[W.id]===!0||(W.addEventListener("dispose",q),U[W.id]=!0,D.memory.geometries++),W}function ee(Y){const W=Y.attributes;for(const ne in W)w.update(W[ne],F.ARRAY_BUFFER)}function Z(Y){const W=[],ne=Y.index,se=Y.attributes.position;let le=0;if(ne!==null){const pe=ne.array;le=ne.version;for(let me=0,be=pe.length;me<be;me+=3){const ge=pe[me+0],ve=pe[me+1],Se=pe[me+2];W.push(ge,ve,ve,Se,Se,ge)}}else if(se!==void 0){const pe=se.array;le=se.version;for(let me=0,be=pe.length/3-1;me<be;me+=3){const ge=me+0,ve=me+1,Se=me+2;W.push(ge,ve,ve,Se,Se,ge)}}else return;const ce=new(arrayNeedsUint32(W)?Uint32BufferAttribute:Uint16BufferAttribute)(W,1);ce.version=le;const he=G.get(Y);he&&w.remove(he),G.set(Y,ce)}function ie(Y){const W=G.get(Y);if(W){const ne=Y.index;ne!==null&&W.version<ne.version&&Z(Y)}else Z(Y);return G.get(Y)}return{get:K,update:ee,getWireframeAttribute:ie}}function WebGLIndexedBufferRenderer(F,w,D){let O;function U(W){O=W}let G,q;function K(W){G=W.type,q=W.bytesPerElement}function ee(W,ne){F.drawElements(O,ne,G,W*q),D.update(ne,O,1)}function Z(W,ne,se){se!==0&&(F.drawElementsInstanced(O,ne,G,W*q,se),D.update(ne,O,se))}function ie(W,ne,se){if(se===0)return;w.get("WEBGL_multi_draw").multiDrawElementsWEBGL(O,ne,0,G,W,0,se);let ce=0;for(let he=0;he<se;he++)ce+=ne[he];D.update(ce,O,1)}function Y(W,ne,se,le){if(se===0)return;const ce=w.get("WEBGL_multi_draw");if(ce===null)for(let he=0;he<W.length;he++)Z(W[he]/q,ne[he],le[he]);else{ce.multiDrawElementsInstancedWEBGL(O,ne,0,G,W,0,le,0,se);let he=0;for(let pe=0;pe<se;pe++)he+=ne[pe]*le[pe];D.update(he,O,1)}}this.setMode=U,this.setIndex=K,this.render=ee,this.renderInstances=Z,this.renderMultiDraw=ie,this.renderMultiDrawInstances=Y}function WebGLInfo(F){const w={geometries:0,textures:0},D={frame:0,calls:0,triangles:0,points:0,lines:0};function O(G,q,K){switch(D.calls++,q){case F.TRIANGLES:D.triangles+=K*(G/3);break;case F.LINES:D.lines+=K*(G/2);break;case F.LINE_STRIP:D.lines+=K*(G-1);break;case F.LINE_LOOP:D.lines+=K*G;break;case F.POINTS:D.points+=K*G;break;default:error("WebGLInfo: Unknown draw mode:",q);break}}function U(){D.calls=0,D.triangles=0,D.points=0,D.lines=0}return{memory:w,render:D,programs:null,autoReset:!0,reset:U,update:O}}function WebGLMorphtargets(F,w,D){const O=new WeakMap,U=new Vector4;function G(q,K,ee){const Z=q.morphTargetInfluences,ie=K.morphAttributes.position||K.morphAttributes.normal||K.morphAttributes.color,Y=ie!==void 0?ie.length:0;let W=O.get(K);if(W===void 0||W.count!==Y){let Ee=function(){Se.dispose(),O.delete(K),K.removeEventListener("dispose",Ee)};W!==void 0&&W.texture.dispose();const ne=K.morphAttributes.position!==void 0,se=K.morphAttributes.normal!==void 0,le=K.morphAttributes.color!==void 0,ce=K.morphAttributes.position||[],he=K.morphAttributes.normal||[],pe=K.morphAttributes.color||[];let me=0;ne===!0&&(me=1),se===!0&&(me=2),le===!0&&(me=3);let be=K.attributes.position.count*me,ge=1;be>w.maxTextureSize&&(ge=Math.ceil(be/w.maxTextureSize),be=w.maxTextureSize);const ve=new Float32Array(be*ge*4*Y),Se=new DataArrayTexture(ve,be,ge,Y);Se.type=FloatType,Se.needsUpdate=!0;const Me=me*4;for(let we=0;we<Y;we++){const Re=ce[we],Le=he[we],Ne=pe[we],Oe=be*ge*4*we;for(let Pe=0;Pe<Re.count;Pe++){const Ce=Pe*Me;ne===!0&&(U.fromBufferAttribute(Re,Pe),ve[Oe+Ce+0]=U.x,ve[Oe+Ce+1]=U.y,ve[Oe+Ce+2]=U.z,ve[Oe+Ce+3]=0),se===!0&&(U.fromBufferAttribute(Le,Pe),ve[Oe+Ce+4]=U.x,ve[Oe+Ce+5]=U.y,ve[Oe+Ce+6]=U.z,ve[Oe+Ce+7]=0),le===!0&&(U.fromBufferAttribute(Ne,Pe),ve[Oe+Ce+8]=U.x,ve[Oe+Ce+9]=U.y,ve[Oe+Ce+10]=U.z,ve[Oe+Ce+11]=Ne.itemSize===4?U.w:1)}}W={count:Y,texture:Se,size:new Vector2(be,ge)},O.set(K,W),K.addEventListener("dispose",Ee)}if(q.isInstancedMesh===!0&&q.morphTexture!==null)ee.getUniforms().setValue(F,"morphTexture",q.morphTexture,D);else{let ne=0;for(let le=0;le<Z.length;le++)ne+=Z[le];const se=K.morphTargetsRelative?1:1-ne;ee.getUniforms().setValue(F,"morphTargetBaseInfluence",se),ee.getUniforms().setValue(F,"morphTargetInfluences",Z)}ee.getUniforms().setValue(F,"morphTargetsTexture",W.texture,D),ee.getUniforms().setValue(F,"morphTargetsTextureSize",W.size)}return{update:G}}function WebGLObjects(F,w,D,O){let U=new WeakMap;function G(ee){const Z=O.render.frame,ie=ee.geometry,Y=w.get(ee,ie);if(U.get(Y)!==Z&&(w.update(Y),U.set(Y,Z)),ee.isInstancedMesh&&(ee.hasEventListener("dispose",K)===!1&&ee.addEventListener("dispose",K),U.get(ee)!==Z&&(D.update(ee.instanceMatrix,F.ARRAY_BUFFER),ee.instanceColor!==null&&D.update(ee.instanceColor,F.ARRAY_BUFFER),U.set(ee,Z))),ee.isSkinnedMesh){const W=ee.skeleton;U.get(W)!==Z&&(W.update(),U.set(W,Z))}return Y}function q(){U=new WeakMap}function K(ee){const Z=ee.target;Z.removeEventListener("dispose",K),D.remove(Z.instanceMatrix),Z.instanceColor!==null&&D.remove(Z.instanceColor)}return{update:G,dispose:q}}const emptyTexture=new Texture$1,emptyShadowTexture=new DepthTexture(1,1),emptyArrayTexture=new DataArrayTexture,empty3dTexture=new Data3DTexture,emptyCubeTexture=new CubeTexture,arrayCacheF32=[],arrayCacheI32=[],mat4array=new Float32Array(16),mat3array=new Float32Array(9),mat2array=new Float32Array(4);function flatten(F,w,D){const O=F[0];if(O<=0||O>0)return F;const U=w*D;let G=arrayCacheF32[U];if(G===void 0&&(G=new Float32Array(U),arrayCacheF32[U]=G),w!==0){O.toArray(G,0);for(let q=1,K=0;q!==w;++q)K+=D,F[q].toArray(G,K)}return G}function arraysEqual(F,w){if(F.length!==w.length)return!1;for(let D=0,O=F.length;D<O;D++)if(F[D]!==w[D])return!1;return!0}function copyArray(F,w){for(let D=0,O=w.length;D<O;D++)F[D]=w[D]}function allocTexUnits(F,w){let D=arrayCacheI32[w];D===void 0&&(D=new Int32Array(w),arrayCacheI32[w]=D);for(let O=0;O!==w;++O)D[O]=F.allocateTextureUnit();return D}function setValueV1f(F,w){const D=this.cache;D[0]!==w&&(F.uniform1f(this.addr,w),D[0]=w)}function setValueV2f(F,w){const D=this.cache;if(w.x!==void 0)(D[0]!==w.x||D[1]!==w.y)&&(F.uniform2f(this.addr,w.x,w.y),D[0]=w.x,D[1]=w.y);else{if(arraysEqual(D,w))return;F.uniform2fv(this.addr,w),copyArray(D,w)}}function setValueV3f(F,w){const D=this.cache;if(w.x!==void 0)(D[0]!==w.x||D[1]!==w.y||D[2]!==w.z)&&(F.uniform3f(this.addr,w.x,w.y,w.z),D[0]=w.x,D[1]=w.y,D[2]=w.z);else if(w.r!==void 0)(D[0]!==w.r||D[1]!==w.g||D[2]!==w.b)&&(F.uniform3f(this.addr,w.r,w.g,w.b),D[0]=w.r,D[1]=w.g,D[2]=w.b);else{if(arraysEqual(D,w))return;F.uniform3fv(this.addr,w),copyArray(D,w)}}function setValueV4f(F,w){const D=this.cache;if(w.x!==void 0)(D[0]!==w.x||D[1]!==w.y||D[2]!==w.z||D[3]!==w.w)&&(F.uniform4f(this.addr,w.x,w.y,w.z,w.w),D[0]=w.x,D[1]=w.y,D[2]=w.z,D[3]=w.w);else{if(arraysEqual(D,w))return;F.uniform4fv(this.addr,w),copyArray(D,w)}}function setValueM2(F,w){const D=this.cache,O=w.elements;if(O===void 0){if(arraysEqual(D,w))return;F.uniformMatrix2fv(this.addr,!1,w),copyArray(D,w)}else{if(arraysEqual(D,O))return;mat2array.set(O),F.uniformMatrix2fv(this.addr,!1,mat2array),copyArray(D,O)}}function setValueM3(F,w){const D=this.cache,O=w.elements;if(O===void 0){if(arraysEqual(D,w))return;F.uniformMatrix3fv(this.addr,!1,w),copyArray(D,w)}else{if(arraysEqual(D,O))return;mat3array.set(O),F.uniformMatrix3fv(this.addr,!1,mat3array),copyArray(D,O)}}function setValueM4(F,w){const D=this.cache,O=w.elements;if(O===void 0){if(arraysEqual(D,w))return;F.uniformMatrix4fv(this.addr,!1,w),copyArray(D,w)}else{if(arraysEqual(D,O))return;mat4array.set(O),F.uniformMatrix4fv(this.addr,!1,mat4array),copyArray(D,O)}}function setValueV1i(F,w){const D=this.cache;D[0]!==w&&(F.uniform1i(this.addr,w),D[0]=w)}function setValueV2i(F,w){const D=this.cache;if(w.x!==void 0)(D[0]!==w.x||D[1]!==w.y)&&(F.uniform2i(this.addr,w.x,w.y),D[0]=w.x,D[1]=w.y);else{if(arraysEqual(D,w))return;F.uniform2iv(this.addr,w),copyArray(D,w)}}function setValueV3i(F,w){const D=this.cache;if(w.x!==void 0)(D[0]!==w.x||D[1]!==w.y||D[2]!==w.z)&&(F.uniform3i(this.addr,w.x,w.y,w.z),D[0]=w.x,D[1]=w.y,D[2]=w.z);else{if(arraysEqual(D,w))return;F.uniform3iv(this.addr,w),copyArray(D,w)}}function setValueV4i(F,w){const D=this.cache;if(w.x!==void 0)(D[0]!==w.x||D[1]!==w.y||D[2]!==w.z||D[3]!==w.w)&&(F.uniform4i(this.addr,w.x,w.y,w.z,w.w),D[0]=w.x,D[1]=w.y,D[2]=w.z,D[3]=w.w);else{if(arraysEqual(D,w))return;F.uniform4iv(this.addr,w),copyArray(D,w)}}function setValueV1ui(F,w){const D=this.cache;D[0]!==w&&(F.uniform1ui(this.addr,w),D[0]=w)}function setValueV2ui(F,w){const D=this.cache;if(w.x!==void 0)(D[0]!==w.x||D[1]!==w.y)&&(F.uniform2ui(this.addr,w.x,w.y),D[0]=w.x,D[1]=w.y);else{if(arraysEqual(D,w))return;F.uniform2uiv(this.addr,w),copyArray(D,w)}}function setValueV3ui(F,w){const D=this.cache;if(w.x!==void 0)(D[0]!==w.x||D[1]!==w.y||D[2]!==w.z)&&(F.uniform3ui(this.addr,w.x,w.y,w.z),D[0]=w.x,D[1]=w.y,D[2]=w.z);else{if(arraysEqual(D,w))return;F.uniform3uiv(this.addr,w),copyArray(D,w)}}function setValueV4ui(F,w){const D=this.cache;if(w.x!==void 0)(D[0]!==w.x||D[1]!==w.y||D[2]!==w.z||D[3]!==w.w)&&(F.uniform4ui(this.addr,w.x,w.y,w.z,w.w),D[0]=w.x,D[1]=w.y,D[2]=w.z,D[3]=w.w);else{if(arraysEqual(D,w))return;F.uniform4uiv(this.addr,w),copyArray(D,w)}}function setValueT1(F,w,D){const O=this.cache,U=D.allocateTextureUnit();O[0]!==U&&(F.uniform1i(this.addr,U),O[0]=U);let G;this.type===F.SAMPLER_2D_SHADOW?(emptyShadowTexture.compareFunction=LessEqualCompare,G=emptyShadowTexture):G=emptyTexture,D.setTexture2D(w||G,U)}function setValueT3D1(F,w,D){const O=this.cache,U=D.allocateTextureUnit();O[0]!==U&&(F.uniform1i(this.addr,U),O[0]=U),D.setTexture3D(w||empty3dTexture,U)}function setValueT6(F,w,D){const O=this.cache,U=D.allocateTextureUnit();O[0]!==U&&(F.uniform1i(this.addr,U),O[0]=U),D.setTextureCube(w||emptyCubeTexture,U)}function setValueT2DArray1(F,w,D){const O=this.cache,U=D.allocateTextureUnit();O[0]!==U&&(F.uniform1i(this.addr,U),O[0]=U),D.setTexture2DArray(w||emptyArrayTexture,U)}function getSingularSetter(F){switch(F){case 5126:return setValueV1f;case 35664:return setValueV2f;case 35665:return setValueV3f;case 35666:return setValueV4f;case 35674:return setValueM2;case 35675:return setValueM3;case 35676:return setValueM4;case 5124:case 35670:return setValueV1i;case 35667:case 35671:return setValueV2i;case 35668:case 35672:return setValueV3i;case 35669:case 35673:return setValueV4i;case 5125:return setValueV1ui;case 36294:return setValueV2ui;case 36295:return setValueV3ui;case 36296:return setValueV4ui;case 35678:case 36198:case 36298:case 36306:case 35682:return setValueT1;case 35679:case 36299:case 36307:return setValueT3D1;case 35680:case 36300:case 36308:case 36293:return setValueT6;case 36289:case 36303:case 36311:case 36292:return setValueT2DArray1}}function setValueV1fArray(F,w){F.uniform1fv(this.addr,w)}function setValueV2fArray(F,w){const D=flatten(w,this.size,2);F.uniform2fv(this.addr,D)}function setValueV3fArray(F,w){const D=flatten(w,this.size,3);F.uniform3fv(this.addr,D)}function setValueV4fArray(F,w){const D=flatten(w,this.size,4);F.uniform4fv(this.addr,D)}function setValueM2Array(F,w){const D=flatten(w,this.size,4);F.uniformMatrix2fv(this.addr,!1,D)}function setValueM3Array(F,w){const D=flatten(w,this.size,9);F.uniformMatrix3fv(this.addr,!1,D)}function setValueM4Array(F,w){const D=flatten(w,this.size,16);F.uniformMatrix4fv(this.addr,!1,D)}function setValueV1iArray(F,w){F.uniform1iv(this.addr,w)}function setValueV2iArray(F,w){F.uniform2iv(this.addr,w)}function setValueV3iArray(F,w){F.uniform3iv(this.addr,w)}function setValueV4iArray(F,w){F.uniform4iv(this.addr,w)}function setValueV1uiArray(F,w){F.uniform1uiv(this.addr,w)}function setValueV2uiArray(F,w){F.uniform2uiv(this.addr,w)}function setValueV3uiArray(F,w){F.uniform3uiv(this.addr,w)}function setValueV4uiArray(F,w){F.uniform4uiv(this.addr,w)}function setValueT1Array(F,w,D){const O=this.cache,U=w.length,G=allocTexUnits(D,U);arraysEqual(O,G)||(F.uniform1iv(this.addr,G),copyArray(O,G));for(let q=0;q!==U;++q)D.setTexture2D(w[q]||emptyTexture,G[q])}function setValueT3DArray(F,w,D){const O=this.cache,U=w.length,G=allocTexUnits(D,U);arraysEqual(O,G)||(F.uniform1iv(this.addr,G),copyArray(O,G));for(let q=0;q!==U;++q)D.setTexture3D(w[q]||empty3dTexture,G[q])}function setValueT6Array(F,w,D){const O=this.cache,U=w.length,G=allocTexUnits(D,U);arraysEqual(O,G)||(F.uniform1iv(this.addr,G),copyArray(O,G));for(let q=0;q!==U;++q)D.setTextureCube(w[q]||emptyCubeTexture,G[q])}function setValueT2DArrayArray(F,w,D){const O=this.cache,U=w.length,G=allocTexUnits(D,U);arraysEqual(O,G)||(F.uniform1iv(this.addr,G),copyArray(O,G));for(let q=0;q!==U;++q)D.setTexture2DArray(w[q]||emptyArrayTexture,G[q])}function getPureArraySetter(F){switch(F){case 5126:return setValueV1fArray;case 35664:return setValueV2fArray;case 35665:return setValueV3fArray;case 35666:return setValueV4fArray;case 35674:return setValueM2Array;case 35675:return setValueM3Array;case 35676:return setValueM4Array;case 5124:case 35670:return setValueV1iArray;case 35667:case 35671:return setValueV2iArray;case 35668:case 35672:return setValueV3iArray;case 35669:case 35673:return setValueV4iArray;case 5125:return setValueV1uiArray;case 36294:return setValueV2uiArray;case 36295:return setValueV3uiArray;case 36296:return setValueV4uiArray;case 35678:case 36198:case 36298:case 36306:case 35682:return setValueT1Array;case 35679:case 36299:case 36307:return setValueT3DArray;case 35680:case 36300:case 36308:case 36293:return setValueT6Array;case 36289:case 36303:case 36311:case 36292:return setValueT2DArrayArray}}class SingleUniform{constructor(w,D,O){this.id=w,this.addr=O,this.cache=[],this.type=D.type,this.setValue=getSingularSetter(D.type)}}class PureArrayUniform{constructor(w,D,O){this.id=w,this.addr=O,this.cache=[],this.type=D.type,this.size=D.size,this.setValue=getPureArraySetter(D.type)}}class StructuredUniform{constructor(w){this.id=w,this.seq=[],this.map={}}setValue(w,D,O){const U=this.seq;for(let G=0,q=U.length;G!==q;++G){const K=U[G];K.setValue(w,D[K.id],O)}}}const RePathPart=/(\w+)(\])?(\[|\.)?/g;function addUniform(F,w){F.seq.push(w),F.map[w.id]=w}function parseUniform(F,w,D){const O=F.name,U=O.length;for(RePathPart.lastIndex=0;;){const G=RePathPart.exec(O),q=RePathPart.lastIndex;let K=G[1];const ee=G[2]==="]",Z=G[3];if(ee&&(K=K|0),Z===void 0||Z==="["&&q+2===U){addUniform(D,Z===void 0?new SingleUniform(K,F,w):new PureArrayUniform(K,F,w));break}else{let Y=D.map[K];Y===void 0&&(Y=new StructuredUniform(K),addUniform(D,Y)),D=Y}}}class WebGLUniforms{constructor(w,D){this.seq=[],this.map={};const O=w.getProgramParameter(D,w.ACTIVE_UNIFORMS);for(let U=0;U<O;++U){const G=w.getActiveUniform(D,U),q=w.getUniformLocation(D,G.name);parseUniform(G,q,this)}}setValue(w,D,O,U){const G=this.map[D];G!==void 0&&G.setValue(w,O,U)}setOptional(w,D,O){const U=D[O];U!==void 0&&this.setValue(w,O,U)}static upload(w,D,O,U){for(let G=0,q=D.length;G!==q;++G){const K=D[G],ee=O[K.id];ee.needsUpdate!==!1&&K.setValue(w,ee.value,U)}}static seqWithValue(w,D){const O=[];for(let U=0,G=w.length;U!==G;++U){const q=w[U];q.id in D&&O.push(q)}return O}}function WebGLShader(F,w,D){const O=F.createShader(w);return F.shaderSource(O,D),F.compileShader(O),O}const COMPLETION_STATUS_KHR=37297;let programIdCount=0;function handleSource(F,w){const D=F.split(`
`),O=[],U=Math.max(w-6,0),G=Math.min(w+6,D.length);for(let q=U;q<G;q++){const K=q+1;O.push(`${K===w?">":" "} ${K}: ${D[q]}`)}return O.join(`
`)}const _m0=new Matrix3;function getEncodingComponents(F){ColorManagement._getMatrix(_m0,ColorManagement.workingColorSpace,F);const w=`mat3( ${_m0.elements.map(D=>D.toFixed(4))} )`;switch(ColorManagement.getTransfer(F)){case LinearTransfer:return[w,"LinearTransferOETF"];case SRGBTransfer:return[w,"sRGBTransferOETF"];default:return warn("WebGLProgram: Unsupported color space: ",F),[w,"LinearTransferOETF"]}}function getShaderErrors(F,w,D){const O=F.getShaderParameter(w,F.COMPILE_STATUS),G=(F.getShaderInfoLog(w)||"").trim();if(O&&G==="")return"";const q=/ERROR: 0:(\d+)/.exec(G);if(q){const K=parseInt(q[1]);return D.toUpperCase()+`

`+G+`

`+handleSource(F.getShaderSource(w),K)}else return G}function getTexelEncodingFunction(F,w){const D=getEncodingComponents(w);return[`vec4 ${F}( vec4 value ) {`,`	return ${D[1]}( vec4( value.rgb * ${D[0]}, value.a ) );`,"}"].join(`
`)}function getToneMappingFunction(F,w){let D;switch(w){case LinearToneMapping:D="Linear";break;case ReinhardToneMapping:D="Reinhard";break;case CineonToneMapping:D="Cineon";break;case ACESFilmicToneMapping:D="ACESFilmic";break;case AgXToneMapping:D="AgX";break;case NeutralToneMapping:D="Neutral";break;case CustomToneMapping:D="Custom";break;default:warn("WebGLProgram: Unsupported toneMapping:",w),D="Linear"}return"vec3 "+F+"( vec3 color ) { return "+D+"ToneMapping( color ); }"}const _v0=new Vector3;function getLuminanceFunction(){ColorManagement.getLuminanceCoefficients(_v0);const F=_v0.x.toFixed(4),w=_v0.y.toFixed(4),D=_v0.z.toFixed(4);return["float luminance( const in vec3 rgb ) {",`	const vec3 weights = vec3( ${F}, ${w}, ${D} );`,"	return dot( weights, rgb );","}"].join(`
`)}function generateVertexExtensions(F){return[F.extensionClipCullDistance?"#extension GL_ANGLE_clip_cull_distance : require":"",F.extensionMultiDraw?"#extension GL_ANGLE_multi_draw : require":""].filter(filterEmptyLine).join(`
`)}function generateDefines(F){const w=[];for(const D in F){const O=F[D];O!==!1&&w.push("#define "+D+" "+O)}return w.join(`
`)}function fetchAttributeLocations(F,w){const D={},O=F.getProgramParameter(w,F.ACTIVE_ATTRIBUTES);for(let U=0;U<O;U++){const G=F.getActiveAttrib(w,U),q=G.name;let K=1;G.type===F.FLOAT_MAT2&&(K=2),G.type===F.FLOAT_MAT3&&(K=3),G.type===F.FLOAT_MAT4&&(K=4),D[q]={type:G.type,location:F.getAttribLocation(w,q),locationSize:K}}return D}function filterEmptyLine(F){return F!==""}function replaceLightNums(F,w){const D=w.numSpotLightShadows+w.numSpotLightMaps-w.numSpotLightShadowsWithMaps;return F.replace(/NUM_DIR_LIGHTS/g,w.numDirLights).replace(/NUM_SPOT_LIGHTS/g,w.numSpotLights).replace(/NUM_SPOT_LIGHT_MAPS/g,w.numSpotLightMaps).replace(/NUM_SPOT_LIGHT_COORDS/g,D).replace(/NUM_RECT_AREA_LIGHTS/g,w.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g,w.numPointLights).replace(/NUM_HEMI_LIGHTS/g,w.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g,w.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g,w.numSpotLightShadowsWithMaps).replace(/NUM_SPOT_LIGHT_SHADOWS/g,w.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g,w.numPointLightShadows)}function replaceClippingPlaneNums(F,w){return F.replace(/NUM_CLIPPING_PLANES/g,w.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g,w.numClippingPlanes-w.numClipIntersection)}const includePattern=/^[ \t]*#include +<([\w\d./]+)>/gm;function resolveIncludes(F){return F.replace(includePattern,includeReplacer)}const shaderChunkMap=new Map;function includeReplacer(F,w){let D=ShaderChunk[w];if(D===void 0){const O=shaderChunkMap.get(w);if(O!==void 0)D=ShaderChunk[O],warn('WebGLRenderer: Shader chunk "%s" has been deprecated. Use "%s" instead.',w,O);else throw new Error("Can not resolve #include <"+w+">")}return resolveIncludes(D)}const unrollLoopPattern=/#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;function unrollLoops(F){return F.replace(unrollLoopPattern,loopReplacer)}function loopReplacer(F,w,D,O){let U="";for(let G=parseInt(w);G<parseInt(D);G++)U+=O.replace(/\[\s*i\s*\]/g,"[ "+G+" ]").replace(/UNROLLED_LOOP_INDEX/g,G);return U}function generatePrecision(F){let w=`precision ${F.precision} float;
	precision ${F.precision} int;
	precision ${F.precision} sampler2D;
	precision ${F.precision} samplerCube;
	precision ${F.precision} sampler3D;
	precision ${F.precision} sampler2DArray;
	precision ${F.precision} sampler2DShadow;
	precision ${F.precision} samplerCubeShadow;
	precision ${F.precision} sampler2DArrayShadow;
	precision ${F.precision} isampler2D;
	precision ${F.precision} isampler3D;
	precision ${F.precision} isamplerCube;
	precision ${F.precision} isampler2DArray;
	precision ${F.precision} usampler2D;
	precision ${F.precision} usampler3D;
	precision ${F.precision} usamplerCube;
	precision ${F.precision} usampler2DArray;
	`;return F.precision==="highp"?w+=`
#define HIGH_PRECISION`:F.precision==="mediump"?w+=`
#define MEDIUM_PRECISION`:F.precision==="lowp"&&(w+=`
#define LOW_PRECISION`),w}function generateShadowMapTypeDefine(F){let w="SHADOWMAP_TYPE_BASIC";return F.shadowMapType===PCFShadowMap?w="SHADOWMAP_TYPE_PCF":F.shadowMapType===PCFSoftShadowMap?w="SHADOWMAP_TYPE_PCF_SOFT":F.shadowMapType===VSMShadowMap&&(w="SHADOWMAP_TYPE_VSM"),w}function generateEnvMapTypeDefine(F){let w="ENVMAP_TYPE_CUBE";if(F.envMap)switch(F.envMapMode){case CubeReflectionMapping:case CubeRefractionMapping:w="ENVMAP_TYPE_CUBE";break;case CubeUVReflectionMapping:w="ENVMAP_TYPE_CUBE_UV";break}return w}function generateEnvMapModeDefine(F){let w="ENVMAP_MODE_REFLECTION";if(F.envMap)switch(F.envMapMode){case CubeRefractionMapping:w="ENVMAP_MODE_REFRACTION";break}return w}function generateEnvMapBlendingDefine(F){let w="ENVMAP_BLENDING_NONE";if(F.envMap)switch(F.combine){case MultiplyOperation:w="ENVMAP_BLENDING_MULTIPLY";break;case MixOperation:w="ENVMAP_BLENDING_MIX";break;case AddOperation:w="ENVMAP_BLENDING_ADD";break}return w}function generateCubeUVSize(F){const w=F.envMapCubeUVHeight;if(w===null)return null;const D=Math.log2(w)-2,O=1/w;return{texelWidth:1/(3*Math.max(Math.pow(2,D),112)),texelHeight:O,maxMip:D}}function WebGLProgram(F,w,D,O){const U=F.getContext(),G=D.defines;let q=D.vertexShader,K=D.fragmentShader;const ee=generateShadowMapTypeDefine(D),Z=generateEnvMapTypeDefine(D),ie=generateEnvMapModeDefine(D),Y=generateEnvMapBlendingDefine(D),W=generateCubeUVSize(D),ne=generateVertexExtensions(D),se=generateDefines(G),le=U.createProgram();let ce,he,pe=D.glslVersion?"#version "+D.glslVersion+`
`:"";D.isRawShaderMaterial?(ce=["#define SHADER_TYPE "+D.shaderType,"#define SHADER_NAME "+D.shaderName,se].filter(filterEmptyLine).join(`
`),ce.length>0&&(ce+=`
`),he=["#define SHADER_TYPE "+D.shaderType,"#define SHADER_NAME "+D.shaderName,se].filter(filterEmptyLine).join(`
`),he.length>0&&(he+=`
`)):(ce=[generatePrecision(D),"#define SHADER_TYPE "+D.shaderType,"#define SHADER_NAME "+D.shaderName,se,D.extensionClipCullDistance?"#define USE_CLIP_DISTANCE":"",D.batching?"#define USE_BATCHING":"",D.batchingColor?"#define USE_BATCHING_COLOR":"",D.instancing?"#define USE_INSTANCING":"",D.instancingColor?"#define USE_INSTANCING_COLOR":"",D.instancingMorph?"#define USE_INSTANCING_MORPH":"",D.useFog&&D.fog?"#define USE_FOG":"",D.useFog&&D.fogExp2?"#define FOG_EXP2":"",D.map?"#define USE_MAP":"",D.envMap?"#define USE_ENVMAP":"",D.envMap?"#define "+ie:"",D.lightMap?"#define USE_LIGHTMAP":"",D.aoMap?"#define USE_AOMAP":"",D.bumpMap?"#define USE_BUMPMAP":"",D.normalMap?"#define USE_NORMALMAP":"",D.normalMapObjectSpace?"#define USE_NORMALMAP_OBJECTSPACE":"",D.normalMapTangentSpace?"#define USE_NORMALMAP_TANGENTSPACE":"",D.displacementMap?"#define USE_DISPLACEMENTMAP":"",D.emissiveMap?"#define USE_EMISSIVEMAP":"",D.anisotropy?"#define USE_ANISOTROPY":"",D.anisotropyMap?"#define USE_ANISOTROPYMAP":"",D.clearcoatMap?"#define USE_CLEARCOATMAP":"",D.clearcoatRoughnessMap?"#define USE_CLEARCOAT_ROUGHNESSMAP":"",D.clearcoatNormalMap?"#define USE_CLEARCOAT_NORMALMAP":"",D.iridescenceMap?"#define USE_IRIDESCENCEMAP":"",D.iridescenceThicknessMap?"#define USE_IRIDESCENCE_THICKNESSMAP":"",D.specularMap?"#define USE_SPECULARMAP":"",D.specularColorMap?"#define USE_SPECULAR_COLORMAP":"",D.specularIntensityMap?"#define USE_SPECULAR_INTENSITYMAP":"",D.roughnessMap?"#define USE_ROUGHNESSMAP":"",D.metalnessMap?"#define USE_METALNESSMAP":"",D.alphaMap?"#define USE_ALPHAMAP":"",D.alphaHash?"#define USE_ALPHAHASH":"",D.transmission?"#define USE_TRANSMISSION":"",D.transmissionMap?"#define USE_TRANSMISSIONMAP":"",D.thicknessMap?"#define USE_THICKNESSMAP":"",D.sheenColorMap?"#define USE_SHEEN_COLORMAP":"",D.sheenRoughnessMap?"#define USE_SHEEN_ROUGHNESSMAP":"",D.mapUv?"#define MAP_UV "+D.mapUv:"",D.alphaMapUv?"#define ALPHAMAP_UV "+D.alphaMapUv:"",D.lightMapUv?"#define LIGHTMAP_UV "+D.lightMapUv:"",D.aoMapUv?"#define AOMAP_UV "+D.aoMapUv:"",D.emissiveMapUv?"#define EMISSIVEMAP_UV "+D.emissiveMapUv:"",D.bumpMapUv?"#define BUMPMAP_UV "+D.bumpMapUv:"",D.normalMapUv?"#define NORMALMAP_UV "+D.normalMapUv:"",D.displacementMapUv?"#define DISPLACEMENTMAP_UV "+D.displacementMapUv:"",D.metalnessMapUv?"#define METALNESSMAP_UV "+D.metalnessMapUv:"",D.roughnessMapUv?"#define ROUGHNESSMAP_UV "+D.roughnessMapUv:"",D.anisotropyMapUv?"#define ANISOTROPYMAP_UV "+D.anisotropyMapUv:"",D.clearcoatMapUv?"#define CLEARCOATMAP_UV "+D.clearcoatMapUv:"",D.clearcoatNormalMapUv?"#define CLEARCOAT_NORMALMAP_UV "+D.clearcoatNormalMapUv:"",D.clearcoatRoughnessMapUv?"#define CLEARCOAT_ROUGHNESSMAP_UV "+D.clearcoatRoughnessMapUv:"",D.iridescenceMapUv?"#define IRIDESCENCEMAP_UV "+D.iridescenceMapUv:"",D.iridescenceThicknessMapUv?"#define IRIDESCENCE_THICKNESSMAP_UV "+D.iridescenceThicknessMapUv:"",D.sheenColorMapUv?"#define SHEEN_COLORMAP_UV "+D.sheenColorMapUv:"",D.sheenRoughnessMapUv?"#define SHEEN_ROUGHNESSMAP_UV "+D.sheenRoughnessMapUv:"",D.specularMapUv?"#define SPECULARMAP_UV "+D.specularMapUv:"",D.specularColorMapUv?"#define SPECULAR_COLORMAP_UV "+D.specularColorMapUv:"",D.specularIntensityMapUv?"#define SPECULAR_INTENSITYMAP_UV "+D.specularIntensityMapUv:"",D.transmissionMapUv?"#define TRANSMISSIONMAP_UV "+D.transmissionMapUv:"",D.thicknessMapUv?"#define THICKNESSMAP_UV "+D.thicknessMapUv:"",D.vertexTangents&&D.flatShading===!1?"#define USE_TANGENT":"",D.vertexColors?"#define USE_COLOR":"",D.vertexAlphas?"#define USE_COLOR_ALPHA":"",D.vertexUv1s?"#define USE_UV1":"",D.vertexUv2s?"#define USE_UV2":"",D.vertexUv3s?"#define USE_UV3":"",D.pointsUvs?"#define USE_POINTS_UV":"",D.flatShading?"#define FLAT_SHADED":"",D.skinning?"#define USE_SKINNING":"",D.morphTargets?"#define USE_MORPHTARGETS":"",D.morphNormals&&D.flatShading===!1?"#define USE_MORPHNORMALS":"",D.morphColors?"#define USE_MORPHCOLORS":"",D.morphTargetsCount>0?"#define MORPHTARGETS_TEXTURE_STRIDE "+D.morphTextureStride:"",D.morphTargetsCount>0?"#define MORPHTARGETS_COUNT "+D.morphTargetsCount:"",D.doubleSided?"#define DOUBLE_SIDED":"",D.flipSided?"#define FLIP_SIDED":"",D.shadowMapEnabled?"#define USE_SHADOWMAP":"",D.shadowMapEnabled?"#define "+ee:"",D.sizeAttenuation?"#define USE_SIZEATTENUATION":"",D.numLightProbes>0?"#define USE_LIGHT_PROBES":"",D.logarithmicDepthBuffer?"#define USE_LOGARITHMIC_DEPTH_BUFFER":"",D.reversedDepthBuffer?"#define USE_REVERSED_DEPTH_BUFFER":"","uniform mat4 modelMatrix;","uniform mat4 modelViewMatrix;","uniform mat4 projectionMatrix;","uniform mat4 viewMatrix;","uniform mat3 normalMatrix;","uniform vec3 cameraPosition;","uniform bool isOrthographic;","#ifdef USE_INSTANCING","	attribute mat4 instanceMatrix;","#endif","#ifdef USE_INSTANCING_COLOR","	attribute vec3 instanceColor;","#endif","#ifdef USE_INSTANCING_MORPH","	uniform sampler2D morphTexture;","#endif","attribute vec3 position;","attribute vec3 normal;","attribute vec2 uv;","#ifdef USE_UV1","	attribute vec2 uv1;","#endif","#ifdef USE_UV2","	attribute vec2 uv2;","#endif","#ifdef USE_UV3","	attribute vec2 uv3;","#endif","#ifdef USE_TANGENT","	attribute vec4 tangent;","#endif","#if defined( USE_COLOR_ALPHA )","	attribute vec4 color;","#elif defined( USE_COLOR )","	attribute vec3 color;","#endif","#ifdef USE_SKINNING","	attribute vec4 skinIndex;","	attribute vec4 skinWeight;","#endif",`
`].filter(filterEmptyLine).join(`
`),he=[generatePrecision(D),"#define SHADER_TYPE "+D.shaderType,"#define SHADER_NAME "+D.shaderName,se,D.useFog&&D.fog?"#define USE_FOG":"",D.useFog&&D.fogExp2?"#define FOG_EXP2":"",D.alphaToCoverage?"#define ALPHA_TO_COVERAGE":"",D.map?"#define USE_MAP":"",D.matcap?"#define USE_MATCAP":"",D.envMap?"#define USE_ENVMAP":"",D.envMap?"#define "+Z:"",D.envMap?"#define "+ie:"",D.envMap?"#define "+Y:"",W?"#define CUBEUV_TEXEL_WIDTH "+W.texelWidth:"",W?"#define CUBEUV_TEXEL_HEIGHT "+W.texelHeight:"",W?"#define CUBEUV_MAX_MIP "+W.maxMip+".0":"",D.lightMap?"#define USE_LIGHTMAP":"",D.aoMap?"#define USE_AOMAP":"",D.bumpMap?"#define USE_BUMPMAP":"",D.normalMap?"#define USE_NORMALMAP":"",D.normalMapObjectSpace?"#define USE_NORMALMAP_OBJECTSPACE":"",D.normalMapTangentSpace?"#define USE_NORMALMAP_TANGENTSPACE":"",D.emissiveMap?"#define USE_EMISSIVEMAP":"",D.anisotropy?"#define USE_ANISOTROPY":"",D.anisotropyMap?"#define USE_ANISOTROPYMAP":"",D.clearcoat?"#define USE_CLEARCOAT":"",D.clearcoatMap?"#define USE_CLEARCOATMAP":"",D.clearcoatRoughnessMap?"#define USE_CLEARCOAT_ROUGHNESSMAP":"",D.clearcoatNormalMap?"#define USE_CLEARCOAT_NORMALMAP":"",D.dispersion?"#define USE_DISPERSION":"",D.iridescence?"#define USE_IRIDESCENCE":"",D.iridescenceMap?"#define USE_IRIDESCENCEMAP":"",D.iridescenceThicknessMap?"#define USE_IRIDESCENCE_THICKNESSMAP":"",D.specularMap?"#define USE_SPECULARMAP":"",D.specularColorMap?"#define USE_SPECULAR_COLORMAP":"",D.specularIntensityMap?"#define USE_SPECULAR_INTENSITYMAP":"",D.roughnessMap?"#define USE_ROUGHNESSMAP":"",D.metalnessMap?"#define USE_METALNESSMAP":"",D.alphaMap?"#define USE_ALPHAMAP":"",D.alphaTest?"#define USE_ALPHATEST":"",D.alphaHash?"#define USE_ALPHAHASH":"",D.sheen?"#define USE_SHEEN":"",D.sheenColorMap?"#define USE_SHEEN_COLORMAP":"",D.sheenRoughnessMap?"#define USE_SHEEN_ROUGHNESSMAP":"",D.transmission?"#define USE_TRANSMISSION":"",D.transmissionMap?"#define USE_TRANSMISSIONMAP":"",D.thicknessMap?"#define USE_THICKNESSMAP":"",D.vertexTangents&&D.flatShading===!1?"#define USE_TANGENT":"",D.vertexColors||D.instancingColor||D.batchingColor?"#define USE_COLOR":"",D.vertexAlphas?"#define USE_COLOR_ALPHA":"",D.vertexUv1s?"#define USE_UV1":"",D.vertexUv2s?"#define USE_UV2":"",D.vertexUv3s?"#define USE_UV3":"",D.pointsUvs?"#define USE_POINTS_UV":"",D.gradientMap?"#define USE_GRADIENTMAP":"",D.flatShading?"#define FLAT_SHADED":"",D.doubleSided?"#define DOUBLE_SIDED":"",D.flipSided?"#define FLIP_SIDED":"",D.shadowMapEnabled?"#define USE_SHADOWMAP":"",D.shadowMapEnabled?"#define "+ee:"",D.premultipliedAlpha?"#define PREMULTIPLIED_ALPHA":"",D.numLightProbes>0?"#define USE_LIGHT_PROBES":"",D.decodeVideoTexture?"#define DECODE_VIDEO_TEXTURE":"",D.decodeVideoTextureEmissive?"#define DECODE_VIDEO_TEXTURE_EMISSIVE":"",D.logarithmicDepthBuffer?"#define USE_LOGARITHMIC_DEPTH_BUFFER":"",D.reversedDepthBuffer?"#define USE_REVERSED_DEPTH_BUFFER":"","uniform mat4 viewMatrix;","uniform vec3 cameraPosition;","uniform bool isOrthographic;",D.toneMapping!==NoToneMapping?"#define TONE_MAPPING":"",D.toneMapping!==NoToneMapping?ShaderChunk.tonemapping_pars_fragment:"",D.toneMapping!==NoToneMapping?getToneMappingFunction("toneMapping",D.toneMapping):"",D.dithering?"#define DITHERING":"",D.opaque?"#define OPAQUE":"",ShaderChunk.colorspace_pars_fragment,getTexelEncodingFunction("linearToOutputTexel",D.outputColorSpace),getLuminanceFunction(),D.useDepthPacking?"#define DEPTH_PACKING "+D.depthPacking:"",`
`].filter(filterEmptyLine).join(`
`)),q=resolveIncludes(q),q=replaceLightNums(q,D),q=replaceClippingPlaneNums(q,D),K=resolveIncludes(K),K=replaceLightNums(K,D),K=replaceClippingPlaneNums(K,D),q=unrollLoops(q),K=unrollLoops(K),D.isRawShaderMaterial!==!0&&(pe=`#version 300 es
`,ce=[ne,"#define attribute in","#define varying out","#define texture2D texture"].join(`
`)+`
`+ce,he=["#define varying in",D.glslVersion===GLSL3?"":"layout(location = 0) out highp vec4 pc_fragColor;",D.glslVersion===GLSL3?"":"#define gl_FragColor pc_fragColor","#define gl_FragDepthEXT gl_FragDepth","#define texture2D texture","#define textureCube texture","#define texture2DProj textureProj","#define texture2DLodEXT textureLod","#define texture2DProjLodEXT textureProjLod","#define textureCubeLodEXT textureLod","#define texture2DGradEXT textureGrad","#define texture2DProjGradEXT textureProjGrad","#define textureCubeGradEXT textureGrad"].join(`
`)+`
`+he);const me=pe+ce+q,be=pe+he+K,ge=WebGLShader(U,U.VERTEX_SHADER,me),ve=WebGLShader(U,U.FRAGMENT_SHADER,be);U.attachShader(le,ge),U.attachShader(le,ve),D.index0AttributeName!==void 0?U.bindAttribLocation(le,0,D.index0AttributeName):D.morphTargets===!0&&U.bindAttribLocation(le,0,"position"),U.linkProgram(le);function Se(Re){if(F.debug.checkShaderErrors){const Le=U.getProgramInfoLog(le)||"",Ne=U.getShaderInfoLog(ge)||"",Oe=U.getShaderInfoLog(ve)||"",Pe=Le.trim(),Ce=Ne.trim(),Be=Oe.trim();let ze=!0,Xe=!0;if(U.getProgramParameter(le,U.LINK_STATUS)===!1)if(ze=!1,typeof F.debug.onShaderError=="function")F.debug.onShaderError(U,le,ge,ve);else{const lt=getShaderErrors(U,ge,"vertex"),ke=getShaderErrors(U,ve,"fragment");error("THREE.WebGLProgram: Shader Error "+U.getError()+" - VALIDATE_STATUS "+U.getProgramParameter(le,U.VALIDATE_STATUS)+`

Material Name: `+Re.name+`
Material Type: `+Re.type+`

Program Info Log: `+Pe+`
`+lt+`
`+ke)}else Pe!==""?warn("WebGLProgram: Program Info Log:",Pe):(Ce===""||Be==="")&&(Xe=!1);Xe&&(Re.diagnostics={runnable:ze,programLog:Pe,vertexShader:{log:Ce,prefix:ce},fragmentShader:{log:Be,prefix:he}})}U.deleteShader(ge),U.deleteShader(ve),Me=new WebGLUniforms(U,le),Ee=fetchAttributeLocations(U,le)}let Me;this.getUniforms=function(){return Me===void 0&&Se(this),Me};let Ee;this.getAttributes=function(){return Ee===void 0&&Se(this),Ee};let we=D.rendererExtensionParallelShaderCompile===!1;return this.isReady=function(){return we===!1&&(we=U.getProgramParameter(le,COMPLETION_STATUS_KHR)),we},this.destroy=function(){O.releaseStatesOfProgram(this),U.deleteProgram(le),this.program=void 0},this.type=D.shaderType,this.name=D.shaderName,this.id=programIdCount++,this.cacheKey=w,this.usedTimes=1,this.program=le,this.vertexShader=ge,this.fragmentShader=ve,this}let _id=0;class WebGLShaderCache{constructor(){this.shaderCache=new Map,this.materialCache=new Map}update(w){const D=w.vertexShader,O=w.fragmentShader,U=this._getShaderStage(D),G=this._getShaderStage(O),q=this._getShaderCacheForMaterial(w);return q.has(U)===!1&&(q.add(U),U.usedTimes++),q.has(G)===!1&&(q.add(G),G.usedTimes++),this}remove(w){const D=this.materialCache.get(w);for(const O of D)O.usedTimes--,O.usedTimes===0&&this.shaderCache.delete(O.code);return this.materialCache.delete(w),this}getVertexShaderID(w){return this._getShaderStage(w.vertexShader).id}getFragmentShaderID(w){return this._getShaderStage(w.fragmentShader).id}dispose(){this.shaderCache.clear(),this.materialCache.clear()}_getShaderCacheForMaterial(w){const D=this.materialCache;let O=D.get(w);return O===void 0&&(O=new Set,D.set(w,O)),O}_getShaderStage(w){const D=this.shaderCache;let O=D.get(w);return O===void 0&&(O=new WebGLShaderStage(w),D.set(w,O)),O}}class WebGLShaderStage{constructor(w){this.id=_id++,this.code=w,this.usedTimes=0}}function WebGLPrograms(F,w,D,O,U,G,q){const K=new Layers,ee=new WebGLShaderCache,Z=new Set,ie=[],Y=U.logarithmicDepthBuffer,W=U.vertexTextures;let ne=U.precision;const se={MeshDepthMaterial:"depth",MeshDistanceMaterial:"distanceRGBA",MeshNormalMaterial:"normal",MeshBasicMaterial:"basic",MeshLambertMaterial:"lambert",MeshPhongMaterial:"phong",MeshToonMaterial:"toon",MeshStandardMaterial:"physical",MeshPhysicalMaterial:"physical",MeshMatcapMaterial:"matcap",LineBasicMaterial:"basic",LineDashedMaterial:"dashed",PointsMaterial:"points",ShadowMaterial:"shadow",SpriteMaterial:"sprite"};function le(Ee){return Z.add(Ee),Ee===0?"uv":`uv${Ee}`}function ce(Ee,we,Re,Le,Ne){const Oe=Le.fog,Pe=Ne.geometry,Ce=Ee.isMeshStandardMaterial?Le.environment:null,Be=(Ee.isMeshStandardMaterial?D:w).get(Ee.envMap||Ce),ze=Be&&Be.mapping===CubeUVReflectionMapping?Be.image.height:null,Xe=se[Ee.type];Ee.precision!==null&&(ne=U.getMaxPrecision(Ee.precision),ne!==Ee.precision&&warn("WebGLProgram.getParameters:",Ee.precision,"not supported, using",ne,"instead."));const lt=Pe.morphAttributes.position||Pe.morphAttributes.normal||Pe.morphAttributes.color,ke=lt!==void 0?lt.length:0;let rt=0;Pe.morphAttributes.position!==void 0&&(rt=1),Pe.morphAttributes.normal!==void 0&&(rt=2),Pe.morphAttributes.color!==void 0&&(rt=3);let St,Lt,$t,mt;if(Xe){const hi=ShaderLib[Xe];St=hi.vertexShader,Lt=hi.fragmentShader}else St=Ee.vertexShader,Lt=Ee.fragmentShader,ee.update(Ee),$t=ee.getVertexShaderID(Ee),mt=ee.getFragmentShaderID(Ee);const bt=F.getRenderTarget(),Xt=F.state.buffers.depth.getReversed(),hn=Ne.isInstancedMesh===!0,Jt=Ne.isBatchedMesh===!0,Mn=!!Ee.map,Zn=!!Ee.matcap,vn=!!Be,In=!!Ee.aoMap,st=!!Ee.lightMap,Gn=!!Ee.bumpMap,qn=!!Ee.normalMap,ai=!!Ee.displacementMap,yn=!!Ee.emissiveMap,li=!!Ee.metalnessMap,Tn=!!Ee.roughnessMap,En=Ee.anisotropy>0,Ke=Ee.clearcoat>0,Fe=Ee.dispersion>0,pt=Ee.iridescence>0,zt=Ee.sheen>0,qt=Ee.transmission>0,Nt=En&&!!Ee.anisotropyMap,Rn=Ke&&!!Ee.clearcoatMap,fn=Ke&&!!Ee.clearcoatNormalMap,Nn=Ke&&!!Ee.clearcoatRoughnessMap,An=pt&&!!Ee.iridescenceMap,Wt=pt&&!!Ee.iridescenceThicknessMap,Dt=zt&&!!Ee.sheenColorMap,Bn=zt&&!!Ee.sheenRoughnessMap,Sn=!!Ee.specularMap,bn=!!Ee.specularColorMap,kn=!!Ee.specularIntensityMap,nt=qt&&!!Ee.transmissionMap,dn=qt&&!!Ee.thicknessMap,tn=!!Ee.gradientMap,Zt=!!Ee.alphaMap,Bt=Ee.alphaTest>0,wt=!!Ee.alphaHash,Qt=!!Ee.extensions;let Yn=NoToneMapping;Ee.toneMapped&&(bt===null||bt.isXRRenderTarget===!0)&&(Yn=F.toneMapping);const Ai={shaderID:Xe,shaderType:Ee.type,shaderName:Ee.name,vertexShader:St,fragmentShader:Lt,defines:Ee.defines,customVertexShaderID:$t,customFragmentShaderID:mt,isRawShaderMaterial:Ee.isRawShaderMaterial===!0,glslVersion:Ee.glslVersion,precision:ne,batching:Jt,batchingColor:Jt&&Ne._colorsTexture!==null,instancing:hn,instancingColor:hn&&Ne.instanceColor!==null,instancingMorph:hn&&Ne.morphTexture!==null,supportsVertexTextures:W,outputColorSpace:bt===null?F.outputColorSpace:bt.isXRRenderTarget===!0?bt.texture.colorSpace:LinearSRGBColorSpace,alphaToCoverage:!!Ee.alphaToCoverage,map:Mn,matcap:Zn,envMap:vn,envMapMode:vn&&Be.mapping,envMapCubeUVHeight:ze,aoMap:In,lightMap:st,bumpMap:Gn,normalMap:qn,displacementMap:W&&ai,emissiveMap:yn,normalMapObjectSpace:qn&&Ee.normalMapType===ObjectSpaceNormalMap,normalMapTangentSpace:qn&&Ee.normalMapType===TangentSpaceNormalMap,metalnessMap:li,roughnessMap:Tn,anisotropy:En,anisotropyMap:Nt,clearcoat:Ke,clearcoatMap:Rn,clearcoatNormalMap:fn,clearcoatRoughnessMap:Nn,dispersion:Fe,iridescence:pt,iridescenceMap:An,iridescenceThicknessMap:Wt,sheen:zt,sheenColorMap:Dt,sheenRoughnessMap:Bn,specularMap:Sn,specularColorMap:bn,specularIntensityMap:kn,transmission:qt,transmissionMap:nt,thicknessMap:dn,gradientMap:tn,opaque:Ee.transparent===!1&&Ee.blending===NormalBlending&&Ee.alphaToCoverage===!1,alphaMap:Zt,alphaTest:Bt,alphaHash:wt,combine:Ee.combine,mapUv:Mn&&le(Ee.map.channel),aoMapUv:In&&le(Ee.aoMap.channel),lightMapUv:st&&le(Ee.lightMap.channel),bumpMapUv:Gn&&le(Ee.bumpMap.channel),normalMapUv:qn&&le(Ee.normalMap.channel),displacementMapUv:ai&&le(Ee.displacementMap.channel),emissiveMapUv:yn&&le(Ee.emissiveMap.channel),metalnessMapUv:li&&le(Ee.metalnessMap.channel),roughnessMapUv:Tn&&le(Ee.roughnessMap.channel),anisotropyMapUv:Nt&&le(Ee.anisotropyMap.channel),clearcoatMapUv:Rn&&le(Ee.clearcoatMap.channel),clearcoatNormalMapUv:fn&&le(Ee.clearcoatNormalMap.channel),clearcoatRoughnessMapUv:Nn&&le(Ee.clearcoatRoughnessMap.channel),iridescenceMapUv:An&&le(Ee.iridescenceMap.channel),iridescenceThicknessMapUv:Wt&&le(Ee.iridescenceThicknessMap.channel),sheenColorMapUv:Dt&&le(Ee.sheenColorMap.channel),sheenRoughnessMapUv:Bn&&le(Ee.sheenRoughnessMap.channel),specularMapUv:Sn&&le(Ee.specularMap.channel),specularColorMapUv:bn&&le(Ee.specularColorMap.channel),specularIntensityMapUv:kn&&le(Ee.specularIntensityMap.channel),transmissionMapUv:nt&&le(Ee.transmissionMap.channel),thicknessMapUv:dn&&le(Ee.thicknessMap.channel),alphaMapUv:Zt&&le(Ee.alphaMap.channel),vertexTangents:!!Pe.attributes.tangent&&(qn||En),vertexColors:Ee.vertexColors,vertexAlphas:Ee.vertexColors===!0&&!!Pe.attributes.color&&Pe.attributes.color.itemSize===4,pointsUvs:Ne.isPoints===!0&&!!Pe.attributes.uv&&(Mn||Zt),fog:!!Oe,useFog:Ee.fog===!0,fogExp2:!!Oe&&Oe.isFogExp2,flatShading:Ee.flatShading===!0&&Ee.wireframe===!1,sizeAttenuation:Ee.sizeAttenuation===!0,logarithmicDepthBuffer:Y,reversedDepthBuffer:Xt,skinning:Ne.isSkinnedMesh===!0,morphTargets:Pe.morphAttributes.position!==void 0,morphNormals:Pe.morphAttributes.normal!==void 0,morphColors:Pe.morphAttributes.color!==void 0,morphTargetsCount:ke,morphTextureStride:rt,numDirLights:we.directional.length,numPointLights:we.point.length,numSpotLights:we.spot.length,numSpotLightMaps:we.spotLightMap.length,numRectAreaLights:we.rectArea.length,numHemiLights:we.hemi.length,numDirLightShadows:we.directionalShadowMap.length,numPointLightShadows:we.pointShadowMap.length,numSpotLightShadows:we.spotShadowMap.length,numSpotLightShadowsWithMaps:we.numSpotLightShadowsWithMaps,numLightProbes:we.numLightProbes,numClippingPlanes:q.numPlanes,numClipIntersection:q.numIntersection,dithering:Ee.dithering,shadowMapEnabled:F.shadowMap.enabled&&Re.length>0,shadowMapType:F.shadowMap.type,toneMapping:Yn,decodeVideoTexture:Mn&&Ee.map.isVideoTexture===!0&&ColorManagement.getTransfer(Ee.map.colorSpace)===SRGBTransfer,decodeVideoTextureEmissive:yn&&Ee.emissiveMap.isVideoTexture===!0&&ColorManagement.getTransfer(Ee.emissiveMap.colorSpace)===SRGBTransfer,premultipliedAlpha:Ee.premultipliedAlpha,doubleSided:Ee.side===DoubleSide,flipSided:Ee.side===BackSide,useDepthPacking:Ee.depthPacking>=0,depthPacking:Ee.depthPacking||0,index0AttributeName:Ee.index0AttributeName,extensionClipCullDistance:Qt&&Ee.extensions.clipCullDistance===!0&&O.has("WEBGL_clip_cull_distance"),extensionMultiDraw:(Qt&&Ee.extensions.multiDraw===!0||Jt)&&O.has("WEBGL_multi_draw"),rendererExtensionParallelShaderCompile:O.has("KHR_parallel_shader_compile"),customProgramCacheKey:Ee.customProgramCacheKey()};return Ai.vertexUv1s=Z.has(1),Ai.vertexUv2s=Z.has(2),Ai.vertexUv3s=Z.has(3),Z.clear(),Ai}function he(Ee){const we=[];if(Ee.shaderID?we.push(Ee.shaderID):(we.push(Ee.customVertexShaderID),we.push(Ee.customFragmentShaderID)),Ee.defines!==void 0)for(const Re in Ee.defines)we.push(Re),we.push(Ee.defines[Re]);return Ee.isRawShaderMaterial===!1&&(pe(we,Ee),me(we,Ee),we.push(F.outputColorSpace)),we.push(Ee.customProgramCacheKey),we.join()}function pe(Ee,we){Ee.push(we.precision),Ee.push(we.outputColorSpace),Ee.push(we.envMapMode),Ee.push(we.envMapCubeUVHeight),Ee.push(we.mapUv),Ee.push(we.alphaMapUv),Ee.push(we.lightMapUv),Ee.push(we.aoMapUv),Ee.push(we.bumpMapUv),Ee.push(we.normalMapUv),Ee.push(we.displacementMapUv),Ee.push(we.emissiveMapUv),Ee.push(we.metalnessMapUv),Ee.push(we.roughnessMapUv),Ee.push(we.anisotropyMapUv),Ee.push(we.clearcoatMapUv),Ee.push(we.clearcoatNormalMapUv),Ee.push(we.clearcoatRoughnessMapUv),Ee.push(we.iridescenceMapUv),Ee.push(we.iridescenceThicknessMapUv),Ee.push(we.sheenColorMapUv),Ee.push(we.sheenRoughnessMapUv),Ee.push(we.specularMapUv),Ee.push(we.specularColorMapUv),Ee.push(we.specularIntensityMapUv),Ee.push(we.transmissionMapUv),Ee.push(we.thicknessMapUv),Ee.push(we.combine),Ee.push(we.fogExp2),Ee.push(we.sizeAttenuation),Ee.push(we.morphTargetsCount),Ee.push(we.morphAttributeCount),Ee.push(we.numDirLights),Ee.push(we.numPointLights),Ee.push(we.numSpotLights),Ee.push(we.numSpotLightMaps),Ee.push(we.numHemiLights),Ee.push(we.numRectAreaLights),Ee.push(we.numDirLightShadows),Ee.push(we.numPointLightShadows),Ee.push(we.numSpotLightShadows),Ee.push(we.numSpotLightShadowsWithMaps),Ee.push(we.numLightProbes),Ee.push(we.shadowMapType),Ee.push(we.toneMapping),Ee.push(we.numClippingPlanes),Ee.push(we.numClipIntersection),Ee.push(we.depthPacking)}function me(Ee,we){K.disableAll(),we.supportsVertexTextures&&K.enable(0),we.instancing&&K.enable(1),we.instancingColor&&K.enable(2),we.instancingMorph&&K.enable(3),we.matcap&&K.enable(4),we.envMap&&K.enable(5),we.normalMapObjectSpace&&K.enable(6),we.normalMapTangentSpace&&K.enable(7),we.clearcoat&&K.enable(8),we.iridescence&&K.enable(9),we.alphaTest&&K.enable(10),we.vertexColors&&K.enable(11),we.vertexAlphas&&K.enable(12),we.vertexUv1s&&K.enable(13),we.vertexUv2s&&K.enable(14),we.vertexUv3s&&K.enable(15),we.vertexTangents&&K.enable(16),we.anisotropy&&K.enable(17),we.alphaHash&&K.enable(18),we.batching&&K.enable(19),we.dispersion&&K.enable(20),we.batchingColor&&K.enable(21),we.gradientMap&&K.enable(22),Ee.push(K.mask),K.disableAll(),we.fog&&K.enable(0),we.useFog&&K.enable(1),we.flatShading&&K.enable(2),we.logarithmicDepthBuffer&&K.enable(3),we.reversedDepthBuffer&&K.enable(4),we.skinning&&K.enable(5),we.morphTargets&&K.enable(6),we.morphNormals&&K.enable(7),we.morphColors&&K.enable(8),we.premultipliedAlpha&&K.enable(9),we.shadowMapEnabled&&K.enable(10),we.doubleSided&&K.enable(11),we.flipSided&&K.enable(12),we.useDepthPacking&&K.enable(13),we.dithering&&K.enable(14),we.transmission&&K.enable(15),we.sheen&&K.enable(16),we.opaque&&K.enable(17),we.pointsUvs&&K.enable(18),we.decodeVideoTexture&&K.enable(19),we.decodeVideoTextureEmissive&&K.enable(20),we.alphaToCoverage&&K.enable(21),Ee.push(K.mask)}function be(Ee){const we=se[Ee.type];let Re;if(we){const Le=ShaderLib[we];Re=UniformsUtils.clone(Le.uniforms)}else Re=Ee.uniforms;return Re}function ge(Ee,we){let Re;for(let Le=0,Ne=ie.length;Le<Ne;Le++){const Oe=ie[Le];if(Oe.cacheKey===we){Re=Oe,++Re.usedTimes;break}}return Re===void 0&&(Re=new WebGLProgram(F,we,Ee,G),ie.push(Re)),Re}function ve(Ee){if(--Ee.usedTimes===0){const we=ie.indexOf(Ee);ie[we]=ie[ie.length-1],ie.pop(),Ee.destroy()}}function Se(Ee){ee.remove(Ee)}function Me(){ee.dispose()}return{getParameters:ce,getProgramCacheKey:he,getUniforms:be,acquireProgram:ge,releaseProgram:ve,releaseShaderCache:Se,programs:ie,dispose:Me}}function WebGLProperties(){let F=new WeakMap;function w(q){return F.has(q)}function D(q){let K=F.get(q);return K===void 0&&(K={},F.set(q,K)),K}function O(q){F.delete(q)}function U(q,K,ee){F.get(q)[K]=ee}function G(){F=new WeakMap}return{has:w,get:D,remove:O,update:U,dispose:G}}function painterSortStable(F,w){return F.groupOrder!==w.groupOrder?F.groupOrder-w.groupOrder:F.renderOrder!==w.renderOrder?F.renderOrder-w.renderOrder:F.material.id!==w.material.id?F.material.id-w.material.id:F.z!==w.z?F.z-w.z:F.id-w.id}function reversePainterSortStable(F,w){return F.groupOrder!==w.groupOrder?F.groupOrder-w.groupOrder:F.renderOrder!==w.renderOrder?F.renderOrder-w.renderOrder:F.z!==w.z?w.z-F.z:F.id-w.id}function WebGLRenderList(){const F=[];let w=0;const D=[],O=[],U=[];function G(){w=0,D.length=0,O.length=0,U.length=0}function q(Y,W,ne,se,le,ce){let he=F[w];return he===void 0?(he={id:Y.id,object:Y,geometry:W,material:ne,groupOrder:se,renderOrder:Y.renderOrder,z:le,group:ce},F[w]=he):(he.id=Y.id,he.object=Y,he.geometry=W,he.material=ne,he.groupOrder=se,he.renderOrder=Y.renderOrder,he.z=le,he.group=ce),w++,he}function K(Y,W,ne,se,le,ce){const he=q(Y,W,ne,se,le,ce);ne.transmission>0?O.push(he):ne.transparent===!0?U.push(he):D.push(he)}function ee(Y,W,ne,se,le,ce){const he=q(Y,W,ne,se,le,ce);ne.transmission>0?O.unshift(he):ne.transparent===!0?U.unshift(he):D.unshift(he)}function Z(Y,W){D.length>1&&D.sort(Y||painterSortStable),O.length>1&&O.sort(W||reversePainterSortStable),U.length>1&&U.sort(W||reversePainterSortStable)}function ie(){for(let Y=w,W=F.length;Y<W;Y++){const ne=F[Y];if(ne.id===null)break;ne.id=null,ne.object=null,ne.geometry=null,ne.material=null,ne.group=null}}return{opaque:D,transmissive:O,transparent:U,init:G,push:K,unshift:ee,finish:ie,sort:Z}}function WebGLRenderLists(){let F=new WeakMap;function w(O,U){const G=F.get(O);let q;return G===void 0?(q=new WebGLRenderList,F.set(O,[q])):U>=G.length?(q=new WebGLRenderList,G.push(q)):q=G[U],q}function D(){F=new WeakMap}return{get:w,dispose:D}}function UniformsCache(){const F={};return{get:function(w){if(F[w.id]!==void 0)return F[w.id];let D;switch(w.type){case"DirectionalLight":D={direction:new Vector3,color:new Color};break;case"SpotLight":D={position:new Vector3,direction:new Vector3,color:new Color,distance:0,coneCos:0,penumbraCos:0,decay:0};break;case"PointLight":D={position:new Vector3,color:new Color,distance:0,decay:0};break;case"HemisphereLight":D={direction:new Vector3,skyColor:new Color,groundColor:new Color};break;case"RectAreaLight":D={color:new Color,position:new Vector3,halfWidth:new Vector3,halfHeight:new Vector3};break}return F[w.id]=D,D}}}function ShadowUniformsCache(){const F={};return{get:function(w){if(F[w.id]!==void 0)return F[w.id];let D;switch(w.type){case"DirectionalLight":D={shadowIntensity:1,shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new Vector2};break;case"SpotLight":D={shadowIntensity:1,shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new Vector2};break;case"PointLight":D={shadowIntensity:1,shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new Vector2,shadowCameraNear:1,shadowCameraFar:1e3};break}return F[w.id]=D,D}}}let nextVersion=0;function shadowCastingAndTexturingLightsFirst(F,w){return(w.castShadow?2:0)-(F.castShadow?2:0)+(w.map?1:0)-(F.map?1:0)}function WebGLLights(F){const w=new UniformsCache,D=ShadowUniformsCache(),O={version:0,hash:{directionalLength:-1,pointLength:-1,spotLength:-1,rectAreaLength:-1,hemiLength:-1,numDirectionalShadows:-1,numPointShadows:-1,numSpotShadows:-1,numSpotMaps:-1,numLightProbes:-1},ambient:[0,0,0],probe:[],directional:[],directionalShadow:[],directionalShadowMap:[],directionalShadowMatrix:[],spot:[],spotLightMap:[],spotShadow:[],spotShadowMap:[],spotLightMatrix:[],rectArea:[],rectAreaLTC1:null,rectAreaLTC2:null,point:[],pointShadow:[],pointShadowMap:[],pointShadowMatrix:[],hemi:[],numSpotLightShadowsWithMaps:0,numLightProbes:0};for(let Z=0;Z<9;Z++)O.probe.push(new Vector3);const U=new Vector3,G=new Matrix4,q=new Matrix4;function K(Z){let ie=0,Y=0,W=0;for(let Ee=0;Ee<9;Ee++)O.probe[Ee].set(0,0,0);let ne=0,se=0,le=0,ce=0,he=0,pe=0,me=0,be=0,ge=0,ve=0,Se=0;Z.sort(shadowCastingAndTexturingLightsFirst);for(let Ee=0,we=Z.length;Ee<we;Ee++){const Re=Z[Ee],Le=Re.color,Ne=Re.intensity,Oe=Re.distance,Pe=Re.shadow&&Re.shadow.map?Re.shadow.map.texture:null;if(Re.isAmbientLight)ie+=Le.r*Ne,Y+=Le.g*Ne,W+=Le.b*Ne;else if(Re.isLightProbe){for(let Ce=0;Ce<9;Ce++)O.probe[Ce].addScaledVector(Re.sh.coefficients[Ce],Ne);Se++}else if(Re.isDirectionalLight){const Ce=w.get(Re);if(Ce.color.copy(Re.color).multiplyScalar(Re.intensity),Re.castShadow){const Be=Re.shadow,ze=D.get(Re);ze.shadowIntensity=Be.intensity,ze.shadowBias=Be.bias,ze.shadowNormalBias=Be.normalBias,ze.shadowRadius=Be.radius,ze.shadowMapSize=Be.mapSize,O.directionalShadow[ne]=ze,O.directionalShadowMap[ne]=Pe,O.directionalShadowMatrix[ne]=Re.shadow.matrix,pe++}O.directional[ne]=Ce,ne++}else if(Re.isSpotLight){const Ce=w.get(Re);Ce.position.setFromMatrixPosition(Re.matrixWorld),Ce.color.copy(Le).multiplyScalar(Ne),Ce.distance=Oe,Ce.coneCos=Math.cos(Re.angle),Ce.penumbraCos=Math.cos(Re.angle*(1-Re.penumbra)),Ce.decay=Re.decay,O.spot[le]=Ce;const Be=Re.shadow;if(Re.map&&(O.spotLightMap[ge]=Re.map,ge++,Be.updateMatrices(Re),Re.castShadow&&ve++),O.spotLightMatrix[le]=Be.matrix,Re.castShadow){const ze=D.get(Re);ze.shadowIntensity=Be.intensity,ze.shadowBias=Be.bias,ze.shadowNormalBias=Be.normalBias,ze.shadowRadius=Be.radius,ze.shadowMapSize=Be.mapSize,O.spotShadow[le]=ze,O.spotShadowMap[le]=Pe,be++}le++}else if(Re.isRectAreaLight){const Ce=w.get(Re);Ce.color.copy(Le).multiplyScalar(Ne),Ce.halfWidth.set(Re.width*.5,0,0),Ce.halfHeight.set(0,Re.height*.5,0),O.rectArea[ce]=Ce,ce++}else if(Re.isPointLight){const Ce=w.get(Re);if(Ce.color.copy(Re.color).multiplyScalar(Re.intensity),Ce.distance=Re.distance,Ce.decay=Re.decay,Re.castShadow){const Be=Re.shadow,ze=D.get(Re);ze.shadowIntensity=Be.intensity,ze.shadowBias=Be.bias,ze.shadowNormalBias=Be.normalBias,ze.shadowRadius=Be.radius,ze.shadowMapSize=Be.mapSize,ze.shadowCameraNear=Be.camera.near,ze.shadowCameraFar=Be.camera.far,O.pointShadow[se]=ze,O.pointShadowMap[se]=Pe,O.pointShadowMatrix[se]=Re.shadow.matrix,me++}O.point[se]=Ce,se++}else if(Re.isHemisphereLight){const Ce=w.get(Re);Ce.skyColor.copy(Re.color).multiplyScalar(Ne),Ce.groundColor.copy(Re.groundColor).multiplyScalar(Ne),O.hemi[he]=Ce,he++}}ce>0&&(F.has("OES_texture_float_linear")===!0?(O.rectAreaLTC1=UniformsLib.LTC_FLOAT_1,O.rectAreaLTC2=UniformsLib.LTC_FLOAT_2):(O.rectAreaLTC1=UniformsLib.LTC_HALF_1,O.rectAreaLTC2=UniformsLib.LTC_HALF_2)),O.ambient[0]=ie,O.ambient[1]=Y,O.ambient[2]=W;const Me=O.hash;(Me.directionalLength!==ne||Me.pointLength!==se||Me.spotLength!==le||Me.rectAreaLength!==ce||Me.hemiLength!==he||Me.numDirectionalShadows!==pe||Me.numPointShadows!==me||Me.numSpotShadows!==be||Me.numSpotMaps!==ge||Me.numLightProbes!==Se)&&(O.directional.length=ne,O.spot.length=le,O.rectArea.length=ce,O.point.length=se,O.hemi.length=he,O.directionalShadow.length=pe,O.directionalShadowMap.length=pe,O.pointShadow.length=me,O.pointShadowMap.length=me,O.spotShadow.length=be,O.spotShadowMap.length=be,O.directionalShadowMatrix.length=pe,O.pointShadowMatrix.length=me,O.spotLightMatrix.length=be+ge-ve,O.spotLightMap.length=ge,O.numSpotLightShadowsWithMaps=ve,O.numLightProbes=Se,Me.directionalLength=ne,Me.pointLength=se,Me.spotLength=le,Me.rectAreaLength=ce,Me.hemiLength=he,Me.numDirectionalShadows=pe,Me.numPointShadows=me,Me.numSpotShadows=be,Me.numSpotMaps=ge,Me.numLightProbes=Se,O.version=nextVersion++)}function ee(Z,ie){let Y=0,W=0,ne=0,se=0,le=0;const ce=ie.matrixWorldInverse;for(let he=0,pe=Z.length;he<pe;he++){const me=Z[he];if(me.isDirectionalLight){const be=O.directional[Y];be.direction.setFromMatrixPosition(me.matrixWorld),U.setFromMatrixPosition(me.target.matrixWorld),be.direction.sub(U),be.direction.transformDirection(ce),Y++}else if(me.isSpotLight){const be=O.spot[ne];be.position.setFromMatrixPosition(me.matrixWorld),be.position.applyMatrix4(ce),be.direction.setFromMatrixPosition(me.matrixWorld),U.setFromMatrixPosition(me.target.matrixWorld),be.direction.sub(U),be.direction.transformDirection(ce),ne++}else if(me.isRectAreaLight){const be=O.rectArea[se];be.position.setFromMatrixPosition(me.matrixWorld),be.position.applyMatrix4(ce),q.identity(),G.copy(me.matrixWorld),G.premultiply(ce),q.extractRotation(G),be.halfWidth.set(me.width*.5,0,0),be.halfHeight.set(0,me.height*.5,0),be.halfWidth.applyMatrix4(q),be.halfHeight.applyMatrix4(q),se++}else if(me.isPointLight){const be=O.point[W];be.position.setFromMatrixPosition(me.matrixWorld),be.position.applyMatrix4(ce),W++}else if(me.isHemisphereLight){const be=O.hemi[le];be.direction.setFromMatrixPosition(me.matrixWorld),be.direction.transformDirection(ce),le++}}}return{setup:K,setupView:ee,state:O}}function WebGLRenderState(F){const w=new WebGLLights(F),D=[],O=[];function U(ie){Z.camera=ie,D.length=0,O.length=0}function G(ie){D.push(ie)}function q(ie){O.push(ie)}function K(){w.setup(D)}function ee(ie){w.setupView(D,ie)}const Z={lightsArray:D,shadowsArray:O,camera:null,lights:w,transmissionRenderTarget:{}};return{init:U,state:Z,setupLights:K,setupLightsView:ee,pushLight:G,pushShadow:q}}function WebGLRenderStates(F){let w=new WeakMap;function D(U,G=0){const q=w.get(U);let K;return q===void 0?(K=new WebGLRenderState(F),w.set(U,[K])):G>=q.length?(K=new WebGLRenderState(F),q.push(K)):K=q[G],K}function O(){w=new WeakMap}return{get:D,dispose:O}}const vertex=`void main() {
	gl_Position = vec4( position, 1.0 );
}`,fragment=`uniform sampler2D shadow_pass;
uniform vec2 resolution;
uniform float radius;
#include <packing>
void main() {
	const float samples = float( VSM_SAMPLES );
	float mean = 0.0;
	float squared_mean = 0.0;
	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );
	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;
	for ( float i = 0.0; i < samples; i ++ ) {
		float uvOffset = uvStart + i * uvStride;
		#ifdef HORIZONTAL_PASS
			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );
			mean += distribution.x;
			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;
		#else
			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );
			mean += depth;
			squared_mean += depth * depth;
		#endif
	}
	mean = mean / samples;
	squared_mean = squared_mean / samples;
	float std_dev = sqrt( squared_mean - mean * mean );
	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );
}`;function WebGLShadowMap(F,w,D){let O=new Frustum;const U=new Vector2,G=new Vector2,q=new Vector4,K=new MeshDepthMaterial({depthPacking:RGBADepthPacking}),ee=new MeshDistanceMaterial,Z={},ie=D.maxTextureSize,Y={[FrontSide]:BackSide,[BackSide]:FrontSide,[DoubleSide]:DoubleSide},W=new ShaderMaterial({defines:{VSM_SAMPLES:8},uniforms:{shadow_pass:{value:null},resolution:{value:new Vector2},radius:{value:4}},vertexShader:vertex,fragmentShader:fragment}),ne=W.clone();ne.defines.HORIZONTAL_PASS=1;const se=new BufferGeometry;se.setAttribute("position",new BufferAttribute(new Float32Array([-1,-1,.5,3,-1,.5,-1,3,.5]),3));const le=new Mesh(se,W),ce=this;this.enabled=!1,this.autoUpdate=!0,this.needsUpdate=!1,this.type=PCFShadowMap;let he=this.type;this.render=function(ve,Se,Me){if(ce.enabled===!1||ce.autoUpdate===!1&&ce.needsUpdate===!1||ve.length===0)return;const Ee=F.getRenderTarget(),we=F.getActiveCubeFace(),Re=F.getActiveMipmapLevel(),Le=F.state;Le.setBlending(NoBlending),Le.buffers.depth.getReversed()===!0?Le.buffers.color.setClear(0,0,0,0):Le.buffers.color.setClear(1,1,1,1),Le.buffers.depth.setTest(!0),Le.setScissorTest(!1);const Ne=he!==VSMShadowMap&&this.type===VSMShadowMap,Oe=he===VSMShadowMap&&this.type!==VSMShadowMap;for(let Pe=0,Ce=ve.length;Pe<Ce;Pe++){const Be=ve[Pe],ze=Be.shadow;if(ze===void 0){warn("WebGLShadowMap:",Be,"has no shadow.");continue}if(ze.autoUpdate===!1&&ze.needsUpdate===!1)continue;U.copy(ze.mapSize);const Xe=ze.getFrameExtents();if(U.multiply(Xe),G.copy(ze.mapSize),(U.x>ie||U.y>ie)&&(U.x>ie&&(G.x=Math.floor(ie/Xe.x),U.x=G.x*Xe.x,ze.mapSize.x=G.x),U.y>ie&&(G.y=Math.floor(ie/Xe.y),U.y=G.y*Xe.y,ze.mapSize.y=G.y)),ze.map===null||Ne===!0||Oe===!0){const ke=this.type!==VSMShadowMap?{minFilter:NearestFilter,magFilter:NearestFilter}:{};ze.map!==null&&ze.map.dispose(),ze.map=new WebGLRenderTarget(U.x,U.y,ke),ze.map.texture.name=Be.name+".shadowMap",ze.camera.updateProjectionMatrix()}F.setRenderTarget(ze.map),F.clear();const lt=ze.getViewportCount();for(let ke=0;ke<lt;ke++){const rt=ze.getViewport(ke);q.set(G.x*rt.x,G.y*rt.y,G.x*rt.z,G.y*rt.w),Le.viewport(q),ze.updateMatrices(Be,ke),O=ze.getFrustum(),be(Se,Me,ze.camera,Be,this.type)}ze.isPointLightShadow!==!0&&this.type===VSMShadowMap&&pe(ze,Me),ze.needsUpdate=!1}he=this.type,ce.needsUpdate=!1,F.setRenderTarget(Ee,we,Re)};function pe(ve,Se){const Me=w.update(le);W.defines.VSM_SAMPLES!==ve.blurSamples&&(W.defines.VSM_SAMPLES=ve.blurSamples,ne.defines.VSM_SAMPLES=ve.blurSamples,W.needsUpdate=!0,ne.needsUpdate=!0),ve.mapPass===null&&(ve.mapPass=new WebGLRenderTarget(U.x,U.y)),W.uniforms.shadow_pass.value=ve.map.texture,W.uniforms.resolution.value=ve.mapSize,W.uniforms.radius.value=ve.radius,F.setRenderTarget(ve.mapPass),F.clear(),F.renderBufferDirect(Se,null,Me,W,le,null),ne.uniforms.shadow_pass.value=ve.mapPass.texture,ne.uniforms.resolution.value=ve.mapSize,ne.uniforms.radius.value=ve.radius,F.setRenderTarget(ve.map),F.clear(),F.renderBufferDirect(Se,null,Me,ne,le,null)}function me(ve,Se,Me,Ee){let we=null;const Re=Me.isPointLight===!0?ve.customDistanceMaterial:ve.customDepthMaterial;if(Re!==void 0)we=Re;else if(we=Me.isPointLight===!0?ee:K,F.localClippingEnabled&&Se.clipShadows===!0&&Array.isArray(Se.clippingPlanes)&&Se.clippingPlanes.length!==0||Se.displacementMap&&Se.displacementScale!==0||Se.alphaMap&&Se.alphaTest>0||Se.map&&Se.alphaTest>0||Se.alphaToCoverage===!0){const Le=we.uuid,Ne=Se.uuid;let Oe=Z[Le];Oe===void 0&&(Oe={},Z[Le]=Oe);let Pe=Oe[Ne];Pe===void 0&&(Pe=we.clone(),Oe[Ne]=Pe,Se.addEventListener("dispose",ge)),we=Pe}if(we.visible=Se.visible,we.wireframe=Se.wireframe,Ee===VSMShadowMap?we.side=Se.shadowSide!==null?Se.shadowSide:Se.side:we.side=Se.shadowSide!==null?Se.shadowSide:Y[Se.side],we.alphaMap=Se.alphaMap,we.alphaTest=Se.alphaToCoverage===!0?.5:Se.alphaTest,we.map=Se.map,we.clipShadows=Se.clipShadows,we.clippingPlanes=Se.clippingPlanes,we.clipIntersection=Se.clipIntersection,we.displacementMap=Se.displacementMap,we.displacementScale=Se.displacementScale,we.displacementBias=Se.displacementBias,we.wireframeLinewidth=Se.wireframeLinewidth,we.linewidth=Se.linewidth,Me.isPointLight===!0&&we.isMeshDistanceMaterial===!0){const Le=F.properties.get(we);Le.light=Me}return we}function be(ve,Se,Me,Ee,we){if(ve.visible===!1)return;if(ve.layers.test(Se.layers)&&(ve.isMesh||ve.isLine||ve.isPoints)&&(ve.castShadow||ve.receiveShadow&&we===VSMShadowMap)&&(!ve.frustumCulled||O.intersectsObject(ve))){ve.modelViewMatrix.multiplyMatrices(Me.matrixWorldInverse,ve.matrixWorld);const Ne=w.update(ve),Oe=ve.material;if(Array.isArray(Oe)){const Pe=Ne.groups;for(let Ce=0,Be=Pe.length;Ce<Be;Ce++){const ze=Pe[Ce],Xe=Oe[ze.materialIndex];if(Xe&&Xe.visible){const lt=me(ve,Xe,Ee,we);ve.onBeforeShadow(F,ve,Se,Me,Ne,lt,ze),F.renderBufferDirect(Me,null,Ne,lt,ve,ze),ve.onAfterShadow(F,ve,Se,Me,Ne,lt,ze)}}}else if(Oe.visible){const Pe=me(ve,Oe,Ee,we);ve.onBeforeShadow(F,ve,Se,Me,Ne,Pe,null),F.renderBufferDirect(Me,null,Ne,Pe,ve,null),ve.onAfterShadow(F,ve,Se,Me,Ne,Pe,null)}}const Le=ve.children;for(let Ne=0,Oe=Le.length;Ne<Oe;Ne++)be(Le[Ne],Se,Me,Ee,we)}function ge(ve){ve.target.removeEventListener("dispose",ge);for(const Me in Z){const Ee=Z[Me],we=ve.target.uuid;we in Ee&&(Ee[we].dispose(),delete Ee[we])}}}const reversedFuncs={[NeverDepth]:AlwaysDepth,[LessDepth]:GreaterDepth,[EqualDepth]:NotEqualDepth,[LessEqualDepth]:GreaterEqualDepth,[AlwaysDepth]:NeverDepth,[GreaterDepth]:LessDepth,[NotEqualDepth]:EqualDepth,[GreaterEqualDepth]:LessEqualDepth};function WebGLState(F,w){function D(){let nt=!1;const dn=new Vector4;let tn=null;const Zt=new Vector4(0,0,0,0);return{setMask:function(Bt){tn!==Bt&&!nt&&(F.colorMask(Bt,Bt,Bt,Bt),tn=Bt)},setLocked:function(Bt){nt=Bt},setClear:function(Bt,wt,Qt,Yn,Ai){Ai===!0&&(Bt*=Yn,wt*=Yn,Qt*=Yn),dn.set(Bt,wt,Qt,Yn),Zt.equals(dn)===!1&&(F.clearColor(Bt,wt,Qt,Yn),Zt.copy(dn))},reset:function(){nt=!1,tn=null,Zt.set(-1,0,0,0)}}}function O(){let nt=!1,dn=!1,tn=null,Zt=null,Bt=null;return{setReversed:function(wt){if(dn!==wt){const Qt=w.get("EXT_clip_control");wt?Qt.clipControlEXT(Qt.LOWER_LEFT_EXT,Qt.ZERO_TO_ONE_EXT):Qt.clipControlEXT(Qt.LOWER_LEFT_EXT,Qt.NEGATIVE_ONE_TO_ONE_EXT),dn=wt;const Yn=Bt;Bt=null,this.setClear(Yn)}},getReversed:function(){return dn},setTest:function(wt){wt?bt(F.DEPTH_TEST):Xt(F.DEPTH_TEST)},setMask:function(wt){tn!==wt&&!nt&&(F.depthMask(wt),tn=wt)},setFunc:function(wt){if(dn&&(wt=reversedFuncs[wt]),Zt!==wt){switch(wt){case NeverDepth:F.depthFunc(F.NEVER);break;case AlwaysDepth:F.depthFunc(F.ALWAYS);break;case LessDepth:F.depthFunc(F.LESS);break;case LessEqualDepth:F.depthFunc(F.LEQUAL);break;case EqualDepth:F.depthFunc(F.EQUAL);break;case GreaterEqualDepth:F.depthFunc(F.GEQUAL);break;case GreaterDepth:F.depthFunc(F.GREATER);break;case NotEqualDepth:F.depthFunc(F.NOTEQUAL);break;default:F.depthFunc(F.LEQUAL)}Zt=wt}},setLocked:function(wt){nt=wt},setClear:function(wt){Bt!==wt&&(dn&&(wt=1-wt),F.clearDepth(wt),Bt=wt)},reset:function(){nt=!1,tn=null,Zt=null,Bt=null,dn=!1}}}function U(){let nt=!1,dn=null,tn=null,Zt=null,Bt=null,wt=null,Qt=null,Yn=null,Ai=null;return{setTest:function(hi){nt||(hi?bt(F.STENCIL_TEST):Xt(F.STENCIL_TEST))},setMask:function(hi){dn!==hi&&!nt&&(F.stencilMask(hi),dn=hi)},setFunc:function(hi,Xi,lr){(tn!==hi||Zt!==Xi||Bt!==lr)&&(F.stencilFunc(hi,Xi,lr),tn=hi,Zt=Xi,Bt=lr)},setOp:function(hi,Xi,lr){(wt!==hi||Qt!==Xi||Yn!==lr)&&(F.stencilOp(hi,Xi,lr),wt=hi,Qt=Xi,Yn=lr)},setLocked:function(hi){nt=hi},setClear:function(hi){Ai!==hi&&(F.clearStencil(hi),Ai=hi)},reset:function(){nt=!1,dn=null,tn=null,Zt=null,Bt=null,wt=null,Qt=null,Yn=null,Ai=null}}}const G=new D,q=new O,K=new U,ee=new WeakMap,Z=new WeakMap;let ie={},Y={},W=new WeakMap,ne=[],se=null,le=!1,ce=null,he=null,pe=null,me=null,be=null,ge=null,ve=null,Se=new Color(0,0,0),Me=0,Ee=!1,we=null,Re=null,Le=null,Ne=null,Oe=null;const Pe=F.getParameter(F.MAX_COMBINED_TEXTURE_IMAGE_UNITS);let Ce=!1,Be=0;const ze=F.getParameter(F.VERSION);ze.indexOf("WebGL")!==-1?(Be=parseFloat(/^WebGL (\d)/.exec(ze)[1]),Ce=Be>=1):ze.indexOf("OpenGL ES")!==-1&&(Be=parseFloat(/^OpenGL ES (\d)/.exec(ze)[1]),Ce=Be>=2);let Xe=null,lt={};const ke=F.getParameter(F.SCISSOR_BOX),rt=F.getParameter(F.VIEWPORT),St=new Vector4().fromArray(ke),Lt=new Vector4().fromArray(rt);function $t(nt,dn,tn,Zt){const Bt=new Uint8Array(4),wt=F.createTexture();F.bindTexture(nt,wt),F.texParameteri(nt,F.TEXTURE_MIN_FILTER,F.NEAREST),F.texParameteri(nt,F.TEXTURE_MAG_FILTER,F.NEAREST);for(let Qt=0;Qt<tn;Qt++)nt===F.TEXTURE_3D||nt===F.TEXTURE_2D_ARRAY?F.texImage3D(dn,0,F.RGBA,1,1,Zt,0,F.RGBA,F.UNSIGNED_BYTE,Bt):F.texImage2D(dn+Qt,0,F.RGBA,1,1,0,F.RGBA,F.UNSIGNED_BYTE,Bt);return wt}const mt={};mt[F.TEXTURE_2D]=$t(F.TEXTURE_2D,F.TEXTURE_2D,1),mt[F.TEXTURE_CUBE_MAP]=$t(F.TEXTURE_CUBE_MAP,F.TEXTURE_CUBE_MAP_POSITIVE_X,6),mt[F.TEXTURE_2D_ARRAY]=$t(F.TEXTURE_2D_ARRAY,F.TEXTURE_2D_ARRAY,1,1),mt[F.TEXTURE_3D]=$t(F.TEXTURE_3D,F.TEXTURE_3D,1,1),G.setClear(0,0,0,1),q.setClear(1),K.setClear(0),bt(F.DEPTH_TEST),q.setFunc(LessEqualDepth),Gn(!1),qn(CullFaceBack),bt(F.CULL_FACE),In(NoBlending);function bt(nt){ie[nt]!==!0&&(F.enable(nt),ie[nt]=!0)}function Xt(nt){ie[nt]!==!1&&(F.disable(nt),ie[nt]=!1)}function hn(nt,dn){return Y[nt]!==dn?(F.bindFramebuffer(nt,dn),Y[nt]=dn,nt===F.DRAW_FRAMEBUFFER&&(Y[F.FRAMEBUFFER]=dn),nt===F.FRAMEBUFFER&&(Y[F.DRAW_FRAMEBUFFER]=dn),!0):!1}function Jt(nt,dn){let tn=ne,Zt=!1;if(nt){tn=W.get(dn),tn===void 0&&(tn=[],W.set(dn,tn));const Bt=nt.textures;if(tn.length!==Bt.length||tn[0]!==F.COLOR_ATTACHMENT0){for(let wt=0,Qt=Bt.length;wt<Qt;wt++)tn[wt]=F.COLOR_ATTACHMENT0+wt;tn.length=Bt.length,Zt=!0}}else tn[0]!==F.BACK&&(tn[0]=F.BACK,Zt=!0);Zt&&F.drawBuffers(tn)}function Mn(nt){return se!==nt?(F.useProgram(nt),se=nt,!0):!1}const Zn={[AddEquation]:F.FUNC_ADD,[SubtractEquation]:F.FUNC_SUBTRACT,[ReverseSubtractEquation]:F.FUNC_REVERSE_SUBTRACT};Zn[MinEquation]=F.MIN,Zn[MaxEquation]=F.MAX;const vn={[ZeroFactor]:F.ZERO,[OneFactor]:F.ONE,[SrcColorFactor]:F.SRC_COLOR,[SrcAlphaFactor]:F.SRC_ALPHA,[SrcAlphaSaturateFactor]:F.SRC_ALPHA_SATURATE,[DstColorFactor]:F.DST_COLOR,[DstAlphaFactor]:F.DST_ALPHA,[OneMinusSrcColorFactor]:F.ONE_MINUS_SRC_COLOR,[OneMinusSrcAlphaFactor]:F.ONE_MINUS_SRC_ALPHA,[OneMinusDstColorFactor]:F.ONE_MINUS_DST_COLOR,[OneMinusDstAlphaFactor]:F.ONE_MINUS_DST_ALPHA,[ConstantColorFactor]:F.CONSTANT_COLOR,[OneMinusConstantColorFactor]:F.ONE_MINUS_CONSTANT_COLOR,[ConstantAlphaFactor]:F.CONSTANT_ALPHA,[OneMinusConstantAlphaFactor]:F.ONE_MINUS_CONSTANT_ALPHA};function In(nt,dn,tn,Zt,Bt,wt,Qt,Yn,Ai,hi){if(nt===NoBlending){le===!0&&(Xt(F.BLEND),le=!1);return}if(le===!1&&(bt(F.BLEND),le=!0),nt!==CustomBlending){if(nt!==ce||hi!==Ee){if((he!==AddEquation||be!==AddEquation)&&(F.blendEquation(F.FUNC_ADD),he=AddEquation,be=AddEquation),hi)switch(nt){case NormalBlending:F.blendFuncSeparate(F.ONE,F.ONE_MINUS_SRC_ALPHA,F.ONE,F.ONE_MINUS_SRC_ALPHA);break;case AdditiveBlending:F.blendFunc(F.ONE,F.ONE);break;case SubtractiveBlending:F.blendFuncSeparate(F.ZERO,F.ONE_MINUS_SRC_COLOR,F.ZERO,F.ONE);break;case MultiplyBlending:F.blendFuncSeparate(F.DST_COLOR,F.ONE_MINUS_SRC_ALPHA,F.ZERO,F.ONE);break;default:error("WebGLState: Invalid blending: ",nt);break}else switch(nt){case NormalBlending:F.blendFuncSeparate(F.SRC_ALPHA,F.ONE_MINUS_SRC_ALPHA,F.ONE,F.ONE_MINUS_SRC_ALPHA);break;case AdditiveBlending:F.blendFuncSeparate(F.SRC_ALPHA,F.ONE,F.ONE,F.ONE);break;case SubtractiveBlending:error("WebGLState: SubtractiveBlending requires material.premultipliedAlpha = true");break;case MultiplyBlending:error("WebGLState: MultiplyBlending requires material.premultipliedAlpha = true");break;default:error("WebGLState: Invalid blending: ",nt);break}pe=null,me=null,ge=null,ve=null,Se.set(0,0,0),Me=0,ce=nt,Ee=hi}return}Bt=Bt||dn,wt=wt||tn,Qt=Qt||Zt,(dn!==he||Bt!==be)&&(F.blendEquationSeparate(Zn[dn],Zn[Bt]),he=dn,be=Bt),(tn!==pe||Zt!==me||wt!==ge||Qt!==ve)&&(F.blendFuncSeparate(vn[tn],vn[Zt],vn[wt],vn[Qt]),pe=tn,me=Zt,ge=wt,ve=Qt),(Yn.equals(Se)===!1||Ai!==Me)&&(F.blendColor(Yn.r,Yn.g,Yn.b,Ai),Se.copy(Yn),Me=Ai),ce=nt,Ee=!1}function st(nt,dn){nt.side===DoubleSide?Xt(F.CULL_FACE):bt(F.CULL_FACE);let tn=nt.side===BackSide;dn&&(tn=!tn),Gn(tn),nt.blending===NormalBlending&&nt.transparent===!1?In(NoBlending):In(nt.blending,nt.blendEquation,nt.blendSrc,nt.blendDst,nt.blendEquationAlpha,nt.blendSrcAlpha,nt.blendDstAlpha,nt.blendColor,nt.blendAlpha,nt.premultipliedAlpha),q.setFunc(nt.depthFunc),q.setTest(nt.depthTest),q.setMask(nt.depthWrite),G.setMask(nt.colorWrite);const Zt=nt.stencilWrite;K.setTest(Zt),Zt&&(K.setMask(nt.stencilWriteMask),K.setFunc(nt.stencilFunc,nt.stencilRef,nt.stencilFuncMask),K.setOp(nt.stencilFail,nt.stencilZFail,nt.stencilZPass)),yn(nt.polygonOffset,nt.polygonOffsetFactor,nt.polygonOffsetUnits),nt.alphaToCoverage===!0?bt(F.SAMPLE_ALPHA_TO_COVERAGE):Xt(F.SAMPLE_ALPHA_TO_COVERAGE)}function Gn(nt){we!==nt&&(nt?F.frontFace(F.CW):F.frontFace(F.CCW),we=nt)}function qn(nt){nt!==CullFaceNone?(bt(F.CULL_FACE),nt!==Re&&(nt===CullFaceBack?F.cullFace(F.BACK):nt===CullFaceFront?F.cullFace(F.FRONT):F.cullFace(F.FRONT_AND_BACK))):Xt(F.CULL_FACE),Re=nt}function ai(nt){nt!==Le&&(Ce&&F.lineWidth(nt),Le=nt)}function yn(nt,dn,tn){nt?(bt(F.POLYGON_OFFSET_FILL),(Ne!==dn||Oe!==tn)&&(F.polygonOffset(dn,tn),Ne=dn,Oe=tn)):Xt(F.POLYGON_OFFSET_FILL)}function li(nt){nt?bt(F.SCISSOR_TEST):Xt(F.SCISSOR_TEST)}function Tn(nt){nt===void 0&&(nt=F.TEXTURE0+Pe-1),Xe!==nt&&(F.activeTexture(nt),Xe=nt)}function En(nt,dn,tn){tn===void 0&&(Xe===null?tn=F.TEXTURE0+Pe-1:tn=Xe);let Zt=lt[tn];Zt===void 0&&(Zt={type:void 0,texture:void 0},lt[tn]=Zt),(Zt.type!==nt||Zt.texture!==dn)&&(Xe!==tn&&(F.activeTexture(tn),Xe=tn),F.bindTexture(nt,dn||mt[nt]),Zt.type=nt,Zt.texture=dn)}function Ke(){const nt=lt[Xe];nt!==void 0&&nt.type!==void 0&&(F.bindTexture(nt.type,null),nt.type=void 0,nt.texture=void 0)}function Fe(){try{F.compressedTexImage2D(...arguments)}catch(nt){nt("WebGLState:",nt)}}function pt(){try{F.compressedTexImage3D(...arguments)}catch(nt){nt("WebGLState:",nt)}}function zt(){try{F.texSubImage2D(...arguments)}catch(nt){nt("WebGLState:",nt)}}function qt(){try{F.texSubImage3D(...arguments)}catch(nt){nt("WebGLState:",nt)}}function Nt(){try{F.compressedTexSubImage2D(...arguments)}catch(nt){nt("WebGLState:",nt)}}function Rn(){try{F.compressedTexSubImage3D(...arguments)}catch(nt){nt("WebGLState:",nt)}}function fn(){try{F.texStorage2D(...arguments)}catch(nt){nt("WebGLState:",nt)}}function Nn(){try{F.texStorage3D(...arguments)}catch(nt){nt("WebGLState:",nt)}}function An(){try{F.texImage2D(...arguments)}catch(nt){nt("WebGLState:",nt)}}function Wt(){try{F.texImage3D(...arguments)}catch(nt){nt("WebGLState:",nt)}}function Dt(nt){St.equals(nt)===!1&&(F.scissor(nt.x,nt.y,nt.z,nt.w),St.copy(nt))}function Bn(nt){Lt.equals(nt)===!1&&(F.viewport(nt.x,nt.y,nt.z,nt.w),Lt.copy(nt))}function Sn(nt,dn){let tn=Z.get(dn);tn===void 0&&(tn=new WeakMap,Z.set(dn,tn));let Zt=tn.get(nt);Zt===void 0&&(Zt=F.getUniformBlockIndex(dn,nt.name),tn.set(nt,Zt))}function bn(nt,dn){const Zt=Z.get(dn).get(nt);ee.get(dn)!==Zt&&(F.uniformBlockBinding(dn,Zt,nt.__bindingPointIndex),ee.set(dn,Zt))}function kn(){F.disable(F.BLEND),F.disable(F.CULL_FACE),F.disable(F.DEPTH_TEST),F.disable(F.POLYGON_OFFSET_FILL),F.disable(F.SCISSOR_TEST),F.disable(F.STENCIL_TEST),F.disable(F.SAMPLE_ALPHA_TO_COVERAGE),F.blendEquation(F.FUNC_ADD),F.blendFunc(F.ONE,F.ZERO),F.blendFuncSeparate(F.ONE,F.ZERO,F.ONE,F.ZERO),F.blendColor(0,0,0,0),F.colorMask(!0,!0,!0,!0),F.clearColor(0,0,0,0),F.depthMask(!0),F.depthFunc(F.LESS),q.setReversed(!1),F.clearDepth(1),F.stencilMask(4294967295),F.stencilFunc(F.ALWAYS,0,4294967295),F.stencilOp(F.KEEP,F.KEEP,F.KEEP),F.clearStencil(0),F.cullFace(F.BACK),F.frontFace(F.CCW),F.polygonOffset(0,0),F.activeTexture(F.TEXTURE0),F.bindFramebuffer(F.FRAMEBUFFER,null),F.bindFramebuffer(F.DRAW_FRAMEBUFFER,null),F.bindFramebuffer(F.READ_FRAMEBUFFER,null),F.useProgram(null),F.lineWidth(1),F.scissor(0,0,F.canvas.width,F.canvas.height),F.viewport(0,0,F.canvas.width,F.canvas.height),ie={},Xe=null,lt={},Y={},W=new WeakMap,ne=[],se=null,le=!1,ce=null,he=null,pe=null,me=null,be=null,ge=null,ve=null,Se=new Color(0,0,0),Me=0,Ee=!1,we=null,Re=null,Le=null,Ne=null,Oe=null,St.set(0,0,F.canvas.width,F.canvas.height),Lt.set(0,0,F.canvas.width,F.canvas.height),G.reset(),q.reset(),K.reset()}return{buffers:{color:G,depth:q,stencil:K},enable:bt,disable:Xt,bindFramebuffer:hn,drawBuffers:Jt,useProgram:Mn,setBlending:In,setMaterial:st,setFlipSided:Gn,setCullFace:qn,setLineWidth:ai,setPolygonOffset:yn,setScissorTest:li,activeTexture:Tn,bindTexture:En,unbindTexture:Ke,compressedTexImage2D:Fe,compressedTexImage3D:pt,texImage2D:An,texImage3D:Wt,updateUBOMapping:Sn,uniformBlockBinding:bn,texStorage2D:fn,texStorage3D:Nn,texSubImage2D:zt,texSubImage3D:qt,compressedTexSubImage2D:Nt,compressedTexSubImage3D:Rn,scissor:Dt,viewport:Bn,reset:kn}}function WebGLTextures(F,w,D,O,U,G,q){const K=w.has("WEBGL_multisampled_render_to_texture")?w.get("WEBGL_multisampled_render_to_texture"):null,ee=typeof navigator>"u"?!1:/OculusBrowser/g.test(navigator.userAgent),Z=new Vector2,ie=new WeakMap;let Y;const W=new WeakMap;let ne=!1;try{ne=typeof OffscreenCanvas<"u"&&new OffscreenCanvas(1,1).getContext("2d")!==null}catch{}function se(Ke,Fe){return ne?new OffscreenCanvas(Ke,Fe):createElementNS("canvas")}function le(Ke,Fe,pt){let zt=1;const qt=En(Ke);if((qt.width>pt||qt.height>pt)&&(zt=pt/Math.max(qt.width,qt.height)),zt<1)if(typeof HTMLImageElement<"u"&&Ke instanceof HTMLImageElement||typeof HTMLCanvasElement<"u"&&Ke instanceof HTMLCanvasElement||typeof ImageBitmap<"u"&&Ke instanceof ImageBitmap||typeof VideoFrame<"u"&&Ke instanceof VideoFrame){const Nt=Math.floor(zt*qt.width),Rn=Math.floor(zt*qt.height);Y===void 0&&(Y=se(Nt,Rn));const fn=Fe?se(Nt,Rn):Y;return fn.width=Nt,fn.height=Rn,fn.getContext("2d").drawImage(Ke,0,0,Nt,Rn),warn("WebGLRenderer: Texture has been resized from ("+qt.width+"x"+qt.height+") to ("+Nt+"x"+Rn+")."),fn}else return"data"in Ke&&warn("WebGLRenderer: Image in DataTexture is too big ("+qt.width+"x"+qt.height+")."),Ke;return Ke}function ce(Ke){return Ke.generateMipmaps}function he(Ke){F.generateMipmap(Ke)}function pe(Ke){return Ke.isWebGLCubeRenderTarget?F.TEXTURE_CUBE_MAP:Ke.isWebGL3DRenderTarget?F.TEXTURE_3D:Ke.isWebGLArrayRenderTarget||Ke.isCompressedArrayTexture?F.TEXTURE_2D_ARRAY:F.TEXTURE_2D}function me(Ke,Fe,pt,zt,qt=!1){if(Ke!==null){if(F[Ke]!==void 0)return F[Ke];warn("WebGLRenderer: Attempt to use non-existing WebGL internal format '"+Ke+"'")}let Nt=Fe;if(Fe===F.RED&&(pt===F.FLOAT&&(Nt=F.R32F),pt===F.HALF_FLOAT&&(Nt=F.R16F),pt===F.UNSIGNED_BYTE&&(Nt=F.R8)),Fe===F.RED_INTEGER&&(pt===F.UNSIGNED_BYTE&&(Nt=F.R8UI),pt===F.UNSIGNED_SHORT&&(Nt=F.R16UI),pt===F.UNSIGNED_INT&&(Nt=F.R32UI),pt===F.BYTE&&(Nt=F.R8I),pt===F.SHORT&&(Nt=F.R16I),pt===F.INT&&(Nt=F.R32I)),Fe===F.RG&&(pt===F.FLOAT&&(Nt=F.RG32F),pt===F.HALF_FLOAT&&(Nt=F.RG16F),pt===F.UNSIGNED_BYTE&&(Nt=F.RG8)),Fe===F.RG_INTEGER&&(pt===F.UNSIGNED_BYTE&&(Nt=F.RG8UI),pt===F.UNSIGNED_SHORT&&(Nt=F.RG16UI),pt===F.UNSIGNED_INT&&(Nt=F.RG32UI),pt===F.BYTE&&(Nt=F.RG8I),pt===F.SHORT&&(Nt=F.RG16I),pt===F.INT&&(Nt=F.RG32I)),Fe===F.RGB_INTEGER&&(pt===F.UNSIGNED_BYTE&&(Nt=F.RGB8UI),pt===F.UNSIGNED_SHORT&&(Nt=F.RGB16UI),pt===F.UNSIGNED_INT&&(Nt=F.RGB32UI),pt===F.BYTE&&(Nt=F.RGB8I),pt===F.SHORT&&(Nt=F.RGB16I),pt===F.INT&&(Nt=F.RGB32I)),Fe===F.RGBA_INTEGER&&(pt===F.UNSIGNED_BYTE&&(Nt=F.RGBA8UI),pt===F.UNSIGNED_SHORT&&(Nt=F.RGBA16UI),pt===F.UNSIGNED_INT&&(Nt=F.RGBA32UI),pt===F.BYTE&&(Nt=F.RGBA8I),pt===F.SHORT&&(Nt=F.RGBA16I),pt===F.INT&&(Nt=F.RGBA32I)),Fe===F.RGB&&(pt===F.UNSIGNED_INT_5_9_9_9_REV&&(Nt=F.RGB9_E5),pt===F.UNSIGNED_INT_10F_11F_11F_REV&&(Nt=F.R11F_G11F_B10F)),Fe===F.RGBA){const Rn=qt?LinearTransfer:ColorManagement.getTransfer(zt);pt===F.FLOAT&&(Nt=F.RGBA32F),pt===F.HALF_FLOAT&&(Nt=F.RGBA16F),pt===F.UNSIGNED_BYTE&&(Nt=Rn===SRGBTransfer?F.SRGB8_ALPHA8:F.RGBA8),pt===F.UNSIGNED_SHORT_4_4_4_4&&(Nt=F.RGBA4),pt===F.UNSIGNED_SHORT_5_5_5_1&&(Nt=F.RGB5_A1)}return(Nt===F.R16F||Nt===F.R32F||Nt===F.RG16F||Nt===F.RG32F||Nt===F.RGBA16F||Nt===F.RGBA32F)&&w.get("EXT_color_buffer_float"),Nt}function be(Ke,Fe){let pt;return Ke?Fe===null||Fe===UnsignedIntType||Fe===UnsignedInt248Type?pt=F.DEPTH24_STENCIL8:Fe===FloatType?pt=F.DEPTH32F_STENCIL8:Fe===UnsignedShortType&&(pt=F.DEPTH24_STENCIL8,warn("DepthTexture: 16 bit depth attachment is not supported with stencil. Using 24-bit attachment.")):Fe===null||Fe===UnsignedIntType||Fe===UnsignedInt248Type?pt=F.DEPTH_COMPONENT24:Fe===FloatType?pt=F.DEPTH_COMPONENT32F:Fe===UnsignedShortType&&(pt=F.DEPTH_COMPONENT16),pt}function ge(Ke,Fe){return ce(Ke)===!0||Ke.isFramebufferTexture&&Ke.minFilter!==NearestFilter&&Ke.minFilter!==LinearFilter?Math.log2(Math.max(Fe.width,Fe.height))+1:Ke.mipmaps!==void 0&&Ke.mipmaps.length>0?Ke.mipmaps.length:Ke.isCompressedTexture&&Array.isArray(Ke.image)?Fe.mipmaps.length:1}function ve(Ke){const Fe=Ke.target;Fe.removeEventListener("dispose",ve),Me(Fe),Fe.isVideoTexture&&ie.delete(Fe)}function Se(Ke){const Fe=Ke.target;Fe.removeEventListener("dispose",Se),we(Fe)}function Me(Ke){const Fe=O.get(Ke);if(Fe.__webglInit===void 0)return;const pt=Ke.source,zt=W.get(pt);if(zt){const qt=zt[Fe.__cacheKey];qt.usedTimes--,qt.usedTimes===0&&Ee(Ke),Object.keys(zt).length===0&&W.delete(pt)}O.remove(Ke)}function Ee(Ke){const Fe=O.get(Ke);F.deleteTexture(Fe.__webglTexture);const pt=Ke.source,zt=W.get(pt);delete zt[Fe.__cacheKey],q.memory.textures--}function we(Ke){const Fe=O.get(Ke);if(Ke.depthTexture&&(Ke.depthTexture.dispose(),O.remove(Ke.depthTexture)),Ke.isWebGLCubeRenderTarget)for(let zt=0;zt<6;zt++){if(Array.isArray(Fe.__webglFramebuffer[zt]))for(let qt=0;qt<Fe.__webglFramebuffer[zt].length;qt++)F.deleteFramebuffer(Fe.__webglFramebuffer[zt][qt]);else F.deleteFramebuffer(Fe.__webglFramebuffer[zt]);Fe.__webglDepthbuffer&&F.deleteRenderbuffer(Fe.__webglDepthbuffer[zt])}else{if(Array.isArray(Fe.__webglFramebuffer))for(let zt=0;zt<Fe.__webglFramebuffer.length;zt++)F.deleteFramebuffer(Fe.__webglFramebuffer[zt]);else F.deleteFramebuffer(Fe.__webglFramebuffer);if(Fe.__webglDepthbuffer&&F.deleteRenderbuffer(Fe.__webglDepthbuffer),Fe.__webglMultisampledFramebuffer&&F.deleteFramebuffer(Fe.__webglMultisampledFramebuffer),Fe.__webglColorRenderbuffer)for(let zt=0;zt<Fe.__webglColorRenderbuffer.length;zt++)Fe.__webglColorRenderbuffer[zt]&&F.deleteRenderbuffer(Fe.__webglColorRenderbuffer[zt]);Fe.__webglDepthRenderbuffer&&F.deleteRenderbuffer(Fe.__webglDepthRenderbuffer)}const pt=Ke.textures;for(let zt=0,qt=pt.length;zt<qt;zt++){const Nt=O.get(pt[zt]);Nt.__webglTexture&&(F.deleteTexture(Nt.__webglTexture),q.memory.textures--),O.remove(pt[zt])}O.remove(Ke)}let Re=0;function Le(){Re=0}function Ne(){const Ke=Re;return Ke>=U.maxTextures&&warn("WebGLTextures: Trying to use "+Ke+" texture units while this GPU supports only "+U.maxTextures),Re+=1,Ke}function Oe(Ke){const Fe=[];return Fe.push(Ke.wrapS),Fe.push(Ke.wrapT),Fe.push(Ke.wrapR||0),Fe.push(Ke.magFilter),Fe.push(Ke.minFilter),Fe.push(Ke.anisotropy),Fe.push(Ke.internalFormat),Fe.push(Ke.format),Fe.push(Ke.type),Fe.push(Ke.generateMipmaps),Fe.push(Ke.premultiplyAlpha),Fe.push(Ke.flipY),Fe.push(Ke.unpackAlignment),Fe.push(Ke.colorSpace),Fe.join()}function Pe(Ke,Fe){const pt=O.get(Ke);if(Ke.isVideoTexture&&li(Ke),Ke.isRenderTargetTexture===!1&&Ke.isExternalTexture!==!0&&Ke.version>0&&pt.__version!==Ke.version){const zt=Ke.image;if(zt===null)warn("WebGLRenderer: Texture marked for update but no image data found.");else if(zt.complete===!1)warn("WebGLRenderer: Texture marked for update but image is incomplete");else{mt(pt,Ke,Fe);return}}else Ke.isExternalTexture&&(pt.__webglTexture=Ke.sourceTexture?Ke.sourceTexture:null);D.bindTexture(F.TEXTURE_2D,pt.__webglTexture,F.TEXTURE0+Fe)}function Ce(Ke,Fe){const pt=O.get(Ke);if(Ke.isRenderTargetTexture===!1&&Ke.version>0&&pt.__version!==Ke.version){mt(pt,Ke,Fe);return}else Ke.isExternalTexture&&(pt.__webglTexture=Ke.sourceTexture?Ke.sourceTexture:null);D.bindTexture(F.TEXTURE_2D_ARRAY,pt.__webglTexture,F.TEXTURE0+Fe)}function Be(Ke,Fe){const pt=O.get(Ke);if(Ke.isRenderTargetTexture===!1&&Ke.version>0&&pt.__version!==Ke.version){mt(pt,Ke,Fe);return}D.bindTexture(F.TEXTURE_3D,pt.__webglTexture,F.TEXTURE0+Fe)}function ze(Ke,Fe){const pt=O.get(Ke);if(Ke.version>0&&pt.__version!==Ke.version){bt(pt,Ke,Fe);return}D.bindTexture(F.TEXTURE_CUBE_MAP,pt.__webglTexture,F.TEXTURE0+Fe)}const Xe={[RepeatWrapping]:F.REPEAT,[ClampToEdgeWrapping]:F.CLAMP_TO_EDGE,[MirroredRepeatWrapping]:F.MIRRORED_REPEAT},lt={[NearestFilter]:F.NEAREST,[NearestMipmapNearestFilter]:F.NEAREST_MIPMAP_NEAREST,[NearestMipmapLinearFilter]:F.NEAREST_MIPMAP_LINEAR,[LinearFilter]:F.LINEAR,[LinearMipmapNearestFilter]:F.LINEAR_MIPMAP_NEAREST,[LinearMipmapLinearFilter]:F.LINEAR_MIPMAP_LINEAR},ke={[NeverCompare]:F.NEVER,[AlwaysCompare]:F.ALWAYS,[LessCompare]:F.LESS,[LessEqualCompare]:F.LEQUAL,[EqualCompare]:F.EQUAL,[GreaterEqualCompare]:F.GEQUAL,[GreaterCompare]:F.GREATER,[NotEqualCompare]:F.NOTEQUAL};function rt(Ke,Fe){if(Fe.type===FloatType&&w.has("OES_texture_float_linear")===!1&&(Fe.magFilter===LinearFilter||Fe.magFilter===LinearMipmapNearestFilter||Fe.magFilter===NearestMipmapLinearFilter||Fe.magFilter===LinearMipmapLinearFilter||Fe.minFilter===LinearFilter||Fe.minFilter===LinearMipmapNearestFilter||Fe.minFilter===NearestMipmapLinearFilter||Fe.minFilter===LinearMipmapLinearFilter)&&warn("WebGLRenderer: Unable to use linear filtering with floating point textures. OES_texture_float_linear not supported on this device."),F.texParameteri(Ke,F.TEXTURE_WRAP_S,Xe[Fe.wrapS]),F.texParameteri(Ke,F.TEXTURE_WRAP_T,Xe[Fe.wrapT]),(Ke===F.TEXTURE_3D||Ke===F.TEXTURE_2D_ARRAY)&&F.texParameteri(Ke,F.TEXTURE_WRAP_R,Xe[Fe.wrapR]),F.texParameteri(Ke,F.TEXTURE_MAG_FILTER,lt[Fe.magFilter]),F.texParameteri(Ke,F.TEXTURE_MIN_FILTER,lt[Fe.minFilter]),Fe.compareFunction&&(F.texParameteri(Ke,F.TEXTURE_COMPARE_MODE,F.COMPARE_REF_TO_TEXTURE),F.texParameteri(Ke,F.TEXTURE_COMPARE_FUNC,ke[Fe.compareFunction])),w.has("EXT_texture_filter_anisotropic")===!0){if(Fe.magFilter===NearestFilter||Fe.minFilter!==NearestMipmapLinearFilter&&Fe.minFilter!==LinearMipmapLinearFilter||Fe.type===FloatType&&w.has("OES_texture_float_linear")===!1)return;if(Fe.anisotropy>1||O.get(Fe).__currentAnisotropy){const pt=w.get("EXT_texture_filter_anisotropic");F.texParameterf(Ke,pt.TEXTURE_MAX_ANISOTROPY_EXT,Math.min(Fe.anisotropy,U.getMaxAnisotropy())),O.get(Fe).__currentAnisotropy=Fe.anisotropy}}}function St(Ke,Fe){let pt=!1;Ke.__webglInit===void 0&&(Ke.__webglInit=!0,Fe.addEventListener("dispose",ve));const zt=Fe.source;let qt=W.get(zt);qt===void 0&&(qt={},W.set(zt,qt));const Nt=Oe(Fe);if(Nt!==Ke.__cacheKey){qt[Nt]===void 0&&(qt[Nt]={texture:F.createTexture(),usedTimes:0},q.memory.textures++,pt=!0),qt[Nt].usedTimes++;const Rn=qt[Ke.__cacheKey];Rn!==void 0&&(qt[Ke.__cacheKey].usedTimes--,Rn.usedTimes===0&&Ee(Fe)),Ke.__cacheKey=Nt,Ke.__webglTexture=qt[Nt].texture}return pt}function Lt(Ke,Fe,pt){return Math.floor(Math.floor(Ke/pt)/Fe)}function $t(Ke,Fe,pt,zt){const Nt=Ke.updateRanges;if(Nt.length===0)D.texSubImage2D(F.TEXTURE_2D,0,0,0,Fe.width,Fe.height,pt,zt,Fe.data);else{Nt.sort((Wt,Dt)=>Wt.start-Dt.start);let Rn=0;for(let Wt=1;Wt<Nt.length;Wt++){const Dt=Nt[Rn],Bn=Nt[Wt],Sn=Dt.start+Dt.count,bn=Lt(Bn.start,Fe.width,4),kn=Lt(Dt.start,Fe.width,4);Bn.start<=Sn+1&&bn===kn&&Lt(Bn.start+Bn.count-1,Fe.width,4)===bn?Dt.count=Math.max(Dt.count,Bn.start+Bn.count-Dt.start):(++Rn,Nt[Rn]=Bn)}Nt.length=Rn+1;const fn=F.getParameter(F.UNPACK_ROW_LENGTH),Nn=F.getParameter(F.UNPACK_SKIP_PIXELS),An=F.getParameter(F.UNPACK_SKIP_ROWS);F.pixelStorei(F.UNPACK_ROW_LENGTH,Fe.width);for(let Wt=0,Dt=Nt.length;Wt<Dt;Wt++){const Bn=Nt[Wt],Sn=Math.floor(Bn.start/4),bn=Math.ceil(Bn.count/4),kn=Sn%Fe.width,nt=Math.floor(Sn/Fe.width),dn=bn,tn=1;F.pixelStorei(F.UNPACK_SKIP_PIXELS,kn),F.pixelStorei(F.UNPACK_SKIP_ROWS,nt),D.texSubImage2D(F.TEXTURE_2D,0,kn,nt,dn,tn,pt,zt,Fe.data)}Ke.clearUpdateRanges(),F.pixelStorei(F.UNPACK_ROW_LENGTH,fn),F.pixelStorei(F.UNPACK_SKIP_PIXELS,Nn),F.pixelStorei(F.UNPACK_SKIP_ROWS,An)}}function mt(Ke,Fe,pt){let zt=F.TEXTURE_2D;(Fe.isDataArrayTexture||Fe.isCompressedArrayTexture)&&(zt=F.TEXTURE_2D_ARRAY),Fe.isData3DTexture&&(zt=F.TEXTURE_3D);const qt=St(Ke,Fe),Nt=Fe.source;D.bindTexture(zt,Ke.__webglTexture,F.TEXTURE0+pt);const Rn=O.get(Nt);if(Nt.version!==Rn.__version||qt===!0){D.activeTexture(F.TEXTURE0+pt);const fn=ColorManagement.getPrimaries(ColorManagement.workingColorSpace),Nn=Fe.colorSpace===NoColorSpace?null:ColorManagement.getPrimaries(Fe.colorSpace),An=Fe.colorSpace===NoColorSpace||fn===Nn?F.NONE:F.BROWSER_DEFAULT_WEBGL;F.pixelStorei(F.UNPACK_FLIP_Y_WEBGL,Fe.flipY),F.pixelStorei(F.UNPACK_PREMULTIPLY_ALPHA_WEBGL,Fe.premultiplyAlpha),F.pixelStorei(F.UNPACK_ALIGNMENT,Fe.unpackAlignment),F.pixelStorei(F.UNPACK_COLORSPACE_CONVERSION_WEBGL,An);let Wt=le(Fe.image,!1,U.maxTextureSize);Wt=Tn(Fe,Wt);const Dt=G.convert(Fe.format,Fe.colorSpace),Bn=G.convert(Fe.type);let Sn=me(Fe.internalFormat,Dt,Bn,Fe.colorSpace,Fe.isVideoTexture);rt(zt,Fe);let bn;const kn=Fe.mipmaps,nt=Fe.isVideoTexture!==!0,dn=Rn.__version===void 0||qt===!0,tn=Nt.dataReady,Zt=ge(Fe,Wt);if(Fe.isDepthTexture)Sn=be(Fe.format===DepthStencilFormat,Fe.type),dn&&(nt?D.texStorage2D(F.TEXTURE_2D,1,Sn,Wt.width,Wt.height):D.texImage2D(F.TEXTURE_2D,0,Sn,Wt.width,Wt.height,0,Dt,Bn,null));else if(Fe.isDataTexture)if(kn.length>0){nt&&dn&&D.texStorage2D(F.TEXTURE_2D,Zt,Sn,kn[0].width,kn[0].height);for(let Bt=0,wt=kn.length;Bt<wt;Bt++)bn=kn[Bt],nt?tn&&D.texSubImage2D(F.TEXTURE_2D,Bt,0,0,bn.width,bn.height,Dt,Bn,bn.data):D.texImage2D(F.TEXTURE_2D,Bt,Sn,bn.width,bn.height,0,Dt,Bn,bn.data);Fe.generateMipmaps=!1}else nt?(dn&&D.texStorage2D(F.TEXTURE_2D,Zt,Sn,Wt.width,Wt.height),tn&&$t(Fe,Wt,Dt,Bn)):D.texImage2D(F.TEXTURE_2D,0,Sn,Wt.width,Wt.height,0,Dt,Bn,Wt.data);else if(Fe.isCompressedTexture)if(Fe.isCompressedArrayTexture){nt&&dn&&D.texStorage3D(F.TEXTURE_2D_ARRAY,Zt,Sn,kn[0].width,kn[0].height,Wt.depth);for(let Bt=0,wt=kn.length;Bt<wt;Bt++)if(bn=kn[Bt],Fe.format!==RGBAFormat)if(Dt!==null)if(nt){if(tn)if(Fe.layerUpdates.size>0){const Qt=getByteLength(bn.width,bn.height,Fe.format,Fe.type);for(const Yn of Fe.layerUpdates){const Ai=bn.data.subarray(Yn*Qt/bn.data.BYTES_PER_ELEMENT,(Yn+1)*Qt/bn.data.BYTES_PER_ELEMENT);D.compressedTexSubImage3D(F.TEXTURE_2D_ARRAY,Bt,0,0,Yn,bn.width,bn.height,1,Dt,Ai)}Fe.clearLayerUpdates()}else D.compressedTexSubImage3D(F.TEXTURE_2D_ARRAY,Bt,0,0,0,bn.width,bn.height,Wt.depth,Dt,bn.data)}else D.compressedTexImage3D(F.TEXTURE_2D_ARRAY,Bt,Sn,bn.width,bn.height,Wt.depth,0,bn.data,0,0);else warn("WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()");else nt?tn&&D.texSubImage3D(F.TEXTURE_2D_ARRAY,Bt,0,0,0,bn.width,bn.height,Wt.depth,Dt,Bn,bn.data):D.texImage3D(F.TEXTURE_2D_ARRAY,Bt,Sn,bn.width,bn.height,Wt.depth,0,Dt,Bn,bn.data)}else{nt&&dn&&D.texStorage2D(F.TEXTURE_2D,Zt,Sn,kn[0].width,kn[0].height);for(let Bt=0,wt=kn.length;Bt<wt;Bt++)bn=kn[Bt],Fe.format!==RGBAFormat?Dt!==null?nt?tn&&D.compressedTexSubImage2D(F.TEXTURE_2D,Bt,0,0,bn.width,bn.height,Dt,bn.data):D.compressedTexImage2D(F.TEXTURE_2D,Bt,Sn,bn.width,bn.height,0,bn.data):warn("WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"):nt?tn&&D.texSubImage2D(F.TEXTURE_2D,Bt,0,0,bn.width,bn.height,Dt,Bn,bn.data):D.texImage2D(F.TEXTURE_2D,Bt,Sn,bn.width,bn.height,0,Dt,Bn,bn.data)}else if(Fe.isDataArrayTexture)if(nt){if(dn&&D.texStorage3D(F.TEXTURE_2D_ARRAY,Zt,Sn,Wt.width,Wt.height,Wt.depth),tn)if(Fe.layerUpdates.size>0){const Bt=getByteLength(Wt.width,Wt.height,Fe.format,Fe.type);for(const wt of Fe.layerUpdates){const Qt=Wt.data.subarray(wt*Bt/Wt.data.BYTES_PER_ELEMENT,(wt+1)*Bt/Wt.data.BYTES_PER_ELEMENT);D.texSubImage3D(F.TEXTURE_2D_ARRAY,0,0,0,wt,Wt.width,Wt.height,1,Dt,Bn,Qt)}Fe.clearLayerUpdates()}else D.texSubImage3D(F.TEXTURE_2D_ARRAY,0,0,0,0,Wt.width,Wt.height,Wt.depth,Dt,Bn,Wt.data)}else D.texImage3D(F.TEXTURE_2D_ARRAY,0,Sn,Wt.width,Wt.height,Wt.depth,0,Dt,Bn,Wt.data);else if(Fe.isData3DTexture)nt?(dn&&D.texStorage3D(F.TEXTURE_3D,Zt,Sn,Wt.width,Wt.height,Wt.depth),tn&&D.texSubImage3D(F.TEXTURE_3D,0,0,0,0,Wt.width,Wt.height,Wt.depth,Dt,Bn,Wt.data)):D.texImage3D(F.TEXTURE_3D,0,Sn,Wt.width,Wt.height,Wt.depth,0,Dt,Bn,Wt.data);else if(Fe.isFramebufferTexture){if(dn)if(nt)D.texStorage2D(F.TEXTURE_2D,Zt,Sn,Wt.width,Wt.height);else{let Bt=Wt.width,wt=Wt.height;for(let Qt=0;Qt<Zt;Qt++)D.texImage2D(F.TEXTURE_2D,Qt,Sn,Bt,wt,0,Dt,Bn,null),Bt>>=1,wt>>=1}}else if(kn.length>0){if(nt&&dn){const Bt=En(kn[0]);D.texStorage2D(F.TEXTURE_2D,Zt,Sn,Bt.width,Bt.height)}for(let Bt=0,wt=kn.length;Bt<wt;Bt++)bn=kn[Bt],nt?tn&&D.texSubImage2D(F.TEXTURE_2D,Bt,0,0,Dt,Bn,bn):D.texImage2D(F.TEXTURE_2D,Bt,Sn,Dt,Bn,bn);Fe.generateMipmaps=!1}else if(nt){if(dn){const Bt=En(Wt);D.texStorage2D(F.TEXTURE_2D,Zt,Sn,Bt.width,Bt.height)}tn&&D.texSubImage2D(F.TEXTURE_2D,0,0,0,Dt,Bn,Wt)}else D.texImage2D(F.TEXTURE_2D,0,Sn,Dt,Bn,Wt);ce(Fe)&&he(zt),Rn.__version=Nt.version,Fe.onUpdate&&Fe.onUpdate(Fe)}Ke.__version=Fe.version}function bt(Ke,Fe,pt){if(Fe.image.length!==6)return;const zt=St(Ke,Fe),qt=Fe.source;D.bindTexture(F.TEXTURE_CUBE_MAP,Ke.__webglTexture,F.TEXTURE0+pt);const Nt=O.get(qt);if(qt.version!==Nt.__version||zt===!0){D.activeTexture(F.TEXTURE0+pt);const Rn=ColorManagement.getPrimaries(ColorManagement.workingColorSpace),fn=Fe.colorSpace===NoColorSpace?null:ColorManagement.getPrimaries(Fe.colorSpace),Nn=Fe.colorSpace===NoColorSpace||Rn===fn?F.NONE:F.BROWSER_DEFAULT_WEBGL;F.pixelStorei(F.UNPACK_FLIP_Y_WEBGL,Fe.flipY),F.pixelStorei(F.UNPACK_PREMULTIPLY_ALPHA_WEBGL,Fe.premultiplyAlpha),F.pixelStorei(F.UNPACK_ALIGNMENT,Fe.unpackAlignment),F.pixelStorei(F.UNPACK_COLORSPACE_CONVERSION_WEBGL,Nn);const An=Fe.isCompressedTexture||Fe.image[0].isCompressedTexture,Wt=Fe.image[0]&&Fe.image[0].isDataTexture,Dt=[];for(let wt=0;wt<6;wt++)!An&&!Wt?Dt[wt]=le(Fe.image[wt],!0,U.maxCubemapSize):Dt[wt]=Wt?Fe.image[wt].image:Fe.image[wt],Dt[wt]=Tn(Fe,Dt[wt]);const Bn=Dt[0],Sn=G.convert(Fe.format,Fe.colorSpace),bn=G.convert(Fe.type),kn=me(Fe.internalFormat,Sn,bn,Fe.colorSpace),nt=Fe.isVideoTexture!==!0,dn=Nt.__version===void 0||zt===!0,tn=qt.dataReady;let Zt=ge(Fe,Bn);rt(F.TEXTURE_CUBE_MAP,Fe);let Bt;if(An){nt&&dn&&D.texStorage2D(F.TEXTURE_CUBE_MAP,Zt,kn,Bn.width,Bn.height);for(let wt=0;wt<6;wt++){Bt=Dt[wt].mipmaps;for(let Qt=0;Qt<Bt.length;Qt++){const Yn=Bt[Qt];Fe.format!==RGBAFormat?Sn!==null?nt?tn&&D.compressedTexSubImage2D(F.TEXTURE_CUBE_MAP_POSITIVE_X+wt,Qt,0,0,Yn.width,Yn.height,Sn,Yn.data):D.compressedTexImage2D(F.TEXTURE_CUBE_MAP_POSITIVE_X+wt,Qt,kn,Yn.width,Yn.height,0,Yn.data):warn("WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()"):nt?tn&&D.texSubImage2D(F.TEXTURE_CUBE_MAP_POSITIVE_X+wt,Qt,0,0,Yn.width,Yn.height,Sn,bn,Yn.data):D.texImage2D(F.TEXTURE_CUBE_MAP_POSITIVE_X+wt,Qt,kn,Yn.width,Yn.height,0,Sn,bn,Yn.data)}}}else{if(Bt=Fe.mipmaps,nt&&dn){Bt.length>0&&Zt++;const wt=En(Dt[0]);D.texStorage2D(F.TEXTURE_CUBE_MAP,Zt,kn,wt.width,wt.height)}for(let wt=0;wt<6;wt++)if(Wt){nt?tn&&D.texSubImage2D(F.TEXTURE_CUBE_MAP_POSITIVE_X+wt,0,0,0,Dt[wt].width,Dt[wt].height,Sn,bn,Dt[wt].data):D.texImage2D(F.TEXTURE_CUBE_MAP_POSITIVE_X+wt,0,kn,Dt[wt].width,Dt[wt].height,0,Sn,bn,Dt[wt].data);for(let Qt=0;Qt<Bt.length;Qt++){const Ai=Bt[Qt].image[wt].image;nt?tn&&D.texSubImage2D(F.TEXTURE_CUBE_MAP_POSITIVE_X+wt,Qt+1,0,0,Ai.width,Ai.height,Sn,bn,Ai.data):D.texImage2D(F.TEXTURE_CUBE_MAP_POSITIVE_X+wt,Qt+1,kn,Ai.width,Ai.height,0,Sn,bn,Ai.data)}}else{nt?tn&&D.texSubImage2D(F.TEXTURE_CUBE_MAP_POSITIVE_X+wt,0,0,0,Sn,bn,Dt[wt]):D.texImage2D(F.TEXTURE_CUBE_MAP_POSITIVE_X+wt,0,kn,Sn,bn,Dt[wt]);for(let Qt=0;Qt<Bt.length;Qt++){const Yn=Bt[Qt];nt?tn&&D.texSubImage2D(F.TEXTURE_CUBE_MAP_POSITIVE_X+wt,Qt+1,0,0,Sn,bn,Yn.image[wt]):D.texImage2D(F.TEXTURE_CUBE_MAP_POSITIVE_X+wt,Qt+1,kn,Sn,bn,Yn.image[wt])}}}ce(Fe)&&he(F.TEXTURE_CUBE_MAP),Nt.__version=qt.version,Fe.onUpdate&&Fe.onUpdate(Fe)}Ke.__version=Fe.version}function Xt(Ke,Fe,pt,zt,qt,Nt){const Rn=G.convert(pt.format,pt.colorSpace),fn=G.convert(pt.type),Nn=me(pt.internalFormat,Rn,fn,pt.colorSpace),An=O.get(Fe),Wt=O.get(pt);if(Wt.__renderTarget=Fe,!An.__hasExternalTextures){const Dt=Math.max(1,Fe.width>>Nt),Bn=Math.max(1,Fe.height>>Nt);qt===F.TEXTURE_3D||qt===F.TEXTURE_2D_ARRAY?D.texImage3D(qt,Nt,Nn,Dt,Bn,Fe.depth,0,Rn,fn,null):D.texImage2D(qt,Nt,Nn,Dt,Bn,0,Rn,fn,null)}D.bindFramebuffer(F.FRAMEBUFFER,Ke),yn(Fe)?K.framebufferTexture2DMultisampleEXT(F.FRAMEBUFFER,zt,qt,Wt.__webglTexture,0,ai(Fe)):(qt===F.TEXTURE_2D||qt>=F.TEXTURE_CUBE_MAP_POSITIVE_X&&qt<=F.TEXTURE_CUBE_MAP_NEGATIVE_Z)&&F.framebufferTexture2D(F.FRAMEBUFFER,zt,qt,Wt.__webglTexture,Nt),D.bindFramebuffer(F.FRAMEBUFFER,null)}function hn(Ke,Fe,pt){if(F.bindRenderbuffer(F.RENDERBUFFER,Ke),Fe.depthBuffer){const zt=Fe.depthTexture,qt=zt&&zt.isDepthTexture?zt.type:null,Nt=be(Fe.stencilBuffer,qt),Rn=Fe.stencilBuffer?F.DEPTH_STENCIL_ATTACHMENT:F.DEPTH_ATTACHMENT,fn=ai(Fe);yn(Fe)?K.renderbufferStorageMultisampleEXT(F.RENDERBUFFER,fn,Nt,Fe.width,Fe.height):pt?F.renderbufferStorageMultisample(F.RENDERBUFFER,fn,Nt,Fe.width,Fe.height):F.renderbufferStorage(F.RENDERBUFFER,Nt,Fe.width,Fe.height),F.framebufferRenderbuffer(F.FRAMEBUFFER,Rn,F.RENDERBUFFER,Ke)}else{const zt=Fe.textures;for(let qt=0;qt<zt.length;qt++){const Nt=zt[qt],Rn=G.convert(Nt.format,Nt.colorSpace),fn=G.convert(Nt.type),Nn=me(Nt.internalFormat,Rn,fn,Nt.colorSpace),An=ai(Fe);pt&&yn(Fe)===!1?F.renderbufferStorageMultisample(F.RENDERBUFFER,An,Nn,Fe.width,Fe.height):yn(Fe)?K.renderbufferStorageMultisampleEXT(F.RENDERBUFFER,An,Nn,Fe.width,Fe.height):F.renderbufferStorage(F.RENDERBUFFER,Nn,Fe.width,Fe.height)}}F.bindRenderbuffer(F.RENDERBUFFER,null)}function Jt(Ke,Fe){if(Fe&&Fe.isWebGLCubeRenderTarget)throw new Error("Depth Texture with cube render targets is not supported");if(D.bindFramebuffer(F.FRAMEBUFFER,Ke),!(Fe.depthTexture&&Fe.depthTexture.isDepthTexture))throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");const zt=O.get(Fe.depthTexture);zt.__renderTarget=Fe,(!zt.__webglTexture||Fe.depthTexture.image.width!==Fe.width||Fe.depthTexture.image.height!==Fe.height)&&(Fe.depthTexture.image.width=Fe.width,Fe.depthTexture.image.height=Fe.height,Fe.depthTexture.needsUpdate=!0),Pe(Fe.depthTexture,0);const qt=zt.__webglTexture,Nt=ai(Fe);if(Fe.depthTexture.format===DepthFormat)yn(Fe)?K.framebufferTexture2DMultisampleEXT(F.FRAMEBUFFER,F.DEPTH_ATTACHMENT,F.TEXTURE_2D,qt,0,Nt):F.framebufferTexture2D(F.FRAMEBUFFER,F.DEPTH_ATTACHMENT,F.TEXTURE_2D,qt,0);else if(Fe.depthTexture.format===DepthStencilFormat)yn(Fe)?K.framebufferTexture2DMultisampleEXT(F.FRAMEBUFFER,F.DEPTH_STENCIL_ATTACHMENT,F.TEXTURE_2D,qt,0,Nt):F.framebufferTexture2D(F.FRAMEBUFFER,F.DEPTH_STENCIL_ATTACHMENT,F.TEXTURE_2D,qt,0);else throw new Error("Unknown depthTexture format")}function Mn(Ke){const Fe=O.get(Ke),pt=Ke.isWebGLCubeRenderTarget===!0;if(Fe.__boundDepthTexture!==Ke.depthTexture){const zt=Ke.depthTexture;if(Fe.__depthDisposeCallback&&Fe.__depthDisposeCallback(),zt){const qt=()=>{delete Fe.__boundDepthTexture,delete Fe.__depthDisposeCallback,zt.removeEventListener("dispose",qt)};zt.addEventListener("dispose",qt),Fe.__depthDisposeCallback=qt}Fe.__boundDepthTexture=zt}if(Ke.depthTexture&&!Fe.__autoAllocateDepthBuffer){if(pt)throw new Error("target.depthTexture not supported in Cube render targets");const zt=Ke.texture.mipmaps;zt&&zt.length>0?Jt(Fe.__webglFramebuffer[0],Ke):Jt(Fe.__webglFramebuffer,Ke)}else if(pt){Fe.__webglDepthbuffer=[];for(let zt=0;zt<6;zt++)if(D.bindFramebuffer(F.FRAMEBUFFER,Fe.__webglFramebuffer[zt]),Fe.__webglDepthbuffer[zt]===void 0)Fe.__webglDepthbuffer[zt]=F.createRenderbuffer(),hn(Fe.__webglDepthbuffer[zt],Ke,!1);else{const qt=Ke.stencilBuffer?F.DEPTH_STENCIL_ATTACHMENT:F.DEPTH_ATTACHMENT,Nt=Fe.__webglDepthbuffer[zt];F.bindRenderbuffer(F.RENDERBUFFER,Nt),F.framebufferRenderbuffer(F.FRAMEBUFFER,qt,F.RENDERBUFFER,Nt)}}else{const zt=Ke.texture.mipmaps;if(zt&&zt.length>0?D.bindFramebuffer(F.FRAMEBUFFER,Fe.__webglFramebuffer[0]):D.bindFramebuffer(F.FRAMEBUFFER,Fe.__webglFramebuffer),Fe.__webglDepthbuffer===void 0)Fe.__webglDepthbuffer=F.createRenderbuffer(),hn(Fe.__webglDepthbuffer,Ke,!1);else{const qt=Ke.stencilBuffer?F.DEPTH_STENCIL_ATTACHMENT:F.DEPTH_ATTACHMENT,Nt=Fe.__webglDepthbuffer;F.bindRenderbuffer(F.RENDERBUFFER,Nt),F.framebufferRenderbuffer(F.FRAMEBUFFER,qt,F.RENDERBUFFER,Nt)}}D.bindFramebuffer(F.FRAMEBUFFER,null)}function Zn(Ke,Fe,pt){const zt=O.get(Ke);Fe!==void 0&&Xt(zt.__webglFramebuffer,Ke,Ke.texture,F.COLOR_ATTACHMENT0,F.TEXTURE_2D,0),pt!==void 0&&Mn(Ke)}function vn(Ke){const Fe=Ke.texture,pt=O.get(Ke),zt=O.get(Fe);Ke.addEventListener("dispose",Se);const qt=Ke.textures,Nt=Ke.isWebGLCubeRenderTarget===!0,Rn=qt.length>1;if(Rn||(zt.__webglTexture===void 0&&(zt.__webglTexture=F.createTexture()),zt.__version=Fe.version,q.memory.textures++),Nt){pt.__webglFramebuffer=[];for(let fn=0;fn<6;fn++)if(Fe.mipmaps&&Fe.mipmaps.length>0){pt.__webglFramebuffer[fn]=[];for(let Nn=0;Nn<Fe.mipmaps.length;Nn++)pt.__webglFramebuffer[fn][Nn]=F.createFramebuffer()}else pt.__webglFramebuffer[fn]=F.createFramebuffer()}else{if(Fe.mipmaps&&Fe.mipmaps.length>0){pt.__webglFramebuffer=[];for(let fn=0;fn<Fe.mipmaps.length;fn++)pt.__webglFramebuffer[fn]=F.createFramebuffer()}else pt.__webglFramebuffer=F.createFramebuffer();if(Rn)for(let fn=0,Nn=qt.length;fn<Nn;fn++){const An=O.get(qt[fn]);An.__webglTexture===void 0&&(An.__webglTexture=F.createTexture(),q.memory.textures++)}if(Ke.samples>0&&yn(Ke)===!1){pt.__webglMultisampledFramebuffer=F.createFramebuffer(),pt.__webglColorRenderbuffer=[],D.bindFramebuffer(F.FRAMEBUFFER,pt.__webglMultisampledFramebuffer);for(let fn=0;fn<qt.length;fn++){const Nn=qt[fn];pt.__webglColorRenderbuffer[fn]=F.createRenderbuffer(),F.bindRenderbuffer(F.RENDERBUFFER,pt.__webglColorRenderbuffer[fn]);const An=G.convert(Nn.format,Nn.colorSpace),Wt=G.convert(Nn.type),Dt=me(Nn.internalFormat,An,Wt,Nn.colorSpace,Ke.isXRRenderTarget===!0),Bn=ai(Ke);F.renderbufferStorageMultisample(F.RENDERBUFFER,Bn,Dt,Ke.width,Ke.height),F.framebufferRenderbuffer(F.FRAMEBUFFER,F.COLOR_ATTACHMENT0+fn,F.RENDERBUFFER,pt.__webglColorRenderbuffer[fn])}F.bindRenderbuffer(F.RENDERBUFFER,null),Ke.depthBuffer&&(pt.__webglDepthRenderbuffer=F.createRenderbuffer(),hn(pt.__webglDepthRenderbuffer,Ke,!0)),D.bindFramebuffer(F.FRAMEBUFFER,null)}}if(Nt){D.bindTexture(F.TEXTURE_CUBE_MAP,zt.__webglTexture),rt(F.TEXTURE_CUBE_MAP,Fe);for(let fn=0;fn<6;fn++)if(Fe.mipmaps&&Fe.mipmaps.length>0)for(let Nn=0;Nn<Fe.mipmaps.length;Nn++)Xt(pt.__webglFramebuffer[fn][Nn],Ke,Fe,F.COLOR_ATTACHMENT0,F.TEXTURE_CUBE_MAP_POSITIVE_X+fn,Nn);else Xt(pt.__webglFramebuffer[fn],Ke,Fe,F.COLOR_ATTACHMENT0,F.TEXTURE_CUBE_MAP_POSITIVE_X+fn,0);ce(Fe)&&he(F.TEXTURE_CUBE_MAP),D.unbindTexture()}else if(Rn){for(let fn=0,Nn=qt.length;fn<Nn;fn++){const An=qt[fn],Wt=O.get(An);let Dt=F.TEXTURE_2D;(Ke.isWebGL3DRenderTarget||Ke.isWebGLArrayRenderTarget)&&(Dt=Ke.isWebGL3DRenderTarget?F.TEXTURE_3D:F.TEXTURE_2D_ARRAY),D.bindTexture(Dt,Wt.__webglTexture),rt(Dt,An),Xt(pt.__webglFramebuffer,Ke,An,F.COLOR_ATTACHMENT0+fn,Dt,0),ce(An)&&he(Dt)}D.unbindTexture()}else{let fn=F.TEXTURE_2D;if((Ke.isWebGL3DRenderTarget||Ke.isWebGLArrayRenderTarget)&&(fn=Ke.isWebGL3DRenderTarget?F.TEXTURE_3D:F.TEXTURE_2D_ARRAY),D.bindTexture(fn,zt.__webglTexture),rt(fn,Fe),Fe.mipmaps&&Fe.mipmaps.length>0)for(let Nn=0;Nn<Fe.mipmaps.length;Nn++)Xt(pt.__webglFramebuffer[Nn],Ke,Fe,F.COLOR_ATTACHMENT0,fn,Nn);else Xt(pt.__webglFramebuffer,Ke,Fe,F.COLOR_ATTACHMENT0,fn,0);ce(Fe)&&he(fn),D.unbindTexture()}Ke.depthBuffer&&Mn(Ke)}function In(Ke){const Fe=Ke.textures;for(let pt=0,zt=Fe.length;pt<zt;pt++){const qt=Fe[pt];if(ce(qt)){const Nt=pe(Ke),Rn=O.get(qt).__webglTexture;D.bindTexture(Nt,Rn),he(Nt),D.unbindTexture()}}}const st=[],Gn=[];function qn(Ke){if(Ke.samples>0){if(yn(Ke)===!1){const Fe=Ke.textures,pt=Ke.width,zt=Ke.height;let qt=F.COLOR_BUFFER_BIT;const Nt=Ke.stencilBuffer?F.DEPTH_STENCIL_ATTACHMENT:F.DEPTH_ATTACHMENT,Rn=O.get(Ke),fn=Fe.length>1;if(fn)for(let An=0;An<Fe.length;An++)D.bindFramebuffer(F.FRAMEBUFFER,Rn.__webglMultisampledFramebuffer),F.framebufferRenderbuffer(F.FRAMEBUFFER,F.COLOR_ATTACHMENT0+An,F.RENDERBUFFER,null),D.bindFramebuffer(F.FRAMEBUFFER,Rn.__webglFramebuffer),F.framebufferTexture2D(F.DRAW_FRAMEBUFFER,F.COLOR_ATTACHMENT0+An,F.TEXTURE_2D,null,0);D.bindFramebuffer(F.READ_FRAMEBUFFER,Rn.__webglMultisampledFramebuffer);const Nn=Ke.texture.mipmaps;Nn&&Nn.length>0?D.bindFramebuffer(F.DRAW_FRAMEBUFFER,Rn.__webglFramebuffer[0]):D.bindFramebuffer(F.DRAW_FRAMEBUFFER,Rn.__webglFramebuffer);for(let An=0;An<Fe.length;An++){if(Ke.resolveDepthBuffer&&(Ke.depthBuffer&&(qt|=F.DEPTH_BUFFER_BIT),Ke.stencilBuffer&&Ke.resolveStencilBuffer&&(qt|=F.STENCIL_BUFFER_BIT)),fn){F.framebufferRenderbuffer(F.READ_FRAMEBUFFER,F.COLOR_ATTACHMENT0,F.RENDERBUFFER,Rn.__webglColorRenderbuffer[An]);const Wt=O.get(Fe[An]).__webglTexture;F.framebufferTexture2D(F.DRAW_FRAMEBUFFER,F.COLOR_ATTACHMENT0,F.TEXTURE_2D,Wt,0)}F.blitFramebuffer(0,0,pt,zt,0,0,pt,zt,qt,F.NEAREST),ee===!0&&(st.length=0,Gn.length=0,st.push(F.COLOR_ATTACHMENT0+An),Ke.depthBuffer&&Ke.resolveDepthBuffer===!1&&(st.push(Nt),Gn.push(Nt),F.invalidateFramebuffer(F.DRAW_FRAMEBUFFER,Gn)),F.invalidateFramebuffer(F.READ_FRAMEBUFFER,st))}if(D.bindFramebuffer(F.READ_FRAMEBUFFER,null),D.bindFramebuffer(F.DRAW_FRAMEBUFFER,null),fn)for(let An=0;An<Fe.length;An++){D.bindFramebuffer(F.FRAMEBUFFER,Rn.__webglMultisampledFramebuffer),F.framebufferRenderbuffer(F.FRAMEBUFFER,F.COLOR_ATTACHMENT0+An,F.RENDERBUFFER,Rn.__webglColorRenderbuffer[An]);const Wt=O.get(Fe[An]).__webglTexture;D.bindFramebuffer(F.FRAMEBUFFER,Rn.__webglFramebuffer),F.framebufferTexture2D(F.DRAW_FRAMEBUFFER,F.COLOR_ATTACHMENT0+An,F.TEXTURE_2D,Wt,0)}D.bindFramebuffer(F.DRAW_FRAMEBUFFER,Rn.__webglMultisampledFramebuffer)}else if(Ke.depthBuffer&&Ke.resolveDepthBuffer===!1&&ee){const Fe=Ke.stencilBuffer?F.DEPTH_STENCIL_ATTACHMENT:F.DEPTH_ATTACHMENT;F.invalidateFramebuffer(F.DRAW_FRAMEBUFFER,[Fe])}}}function ai(Ke){return Math.min(U.maxSamples,Ke.samples)}function yn(Ke){const Fe=O.get(Ke);return Ke.samples>0&&w.has("WEBGL_multisampled_render_to_texture")===!0&&Fe.__useRenderToTexture!==!1}function li(Ke){const Fe=q.render.frame;ie.get(Ke)!==Fe&&(ie.set(Ke,Fe),Ke.update())}function Tn(Ke,Fe){const pt=Ke.colorSpace,zt=Ke.format,qt=Ke.type;return Ke.isCompressedTexture===!0||Ke.isVideoTexture===!0||pt!==LinearSRGBColorSpace&&pt!==NoColorSpace&&(ColorManagement.getTransfer(pt)===SRGBTransfer?(zt!==RGBAFormat||qt!==UnsignedByteType)&&warn("WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType."):error("WebGLTextures: Unsupported texture color space:",pt)),Fe}function En(Ke){return typeof HTMLImageElement<"u"&&Ke instanceof HTMLImageElement?(Z.width=Ke.naturalWidth||Ke.width,Z.height=Ke.naturalHeight||Ke.height):typeof VideoFrame<"u"&&Ke instanceof VideoFrame?(Z.width=Ke.displayWidth,Z.height=Ke.displayHeight):(Z.width=Ke.width,Z.height=Ke.height),Z}this.allocateTextureUnit=Ne,this.resetTextureUnits=Le,this.setTexture2D=Pe,this.setTexture2DArray=Ce,this.setTexture3D=Be,this.setTextureCube=ze,this.rebindTextures=Zn,this.setupRenderTarget=vn,this.updateRenderTargetMipmap=In,this.updateMultisampleRenderTarget=qn,this.setupDepthRenderbuffer=Mn,this.setupFrameBufferTexture=Xt,this.useMultisampledRTT=yn}function WebGLUtils(F,w){function D(O,U=NoColorSpace){let G;const q=ColorManagement.getTransfer(U);if(O===UnsignedByteType)return F.UNSIGNED_BYTE;if(O===UnsignedShort4444Type)return F.UNSIGNED_SHORT_4_4_4_4;if(O===UnsignedShort5551Type)return F.UNSIGNED_SHORT_5_5_5_1;if(O===UnsignedInt5999Type)return F.UNSIGNED_INT_5_9_9_9_REV;if(O===UnsignedInt101111Type)return F.UNSIGNED_INT_10F_11F_11F_REV;if(O===ByteType)return F.BYTE;if(O===ShortType)return F.SHORT;if(O===UnsignedShortType)return F.UNSIGNED_SHORT;if(O===IntType)return F.INT;if(O===UnsignedIntType)return F.UNSIGNED_INT;if(O===FloatType)return F.FLOAT;if(O===HalfFloatType)return F.HALF_FLOAT;if(O===AlphaFormat)return F.ALPHA;if(O===RGBFormat)return F.RGB;if(O===RGBAFormat)return F.RGBA;if(O===DepthFormat)return F.DEPTH_COMPONENT;if(O===DepthStencilFormat)return F.DEPTH_STENCIL;if(O===RedFormat)return F.RED;if(O===RedIntegerFormat)return F.RED_INTEGER;if(O===RGFormat)return F.RG;if(O===RGIntegerFormat)return F.RG_INTEGER;if(O===RGBAIntegerFormat)return F.RGBA_INTEGER;if(O===RGB_S3TC_DXT1_Format||O===RGBA_S3TC_DXT1_Format||O===RGBA_S3TC_DXT3_Format||O===RGBA_S3TC_DXT5_Format)if(q===SRGBTransfer)if(G=w.get("WEBGL_compressed_texture_s3tc_srgb"),G!==null){if(O===RGB_S3TC_DXT1_Format)return G.COMPRESSED_SRGB_S3TC_DXT1_EXT;if(O===RGBA_S3TC_DXT1_Format)return G.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;if(O===RGBA_S3TC_DXT3_Format)return G.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;if(O===RGBA_S3TC_DXT5_Format)return G.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT}else return null;else if(G=w.get("WEBGL_compressed_texture_s3tc"),G!==null){if(O===RGB_S3TC_DXT1_Format)return G.COMPRESSED_RGB_S3TC_DXT1_EXT;if(O===RGBA_S3TC_DXT1_Format)return G.COMPRESSED_RGBA_S3TC_DXT1_EXT;if(O===RGBA_S3TC_DXT3_Format)return G.COMPRESSED_RGBA_S3TC_DXT3_EXT;if(O===RGBA_S3TC_DXT5_Format)return G.COMPRESSED_RGBA_S3TC_DXT5_EXT}else return null;if(O===RGB_PVRTC_4BPPV1_Format||O===RGB_PVRTC_2BPPV1_Format||O===RGBA_PVRTC_4BPPV1_Format||O===RGBA_PVRTC_2BPPV1_Format)if(G=w.get("WEBGL_compressed_texture_pvrtc"),G!==null){if(O===RGB_PVRTC_4BPPV1_Format)return G.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;if(O===RGB_PVRTC_2BPPV1_Format)return G.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;if(O===RGBA_PVRTC_4BPPV1_Format)return G.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;if(O===RGBA_PVRTC_2BPPV1_Format)return G.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG}else return null;if(O===RGB_ETC1_Format||O===RGB_ETC2_Format||O===RGBA_ETC2_EAC_Format)if(G=w.get("WEBGL_compressed_texture_etc"),G!==null){if(O===RGB_ETC1_Format||O===RGB_ETC2_Format)return q===SRGBTransfer?G.COMPRESSED_SRGB8_ETC2:G.COMPRESSED_RGB8_ETC2;if(O===RGBA_ETC2_EAC_Format)return q===SRGBTransfer?G.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC:G.COMPRESSED_RGBA8_ETC2_EAC}else return null;if(O===RGBA_ASTC_4x4_Format||O===RGBA_ASTC_5x4_Format||O===RGBA_ASTC_5x5_Format||O===RGBA_ASTC_6x5_Format||O===RGBA_ASTC_6x6_Format||O===RGBA_ASTC_8x5_Format||O===RGBA_ASTC_8x6_Format||O===RGBA_ASTC_8x8_Format||O===RGBA_ASTC_10x5_Format||O===RGBA_ASTC_10x6_Format||O===RGBA_ASTC_10x8_Format||O===RGBA_ASTC_10x10_Format||O===RGBA_ASTC_12x10_Format||O===RGBA_ASTC_12x12_Format)if(G=w.get("WEBGL_compressed_texture_astc"),G!==null){if(O===RGBA_ASTC_4x4_Format)return q===SRGBTransfer?G.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR:G.COMPRESSED_RGBA_ASTC_4x4_KHR;if(O===RGBA_ASTC_5x4_Format)return q===SRGBTransfer?G.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR:G.COMPRESSED_RGBA_ASTC_5x4_KHR;if(O===RGBA_ASTC_5x5_Format)return q===SRGBTransfer?G.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR:G.COMPRESSED_RGBA_ASTC_5x5_KHR;if(O===RGBA_ASTC_6x5_Format)return q===SRGBTransfer?G.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR:G.COMPRESSED_RGBA_ASTC_6x5_KHR;if(O===RGBA_ASTC_6x6_Format)return q===SRGBTransfer?G.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR:G.COMPRESSED_RGBA_ASTC_6x6_KHR;if(O===RGBA_ASTC_8x5_Format)return q===SRGBTransfer?G.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR:G.COMPRESSED_RGBA_ASTC_8x5_KHR;if(O===RGBA_ASTC_8x6_Format)return q===SRGBTransfer?G.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR:G.COMPRESSED_RGBA_ASTC_8x6_KHR;if(O===RGBA_ASTC_8x8_Format)return q===SRGBTransfer?G.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR:G.COMPRESSED_RGBA_ASTC_8x8_KHR;if(O===RGBA_ASTC_10x5_Format)return q===SRGBTransfer?G.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR:G.COMPRESSED_RGBA_ASTC_10x5_KHR;if(O===RGBA_ASTC_10x6_Format)return q===SRGBTransfer?G.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR:G.COMPRESSED_RGBA_ASTC_10x6_KHR;if(O===RGBA_ASTC_10x8_Format)return q===SRGBTransfer?G.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR:G.COMPRESSED_RGBA_ASTC_10x8_KHR;if(O===RGBA_ASTC_10x10_Format)return q===SRGBTransfer?G.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR:G.COMPRESSED_RGBA_ASTC_10x10_KHR;if(O===RGBA_ASTC_12x10_Format)return q===SRGBTransfer?G.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR:G.COMPRESSED_RGBA_ASTC_12x10_KHR;if(O===RGBA_ASTC_12x12_Format)return q===SRGBTransfer?G.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR:G.COMPRESSED_RGBA_ASTC_12x12_KHR}else return null;if(O===RGBA_BPTC_Format||O===RGB_BPTC_SIGNED_Format||O===RGB_BPTC_UNSIGNED_Format)if(G=w.get("EXT_texture_compression_bptc"),G!==null){if(O===RGBA_BPTC_Format)return q===SRGBTransfer?G.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT:G.COMPRESSED_RGBA_BPTC_UNORM_EXT;if(O===RGB_BPTC_SIGNED_Format)return G.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT;if(O===RGB_BPTC_UNSIGNED_Format)return G.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT}else return null;if(O===RED_RGTC1_Format||O===SIGNED_RED_RGTC1_Format||O===RED_GREEN_RGTC2_Format||O===SIGNED_RED_GREEN_RGTC2_Format)if(G=w.get("EXT_texture_compression_rgtc"),G!==null){if(O===RED_RGTC1_Format)return G.COMPRESSED_RED_RGTC1_EXT;if(O===SIGNED_RED_RGTC1_Format)return G.COMPRESSED_SIGNED_RED_RGTC1_EXT;if(O===RED_GREEN_RGTC2_Format)return G.COMPRESSED_RED_GREEN_RGTC2_EXT;if(O===SIGNED_RED_GREEN_RGTC2_Format)return G.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT}else return null;return O===UnsignedInt248Type?F.UNSIGNED_INT_24_8:F[O]!==void 0?F[O]:null}return{convert:D}}const _occlusion_vertex=`
void main() {

	gl_Position = vec4( position, 1.0 );

}`,_occlusion_fragment=`
uniform sampler2DArray depthColor;
uniform float depthWidth;
uniform float depthHeight;

void main() {

	vec2 coord = vec2( gl_FragCoord.x / depthWidth, gl_FragCoord.y / depthHeight );

	if ( coord.x >= 1.0 ) {

		gl_FragDepth = texture( depthColor, vec3( coord.x - 1.0, coord.y, 1 ) ).r;

	} else {

		gl_FragDepth = texture( depthColor, vec3( coord.x, coord.y, 0 ) ).r;

	}

}`;class WebXRDepthSensing{constructor(){this.texture=null,this.mesh=null,this.depthNear=0,this.depthFar=0}init(w,D){if(this.texture===null){const O=new ExternalTexture(w.texture);(w.depthNear!==D.depthNear||w.depthFar!==D.depthFar)&&(this.depthNear=w.depthNear,this.depthFar=w.depthFar),this.texture=O}}getMesh(w){if(this.texture!==null&&this.mesh===null){const D=w.cameras[0].viewport,O=new ShaderMaterial({vertexShader:_occlusion_vertex,fragmentShader:_occlusion_fragment,uniforms:{depthColor:{value:this.texture},depthWidth:{value:D.z},depthHeight:{value:D.w}}});this.mesh=new Mesh(new PlaneGeometry(20,20),O)}return this.mesh}reset(){this.texture=null,this.mesh=null}getDepthTexture(){return this.texture}}class WebXRManager extends EventDispatcher{constructor(w,D){super();const O=this;let U=null,G=1,q=null,K="local-floor",ee=1,Z=null,ie=null,Y=null,W=null,ne=null,se=null;const le=typeof XRWebGLBinding<"u",ce=new WebXRDepthSensing,he={},pe=D.getContextAttributes();let me=null,be=null;const ge=[],ve=[],Se=new Vector2;let Me=null;const Ee=new PerspectiveCamera;Ee.viewport=new Vector4;const we=new PerspectiveCamera;we.viewport=new Vector4;const Re=[Ee,we],Le=new ArrayCamera;let Ne=null,Oe=null;this.cameraAutoUpdate=!0,this.enabled=!1,this.isPresenting=!1,this.getController=function(mt){let bt=ge[mt];return bt===void 0&&(bt=new WebXRController,ge[mt]=bt),bt.getTargetRaySpace()},this.getControllerGrip=function(mt){let bt=ge[mt];return bt===void 0&&(bt=new WebXRController,ge[mt]=bt),bt.getGripSpace()},this.getHand=function(mt){let bt=ge[mt];return bt===void 0&&(bt=new WebXRController,ge[mt]=bt),bt.getHandSpace()};function Pe(mt){const bt=ve.indexOf(mt.inputSource);if(bt===-1)return;const Xt=ge[bt];Xt!==void 0&&(Xt.update(mt.inputSource,mt.frame,Z||q),Xt.dispatchEvent({type:mt.type,data:mt.inputSource}))}function Ce(){U.removeEventListener("select",Pe),U.removeEventListener("selectstart",Pe),U.removeEventListener("selectend",Pe),U.removeEventListener("squeeze",Pe),U.removeEventListener("squeezestart",Pe),U.removeEventListener("squeezeend",Pe),U.removeEventListener("end",Ce),U.removeEventListener("inputsourceschange",Be);for(let mt=0;mt<ge.length;mt++){const bt=ve[mt];bt!==null&&(ve[mt]=null,ge[mt].disconnect(bt))}Ne=null,Oe=null,ce.reset();for(const mt in he)delete he[mt];w.setRenderTarget(me),ne=null,W=null,Y=null,U=null,be=null,$t.stop(),O.isPresenting=!1,w.setPixelRatio(Me),w.setSize(Se.width,Se.height,!1),O.dispatchEvent({type:"sessionend"})}this.setFramebufferScaleFactor=function(mt){G=mt,O.isPresenting===!0&&warn("WebXRManager: Cannot change framebuffer scale while presenting.")},this.setReferenceSpaceType=function(mt){K=mt,O.isPresenting===!0&&warn("WebXRManager: Cannot change reference space type while presenting.")},this.getReferenceSpace=function(){return Z||q},this.setReferenceSpace=function(mt){Z=mt},this.getBaseLayer=function(){return W!==null?W:ne},this.getBinding=function(){return Y===null&&le&&(Y=new XRWebGLBinding(U,D)),Y},this.getFrame=function(){return se},this.getSession=function(){return U},this.setSession=async function(mt){if(U=mt,U!==null){if(me=w.getRenderTarget(),U.addEventListener("select",Pe),U.addEventListener("selectstart",Pe),U.addEventListener("selectend",Pe),U.addEventListener("squeeze",Pe),U.addEventListener("squeezestart",Pe),U.addEventListener("squeezeend",Pe),U.addEventListener("end",Ce),U.addEventListener("inputsourceschange",Be),pe.xrCompatible!==!0&&await D.makeXRCompatible(),Me=w.getPixelRatio(),w.getSize(Se),le&&"createProjectionLayer"in XRWebGLBinding.prototype){let Xt=null,hn=null,Jt=null;pe.depth&&(Jt=pe.stencil?D.DEPTH24_STENCIL8:D.DEPTH_COMPONENT24,Xt=pe.stencil?DepthStencilFormat:DepthFormat,hn=pe.stencil?UnsignedInt248Type:UnsignedIntType);const Mn={colorFormat:D.RGBA8,depthFormat:Jt,scaleFactor:G};Y=this.getBinding(),W=Y.createProjectionLayer(Mn),U.updateRenderState({layers:[W]}),w.setPixelRatio(1),w.setSize(W.textureWidth,W.textureHeight,!1),be=new WebGLRenderTarget(W.textureWidth,W.textureHeight,{format:RGBAFormat,type:UnsignedByteType,depthTexture:new DepthTexture(W.textureWidth,W.textureHeight,hn,void 0,void 0,void 0,void 0,void 0,void 0,Xt),stencilBuffer:pe.stencil,colorSpace:w.outputColorSpace,samples:pe.antialias?4:0,resolveDepthBuffer:W.ignoreDepthValues===!1,resolveStencilBuffer:W.ignoreDepthValues===!1})}else{const Xt={antialias:pe.antialias,alpha:!0,depth:pe.depth,stencil:pe.stencil,framebufferScaleFactor:G};ne=new XRWebGLLayer(U,D,Xt),U.updateRenderState({baseLayer:ne}),w.setPixelRatio(1),w.setSize(ne.framebufferWidth,ne.framebufferHeight,!1),be=new WebGLRenderTarget(ne.framebufferWidth,ne.framebufferHeight,{format:RGBAFormat,type:UnsignedByteType,colorSpace:w.outputColorSpace,stencilBuffer:pe.stencil,resolveDepthBuffer:ne.ignoreDepthValues===!1,resolveStencilBuffer:ne.ignoreDepthValues===!1})}be.isXRRenderTarget=!0,this.setFoveation(ee),Z=null,q=await U.requestReferenceSpace(K),$t.setContext(U),$t.start(),O.isPresenting=!0,O.dispatchEvent({type:"sessionstart"})}},this.getEnvironmentBlendMode=function(){if(U!==null)return U.environmentBlendMode},this.getDepthTexture=function(){return ce.getDepthTexture()};function Be(mt){for(let bt=0;bt<mt.removed.length;bt++){const Xt=mt.removed[bt],hn=ve.indexOf(Xt);hn>=0&&(ve[hn]=null,ge[hn].disconnect(Xt))}for(let bt=0;bt<mt.added.length;bt++){const Xt=mt.added[bt];let hn=ve.indexOf(Xt);if(hn===-1){for(let Mn=0;Mn<ge.length;Mn++)if(Mn>=ve.length){ve.push(Xt),hn=Mn;break}else if(ve[Mn]===null){ve[Mn]=Xt,hn=Mn;break}if(hn===-1)break}const Jt=ge[hn];Jt&&Jt.connect(Xt)}}const ze=new Vector3,Xe=new Vector3;function lt(mt,bt,Xt){ze.setFromMatrixPosition(bt.matrixWorld),Xe.setFromMatrixPosition(Xt.matrixWorld);const hn=ze.distanceTo(Xe),Jt=bt.projectionMatrix.elements,Mn=Xt.projectionMatrix.elements,Zn=Jt[14]/(Jt[10]-1),vn=Jt[14]/(Jt[10]+1),In=(Jt[9]+1)/Jt[5],st=(Jt[9]-1)/Jt[5],Gn=(Jt[8]-1)/Jt[0],qn=(Mn[8]+1)/Mn[0],ai=Zn*Gn,yn=Zn*qn,li=hn/(-Gn+qn),Tn=li*-Gn;if(bt.matrixWorld.decompose(mt.position,mt.quaternion,mt.scale),mt.translateX(Tn),mt.translateZ(li),mt.matrixWorld.compose(mt.position,mt.quaternion,mt.scale),mt.matrixWorldInverse.copy(mt.matrixWorld).invert(),Jt[10]===-1)mt.projectionMatrix.copy(bt.projectionMatrix),mt.projectionMatrixInverse.copy(bt.projectionMatrixInverse);else{const En=Zn+li,Ke=vn+li,Fe=ai-Tn,pt=yn+(hn-Tn),zt=In*vn/Ke*En,qt=st*vn/Ke*En;mt.projectionMatrix.makePerspective(Fe,pt,zt,qt,En,Ke),mt.projectionMatrixInverse.copy(mt.projectionMatrix).invert()}}function ke(mt,bt){bt===null?mt.matrixWorld.copy(mt.matrix):mt.matrixWorld.multiplyMatrices(bt.matrixWorld,mt.matrix),mt.matrixWorldInverse.copy(mt.matrixWorld).invert()}this.updateCamera=function(mt){if(U===null)return;let bt=mt.near,Xt=mt.far;ce.texture!==null&&(ce.depthNear>0&&(bt=ce.depthNear),ce.depthFar>0&&(Xt=ce.depthFar)),Le.near=we.near=Ee.near=bt,Le.far=we.far=Ee.far=Xt,(Ne!==Le.near||Oe!==Le.far)&&(U.updateRenderState({depthNear:Le.near,depthFar:Le.far}),Ne=Le.near,Oe=Le.far),Le.layers.mask=mt.layers.mask|6,Ee.layers.mask=Le.layers.mask&3,we.layers.mask=Le.layers.mask&5;const hn=mt.parent,Jt=Le.cameras;ke(Le,hn);for(let Mn=0;Mn<Jt.length;Mn++)ke(Jt[Mn],hn);Jt.length===2?lt(Le,Ee,we):Le.projectionMatrix.copy(Ee.projectionMatrix),rt(mt,Le,hn)};function rt(mt,bt,Xt){Xt===null?mt.matrix.copy(bt.matrixWorld):(mt.matrix.copy(Xt.matrixWorld),mt.matrix.invert(),mt.matrix.multiply(bt.matrixWorld)),mt.matrix.decompose(mt.position,mt.quaternion,mt.scale),mt.updateMatrixWorld(!0),mt.projectionMatrix.copy(bt.projectionMatrix),mt.projectionMatrixInverse.copy(bt.projectionMatrixInverse),mt.isPerspectiveCamera&&(mt.fov=RAD2DEG*2*Math.atan(1/mt.projectionMatrix.elements[5]),mt.zoom=1)}this.getCamera=function(){return Le},this.getFoveation=function(){if(!(W===null&&ne===null))return ee},this.setFoveation=function(mt){ee=mt,W!==null&&(W.fixedFoveation=mt),ne!==null&&ne.fixedFoveation!==void 0&&(ne.fixedFoveation=mt)},this.hasDepthSensing=function(){return ce.texture!==null},this.getDepthSensingMesh=function(){return ce.getMesh(Le)},this.getCameraTexture=function(mt){return he[mt]};let St=null;function Lt(mt,bt){if(ie=bt.getViewerPose(Z||q),se=bt,ie!==null){const Xt=ie.views;ne!==null&&(w.setRenderTargetFramebuffer(be,ne.framebuffer),w.setRenderTarget(be));let hn=!1;Xt.length!==Le.cameras.length&&(Le.cameras.length=0,hn=!0);for(let vn=0;vn<Xt.length;vn++){const In=Xt[vn];let st=null;if(ne!==null)st=ne.getViewport(In);else{const qn=Y.getViewSubImage(W,In);st=qn.viewport,vn===0&&(w.setRenderTargetTextures(be,qn.colorTexture,qn.depthStencilTexture),w.setRenderTarget(be))}let Gn=Re[vn];Gn===void 0&&(Gn=new PerspectiveCamera,Gn.layers.enable(vn),Gn.viewport=new Vector4,Re[vn]=Gn),Gn.matrix.fromArray(In.transform.matrix),Gn.matrix.decompose(Gn.position,Gn.quaternion,Gn.scale),Gn.projectionMatrix.fromArray(In.projectionMatrix),Gn.projectionMatrixInverse.copy(Gn.projectionMatrix).invert(),Gn.viewport.set(st.x,st.y,st.width,st.height),vn===0&&(Le.matrix.copy(Gn.matrix),Le.matrix.decompose(Le.position,Le.quaternion,Le.scale)),hn===!0&&Le.cameras.push(Gn)}const Jt=U.enabledFeatures;if(Jt&&Jt.includes("depth-sensing")&&U.depthUsage=="gpu-optimized"&&le){Y=O.getBinding();const vn=Y.getDepthInformation(Xt[0]);vn&&vn.isValid&&vn.texture&&ce.init(vn,U.renderState)}if(Jt&&Jt.includes("camera-access")&&le){w.state.unbindTexture(),Y=O.getBinding();for(let vn=0;vn<Xt.length;vn++){const In=Xt[vn].camera;if(In){let st=he[In];st||(st=new ExternalTexture,he[In]=st);const Gn=Y.getCameraImage(In);st.sourceTexture=Gn}}}}for(let Xt=0;Xt<ge.length;Xt++){const hn=ve[Xt],Jt=ge[Xt];hn!==null&&Jt!==void 0&&Jt.update(hn,bt,Z||q)}St&&St(mt,bt),bt.detectedPlanes&&O.dispatchEvent({type:"planesdetected",data:bt}),se=null}const $t=new WebGLAnimation;$t.setAnimationLoop(Lt),this.setAnimationLoop=function(mt){St=mt},this.dispose=function(){}}}const _e1=new Euler,_m1=new Matrix4;function WebGLMaterials(F,w){function D(ce,he){ce.matrixAutoUpdate===!0&&ce.updateMatrix(),he.value.copy(ce.matrix)}function O(ce,he){he.color.getRGB(ce.fogColor.value,getUnlitUniformColorSpace(F)),he.isFog?(ce.fogNear.value=he.near,ce.fogFar.value=he.far):he.isFogExp2&&(ce.fogDensity.value=he.density)}function U(ce,he,pe,me,be){he.isMeshBasicMaterial||he.isMeshLambertMaterial?G(ce,he):he.isMeshToonMaterial?(G(ce,he),Y(ce,he)):he.isMeshPhongMaterial?(G(ce,he),ie(ce,he)):he.isMeshStandardMaterial?(G(ce,he),W(ce,he),he.isMeshPhysicalMaterial&&ne(ce,he,be)):he.isMeshMatcapMaterial?(G(ce,he),se(ce,he)):he.isMeshDepthMaterial?G(ce,he):he.isMeshDistanceMaterial?(G(ce,he),le(ce,he)):he.isMeshNormalMaterial?G(ce,he):he.isLineBasicMaterial?(q(ce,he),he.isLineDashedMaterial&&K(ce,he)):he.isPointsMaterial?ee(ce,he,pe,me):he.isSpriteMaterial?Z(ce,he):he.isShadowMaterial?(ce.color.value.copy(he.color),ce.opacity.value=he.opacity):he.isShaderMaterial&&(he.uniformsNeedUpdate=!1)}function G(ce,he){ce.opacity.value=he.opacity,he.color&&ce.diffuse.value.copy(he.color),he.emissive&&ce.emissive.value.copy(he.emissive).multiplyScalar(he.emissiveIntensity),he.map&&(ce.map.value=he.map,D(he.map,ce.mapTransform)),he.alphaMap&&(ce.alphaMap.value=he.alphaMap,D(he.alphaMap,ce.alphaMapTransform)),he.bumpMap&&(ce.bumpMap.value=he.bumpMap,D(he.bumpMap,ce.bumpMapTransform),ce.bumpScale.value=he.bumpScale,he.side===BackSide&&(ce.bumpScale.value*=-1)),he.normalMap&&(ce.normalMap.value=he.normalMap,D(he.normalMap,ce.normalMapTransform),ce.normalScale.value.copy(he.normalScale),he.side===BackSide&&ce.normalScale.value.negate()),he.displacementMap&&(ce.displacementMap.value=he.displacementMap,D(he.displacementMap,ce.displacementMapTransform),ce.displacementScale.value=he.displacementScale,ce.displacementBias.value=he.displacementBias),he.emissiveMap&&(ce.emissiveMap.value=he.emissiveMap,D(he.emissiveMap,ce.emissiveMapTransform)),he.specularMap&&(ce.specularMap.value=he.specularMap,D(he.specularMap,ce.specularMapTransform)),he.alphaTest>0&&(ce.alphaTest.value=he.alphaTest);const pe=w.get(he),me=pe.envMap,be=pe.envMapRotation;me&&(ce.envMap.value=me,_e1.copy(be),_e1.x*=-1,_e1.y*=-1,_e1.z*=-1,me.isCubeTexture&&me.isRenderTargetTexture===!1&&(_e1.y*=-1,_e1.z*=-1),ce.envMapRotation.value.setFromMatrix4(_m1.makeRotationFromEuler(_e1)),ce.flipEnvMap.value=me.isCubeTexture&&me.isRenderTargetTexture===!1?-1:1,ce.reflectivity.value=he.reflectivity,ce.ior.value=he.ior,ce.refractionRatio.value=he.refractionRatio),he.lightMap&&(ce.lightMap.value=he.lightMap,ce.lightMapIntensity.value=he.lightMapIntensity,D(he.lightMap,ce.lightMapTransform)),he.aoMap&&(ce.aoMap.value=he.aoMap,ce.aoMapIntensity.value=he.aoMapIntensity,D(he.aoMap,ce.aoMapTransform))}function q(ce,he){ce.diffuse.value.copy(he.color),ce.opacity.value=he.opacity,he.map&&(ce.map.value=he.map,D(he.map,ce.mapTransform))}function K(ce,he){ce.dashSize.value=he.dashSize,ce.totalSize.value=he.dashSize+he.gapSize,ce.scale.value=he.scale}function ee(ce,he,pe,me){ce.diffuse.value.copy(he.color),ce.opacity.value=he.opacity,ce.size.value=he.size*pe,ce.scale.value=me*.5,he.map&&(ce.map.value=he.map,D(he.map,ce.uvTransform)),he.alphaMap&&(ce.alphaMap.value=he.alphaMap,D(he.alphaMap,ce.alphaMapTransform)),he.alphaTest>0&&(ce.alphaTest.value=he.alphaTest)}function Z(ce,he){ce.diffuse.value.copy(he.color),ce.opacity.value=he.opacity,ce.rotation.value=he.rotation,he.map&&(ce.map.value=he.map,D(he.map,ce.mapTransform)),he.alphaMap&&(ce.alphaMap.value=he.alphaMap,D(he.alphaMap,ce.alphaMapTransform)),he.alphaTest>0&&(ce.alphaTest.value=he.alphaTest)}function ie(ce,he){ce.specular.value.copy(he.specular),ce.shininess.value=Math.max(he.shininess,1e-4)}function Y(ce,he){he.gradientMap&&(ce.gradientMap.value=he.gradientMap)}function W(ce,he){ce.metalness.value=he.metalness,he.metalnessMap&&(ce.metalnessMap.value=he.metalnessMap,D(he.metalnessMap,ce.metalnessMapTransform)),ce.roughness.value=he.roughness,he.roughnessMap&&(ce.roughnessMap.value=he.roughnessMap,D(he.roughnessMap,ce.roughnessMapTransform)),he.envMap&&(ce.envMapIntensity.value=he.envMapIntensity)}function ne(ce,he,pe){ce.ior.value=he.ior,he.sheen>0&&(ce.sheenColor.value.copy(he.sheenColor).multiplyScalar(he.sheen),ce.sheenRoughness.value=he.sheenRoughness,he.sheenColorMap&&(ce.sheenColorMap.value=he.sheenColorMap,D(he.sheenColorMap,ce.sheenColorMapTransform)),he.sheenRoughnessMap&&(ce.sheenRoughnessMap.value=he.sheenRoughnessMap,D(he.sheenRoughnessMap,ce.sheenRoughnessMapTransform))),he.clearcoat>0&&(ce.clearcoat.value=he.clearcoat,ce.clearcoatRoughness.value=he.clearcoatRoughness,he.clearcoatMap&&(ce.clearcoatMap.value=he.clearcoatMap,D(he.clearcoatMap,ce.clearcoatMapTransform)),he.clearcoatRoughnessMap&&(ce.clearcoatRoughnessMap.value=he.clearcoatRoughnessMap,D(he.clearcoatRoughnessMap,ce.clearcoatRoughnessMapTransform)),he.clearcoatNormalMap&&(ce.clearcoatNormalMap.value=he.clearcoatNormalMap,D(he.clearcoatNormalMap,ce.clearcoatNormalMapTransform),ce.clearcoatNormalScale.value.copy(he.clearcoatNormalScale),he.side===BackSide&&ce.clearcoatNormalScale.value.negate())),he.dispersion>0&&(ce.dispersion.value=he.dispersion),he.iridescence>0&&(ce.iridescence.value=he.iridescence,ce.iridescenceIOR.value=he.iridescenceIOR,ce.iridescenceThicknessMinimum.value=he.iridescenceThicknessRange[0],ce.iridescenceThicknessMaximum.value=he.iridescenceThicknessRange[1],he.iridescenceMap&&(ce.iridescenceMap.value=he.iridescenceMap,D(he.iridescenceMap,ce.iridescenceMapTransform)),he.iridescenceThicknessMap&&(ce.iridescenceThicknessMap.value=he.iridescenceThicknessMap,D(he.iridescenceThicknessMap,ce.iridescenceThicknessMapTransform))),he.transmission>0&&(ce.transmission.value=he.transmission,ce.transmissionSamplerMap.value=pe.texture,ce.transmissionSamplerSize.value.set(pe.width,pe.height),he.transmissionMap&&(ce.transmissionMap.value=he.transmissionMap,D(he.transmissionMap,ce.transmissionMapTransform)),ce.thickness.value=he.thickness,he.thicknessMap&&(ce.thicknessMap.value=he.thicknessMap,D(he.thicknessMap,ce.thicknessMapTransform)),ce.attenuationDistance.value=he.attenuationDistance,ce.attenuationColor.value.copy(he.attenuationColor)),he.anisotropy>0&&(ce.anisotropyVector.value.set(he.anisotropy*Math.cos(he.anisotropyRotation),he.anisotropy*Math.sin(he.anisotropyRotation)),he.anisotropyMap&&(ce.anisotropyMap.value=he.anisotropyMap,D(he.anisotropyMap,ce.anisotropyMapTransform))),ce.specularIntensity.value=he.specularIntensity,ce.specularColor.value.copy(he.specularColor),he.specularColorMap&&(ce.specularColorMap.value=he.specularColorMap,D(he.specularColorMap,ce.specularColorMapTransform)),he.specularIntensityMap&&(ce.specularIntensityMap.value=he.specularIntensityMap,D(he.specularIntensityMap,ce.specularIntensityMapTransform))}function se(ce,he){he.matcap&&(ce.matcap.value=he.matcap)}function le(ce,he){const pe=w.get(he).light;ce.referencePosition.value.setFromMatrixPosition(pe.matrixWorld),ce.nearDistance.value=pe.shadow.camera.near,ce.farDistance.value=pe.shadow.camera.far}return{refreshFogUniforms:O,refreshMaterialUniforms:U}}function WebGLUniformsGroups(F,w,D,O){let U={},G={},q=[];const K=F.getParameter(F.MAX_UNIFORM_BUFFER_BINDINGS);function ee(pe,me){const be=me.program;O.uniformBlockBinding(pe,be)}function Z(pe,me){let be=U[pe.id];be===void 0&&(se(pe),be=ie(pe),U[pe.id]=be,pe.addEventListener("dispose",ce));const ge=me.program;O.updateUBOMapping(pe,ge);const ve=w.render.frame;G[pe.id]!==ve&&(W(pe),G[pe.id]=ve)}function ie(pe){const me=Y();pe.__bindingPointIndex=me;const be=F.createBuffer(),ge=pe.__size,ve=pe.usage;return F.bindBuffer(F.UNIFORM_BUFFER,be),F.bufferData(F.UNIFORM_BUFFER,ge,ve),F.bindBuffer(F.UNIFORM_BUFFER,null),F.bindBufferBase(F.UNIFORM_BUFFER,me,be),be}function Y(){for(let pe=0;pe<K;pe++)if(q.indexOf(pe)===-1)return q.push(pe),pe;return error("WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached."),0}function W(pe){const me=U[pe.id],be=pe.uniforms,ge=pe.__cache;F.bindBuffer(F.UNIFORM_BUFFER,me);for(let ve=0,Se=be.length;ve<Se;ve++){const Me=Array.isArray(be[ve])?be[ve]:[be[ve]];for(let Ee=0,we=Me.length;Ee<we;Ee++){const Re=Me[Ee];if(ne(Re,ve,Ee,ge)===!0){const Le=Re.__offset,Ne=Array.isArray(Re.value)?Re.value:[Re.value];let Oe=0;for(let Pe=0;Pe<Ne.length;Pe++){const Ce=Ne[Pe],Be=le(Ce);typeof Ce=="number"||typeof Ce=="boolean"?(Re.__data[0]=Ce,F.bufferSubData(F.UNIFORM_BUFFER,Le+Oe,Re.__data)):Ce.isMatrix3?(Re.__data[0]=Ce.elements[0],Re.__data[1]=Ce.elements[1],Re.__data[2]=Ce.elements[2],Re.__data[3]=0,Re.__data[4]=Ce.elements[3],Re.__data[5]=Ce.elements[4],Re.__data[6]=Ce.elements[5],Re.__data[7]=0,Re.__data[8]=Ce.elements[6],Re.__data[9]=Ce.elements[7],Re.__data[10]=Ce.elements[8],Re.__data[11]=0):(Ce.toArray(Re.__data,Oe),Oe+=Be.storage/Float32Array.BYTES_PER_ELEMENT)}F.bufferSubData(F.UNIFORM_BUFFER,Le,Re.__data)}}}F.bindBuffer(F.UNIFORM_BUFFER,null)}function ne(pe,me,be,ge){const ve=pe.value,Se=me+"_"+be;if(ge[Se]===void 0)return typeof ve=="number"||typeof ve=="boolean"?ge[Se]=ve:ge[Se]=ve.clone(),!0;{const Me=ge[Se];if(typeof ve=="number"||typeof ve=="boolean"){if(Me!==ve)return ge[Se]=ve,!0}else if(Me.equals(ve)===!1)return Me.copy(ve),!0}return!1}function se(pe){const me=pe.uniforms;let be=0;const ge=16;for(let Se=0,Me=me.length;Se<Me;Se++){const Ee=Array.isArray(me[Se])?me[Se]:[me[Se]];for(let we=0,Re=Ee.length;we<Re;we++){const Le=Ee[we],Ne=Array.isArray(Le.value)?Le.value:[Le.value];for(let Oe=0,Pe=Ne.length;Oe<Pe;Oe++){const Ce=Ne[Oe],Be=le(Ce),ze=be%ge,Xe=ze%Be.boundary,lt=ze+Xe;be+=Xe,lt!==0&&ge-lt<Be.storage&&(be+=ge-lt),Le.__data=new Float32Array(Be.storage/Float32Array.BYTES_PER_ELEMENT),Le.__offset=be,be+=Be.storage}}}const ve=be%ge;return ve>0&&(be+=ge-ve),pe.__size=be,pe.__cache={},this}function le(pe){const me={boundary:0,storage:0};return typeof pe=="number"||typeof pe=="boolean"?(me.boundary=4,me.storage=4):pe.isVector2?(me.boundary=8,me.storage=8):pe.isVector3||pe.isColor?(me.boundary=16,me.storage=12):pe.isVector4?(me.boundary=16,me.storage=16):pe.isMatrix3?(me.boundary=48,me.storage=48):pe.isMatrix4?(me.boundary=64,me.storage=64):pe.isTexture?warn("WebGLRenderer: Texture samplers can not be part of an uniforms group."):warn("WebGLRenderer: Unsupported uniform value type.",pe),me}function ce(pe){const me=pe.target;me.removeEventListener("dispose",ce);const be=q.indexOf(me.__bindingPointIndex);q.splice(be,1),F.deleteBuffer(U[me.id]),delete U[me.id],delete G[me.id]}function he(){for(const pe in U)F.deleteBuffer(U[pe]);q=[],U={},G={}}return{bind:ee,update:Z,dispose:he}}const DATA=new Uint16Array([11481,15204,11534,15171,11808,15015,12385,14843,12894,14716,13396,14600,13693,14483,13976,14366,14237,14171,14405,13961,14511,13770,14605,13598,14687,13444,14760,13305,14822,13066,14876,12857,14923,12675,14963,12517,14997,12379,15025,12230,15049,12023,15070,11843,15086,11687,15100,11551,15111,11433,15120,11330,15127,11217,15132,11060,15135,10922,15138,10801,15139,10695,15139,10600,13012,14923,13020,14917,13064,14886,13176,14800,13349,14666,13513,14526,13724,14398,13960,14230,14200,14020,14383,13827,14488,13651,14583,13491,14667,13348,14740,13132,14803,12908,14856,12713,14901,12542,14938,12394,14968,12241,14992,12017,15010,11822,15024,11654,15034,11507,15041,11380,15044,11269,15044,11081,15042,10913,15037,10764,15031,10635,15023,10520,15014,10419,15003,10330,13657,14676,13658,14673,13670,14660,13698,14622,13750,14547,13834,14442,13956,14317,14112,14093,14291,13889,14407,13704,14499,13538,14586,13389,14664,13201,14733,12966,14792,12758,14842,12577,14882,12418,14915,12272,14940,12033,14959,11826,14972,11646,14980,11490,14983,11355,14983,11212,14979,11008,14971,10830,14961,10675,14950,10540,14936,10420,14923,10315,14909,10204,14894,10041,14089,14460,14090,14459,14096,14452,14112,14431,14141,14388,14186,14305,14252,14130,14341,13941,14399,13756,14467,13585,14539,13430,14610,13272,14677,13026,14737,12808,14790,12617,14833,12449,14869,12303,14896,12065,14916,11845,14929,11655,14937,11490,14939,11347,14936,11184,14930,10970,14921,10783,14912,10621,14900,10480,14885,10356,14867,10247,14848,10062,14827,9894,14805,9745,14400,14208,14400,14206,14402,14198,14406,14174,14415,14122,14427,14035,14444,13913,14469,13767,14504,13613,14548,13463,14598,13324,14651,13082,14704,12858,14752,12658,14795,12483,14831,12330,14860,12106,14881,11875,14895,11675,14903,11501,14905,11351,14903,11178,14900,10953,14892,10757,14880,10589,14865,10442,14847,10313,14827,10162,14805,9965,14782,9792,14757,9642,14731,9507,14562,13883,14562,13883,14563,13877,14566,13862,14570,13830,14576,13773,14584,13689,14595,13582,14613,13461,14637,13336,14668,13120,14704,12897,14741,12695,14776,12516,14808,12358,14835,12150,14856,11910,14870,11701,14878,11519,14882,11361,14884,11187,14880,10951,14871,10748,14858,10572,14842,10418,14823,10286,14801,10099,14777,9897,14751,9722,14725,9567,14696,9430,14666,9309,14702,13604,14702,13604,14702,13600,14703,13591,14705,13570,14707,13533,14709,13477,14712,13400,14718,13305,14727,13106,14743,12907,14762,12716,14784,12539,14807,12380,14827,12190,14844,11943,14855,11727,14863,11539,14870,11376,14871,11204,14868,10960,14858,10748,14845,10565,14829,10406,14809,10269,14786,10058,14761,9852,14734,9671,14705,9512,14674,9374,14641,9253,14608,9076,14821,13366,14821,13365,14821,13364,14821,13358,14821,13344,14821,13320,14819,13252,14817,13145,14815,13011,14814,12858,14817,12698,14823,12539,14832,12389,14841,12214,14850,11968,14856,11750,14861,11558,14866,11390,14867,11226,14862,10972,14853,10754,14840,10565,14823,10401,14803,10259,14780,10032,14754,9820,14725,9635,14694,9473,14661,9333,14627,9203,14593,8988,14557,8798,14923,13014,14922,13014,14922,13012,14922,13004,14920,12987,14919,12957,14915,12907,14909,12834,14902,12738,14894,12623,14888,12498,14883,12370,14880,12203,14878,11970,14875,11759,14873,11569,14874,11401,14872,11243,14865,10986,14855,10762,14842,10568,14825,10401,14804,10255,14781,10017,14754,9799,14725,9611,14692,9445,14658,9301,14623,9139,14587,8920,14548,8729,14509,8562,15008,12672,15008,12672,15008,12671,15007,12667,15005,12656,15001,12637,14997,12605,14989,12556,14978,12490,14966,12407,14953,12313,14940,12136,14927,11934,14914,11742,14903,11563,14896,11401,14889,11247,14879,10992,14866,10767,14851,10570,14833,10400,14812,10252,14789,10007,14761,9784,14731,9592,14698,9424,14663,9279,14627,9088,14588,8868,14548,8676,14508,8508,14467,8360,15080,12386,15080,12386,15079,12385,15078,12383,15076,12378,15072,12367,15066,12347,15057,12315,15045,12253,15030,12138,15012,11998,14993,11845,14972,11685,14951,11530,14935,11383,14920,11228,14904,10981,14887,10762,14870,10567,14850,10397,14827,10248,14803,9997,14774,9771,14743,9578,14710,9407,14674,9259,14637,9048,14596,8826,14555,8632,14514,8464,14471,8317,14427,8182,15139,12008,15139,12008,15138,12008,15137,12007,15135,12003,15130,11990,15124,11969,15115,11929,15102,11872,15086,11794,15064,11693,15041,11581,15013,11459,14987,11336,14966,11170,14944,10944,14921,10738,14898,10552,14875,10387,14850,10239,14824,9983,14794,9758,14762,9563,14728,9392,14692,9244,14653,9014,14611,8791,14569,8597,14526,8427,14481,8281,14436,8110,14391,7885,15188,11617,15188,11617,15187,11617,15186,11618,15183,11617,15179,11612,15173,11601,15163,11581,15150,11546,15133,11495,15110,11427,15083,11346,15051,11246,15024,11057,14996,10868,14967,10687,14938,10517,14911,10362,14882,10206,14853,9956,14821,9737,14787,9543,14752,9375,14715,9228,14675,8980,14632,8760,14589,8565,14544,8395,14498,8248,14451,8049,14404,7824,14357,7630,15228,11298,15228,11298,15227,11299,15226,11301,15223,11303,15219,11302,15213,11299,15204,11290,15191,11271,15174,11217,15150,11129,15119,11015,15087,10886,15057,10744,15024,10599,14990,10455,14957,10318,14924,10143,14891,9911,14856,9701,14820,9516,14782,9352,14744,9200,14703,8946,14659,8725,14615,8533,14568,8366,14521,8220,14472,7992,14423,7770,14374,7578,14315,7408,15260,10819,15260,10819,15259,10822,15258,10826,15256,10832,15251,10836,15246,10841,15237,10838,15225,10821,15207,10788,15183,10734,15151,10660,15120,10571,15087,10469,15049,10359,15012,10249,14974,10041,14937,9837,14900,9647,14860,9475,14820,9320,14779,9147,14736,8902,14691,8688,14646,8499,14598,8335,14549,8189,14499,7940,14448,7720,14397,7529,14347,7363,14256,7218,15285,10410,15285,10411,15285,10413,15284,10418,15282,10425,15278,10434,15272,10442,15264,10449,15252,10445,15235,10433,15210,10403,15179,10358,15149,10301,15113,10218,15073,10059,15033,9894,14991,9726,14951,9565,14909,9413,14865,9273,14822,9073,14777,8845,14730,8641,14682,8459,14633,8300,14583,8129,14531,7883,14479,7670,14426,7482,14373,7321,14305,7176,14201,6939,15305,9939,15305,9940,15305,9945,15304,9955,15302,9967,15298,9989,15293,10010,15286,10033,15274,10044,15258,10045,15233,10022,15205,9975,15174,9903,15136,9808,15095,9697,15053,9578,15009,9451,14965,9327,14918,9198,14871,8973,14825,8766,14775,8579,14725,8408,14675,8259,14622,8058,14569,7821,14515,7615,14460,7435,14405,7276,14350,7108,14256,6866,14149,6653,15321,9444,15321,9445,15321,9448,15320,9458,15317,9470,15314,9490,15310,9515,15302,9540,15292,9562,15276,9579,15251,9577,15226,9559,15195,9519,15156,9463,15116,9389,15071,9304,15025,9208,14978,9023,14927,8838,14878,8661,14827,8496,14774,8344,14722,8206,14667,7973,14612,7749,14556,7555,14499,7382,14443,7229,14385,7025,14322,6791,14210,6588,14100,6409,15333,8920,15333,8921,15332,8927,15332,8943,15329,8965,15326,9002,15322,9048,15316,9106,15307,9162,15291,9204,15267,9221,15244,9221,15212,9196,15175,9134,15133,9043,15088,8930,15040,8801,14990,8665,14938,8526,14886,8391,14830,8261,14775,8087,14719,7866,14661,7664,14603,7482,14544,7322,14485,7178,14426,6936,14367,6713,14281,6517,14166,6348,14054,6198,15341,8360,15341,8361,15341,8366,15341,8379,15339,8399,15336,8431,15332,8473,15326,8527,15318,8585,15302,8632,15281,8670,15258,8690,15227,8690,15191,8664,15149,8612,15104,8543,15055,8456,15001,8360,14948,8259,14892,8122,14834,7923,14776,7734,14716,7558,14656,7397,14595,7250,14534,7070,14472,6835,14410,6628,14350,6443,14243,6283,14125,6135,14010,5889,15348,7715,15348,7717,15348,7725,15347,7745,15345,7780,15343,7836,15339,7905,15334,8e3,15326,8103,15310,8193,15293,8239,15270,8270,15240,8287,15204,8283,15163,8260,15118,8223,15067,8143,15014,8014,14958,7873,14899,7723,14839,7573,14778,7430,14715,7293,14652,7164,14588,6931,14524,6720,14460,6531,14396,6362,14330,6210,14207,6015,14086,5781,13969,5576,15352,7114,15352,7116,15352,7128,15352,7159,15350,7195,15348,7237,15345,7299,15340,7374,15332,7457,15317,7544,15301,7633,15280,7703,15251,7754,15216,7775,15176,7767,15131,7733,15079,7670,15026,7588,14967,7492,14906,7387,14844,7278,14779,7171,14714,6965,14648,6770,14581,6587,14515,6420,14448,6269,14382,6123,14299,5881,14172,5665,14049,5477,13929,5310,15355,6329,15355,6330,15355,6339,15355,6362,15353,6410,15351,6472,15349,6572,15344,6688,15337,6835,15323,6985,15309,7142,15287,7220,15260,7277,15226,7310,15188,7326,15142,7318,15090,7285,15036,7239,14976,7177,14914,7045,14849,6892,14782,6736,14714,6581,14645,6433,14576,6293,14506,6164,14438,5946,14369,5733,14270,5540,14140,5369,14014,5216,13892,5043,15357,5483,15357,5484,15357,5496,15357,5528,15356,5597,15354,5692,15351,5835,15347,6011,15339,6195,15328,6317,15314,6446,15293,6566,15268,6668,15235,6746,15197,6796,15152,6811,15101,6790,15046,6748,14985,6673,14921,6583,14854,6479,14785,6371,14714,6259,14643,6149,14571,5946,14499,5750,14428,5567,14358,5401,14242,5250,14109,5111,13980,4870,13856,4657,15359,4555,15359,4557,15358,4573,15358,4633,15357,4715,15355,4841,15353,5061,15349,5216,15342,5391,15331,5577,15318,5770,15299,5967,15274,6150,15243,6223,15206,6280,15161,6310,15111,6317,15055,6300,14994,6262,14928,6208,14860,6141,14788,5994,14715,5838,14641,5684,14566,5529,14492,5384,14418,5247,14346,5121,14216,4892,14079,4682,13948,4496,13822,4330,15359,3498,15359,3501,15359,3520,15359,3598,15358,3719,15356,3860,15355,4137,15351,4305,15344,4563,15334,4809,15321,5116,15303,5273,15280,5418,15250,5547,15214,5653,15170,5722,15120,5761,15064,5763,15002,5733,14935,5673,14865,5597,14792,5504,14716,5400,14640,5294,14563,5185,14486,5041,14410,4841,14335,4655,14191,4482,14051,4325,13918,4183,13790,4012,15360,2282,15360,2285,15360,2306,15360,2401,15359,2547,15357,2748,15355,3103,15352,3349,15345,3675,15336,4020,15324,4272,15307,4496,15285,4716,15255,4908,15220,5086,15178,5170,15128,5214,15072,5234,15010,5231,14943,5206,14871,5166,14796,5102,14718,4971,14639,4833,14559,4687,14480,4541,14402,4401,14315,4268,14167,4142,14025,3958,13888,3747,13759,3556,15360,923,15360,925,15360,946,15360,1052,15359,1214,15357,1494,15356,1892,15352,2274,15346,2663,15338,3099,15326,3393,15309,3679,15288,3980,15260,4183,15226,4325,15185,4437,15136,4517,15080,4570,15018,4591,14950,4581,14877,4545,14800,4485,14720,4411,14638,4325,14556,4231,14475,4136,14395,3988,14297,3803,14145,3628,13999,3465,13861,3314,13729,3177,15360,263,15360,264,15360,272,15360,325,15359,407,15358,548,15356,780,15352,1144,15347,1580,15339,2099,15328,2425,15312,2795,15292,3133,15264,3329,15232,3517,15191,3689,15143,3819,15088,3923,15025,3978,14956,3999,14882,3979,14804,3931,14722,3855,14639,3756,14554,3645,14470,3529,14388,3409,14279,3289,14124,3173,13975,3055,13834,2848,13701,2658,15360,49,15360,49,15360,52,15360,75,15359,111,15358,201,15356,283,15353,519,15348,726,15340,1045,15329,1415,15314,1795,15295,2173,15269,2410,15237,2649,15197,2866,15150,3054,15095,3140,15032,3196,14963,3228,14888,3236,14808,3224,14725,3191,14639,3146,14553,3088,14466,2976,14382,2836,14262,2692,14103,2549,13952,2409,13808,2278,13674,2154,15360,4,15360,4,15360,4,15360,13,15359,33,15358,59,15357,112,15353,199,15348,302,15341,456,15331,628,15316,827,15297,1082,15272,1332,15241,1601,15202,1851,15156,2069,15101,2172,15039,2256,14970,2314,14894,2348,14813,2358,14728,2344,14640,2311,14551,2263,14463,2203,14376,2133,14247,2059,14084,1915,13930,1761,13784,1609,13648,1464,15360,0,15360,0,15360,0,15360,3,15359,18,15358,26,15357,53,15354,80,15348,97,15341,165,15332,238,15318,326,15299,427,15275,529,15245,654,15207,771,15161,885,15108,994,15046,1089,14976,1170,14900,1229,14817,1266,14731,1284,14641,1282,14550,1260,14460,1223,14370,1174,14232,1116,14066,1050,13909,981,13761,910,13623,839]);let lut=null;function getDFGLUT(){return lut===null&&(lut=new DataTexture(DATA,32,32,RGFormat,HalfFloatType),lut.minFilter=LinearFilter,lut.magFilter=LinearFilter,lut.wrapS=ClampToEdgeWrapping,lut.wrapT=ClampToEdgeWrapping,lut.generateMipmaps=!1,lut.needsUpdate=!0),lut}class WebGLRenderer{constructor(w={}){const{canvas:D=createCanvasElement(),context:O=null,depth:U=!0,stencil:G=!1,alpha:q=!1,antialias:K=!1,premultipliedAlpha:ee=!0,preserveDrawingBuffer:Z=!1,powerPreference:ie="default",failIfMajorPerformanceCaveat:Y=!1,reversedDepthBuffer:W=!1}=w;this.isWebGLRenderer=!0;let ne;if(O!==null){if(typeof WebGLRenderingContext<"u"&&O instanceof WebGLRenderingContext)throw new Error("THREE.WebGLRenderer: WebGL 1 is not supported since r163.");ne=O.getContextAttributes().alpha}else ne=q;const se=new Set([RGBAIntegerFormat,RGIntegerFormat,RedIntegerFormat]),le=new Set([UnsignedByteType,UnsignedIntType,UnsignedShortType,UnsignedInt248Type,UnsignedShort4444Type,UnsignedShort5551Type]),ce=new Uint32Array(4),he=new Int32Array(4);let pe=null,me=null;const be=[],ge=[];this.domElement=D,this.debug={checkShaderErrors:!0,onShaderError:null},this.autoClear=!0,this.autoClearColor=!0,this.autoClearDepth=!0,this.autoClearStencil=!0,this.sortObjects=!0,this.clippingPlanes=[],this.localClippingEnabled=!1,this.toneMapping=NoToneMapping,this.toneMappingExposure=1,this.transmissionResolutionScale=1;const ve=this;let Se=!1;this._outputColorSpace=SRGBColorSpace;let Me=0,Ee=0,we=null,Re=-1,Le=null;const Ne=new Vector4,Oe=new Vector4;let Pe=null;const Ce=new Color(0);let Be=0,ze=D.width,Xe=D.height,lt=1,ke=null,rt=null;const St=new Vector4(0,0,ze,Xe),Lt=new Vector4(0,0,ze,Xe);let $t=!1;const mt=new Frustum;let bt=!1,Xt=!1;const hn=new Matrix4,Jt=new Vector3,Mn=new Vector4,Zn={background:null,fog:null,environment:null,overrideMaterial:null,isScene:!0};let vn=!1;function In(){return we===null?lt:1}let st=O;function Gn(Ue,ct){return D.getContext(Ue,ct)}try{const Ue={alpha:!0,depth:U,stencil:G,antialias:K,premultipliedAlpha:ee,preserveDrawingBuffer:Z,powerPreference:ie,failIfMajorPerformanceCaveat:Y};if("setAttribute"in D&&D.setAttribute("data-engine",`three.js r${REVISION}`),D.addEventListener("webglcontextlost",Bt,!1),D.addEventListener("webglcontextrestored",wt,!1),D.addEventListener("webglcontextcreationerror",Qt,!1),st===null){const ct="webgl2";if(st=Gn(ct,Ue),st===null)throw Gn(ct)?new Error("Error creating WebGL context with your selected attributes."):new Error("Error creating WebGL context.")}}catch(Ue){throw Ue("WebGLRenderer: "+Ue.message),Ue}let qn,ai,yn,li,Tn,En,Ke,Fe,pt,zt,qt,Nt,Rn,fn,Nn,An,Wt,Dt,Bn,Sn,bn,kn,nt,dn;function tn(){qn=new WebGLExtensions(st),qn.init(),kn=new WebGLUtils(st,qn),ai=new WebGLCapabilities(st,qn,w,kn),yn=new WebGLState(st,qn),ai.reversedDepthBuffer&&W&&yn.buffers.depth.setReversed(!0),li=new WebGLInfo(st),Tn=new WebGLProperties,En=new WebGLTextures(st,qn,yn,Tn,ai,kn,li),Ke=new WebGLCubeMaps(ve),Fe=new WebGLCubeUVMaps(ve),pt=new WebGLAttributes(st),nt=new WebGLBindingStates(st,pt),zt=new WebGLGeometries(st,pt,li,nt),qt=new WebGLObjects(st,zt,pt,li),Bn=new WebGLMorphtargets(st,ai,En),An=new WebGLClipping(Tn),Nt=new WebGLPrograms(ve,Ke,Fe,qn,ai,nt,An),Rn=new WebGLMaterials(ve,Tn),fn=new WebGLRenderLists,Nn=new WebGLRenderStates(qn),Dt=new WebGLBackground(ve,Ke,Fe,yn,qt,ne,ee),Wt=new WebGLShadowMap(ve,qt,ai),dn=new WebGLUniformsGroups(st,li,ai,yn),Sn=new WebGLBufferRenderer(st,qn,li),bn=new WebGLIndexedBufferRenderer(st,qn,li),li.programs=Nt.programs,ve.capabilities=ai,ve.extensions=qn,ve.properties=Tn,ve.renderLists=fn,ve.shadowMap=Wt,ve.state=yn,ve.info=li}tn();const Zt=new WebXRManager(ve,st);this.xr=Zt,this.getContext=function(){return st},this.getContextAttributes=function(){return st.getContextAttributes()},this.forceContextLoss=function(){const Ue=qn.get("WEBGL_lose_context");Ue&&Ue.loseContext()},this.forceContextRestore=function(){const Ue=qn.get("WEBGL_lose_context");Ue&&Ue.restoreContext()},this.getPixelRatio=function(){return lt},this.setPixelRatio=function(Ue){Ue!==void 0&&(lt=Ue,this.setSize(ze,Xe,!1))},this.getSize=function(Ue){return Ue.set(ze,Xe)},this.setSize=function(Ue,ct,vt=!0){if(Zt.isPresenting){warn("WebGLRenderer: Can't change size while VR device is presenting.");return}ze=Ue,Xe=ct,D.width=Math.floor(Ue*lt),D.height=Math.floor(ct*lt),vt===!0&&(D.style.width=Ue+"px",D.style.height=ct+"px"),this.setViewport(0,0,Ue,ct)},this.getDrawingBufferSize=function(Ue){return Ue.set(ze*lt,Xe*lt).floor()},this.setDrawingBufferSize=function(Ue,ct,vt){ze=Ue,Xe=ct,lt=vt,D.width=Math.floor(Ue*vt),D.height=Math.floor(ct*vt),this.setViewport(0,0,Ue,ct)},this.getCurrentViewport=function(Ue){return Ue.copy(Ne)},this.getViewport=function(Ue){return Ue.copy(St)},this.setViewport=function(Ue,ct,vt,_t){Ue.isVector4?St.set(Ue.x,Ue.y,Ue.z,Ue.w):St.set(Ue,ct,vt,_t),yn.viewport(Ne.copy(St).multiplyScalar(lt).round())},this.getScissor=function(Ue){return Ue.copy(Lt)},this.setScissor=function(Ue,ct,vt,_t){Ue.isVector4?Lt.set(Ue.x,Ue.y,Ue.z,Ue.w):Lt.set(Ue,ct,vt,_t),yn.scissor(Oe.copy(Lt).multiplyScalar(lt).round())},this.getScissorTest=function(){return $t},this.setScissorTest=function(Ue){yn.setScissorTest($t=Ue)},this.setOpaqueSort=function(Ue){ke=Ue},this.setTransparentSort=function(Ue){rt=Ue},this.getClearColor=function(Ue){return Ue.copy(Dt.getClearColor())},this.setClearColor=function(){Dt.setClearColor(...arguments)},this.getClearAlpha=function(){return Dt.getClearAlpha()},this.setClearAlpha=function(){Dt.setClearAlpha(...arguments)},this.clear=function(Ue=!0,ct=!0,vt=!0){let _t=0;if(Ue){let je=!1;if(we!==null){const Gt=we.texture.format;je=se.has(Gt)}if(je){const Gt=we.texture.type,Yt=le.has(Gt),mn=Dt.getClearColor(),_n=Dt.getClearAlpha(),zn=mn.r,Wn=mn.g,$n=mn.b;Yt?(ce[0]=zn,ce[1]=Wn,ce[2]=$n,ce[3]=_n,st.clearBufferuiv(st.COLOR,0,ce)):(he[0]=zn,he[1]=Wn,he[2]=$n,he[3]=_n,st.clearBufferiv(st.COLOR,0,he))}else _t|=st.COLOR_BUFFER_BIT}ct&&(_t|=st.DEPTH_BUFFER_BIT),vt&&(_t|=st.STENCIL_BUFFER_BIT,this.state.buffers.stencil.setMask(4294967295)),st.clear(_t)},this.clearColor=function(){this.clear(!0,!1,!1)},this.clearDepth=function(){this.clear(!1,!0,!1)},this.clearStencil=function(){this.clear(!1,!1,!0)},this.dispose=function(){D.removeEventListener("webglcontextlost",Bt,!1),D.removeEventListener("webglcontextrestored",wt,!1),D.removeEventListener("webglcontextcreationerror",Qt,!1),Dt.dispose(),fn.dispose(),Nn.dispose(),Tn.dispose(),Ke.dispose(),Fe.dispose(),qt.dispose(),nt.dispose(),dn.dispose(),Nt.dispose(),Zt.dispose(),Zt.removeEventListener("sessionstart",Qr),Zt.removeEventListener("sessionend",qr),hr.stop()};function Bt(Ue){Ue.preventDefault(),log("WebGLRenderer: Context Lost."),Se=!0}function wt(){log("WebGLRenderer: Context Restored."),Se=!1;const Ue=li.autoReset,ct=Wt.enabled,vt=Wt.autoUpdate,_t=Wt.needsUpdate,je=Wt.type;tn(),li.autoReset=Ue,Wt.enabled=ct,Wt.autoUpdate=vt,Wt.needsUpdate=_t,Wt.type=je}function Qt(Ue){error("WebGLRenderer: A WebGL context could not be created. Reason: ",Ue.statusMessage)}function Yn(Ue){const ct=Ue.target;ct.removeEventListener("dispose",Yn),Ai(ct)}function Ai(Ue){hi(Ue),Tn.remove(Ue)}function hi(Ue){const ct=Tn.get(Ue).programs;ct!==void 0&&(ct.forEach(function(vt){Nt.releaseProgram(vt)}),Ue.isShaderMaterial&&Nt.releaseShaderCache(Ue))}this.renderBufferDirect=function(Ue,ct,vt,_t,je,Gt){ct===null&&(ct=Zn);const Yt=je.isMesh&&je.matrixWorld.determinant()<0,mn=yt(Ue,ct,vt,_t,je);yn.setMaterial(_t,Yt);let _n=vt.index,zn=1;if(_t.wireframe===!0){if(_n=zt.getWireframeAttribute(vt),_n===void 0)return;zn=2}const Wn=vt.drawRange,$n=vt.attributes.position;let jn=Wn.start*zn,fi=(Wn.start+Wn.count)*zn;Gt!==null&&(jn=Math.max(jn,Gt.start*zn),fi=Math.min(fi,(Gt.start+Gt.count)*zn)),_n!==null?(jn=Math.max(jn,0),fi=Math.min(fi,_n.count)):$n!=null&&(jn=Math.max(jn,0),fi=Math.min(fi,$n.count));const vi=fi-jn;if(vi<0||vi===1/0)return;nt.setup(je,_t,mn,vt,_n);let pi,Ti=Sn;if(_n!==null&&(pi=pt.get(_n),Ti=bn,Ti.setIndex(pi)),je.isMesh)_t.wireframe===!0?(yn.setLineWidth(_t.wireframeLinewidth*In()),Ti.setMode(st.LINES)):Ti.setMode(st.TRIANGLES);else if(je.isLine){let Hn=_t.linewidth;Hn===void 0&&(Hn=1),yn.setLineWidth(Hn*In()),je.isLineSegments?Ti.setMode(st.LINES):je.isLineLoop?Ti.setMode(st.LINE_LOOP):Ti.setMode(st.LINE_STRIP)}else je.isPoints?Ti.setMode(st.POINTS):je.isSprite&&Ti.setMode(st.TRIANGLES);if(je.isBatchedMesh)if(je._multiDrawInstances!==null)warnOnce("WebGLRenderer: renderMultiDrawInstances has been deprecated and will be removed in r184. Append to renderMultiDraw arguments and use indirection."),Ti.renderMultiDrawInstances(je._multiDrawStarts,je._multiDrawCounts,je._multiDrawCount,je._multiDrawInstances);else if(qn.get("WEBGL_multi_draw"))Ti.renderMultiDraw(je._multiDrawStarts,je._multiDrawCounts,je._multiDrawCount);else{const Hn=je._multiDrawStarts,Di=je._multiDrawCounts,ui=je._multiDrawCount,Yi=_n?pt.get(_n).bytesPerElement:1,Yr=Tn.get(_t).currentProgram.getUniforms();for(let Bi=0;Bi<ui;Bi++)Yr.setValue(st,"_gl_DrawID",Bi),Ti.render(Hn[Bi]/Yi,Di[Bi])}else if(je.isInstancedMesh)Ti.renderInstances(jn,vi,je.count);else if(vt.isInstancedBufferGeometry){const Hn=vt._maxInstanceCount!==void 0?vt._maxInstanceCount:1/0,Di=Math.min(vt.instanceCount,Hn);Ti.renderInstances(jn,vi,Di)}else Ti.render(jn,vi)};function Xi(Ue,ct,vt){Ue.transparent===!0&&Ue.side===DoubleSide&&Ue.forceSinglePass===!1?(Ue.side=BackSide,Ue.needsUpdate=!0,Ge(Ue,ct,vt),Ue.side=FrontSide,Ue.needsUpdate=!0,Ge(Ue,ct,vt),Ue.side=DoubleSide):Ge(Ue,ct,vt)}this.compile=function(Ue,ct,vt=null){vt===null&&(vt=Ue),me=Nn.get(vt),me.init(ct),ge.push(me),vt.traverseVisible(function(je){je.isLight&&je.layers.test(ct.layers)&&(me.pushLight(je),je.castShadow&&me.pushShadow(je))}),Ue!==vt&&Ue.traverseVisible(function(je){je.isLight&&je.layers.test(ct.layers)&&(me.pushLight(je),je.castShadow&&me.pushShadow(je))}),me.setupLights();const _t=new Set;return Ue.traverse(function(je){if(!(je.isMesh||je.isPoints||je.isLine||je.isSprite))return;const Gt=je.material;if(Gt)if(Array.isArray(Gt))for(let Yt=0;Yt<Gt.length;Yt++){const mn=Gt[Yt];Xi(mn,vt,je),_t.add(mn)}else Xi(Gt,vt,je),_t.add(Gt)}),me=ge.pop(),_t},this.compileAsync=function(Ue,ct,vt=null){const _t=this.compile(Ue,ct,vt);return new Promise(je=>{function Gt(){if(_t.forEach(function(Yt){Tn.get(Yt).currentProgram.isReady()&&_t.delete(Yt)}),_t.size===0){je(Ue);return}setTimeout(Gt,10)}qn.get("KHR_parallel_shader_compile")!==null?Gt():setTimeout(Gt,10)})};let lr=null;function es(Ue){lr&&lr(Ue)}function Qr(){hr.stop()}function qr(){hr.start()}const hr=new WebGLAnimation;hr.setAnimationLoop(es),typeof self<"u"&&hr.setContext(self),this.setAnimationLoop=function(Ue){lr=Ue,Zt.setAnimationLoop(Ue),Ue===null?hr.stop():hr.start()},Zt.addEventListener("sessionstart",Qr),Zt.addEventListener("sessionend",qr),this.render=function(Ue,ct){if(ct!==void 0&&ct.isCamera!==!0){error("WebGLRenderer.render: camera is not an instance of THREE.Camera.");return}if(Se===!0)return;if(Ue.matrixWorldAutoUpdate===!0&&Ue.updateMatrixWorld(),ct.parent===null&&ct.matrixWorldAutoUpdate===!0&&ct.updateMatrixWorld(),Zt.enabled===!0&&Zt.isPresenting===!0&&(Zt.cameraAutoUpdate===!0&&Zt.updateCamera(ct),ct=Zt.getCamera()),Ue.isScene===!0&&Ue.onBeforeRender(ve,Ue,ct,we),me=Nn.get(Ue,ge.length),me.init(ct),ge.push(me),hn.multiplyMatrices(ct.projectionMatrix,ct.matrixWorldInverse),mt.setFromProjectionMatrix(hn,WebGLCoordinateSystem,ct.reversedDepth),Xt=this.localClippingEnabled,bt=An.init(this.clippingPlanes,Xt),pe=fn.get(Ue,be.length),pe.init(),be.push(pe),Zt.enabled===!0&&Zt.isPresenting===!0){const Gt=ve.xr.getDepthSensingMesh();Gt!==null&&wr(Gt,ct,-1/0,ve.sortObjects)}wr(Ue,ct,0,ve.sortObjects),pe.finish(),ve.sortObjects===!0&&pe.sort(ke,rt),vn=Zt.enabled===!1||Zt.isPresenting===!1||Zt.hasDepthSensing()===!1,vn&&Dt.addToRenderList(pe,Ue),this.info.render.frame++,bt===!0&&An.beginShadows();const vt=me.state.shadowsArray;Wt.render(vt,Ue,ct),bt===!0&&An.endShadows(),this.info.autoReset===!0&&this.info.reset();const _t=pe.opaque,je=pe.transmissive;if(me.setupLights(),ct.isArrayCamera){const Gt=ct.cameras;if(je.length>0)for(let Yt=0,mn=Gt.length;Yt<mn;Yt++){const _n=Gt[Yt];Xr(_t,je,Ue,_n)}vn&&Dt.render(Ue);for(let Yt=0,mn=Gt.length;Yt<mn;Yt++){const _n=Gt[Yt];Wr(pe,Ue,_n,_n.viewport)}}else je.length>0&&Xr(_t,je,Ue,ct),vn&&Dt.render(Ue),Wr(pe,Ue,ct);we!==null&&Ee===0&&(En.updateMultisampleRenderTarget(we),En.updateRenderTargetMipmap(we)),Ue.isScene===!0&&Ue.onAfterRender(ve,Ue,ct),nt.resetDefaultState(),Re=-1,Le=null,ge.pop(),ge.length>0?(me=ge[ge.length-1],bt===!0&&An.setGlobalState(ve.clippingPlanes,me.state.camera)):me=null,be.pop(),be.length>0?pe=be[be.length-1]:pe=null};function wr(Ue,ct,vt,_t){if(Ue.visible===!1)return;if(Ue.layers.test(ct.layers)){if(Ue.isGroup)vt=Ue.renderOrder;else if(Ue.isLOD)Ue.autoUpdate===!0&&Ue.update(ct);else if(Ue.isLight)me.pushLight(Ue),Ue.castShadow&&me.pushShadow(Ue);else if(Ue.isSprite){if(!Ue.frustumCulled||mt.intersectsSprite(Ue)){_t&&Mn.setFromMatrixPosition(Ue.matrixWorld).applyMatrix4(hn);const Yt=qt.update(Ue),mn=Ue.material;mn.visible&&pe.push(Ue,Yt,mn,vt,Mn.z,null)}}else if((Ue.isMesh||Ue.isLine||Ue.isPoints)&&(!Ue.frustumCulled||mt.intersectsObject(Ue))){const Yt=qt.update(Ue),mn=Ue.material;if(_t&&(Ue.boundingSphere!==void 0?(Ue.boundingSphere===null&&Ue.computeBoundingSphere(),Mn.copy(Ue.boundingSphere.center)):(Yt.boundingSphere===null&&Yt.computeBoundingSphere(),Mn.copy(Yt.boundingSphere.center)),Mn.applyMatrix4(Ue.matrixWorld).applyMatrix4(hn)),Array.isArray(mn)){const _n=Yt.groups;for(let zn=0,Wn=_n.length;zn<Wn;zn++){const $n=_n[zn],jn=mn[$n.materialIndex];jn&&jn.visible&&pe.push(Ue,Yt,jn,vt,Mn.z,$n)}}else mn.visible&&pe.push(Ue,Yt,mn,vt,Mn.z,null)}}const Gt=Ue.children;for(let Yt=0,mn=Gt.length;Yt<mn;Yt++)wr(Gt[Yt],ct,vt,_t)}function Wr(Ue,ct,vt,_t){const{opaque:je,transmissive:Gt,transparent:Yt}=Ue;me.setupLightsView(vt),bt===!0&&An.setGlobalState(ve.clippingPlanes,vt),_t&&yn.viewport(Ne.copy(_t)),je.length>0&&cr(je,ct,vt),Gt.length>0&&cr(Gt,ct,vt),Yt.length>0&&cr(Yt,ct,vt),yn.buffers.depth.setTest(!0),yn.buffers.depth.setMask(!0),yn.buffers.color.setMask(!0),yn.setPolygonOffset(!1)}function Xr(Ue,ct,vt,_t){if((vt.isScene===!0?vt.overrideMaterial:null)!==null)return;me.state.transmissionRenderTarget[_t.id]===void 0&&(me.state.transmissionRenderTarget[_t.id]=new WebGLRenderTarget(1,1,{generateMipmaps:!0,type:qn.has("EXT_color_buffer_half_float")||qn.has("EXT_color_buffer_float")?HalfFloatType:UnsignedByteType,minFilter:LinearMipmapLinearFilter,samples:4,stencilBuffer:G,resolveDepthBuffer:!1,resolveStencilBuffer:!1,colorSpace:ColorManagement.workingColorSpace}));const Gt=me.state.transmissionRenderTarget[_t.id],Yt=_t.viewport||Ne;Gt.setSize(Yt.z*ve.transmissionResolutionScale,Yt.w*ve.transmissionResolutionScale);const mn=ve.getRenderTarget(),_n=ve.getActiveCubeFace(),zn=ve.getActiveMipmapLevel();ve.setRenderTarget(Gt),ve.getClearColor(Ce),Be=ve.getClearAlpha(),Be<1&&ve.setClearColor(16777215,.5),ve.clear(),vn&&Dt.render(vt);const Wn=ve.toneMapping;ve.toneMapping=NoToneMapping;const $n=_t.viewport;if(_t.viewport!==void 0&&(_t.viewport=void 0),me.setupLightsView(_t),bt===!0&&An.setGlobalState(ve.clippingPlanes,_t),cr(Ue,vt,_t),En.updateMultisampleRenderTarget(Gt),En.updateRenderTargetMipmap(Gt),qn.has("WEBGL_multisampled_render_to_texture")===!1){let jn=!1;for(let fi=0,vi=ct.length;fi<vi;fi++){const pi=ct[fi],{object:Ti,geometry:Hn,material:Di,group:ui}=pi;if(Di.side===DoubleSide&&Ti.layers.test(_t.layers)){const Yi=Di.side;Di.side=BackSide,Di.needsUpdate=!0,ji(Ti,vt,_t,Hn,Di,ui),Di.side=Yi,Di.needsUpdate=!0,jn=!0}}jn===!0&&(En.updateMultisampleRenderTarget(Gt),En.updateRenderTargetMipmap(Gt))}ve.setRenderTarget(mn,_n,zn),ve.setClearColor(Ce,Be),$n!==void 0&&(_t.viewport=$n),ve.toneMapping=Wn}function cr(Ue,ct,vt){const _t=ct.isScene===!0?ct.overrideMaterial:null;for(let je=0,Gt=Ue.length;je<Gt;je++){const Yt=Ue[je],{object:mn,geometry:_n,group:zn}=Yt;let Wn=Yt.material;Wn.allowOverride===!0&&_t!==null&&(Wn=_t),mn.layers.test(vt.layers)&&ji(mn,ct,vt,_n,Wn,zn)}}function ji(Ue,ct,vt,_t,je,Gt){Ue.onBeforeRender(ve,ct,vt,_t,je,Gt),Ue.modelViewMatrix.multiplyMatrices(vt.matrixWorldInverse,Ue.matrixWorld),Ue.normalMatrix.getNormalMatrix(Ue.modelViewMatrix),je.onBeforeRender(ve,ct,vt,_t,Ue,Gt),je.transparent===!0&&je.side===DoubleSide&&je.forceSinglePass===!1?(je.side=BackSide,je.needsUpdate=!0,ve.renderBufferDirect(vt,ct,_t,je,Ue,Gt),je.side=FrontSide,je.needsUpdate=!0,ve.renderBufferDirect(vt,ct,_t,je,Ue,Gt),je.side=DoubleSide):ve.renderBufferDirect(vt,ct,_t,je,Ue,Gt),Ue.onAfterRender(ve,ct,vt,_t,je,Gt)}function Ge(Ue,ct,vt){ct.isScene!==!0&&(ct=Zn);const _t=Tn.get(Ue),je=me.state.lights,Gt=me.state.shadowsArray,Yt=je.state.version,mn=Nt.getParameters(Ue,je.state,Gt,ct,vt),_n=Nt.getProgramCacheKey(mn);let zn=_t.programs;_t.environment=Ue.isMeshStandardMaterial?ct.environment:null,_t.fog=ct.fog,_t.envMap=(Ue.isMeshStandardMaterial?Fe:Ke).get(Ue.envMap||_t.environment),_t.envMapRotation=_t.environment!==null&&Ue.envMap===null?ct.environmentRotation:Ue.envMapRotation,zn===void 0&&(Ue.addEventListener("dispose",Yn),zn=new Map,_t.programs=zn);let Wn=zn.get(_n);if(Wn!==void 0){if(_t.currentProgram===Wn&&_t.lightsStateVersion===Yt)return ft(Ue,mn),Wn}else mn.uniforms=Nt.getUniforms(Ue),Ue.onBeforeCompile(mn,ve),Wn=Nt.acquireProgram(mn,_n),zn.set(_n,Wn),_t.uniforms=mn.uniforms;const $n=_t.uniforms;return(!Ue.isShaderMaterial&&!Ue.isRawShaderMaterial||Ue.clipping===!0)&&($n.clippingPlanes=An.uniform),ft(Ue,mn),_t.needsLights=kt(Ue),_t.lightsStateVersion=Yt,_t.needsLights&&($n.ambientLightColor.value=je.state.ambient,$n.lightProbe.value=je.state.probe,$n.directionalLights.value=je.state.directional,$n.directionalLightShadows.value=je.state.directionalShadow,$n.spotLights.value=je.state.spot,$n.spotLightShadows.value=je.state.spotShadow,$n.rectAreaLights.value=je.state.rectArea,$n.ltc_1.value=je.state.rectAreaLTC1,$n.ltc_2.value=je.state.rectAreaLTC2,$n.pointLights.value=je.state.point,$n.pointLightShadows.value=je.state.pointShadow,$n.hemisphereLights.value=je.state.hemi,$n.directionalShadowMap.value=je.state.directionalShadowMap,$n.directionalShadowMatrix.value=je.state.directionalShadowMatrix,$n.spotShadowMap.value=je.state.spotShadowMap,$n.spotLightMatrix.value=je.state.spotLightMatrix,$n.spotLightMap.value=je.state.spotLightMap,$n.pointShadowMap.value=je.state.pointShadowMap,$n.pointShadowMatrix.value=je.state.pointShadowMatrix),_t.currentProgram=Wn,_t.uniformsList=null,Wn}function tt(Ue){if(Ue.uniformsList===null){const ct=Ue.currentProgram.getUniforms();Ue.uniformsList=WebGLUniforms.seqWithValue(ct.seq,Ue.uniforms)}return Ue.uniformsList}function ft(Ue,ct){const vt=Tn.get(Ue);vt.outputColorSpace=ct.outputColorSpace,vt.batching=ct.batching,vt.batchingColor=ct.batchingColor,vt.instancing=ct.instancing,vt.instancingColor=ct.instancingColor,vt.instancingMorph=ct.instancingMorph,vt.skinning=ct.skinning,vt.morphTargets=ct.morphTargets,vt.morphNormals=ct.morphNormals,vt.morphColors=ct.morphColors,vt.morphTargetsCount=ct.morphTargetsCount,vt.numClippingPlanes=ct.numClippingPlanes,vt.numIntersection=ct.numClipIntersection,vt.vertexAlphas=ct.vertexAlphas,vt.vertexTangents=ct.vertexTangents,vt.toneMapping=ct.toneMapping}function yt(Ue,ct,vt,_t,je){ct.isScene!==!0&&(ct=Zn),En.resetTextureUnits();const Gt=ct.fog,Yt=_t.isMeshStandardMaterial?ct.environment:null,mn=we===null?ve.outputColorSpace:we.isXRRenderTarget===!0?we.texture.colorSpace:LinearSRGBColorSpace,_n=(_t.isMeshStandardMaterial?Fe:Ke).get(_t.envMap||Yt),zn=_t.vertexColors===!0&&!!vt.attributes.color&&vt.attributes.color.itemSize===4,Wn=!!vt.attributes.tangent&&(!!_t.normalMap||_t.anisotropy>0),$n=!!vt.morphAttributes.position,jn=!!vt.morphAttributes.normal,fi=!!vt.morphAttributes.color;let vi=NoToneMapping;_t.toneMapped&&(we===null||we.isXRRenderTarget===!0)&&(vi=ve.toneMapping);const pi=vt.morphAttributes.position||vt.morphAttributes.normal||vt.morphAttributes.color,Ti=pi!==void 0?pi.length:0,Hn=Tn.get(_t),Di=me.state.lights;if(bt===!0&&(Xt===!0||Ue!==Le)){const er=Ue===Le&&_t.id===Re;An.setState(_t,Ue,er)}let ui=!1;_t.version===Hn.__version?(Hn.needsLights&&Hn.lightsStateVersion!==Di.state.version||Hn.outputColorSpace!==mn||je.isBatchedMesh&&Hn.batching===!1||!je.isBatchedMesh&&Hn.batching===!0||je.isBatchedMesh&&Hn.batchingColor===!0&&je.colorTexture===null||je.isBatchedMesh&&Hn.batchingColor===!1&&je.colorTexture!==null||je.isInstancedMesh&&Hn.instancing===!1||!je.isInstancedMesh&&Hn.instancing===!0||je.isSkinnedMesh&&Hn.skinning===!1||!je.isSkinnedMesh&&Hn.skinning===!0||je.isInstancedMesh&&Hn.instancingColor===!0&&je.instanceColor===null||je.isInstancedMesh&&Hn.instancingColor===!1&&je.instanceColor!==null||je.isInstancedMesh&&Hn.instancingMorph===!0&&je.morphTexture===null||je.isInstancedMesh&&Hn.instancingMorph===!1&&je.morphTexture!==null||Hn.envMap!==_n||_t.fog===!0&&Hn.fog!==Gt||Hn.numClippingPlanes!==void 0&&(Hn.numClippingPlanes!==An.numPlanes||Hn.numIntersection!==An.numIntersection)||Hn.vertexAlphas!==zn||Hn.vertexTangents!==Wn||Hn.morphTargets!==$n||Hn.morphNormals!==jn||Hn.morphColors!==fi||Hn.toneMapping!==vi||Hn.morphTargetsCount!==Ti)&&(ui=!0):(ui=!0,Hn.__version=_t.version);let Yi=Hn.currentProgram;ui===!0&&(Yi=Ge(_t,ct,je));let Yr=!1,Bi=!1,Lr=!1;const Pi=Yi.getUniforms(),Wi=Hn.uniforms;if(yn.useProgram(Yi.program)&&(Yr=!0,Bi=!0,Lr=!0),_t.id!==Re&&(Re=_t.id,Bi=!0),Yr||Le!==Ue){yn.buffers.depth.getReversed()&&Ue.reversedDepth!==!0&&(Ue._reversedDepth=!0,Ue.updateProjectionMatrix()),Pi.setValue(st,"projectionMatrix",Ue.projectionMatrix),Pi.setValue(st,"viewMatrix",Ue.matrixWorldInverse);const tr=Pi.map.cameraPosition;tr!==void 0&&tr.setValue(st,Jt.setFromMatrixPosition(Ue.matrixWorld)),ai.logarithmicDepthBuffer&&Pi.setValue(st,"logDepthBufFC",2/(Math.log(Ue.far+1)/Math.LN2)),(_t.isMeshPhongMaterial||_t.isMeshToonMaterial||_t.isMeshLambertMaterial||_t.isMeshBasicMaterial||_t.isMeshStandardMaterial||_t.isShaderMaterial)&&Pi.setValue(st,"isOrthographic",Ue.isOrthographicCamera===!0),Le!==Ue&&(Le=Ue,Bi=!0,Lr=!0)}if(je.isSkinnedMesh){Pi.setOptional(st,je,"bindMatrix"),Pi.setOptional(st,je,"bindMatrixInverse");const er=je.skeleton;er&&(er.boneTexture===null&&er.computeBoneTexture(),Pi.setValue(st,"boneTexture",er.boneTexture,En))}je.isBatchedMesh&&(Pi.setOptional(st,je,"batchingTexture"),Pi.setValue(st,"batchingTexture",je._matricesTexture,En),Pi.setOptional(st,je,"batchingIdTexture"),Pi.setValue(st,"batchingIdTexture",je._indirectTexture,En),Pi.setOptional(st,je,"batchingColorTexture"),je._colorsTexture!==null&&Pi.setValue(st,"batchingColorTexture",je._colorsTexture,En));const Ki=vt.morphAttributes;if((Ki.position!==void 0||Ki.normal!==void 0||Ki.color!==void 0)&&Bn.update(je,vt,Yi),(Bi||Hn.receiveShadow!==je.receiveShadow)&&(Hn.receiveShadow=je.receiveShadow,Pi.setValue(st,"receiveShadow",je.receiveShadow)),_t.isMeshGouraudMaterial&&_t.envMap!==null&&(Wi.envMap.value=_n,Wi.flipEnvMap.value=_n.isCubeTexture&&_n.isRenderTargetTexture===!1?-1:1),_t.isMeshStandardMaterial&&_t.envMap===null&&ct.environment!==null&&(Wi.envMapIntensity.value=ct.environmentIntensity),Wi.dfgLUT!==void 0&&(Wi.dfgLUT.value=getDFGLUT()),Bi&&(Pi.setValue(st,"toneMappingExposure",ve.toneMappingExposure),Hn.needsLights&&It(Wi,Lr),Gt&&_t.fog===!0&&Rn.refreshFogUniforms(Wi,Gt),Rn.refreshMaterialUniforms(Wi,_t,lt,Xe,me.state.transmissionRenderTarget[Ue.id]),WebGLUniforms.upload(st,tt(Hn),Wi,En)),_t.isShaderMaterial&&_t.uniformsNeedUpdate===!0&&(WebGLUniforms.upload(st,tt(Hn),Wi,En),_t.uniformsNeedUpdate=!1),_t.isSpriteMaterial&&Pi.setValue(st,"center",je.center),Pi.setValue(st,"modelViewMatrix",je.modelViewMatrix),Pi.setValue(st,"normalMatrix",je.normalMatrix),Pi.setValue(st,"modelMatrix",je.matrixWorld),_t.isShaderMaterial||_t.isRawShaderMaterial){const er=_t.uniformsGroups;for(let tr=0,Mr=er.length;tr<Mr;tr++){const Jn=er[tr];dn.update(Jn,Yi),dn.bind(Jn,Yi)}}return Yi}function It(Ue,ct){Ue.ambientLightColor.needsUpdate=ct,Ue.lightProbe.needsUpdate=ct,Ue.directionalLights.needsUpdate=ct,Ue.directionalLightShadows.needsUpdate=ct,Ue.pointLights.needsUpdate=ct,Ue.pointLightShadows.needsUpdate=ct,Ue.spotLights.needsUpdate=ct,Ue.spotLightShadows.needsUpdate=ct,Ue.rectAreaLights.needsUpdate=ct,Ue.hemisphereLights.needsUpdate=ct}function kt(Ue){return Ue.isMeshLambertMaterial||Ue.isMeshToonMaterial||Ue.isMeshPhongMaterial||Ue.isMeshStandardMaterial||Ue.isShadowMaterial||Ue.isShaderMaterial&&Ue.lights===!0}this.getActiveCubeFace=function(){return Me},this.getActiveMipmapLevel=function(){return Ee},this.getRenderTarget=function(){return we},this.setRenderTargetTextures=function(Ue,ct,vt){const _t=Tn.get(Ue);_t.__autoAllocateDepthBuffer=Ue.resolveDepthBuffer===!1,_t.__autoAllocateDepthBuffer===!1&&(_t.__useRenderToTexture=!1),Tn.get(Ue.texture).__webglTexture=ct,Tn.get(Ue.depthTexture).__webglTexture=_t.__autoAllocateDepthBuffer?void 0:vt,_t.__hasExternalTextures=!0},this.setRenderTargetFramebuffer=function(Ue,ct){const vt=Tn.get(Ue);vt.__webglFramebuffer=ct,vt.__useDefaultFramebuffer=ct===void 0};const Kt=st.createFramebuffer();this.setRenderTarget=function(Ue,ct=0,vt=0){we=Ue,Me=ct,Ee=vt;let _t=!0,je=null,Gt=!1,Yt=!1;if(Ue){const _n=Tn.get(Ue);if(_n.__useDefaultFramebuffer!==void 0)yn.bindFramebuffer(st.FRAMEBUFFER,null),_t=!1;else if(_n.__webglFramebuffer===void 0)En.setupRenderTarget(Ue);else if(_n.__hasExternalTextures)En.rebindTextures(Ue,Tn.get(Ue.texture).__webglTexture,Tn.get(Ue.depthTexture).__webglTexture);else if(Ue.depthBuffer){const $n=Ue.depthTexture;if(_n.__boundDepthTexture!==$n){if($n!==null&&Tn.has($n)&&(Ue.width!==$n.image.width||Ue.height!==$n.image.height))throw new Error("WebGLRenderTarget: Attached DepthTexture is initialized to the incorrect size.");En.setupDepthRenderbuffer(Ue)}}const zn=Ue.texture;(zn.isData3DTexture||zn.isDataArrayTexture||zn.isCompressedArrayTexture)&&(Yt=!0);const Wn=Tn.get(Ue).__webglFramebuffer;Ue.isWebGLCubeRenderTarget?(Array.isArray(Wn[ct])?je=Wn[ct][vt]:je=Wn[ct],Gt=!0):Ue.samples>0&&En.useMultisampledRTT(Ue)===!1?je=Tn.get(Ue).__webglMultisampledFramebuffer:Array.isArray(Wn)?je=Wn[vt]:je=Wn,Ne.copy(Ue.viewport),Oe.copy(Ue.scissor),Pe=Ue.scissorTest}else Ne.copy(St).multiplyScalar(lt).floor(),Oe.copy(Lt).multiplyScalar(lt).floor(),Pe=$t;if(vt!==0&&(je=Kt),yn.bindFramebuffer(st.FRAMEBUFFER,je)&&_t&&yn.drawBuffers(Ue,je),yn.viewport(Ne),yn.scissor(Oe),yn.setScissorTest(Pe),Gt){const _n=Tn.get(Ue.texture);st.framebufferTexture2D(st.FRAMEBUFFER,st.COLOR_ATTACHMENT0,st.TEXTURE_CUBE_MAP_POSITIVE_X+ct,_n.__webglTexture,vt)}else if(Yt){const _n=ct;for(let zn=0;zn<Ue.textures.length;zn++){const Wn=Tn.get(Ue.textures[zn]);st.framebufferTextureLayer(st.FRAMEBUFFER,st.COLOR_ATTACHMENT0+zn,Wn.__webglTexture,vt,_n)}}else if(Ue!==null&&vt!==0){const _n=Tn.get(Ue.texture);st.framebufferTexture2D(st.FRAMEBUFFER,st.COLOR_ATTACHMENT0,st.TEXTURE_2D,_n.__webglTexture,vt)}Re=-1},this.readRenderTargetPixels=function(Ue,ct,vt,_t,je,Gt,Yt,mn=0){if(!(Ue&&Ue.isWebGLRenderTarget)){error("WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");return}let _n=Tn.get(Ue).__webglFramebuffer;if(Ue.isWebGLCubeRenderTarget&&Yt!==void 0&&(_n=_n[Yt]),_n){yn.bindFramebuffer(st.FRAMEBUFFER,_n);try{const zn=Ue.textures[mn],Wn=zn.format,$n=zn.type;if(!ai.textureFormatReadable(Wn)){error("WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");return}if(!ai.textureTypeReadable($n)){error("WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");return}ct>=0&&ct<=Ue.width-_t&&vt>=0&&vt<=Ue.height-je&&(Ue.textures.length>1&&st.readBuffer(st.COLOR_ATTACHMENT0+mn),st.readPixels(ct,vt,_t,je,kn.convert(Wn),kn.convert($n),Gt))}finally{const zn=we!==null?Tn.get(we).__webglFramebuffer:null;yn.bindFramebuffer(st.FRAMEBUFFER,zn)}}},this.readRenderTargetPixelsAsync=async function(Ue,ct,vt,_t,je,Gt,Yt,mn=0){if(!(Ue&&Ue.isWebGLRenderTarget))throw new Error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");let _n=Tn.get(Ue).__webglFramebuffer;if(Ue.isWebGLCubeRenderTarget&&Yt!==void 0&&(_n=_n[Yt]),_n)if(ct>=0&&ct<=Ue.width-_t&&vt>=0&&vt<=Ue.height-je){yn.bindFramebuffer(st.FRAMEBUFFER,_n);const zn=Ue.textures[mn],Wn=zn.format,$n=zn.type;if(!ai.textureFormatReadable(Wn))throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in RGBA or implementation defined format.");if(!ai.textureTypeReadable($n))throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in UnsignedByteType or implementation defined type.");const jn=st.createBuffer();st.bindBuffer(st.PIXEL_PACK_BUFFER,jn),st.bufferData(st.PIXEL_PACK_BUFFER,Gt.byteLength,st.STREAM_READ),Ue.textures.length>1&&st.readBuffer(st.COLOR_ATTACHMENT0+mn),st.readPixels(ct,vt,_t,je,kn.convert(Wn),kn.convert($n),0);const fi=we!==null?Tn.get(we).__webglFramebuffer:null;yn.bindFramebuffer(st.FRAMEBUFFER,fi);const vi=st.fenceSync(st.SYNC_GPU_COMMANDS_COMPLETE,0);return st.flush(),await probeAsync(st,vi,4),st.bindBuffer(st.PIXEL_PACK_BUFFER,jn),st.getBufferSubData(st.PIXEL_PACK_BUFFER,0,Gt),st.deleteBuffer(jn),st.deleteSync(vi),Gt}else throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: requested read bounds are out of range.")},this.copyFramebufferToTexture=function(Ue,ct=null,vt=0){const _t=Math.pow(2,-vt),je=Math.floor(Ue.image.width*_t),Gt=Math.floor(Ue.image.height*_t),Yt=ct!==null?ct.x:0,mn=ct!==null?ct.y:0;En.setTexture2D(Ue,0),st.copyTexSubImage2D(st.TEXTURE_2D,vt,0,0,Yt,mn,je,Gt),yn.unbindTexture()};const On=st.createFramebuffer(),gn=st.createFramebuffer();this.copyTextureToTexture=function(Ue,ct,vt=null,_t=null,je=0,Gt=null){Gt===null&&(je!==0?(warnOnce("WebGLRenderer: copyTextureToTexture function signature has changed to support src and dst mipmap levels."),Gt=je,je=0):Gt=0);let Yt,mn,_n,zn,Wn,$n,jn,fi,vi;const pi=Ue.isCompressedTexture?Ue.mipmaps[Gt]:Ue.image;if(vt!==null)Yt=vt.max.x-vt.min.x,mn=vt.max.y-vt.min.y,_n=vt.isBox3?vt.max.z-vt.min.z:1,zn=vt.min.x,Wn=vt.min.y,$n=vt.isBox3?vt.min.z:0;else{const Ki=Math.pow(2,-je);Yt=Math.floor(pi.width*Ki),mn=Math.floor(pi.height*Ki),Ue.isDataArrayTexture?_n=pi.depth:Ue.isData3DTexture?_n=Math.floor(pi.depth*Ki):_n=1,zn=0,Wn=0,$n=0}_t!==null?(jn=_t.x,fi=_t.y,vi=_t.z):(jn=0,fi=0,vi=0);const Ti=kn.convert(ct.format),Hn=kn.convert(ct.type);let Di;ct.isData3DTexture?(En.setTexture3D(ct,0),Di=st.TEXTURE_3D):ct.isDataArrayTexture||ct.isCompressedArrayTexture?(En.setTexture2DArray(ct,0),Di=st.TEXTURE_2D_ARRAY):(En.setTexture2D(ct,0),Di=st.TEXTURE_2D),st.pixelStorei(st.UNPACK_FLIP_Y_WEBGL,ct.flipY),st.pixelStorei(st.UNPACK_PREMULTIPLY_ALPHA_WEBGL,ct.premultiplyAlpha),st.pixelStorei(st.UNPACK_ALIGNMENT,ct.unpackAlignment);const ui=st.getParameter(st.UNPACK_ROW_LENGTH),Yi=st.getParameter(st.UNPACK_IMAGE_HEIGHT),Yr=st.getParameter(st.UNPACK_SKIP_PIXELS),Bi=st.getParameter(st.UNPACK_SKIP_ROWS),Lr=st.getParameter(st.UNPACK_SKIP_IMAGES);st.pixelStorei(st.UNPACK_ROW_LENGTH,pi.width),st.pixelStorei(st.UNPACK_IMAGE_HEIGHT,pi.height),st.pixelStorei(st.UNPACK_SKIP_PIXELS,zn),st.pixelStorei(st.UNPACK_SKIP_ROWS,Wn),st.pixelStorei(st.UNPACK_SKIP_IMAGES,$n);const Pi=Ue.isDataArrayTexture||Ue.isData3DTexture,Wi=ct.isDataArrayTexture||ct.isData3DTexture;if(Ue.isDepthTexture){const Ki=Tn.get(Ue),er=Tn.get(ct),tr=Tn.get(Ki.__renderTarget),Mr=Tn.get(er.__renderTarget);yn.bindFramebuffer(st.READ_FRAMEBUFFER,tr.__webglFramebuffer),yn.bindFramebuffer(st.DRAW_FRAMEBUFFER,Mr.__webglFramebuffer);for(let Jn=0;Jn<_n;Jn++)Pi&&(st.framebufferTextureLayer(st.READ_FRAMEBUFFER,st.COLOR_ATTACHMENT0,Tn.get(Ue).__webglTexture,je,$n+Jn),st.framebufferTextureLayer(st.DRAW_FRAMEBUFFER,st.COLOR_ATTACHMENT0,Tn.get(ct).__webglTexture,Gt,vi+Jn)),st.blitFramebuffer(zn,Wn,Yt,mn,jn,fi,Yt,mn,st.DEPTH_BUFFER_BIT,st.NEAREST);yn.bindFramebuffer(st.READ_FRAMEBUFFER,null),yn.bindFramebuffer(st.DRAW_FRAMEBUFFER,null)}else if(je!==0||Ue.isRenderTargetTexture||Tn.has(Ue)){const Ki=Tn.get(Ue),er=Tn.get(ct);yn.bindFramebuffer(st.READ_FRAMEBUFFER,On),yn.bindFramebuffer(st.DRAW_FRAMEBUFFER,gn);for(let tr=0;tr<_n;tr++)Pi?st.framebufferTextureLayer(st.READ_FRAMEBUFFER,st.COLOR_ATTACHMENT0,Ki.__webglTexture,je,$n+tr):st.framebufferTexture2D(st.READ_FRAMEBUFFER,st.COLOR_ATTACHMENT0,st.TEXTURE_2D,Ki.__webglTexture,je),Wi?st.framebufferTextureLayer(st.DRAW_FRAMEBUFFER,st.COLOR_ATTACHMENT0,er.__webglTexture,Gt,vi+tr):st.framebufferTexture2D(st.DRAW_FRAMEBUFFER,st.COLOR_ATTACHMENT0,st.TEXTURE_2D,er.__webglTexture,Gt),je!==0?st.blitFramebuffer(zn,Wn,Yt,mn,jn,fi,Yt,mn,st.COLOR_BUFFER_BIT,st.NEAREST):Wi?st.copyTexSubImage3D(Di,Gt,jn,fi,vi+tr,zn,Wn,Yt,mn):st.copyTexSubImage2D(Di,Gt,jn,fi,zn,Wn,Yt,mn);yn.bindFramebuffer(st.READ_FRAMEBUFFER,null),yn.bindFramebuffer(st.DRAW_FRAMEBUFFER,null)}else Wi?Ue.isDataTexture||Ue.isData3DTexture?st.texSubImage3D(Di,Gt,jn,fi,vi,Yt,mn,_n,Ti,Hn,pi.data):ct.isCompressedArrayTexture?st.compressedTexSubImage3D(Di,Gt,jn,fi,vi,Yt,mn,_n,Ti,pi.data):st.texSubImage3D(Di,Gt,jn,fi,vi,Yt,mn,_n,Ti,Hn,pi):Ue.isDataTexture?st.texSubImage2D(st.TEXTURE_2D,Gt,jn,fi,Yt,mn,Ti,Hn,pi.data):Ue.isCompressedTexture?st.compressedTexSubImage2D(st.TEXTURE_2D,Gt,jn,fi,pi.width,pi.height,Ti,pi.data):st.texSubImage2D(st.TEXTURE_2D,Gt,jn,fi,Yt,mn,Ti,Hn,pi);st.pixelStorei(st.UNPACK_ROW_LENGTH,ui),st.pixelStorei(st.UNPACK_IMAGE_HEIGHT,Yi),st.pixelStorei(st.UNPACK_SKIP_PIXELS,Yr),st.pixelStorei(st.UNPACK_SKIP_ROWS,Bi),st.pixelStorei(st.UNPACK_SKIP_IMAGES,Lr),Gt===0&&ct.generateMipmaps&&st.generateMipmap(Di),yn.unbindTexture()},this.initRenderTarget=function(Ue){Tn.get(Ue).__webglFramebuffer===void 0&&En.setupRenderTarget(Ue)},this.initTexture=function(Ue){Ue.isCubeTexture?En.setTextureCube(Ue,0):Ue.isData3DTexture?En.setTexture3D(Ue,0):Ue.isDataArrayTexture||Ue.isCompressedArrayTexture?En.setTexture2DArray(Ue,0):En.setTexture2D(Ue,0),yn.unbindTexture()},this.resetState=function(){Me=0,Ee=0,we=null,yn.reset(),nt.reset()},typeof __THREE_DEVTOOLS__<"u"&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{detail:this}))}get coordinateSystem(){return WebGLCoordinateSystem}get outputColorSpace(){return this._outputColorSpace}set outputColorSpace(w){this._outputColorSpace=w;const D=this.getContext();D.drawingBufferColorSpace=ColorManagement._getDrawingBufferColorSpace(w),D.unpackColorSpace=ColorManagement._getUnpackColorSpace()}}/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */const t$1=globalThis,i$2=t$1.trustedTypes,s$1=i$2?i$2.createPolicy("lit-html",{createHTML:F=>F}):void 0,e="$lit$",h=`lit$${Math.random().toFixed(9).slice(2)}$`,o$1="?"+h,n$1=`<${o$1}>`,r=document,l=()=>r.createComment(""),c$1=F=>F===null||typeof F!="object"&&typeof F!="function",a$1=Array.isArray,u$1=F=>a$1(F)||typeof F?.[Symbol.iterator]=="function",d=`[ 	
\f\r]`,f=/<(?:(!--|\/[^a-zA-Z])|(\/?[a-zA-Z][^>\s]*)|(\/?$))/g,v=/-->/g,_=/>/g,m=RegExp(`>|${d}(?:([^\\s"'>=/]+)(${d}*=${d}*(?:[^ 	
\f\r"'\`<>=]|("|')|))|$)`,"g"),p=/'/g,g$1=/"/g,$=/^(?:script|style|textarea|title)$/i,y$1=F=>(w,...D)=>({_$litType$:F,strings:w,values:D}),x$1=y$1(1),T=Symbol.for("lit-noChange"),E$1=Symbol.for("lit-nothing"),A$1=new WeakMap,C$1=r.createTreeWalker(r,129);function P(F,w){if(!a$1(F)||!F.hasOwnProperty("raw"))throw Error("invalid template strings array");return s$1!==void 0?s$1.createHTML(w):w}const V=(F,w)=>{const D=F.length-1,O=[];let U,G=w===2?"<svg>":w===3?"<math>":"",q=f;for(let K=0;K<D;K++){const ee=F[K];let Z,ie,Y=-1,W=0;for(;W<ee.length&&(q.lastIndex=W,ie=q.exec(ee),ie!==null);)W=q.lastIndex,q===f?ie[1]==="!--"?q=v:ie[1]!==void 0?q=_:ie[2]!==void 0?($.test(ie[2])&&(U=RegExp("</"+ie[2],"g")),q=m):ie[3]!==void 0&&(q=m):q===m?ie[0]===">"?(q=U??f,Y=-1):ie[1]===void 0?Y=-2:(Y=q.lastIndex-ie[2].length,Z=ie[1],q=ie[3]===void 0?m:ie[3]==='"'?g$1:p):q===g$1||q===p?q=m:q===v||q===_?q=f:(q=m,U=void 0);const ne=q===m&&F[K+1].startsWith("/>")?" ":"";G+=q===f?ee+n$1:Y>=0?(O.push(Z),ee.slice(0,Y)+e+ee.slice(Y)+h+ne):ee+h+(Y===-2?K:ne)}return[P(F,G+(F[D]||"<?>")+(w===2?"</svg>":w===3?"</math>":"")),O]};class N{constructor({strings:w,_$litType$:D},O){let U;this.parts=[];let G=0,q=0;const K=w.length-1,ee=this.parts,[Z,ie]=V(w,D);if(this.el=N.createElement(Z,O),C$1.currentNode=this.el.content,D===2||D===3){const Y=this.el.content.firstChild;Y.replaceWith(...Y.childNodes)}for(;(U=C$1.nextNode())!==null&&ee.length<K;){if(U.nodeType===1){if(U.hasAttributes())for(const Y of U.getAttributeNames())if(Y.endsWith(e)){const W=ie[q++],ne=U.getAttribute(Y).split(h),se=/([.?@])?(.*)/.exec(W);ee.push({type:1,index:G,name:se[2],strings:ne,ctor:se[1]==="."?H:se[1]==="?"?I$1:se[1]==="@"?L:k}),U.removeAttribute(Y)}else Y.startsWith(h)&&(ee.push({type:6,index:G}),U.removeAttribute(Y));if($.test(U.tagName)){const Y=U.textContent.split(h),W=Y.length-1;if(W>0){U.textContent=i$2?i$2.emptyScript:"";for(let ne=0;ne<W;ne++)U.append(Y[ne],l()),C$1.nextNode(),ee.push({type:2,index:++G});U.append(Y[W],l())}}}else if(U.nodeType===8)if(U.data===o$1)ee.push({type:2,index:G});else{let Y=-1;for(;(Y=U.data.indexOf(h,Y+1))!==-1;)ee.push({type:7,index:G}),Y+=h.length-1}G++}}static createElement(w,D){const O=r.createElement("template");return O.innerHTML=w,O}}function S$1(F,w,D=F,O){if(w===T)return w;let U=O!==void 0?D._$Co?.[O]:D._$Cl;const G=c$1(w)?void 0:w._$litDirective$;return U?.constructor!==G&&(U?._$AO?.(!1),G===void 0?U=void 0:(U=new G(F),U._$AT(F,D,O)),O!==void 0?(D._$Co??=[])[O]=U:D._$Cl=U),U!==void 0&&(w=S$1(F,U._$AS(F,w.values),U,O)),w}class M{constructor(w,D){this._$AV=[],this._$AN=void 0,this._$AD=w,this._$AM=D}get parentNode(){return this._$AM.parentNode}get _$AU(){return this._$AM._$AU}u(w){const{el:{content:D},parts:O}=this._$AD,U=(w?.creationScope??r).importNode(D,!0);C$1.currentNode=U;let G=C$1.nextNode(),q=0,K=0,ee=O[0];for(;ee!==void 0;){if(q===ee.index){let Z;ee.type===2?Z=new R(G,G.nextSibling,this,w):ee.type===1?Z=new ee.ctor(G,ee.name,ee.strings,this,w):ee.type===6&&(Z=new z(G,this,w)),this._$AV.push(Z),ee=O[++K]}q!==ee?.index&&(G=C$1.nextNode(),q++)}return C$1.currentNode=r,U}p(w){let D=0;for(const O of this._$AV)O!==void 0&&(O.strings!==void 0?(O._$AI(w,O,D),D+=O.strings.length-2):O._$AI(w[D])),D++}}class R{get _$AU(){return this._$AM?._$AU??this._$Cv}constructor(w,D,O,U){this.type=2,this._$AH=E$1,this._$AN=void 0,this._$AA=w,this._$AB=D,this._$AM=O,this.options=U,this._$Cv=U?.isConnected??!0}get parentNode(){let w=this._$AA.parentNode;const D=this._$AM;return D!==void 0&&w?.nodeType===11&&(w=D.parentNode),w}get startNode(){return this._$AA}get endNode(){return this._$AB}_$AI(w,D=this){w=S$1(this,w,D),c$1(w)?w===E$1||w==null||w===""?(this._$AH!==E$1&&this._$AR(),this._$AH=E$1):w!==this._$AH&&w!==T&&this._(w):w._$litType$!==void 0?this.$(w):w.nodeType!==void 0?this.T(w):u$1(w)?this.k(w):this._(w)}O(w){return this._$AA.parentNode.insertBefore(w,this._$AB)}T(w){this._$AH!==w&&(this._$AR(),this._$AH=this.O(w))}_(w){this._$AH!==E$1&&c$1(this._$AH)?this._$AA.nextSibling.data=w:this.T(r.createTextNode(w)),this._$AH=w}$(w){const{values:D,_$litType$:O}=w,U=typeof O=="number"?this._$AC(w):(O.el===void 0&&(O.el=N.createElement(P(O.h,O.h[0]),this.options)),O);if(this._$AH?._$AD===U)this._$AH.p(D);else{const G=new M(U,this),q=G.u(this.options);G.p(D),this.T(q),this._$AH=G}}_$AC(w){let D=A$1.get(w.strings);return D===void 0&&A$1.set(w.strings,D=new N(w)),D}k(w){a$1(this._$AH)||(this._$AH=[],this._$AR());const D=this._$AH;let O,U=0;for(const G of w)U===D.length?D.push(O=new R(this.O(l()),this.O(l()),this,this.options)):O=D[U],O._$AI(G),U++;U<D.length&&(this._$AR(O&&O._$AB.nextSibling,U),D.length=U)}_$AR(w=this._$AA.nextSibling,D){for(this._$AP?.(!1,!0,D);w!==this._$AB;){const O=w.nextSibling;w.remove(),w=O}}setConnected(w){this._$AM===void 0&&(this._$Cv=w,this._$AP?.(w))}}class k{get tagName(){return this.element.tagName}get _$AU(){return this._$AM._$AU}constructor(w,D,O,U,G){this.type=1,this._$AH=E$1,this._$AN=void 0,this.element=w,this.name=D,this._$AM=U,this.options=G,O.length>2||O[0]!==""||O[1]!==""?(this._$AH=Array(O.length-1).fill(new String),this.strings=O):this._$AH=E$1}_$AI(w,D=this,O,U){const G=this.strings;let q=!1;if(G===void 0)w=S$1(this,w,D,0),q=!c$1(w)||w!==this._$AH&&w!==T,q&&(this._$AH=w);else{const K=w;let ee,Z;for(w=G[0],ee=0;ee<G.length-1;ee++)Z=S$1(this,K[O+ee],D,ee),Z===T&&(Z=this._$AH[ee]),q||=!c$1(Z)||Z!==this._$AH[ee],Z===E$1?w=E$1:w!==E$1&&(w+=(Z??"")+G[ee+1]),this._$AH[ee]=Z}q&&!U&&this.j(w)}j(w){w===E$1?this.element.removeAttribute(this.name):this.element.setAttribute(this.name,w??"")}}class H extends k{constructor(){super(...arguments),this.type=3}j(w){this.element[this.name]=w===E$1?void 0:w}}let I$1=class extends k{constructor(){super(...arguments),this.type=4}j(w){this.element.toggleAttribute(this.name,!!w&&w!==E$1)}};class L extends k{constructor(w,D,O,U,G){super(w,D,O,U,G),this.type=5}_$AI(w,D=this){if((w=S$1(this,w,D,0)??E$1)===T)return;const O=this._$AH,U=w===E$1&&O!==E$1||w.capture!==O.capture||w.once!==O.once||w.passive!==O.passive,G=w!==E$1&&(O===E$1||U);U&&this.element.removeEventListener(this.name,this,O),G&&this.element.addEventListener(this.name,this,w),this._$AH=w}handleEvent(w){typeof this._$AH=="function"?this._$AH.call(this.options?.host??this.element,w):this._$AH.handleEvent(w)}}class z{constructor(w,D,O){this.element=w,this.type=6,this._$AN=void 0,this._$AM=D,this.options=O}get _$AU(){return this._$AM._$AU}_$AI(w){S$1(this,w)}}const j=t$1.litHtmlPolyfillSupport;j?.(N,R),(t$1.litHtmlVersions??=[]).push("3.3.1");const B$1=(F,w,D)=>{const O=D?.renderBefore??w;let U=O._$litPart$;if(U===void 0){const G=D?.renderBefore??null;O._$litPart$=U=new R(w.insertBefore(l(),G),G,void 0,D??{})}return U._$AI(F),U};/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */const s=globalThis;let i$1=class extends y$2{constructor(){super(...arguments),this.renderOptions={host:this},this._$Do=void 0}createRenderRoot(){const w=super.createRenderRoot();return this.renderOptions.renderBefore??=w.firstChild,w}update(w){const D=this.render();this.hasUpdated||(this.renderOptions.isConnected=this.isConnected),super.update(w),this._$Do=B$1(D,this.renderRoot,this.renderOptions)}connectedCallback(){super.connectedCallback(),this._$Do?.setConnected(!0)}disconnectedCallback(){super.disconnectedCallback(),this._$Do?.setConnected(!1)}render(){return T}};i$1._$litElement$=!0,i$1.finalized=!0,s.litElementHydrateSupport?.({LitElement:i$1});const o=s.litElementPolyfillSupport;o?.({LitElement:i$1});(s.litElementVersions??=[]).push("4.2.1");/* @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */const HAS_WEBXR_DEVICE_API=navigator.xr!=null&&self.XRSession!=null&&navigator.xr.isSessionSupported!=null,HAS_WEBXR_HIT_TEST_API=HAS_WEBXR_DEVICE_API&&self.XRSession.prototype.requestHitTestSource!=null,HAS_RESIZE_OBSERVER=self.ResizeObserver!=null,HAS_INTERSECTION_OBSERVER=self.IntersectionObserver!=null,IS_WEBXR_AR_CANDIDATE=HAS_WEBXR_HIT_TEST_API;(()=>{const F=navigator.userAgent||navigator.vendor||self.opera;let w=!1;return(/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(F)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(F.substr(0,4)))&&(w=!0),w})();const IS_ANDROID=/android/i.test(navigator.userAgent),IS_IOS=/iPad|iPhone|iPod/.test(navigator.userAgent)&&!self.MSStream||navigator.platform==="MacIntel"&&navigator.maxTouchPoints>1,IS_FIREFOX=/firefox/i.test(navigator.userAgent),IS_OCULUS=/OculusBrowser/.test(navigator.userAgent),IS_SCENEVIEWER_CANDIDATE=IS_ANDROID&&!IS_FIREFOX&&!IS_OCULUS,IS_WKWEBVIEW=!!(window.webkit&&window.webkit.messageHandlers),IS_AR_QUICKLOOK_CANDIDATE=(()=>{if(IS_IOS){if(IS_WKWEBVIEW)return!!/CriOS\/|EdgiOS\/|FxiOS\/|GSA\/|DuckDuckGo\//.test(navigator.userAgent);{const F=document.createElement("a");return!!(F.relList&&F.relList.supports&&F.relList.supports("ar"))}}else return!1})();/* @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */const deserializeUrl=F=>F&&F!=="null"?toFullUrl(F):null,assertIsArCandidate=()=>{if(IS_WEBXR_AR_CANDIDATE)return;const F=[];throw HAS_WEBXR_DEVICE_API||F.push("WebXR Device API"),HAS_WEBXR_HIT_TEST_API||F.push("WebXR Hit Test API"),new Error(`The following APIs are required for AR, but are missing in this browser: ${F.join(", ")}`)},toFullUrl=F=>new URL(F,window.location.toString()).toString(),throttle=(F,w)=>{let D=null;const O=(...U)=>{D==null&&(F(...U),D=self.setTimeout(()=>D=null,w))};return O.flush=()=>{D!=null&&(self.clearTimeout(D),D=null)},O},debounce=(F,w)=>{let D=null;return(...O)=>{D!=null&&self.clearTimeout(D),D=self.setTimeout(()=>{D=null,F(...O)},w)}},clamp$1=(F,w,D)=>Math.max(w,Math.min(D,F)),isDebugMode=(()=>{const F="model-viewer-debug-mode",w=new RegExp(`[?&]${F}(&|$)`);return()=>self.ModelViewerElement&&self.ModelViewerElement.debugMode||self.location&&self.location.search&&self.location.search.match(w)})(),timePasses=(F=0)=>new Promise(w=>setTimeout(w,F)),waitForEvent=(F,w,D=null)=>new Promise(O=>{function U(G){(!D||D(G))&&(O(G),F.removeEventListener(w,U))}F.addEventListener(w,U)});/* @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */var __decorate$7=function(F,w,D,O){var U=arguments.length,G=U<3?w:O===null?O=Object.getOwnPropertyDescriptor(w,D):O,q;if(typeof Reflect=="object"&&typeof Reflect.decorate=="function")G=Reflect.decorate(F,w,D,O);else for(var K=F.length-1;K>=0;K--)(q=F[K])&&(G=(U<3?q(G):U>3?q(w,D,G):q(w,D))||G);return U>3&&G&&Object.defineProperty(w,D,G),G};const BASE_OPACITY=.5,DEFAULT_SHADOW_INTENSITY=0,DEFAULT_SHADOW_SOFTNESS=1,DEFAULT_EXPOSURE=1,$currentEnvironmentMap=Symbol("currentEnvironmentMap"),$currentBackground=Symbol("currentBackground"),$updateEnvironment=Symbol("updateEnvironment"),$cancelEnvironmentUpdate=Symbol("cancelEnvironmentUpdate"),EnvironmentMixin=F=>{var w,D,O;class U extends F{constructor(){super(...arguments),this.environmentImage=null,this.skyboxImage=null,this.shadowIntensity=DEFAULT_SHADOW_INTENSITY,this.shadowSoftness=DEFAULT_SHADOW_SOFTNESS,this.exposure=DEFAULT_EXPOSURE,this.toneMapping="auto",this.skyboxHeight="0",this[w]=null,this[D]=null,this[O]=null}updated(q){super.updated(q),q.has("shadowIntensity")&&(this[$scene].setShadowIntensity(this.shadowIntensity*BASE_OPACITY),this[$needsRender]()),q.has("shadowSoftness")&&(this[$scene].setShadowSoftness(this.shadowSoftness),this[$needsRender]()),q.has("exposure")&&(this[$scene].exposure=this.exposure,this[$needsRender]()),q.has("toneMapping")&&(this[$scene].toneMapping=this.toneMapping==="aces"?ACESFilmicToneMapping:this.toneMapping==="agx"?AgXToneMapping:this.toneMapping==="reinhard"?ReinhardToneMapping:this.toneMapping==="cineon"?CineonToneMapping:this.toneMapping==="linear"?LinearToneMapping:this.toneMapping==="none"?NoToneMapping:NeutralToneMapping,this[$needsRender]()),(q.has("environmentImage")||q.has("skyboxImage"))&&this[$shouldAttemptPreload]()&&this[$updateEnvironment](),q.has("skyboxHeight")&&(this[$scene].setGroundedSkybox(),this[$needsRender]())}hasBakedShadow(){return this[$scene].bakedShadows.size>0}async[(w=$currentEnvironmentMap,D=$currentBackground,O=$cancelEnvironmentUpdate,$updateEnvironment)](){const{skyboxImage:q,environmentImage:K}=this;this[$cancelEnvironmentUpdate]!=null&&(this[$cancelEnvironmentUpdate](),this[$cancelEnvironmentUpdate]=null);const{textureUtils:ee}=this[$renderer];if(ee==null)return;const Z=this[$progressTracker].beginActivity("environment-update");try{const{environmentMap:ie,skybox:Y}=await ee.generateEnvironmentMapAndSkybox(deserializeUrl(q),K,W=>Z(clamp$1(W,0,1)),this.withCredentials);this[$currentEnvironmentMap]!==ie&&(this[$currentEnvironmentMap]=ie,this.dispatchEvent(new CustomEvent("environment-change"))),Y!=null?this[$currentBackground]=Y.name===ie.name?ie:Y:this[$currentBackground]=null,this[$scene].setEnvironmentAndSkybox(this[$currentEnvironmentMap],this[$currentBackground])}catch(ie){if(ie instanceof Error)throw this[$scene].setEnvironmentAndSkybox(null,null),ie}finally{Z(1)}}}return __decorate$7([n$2({type:String,attribute:"environment-image"})],U.prototype,"environmentImage",void 0),__decorate$7([n$2({type:String,attribute:"skybox-image"})],U.prototype,"skyboxImage",void 0),__decorate$7([n$2({type:Number,attribute:"shadow-intensity"})],U.prototype,"shadowIntensity",void 0),__decorate$7([n$2({type:Number,attribute:"shadow-softness"})],U.prototype,"shadowSoftness",void 0),__decorate$7([n$2({type:Number})],U.prototype,"exposure",void 0),__decorate$7([n$2({type:String,attribute:"tone-mapping"})],U.prototype,"toneMapping",void 0),__decorate$7([n$2({type:String,attribute:"skybox-height"})],U.prototype,"skyboxHeight",void 0),U};/* @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */const CloseIcon=x$1`
<svg xmlns="http://www.w3.org/2000/svg" width="24px" height="24px" viewBox="0 0 24 24" fill="#000000">
    <!-- NOTE(cdata): This SVG filter is a stop-gap until we can implement
         support for dynamic re-coloring of UI components -->
    <defs>
      <filter id="drop-shadow" x="-100%" y="-100%" width="300%" height="300%">
        <feGaussianBlur in="SourceAlpha" stdDeviation="1"/>
        <feOffset dx="0" dy="0" result="offsetblur"/>
        <feFlood flood-color="#000000"/>
        <feComposite in2="offsetblur" operator="in"/>
        <feMerge>
          <feMergeNode/>
          <feMergeNode in="SourceGraphic"/>
        </feMerge>
      </filter>
    </defs>
    <path filter="url(#drop-shadow)" d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/>
    <path d="M0 0h24v24H0z" fill="none"/>
</svg>`;/* @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */const ControlsPrompt=x$1`
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="25" height="36">
    <defs>
        <path id="A" d="M.001.232h24.997V36H.001z" />
    </defs>
    <g transform="translate(-11 -4)" fill="none" fill-rule="evenodd">
        <path fill-opacity="0" fill="#fff" d="M0 0h44v44H0z" />
        <g transform="translate(11 3)">
            <path d="M8.733 11.165c.04-1.108.766-2.027 1.743-2.307a2.54 2.54 0 0 1 .628-.089c.16 0 .314.017.463.044 1.088.2 1.9 1.092 1.9 2.16v8.88h1.26c2.943-1.39 5-4.45 5-8.025a9.01 9.01 0 0 0-1.9-5.56l-.43-.5c-.765-.838-1.683-1.522-2.712-2-1.057-.49-2.226-.77-3.46-.77s-2.4.278-3.46.77c-1.03.478-1.947 1.162-2.71 2l-.43.5a9.01 9.01 0 0 0-1.9 5.56 9.04 9.04 0 0 0 .094 1.305c.03.21.088.41.13.617l.136.624c.083.286.196.56.305.832l.124.333a8.78 8.78 0 0 0 .509.953l.065.122a8.69 8.69 0 0 0 3.521 3.191l1.11.537v-9.178z" fill-opacity=".5" fill="#e4e4e4" />
            <path d="M22.94 26.218l-2.76 7.74c-.172.485-.676.8-1.253.8H12.24c-1.606 0-3.092-.68-3.98-1.82-1.592-2.048-3.647-3.822-6.11-5.27-.095-.055-.15-.137-.152-.23-.004-.1.046-.196.193-.297.56-.393 1.234-.6 1.926-.6a3.43 3.43 0 0 1 .691.069l4.922.994V10.972c0-.663.615-1.203 1.37-1.203s1.373.54 1.373 1.203v9.882h2.953c.273 0 .533.073.757.21l6.257 3.874c.027.017.045.042.07.06.41.296.586.77.426 1.22M4.1 16.614c-.024-.04-.042-.083-.065-.122a8.69 8.69 0 0 1-.509-.953c-.048-.107-.08-.223-.124-.333l-.305-.832c-.058-.202-.09-.416-.136-.624l-.13-.617a9.03 9.03 0 0 1-.094-1.305c0-2.107.714-4.04 1.9-5.56l.43-.5c.764-.84 1.682-1.523 2.71-2 1.058-.49 2.226-.77 3.46-.77s2.402.28 3.46.77c1.03.477 1.947 1.16 2.712 2l.428.5a9 9 0 0 1 1.901 5.559c0 3.577-2.056 6.636-5 8.026h-1.26v-8.882c0-1.067-.822-1.96-1.9-2.16-.15-.028-.304-.044-.463-.044-.22 0-.427.037-.628.09-.977.28-1.703 1.198-1.743 2.306v9.178l-1.11-.537C6.18 19.098 4.96 18 4.1 16.614M22.97 24.09l-6.256-3.874c-.102-.063-.218-.098-.33-.144 2.683-1.8 4.354-4.855 4.354-8.243 0-.486-.037-.964-.104-1.43a9.97 9.97 0 0 0-1.57-4.128l-.295-.408-.066-.092a10.05 10.05 0 0 0-.949-1.078c-.342-.334-.708-.643-1.094-.922-1.155-.834-2.492-1.412-3.94-1.65l-.732-.088-.748-.03a9.29 9.29 0 0 0-1.482.119c-1.447.238-2.786.816-3.94 1.65a9.33 9.33 0 0 0-.813.686 9.59 9.59 0 0 0-.845.877l-.385.437-.36.5-.288.468-.418.778-.04.09c-.593 1.28-.93 2.71-.93 4.222 0 3.832 2.182 7.342 5.56 8.938l1.437.68v4.946L5 25.64a4.44 4.44 0 0 0-.888-.086c-.017 0-.034.003-.05.003-.252.004-.503.033-.75.08a5.08 5.08 0 0 0-.237.056c-.193.046-.382.107-.568.18-.075.03-.15.057-.225.1-.25.114-.494.244-.723.405a1.31 1.31 0 0 0-.566 1.122 1.28 1.28 0 0 0 .645 1.051C4 29.925 5.96 31.614 7.473 33.563a5.06 5.06 0 0 0 .434.491c1.086 1.082 2.656 1.713 4.326 1.715h6.697c.748-.001 1.43-.333 1.858-.872.142-.18.256-.38.336-.602l2.757-7.74c.094-.26.13-.53.112-.794s-.088-.52-.203-.76a2.19 2.19 0 0 0-.821-.91" fill-opacity=".6" fill="#000" />
            <path d="M22.444 24.94l-6.257-3.874a1.45 1.45 0 0 0-.757-.211h-2.953v-9.88c0-.663-.616-1.203-1.373-1.203s-1.37.54-1.37 1.203v16.643l-4.922-.994a3.44 3.44 0 0 0-.692-.069 3.35 3.35 0 0 0-1.925.598c-.147.102-.198.198-.194.298.004.094.058.176.153.23 2.462 1.448 4.517 3.22 6.11 5.27.887 1.14 2.373 1.82 3.98 1.82h6.686c.577 0 1.08-.326 1.253-.8l2.76-7.74c.16-.448-.017-.923-.426-1.22-.025-.02-.043-.043-.07-.06z" fill="#fff" />
            <g transform="translate(0 .769)">
                <mask id="B" fill="#fff">
                    <use xlink:href="#A" />
                </mask>
                <path d="M23.993 24.992a1.96 1.96 0 0 1-.111.794l-2.758 7.74c-.08.22-.194.423-.336.602-.427.54-1.11.87-1.857.872h-6.698c-1.67-.002-3.24-.633-4.326-1.715-.154-.154-.3-.318-.434-.49C5.96 30.846 4 29.157 1.646 27.773c-.385-.225-.626-.618-.645-1.05a1.31 1.31 0 0 1 .566-1.122 4.56 4.56 0 0 1 .723-.405l.225-.1a4.3 4.3 0 0 1 .568-.18l.237-.056c.248-.046.5-.075.75-.08.018 0 .034-.003.05-.003.303-.001.597.027.89.086l3.722.752V20.68l-1.436-.68c-3.377-1.596-5.56-5.106-5.56-8.938 0-1.51.336-2.94.93-4.222.015-.03.025-.06.04-.09.127-.267.268-.525.418-.778.093-.16.186-.316.288-.468.063-.095.133-.186.2-.277L3.773 5c.118-.155.26-.29.385-.437.266-.3.544-.604.845-.877a9.33 9.33 0 0 1 .813-.686C6.97 2.167 8.31 1.59 9.757 1.35a9.27 9.27 0 0 1 1.481-.119 8.82 8.82 0 0 1 .748.031c.247.02.49.05.733.088 1.448.238 2.786.816 3.94 1.65.387.28.752.588 1.094.922a9.94 9.94 0 0 1 .949 1.078l.066.092c.102.133.203.268.295.408a9.97 9.97 0 0 1 1.571 4.128c.066.467.103.945.103 1.43 0 3.388-1.67 6.453-4.353 8.243.11.046.227.08.33.144l6.256 3.874c.37.23.645.55.82.9.115.24.185.498.203.76m.697-1.195c-.265-.55-.677-1.007-1.194-1.326l-5.323-3.297c2.255-2.037 3.564-4.97 3.564-8.114 0-2.19-.637-4.304-1.84-6.114-.126-.188-.26-.37-.4-.552-.645-.848-1.402-1.6-2.252-2.204C15.472.91 13.393.232 11.238.232A10.21 10.21 0 0 0 5.23 2.19c-.848.614-1.606 1.356-2.253 2.205-.136.18-.272.363-.398.55C1.374 6.756.737 8.87.737 11.06c0 4.218 2.407 8.08 6.133 9.842l.863.41v3.092l-2.525-.51c-.356-.07-.717-.106-1.076-.106a5.45 5.45 0 0 0-3.14.996c-.653.46-1.022 1.202-.99 1.983a2.28 2.28 0 0 0 1.138 1.872c2.24 1.318 4.106 2.923 5.543 4.772 1.26 1.62 3.333 2.59 5.55 2.592h6.698c1.42-.001 2.68-.86 3.134-2.138l2.76-7.74c.272-.757.224-1.584-.134-2.325" fill-opacity=".05" fill="#000" mask="url(#B)" />
            </g>
        </g>
    </g>
</svg>`;/* @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */const ARGlyph=x$1`
<svg version="1.1" id="view_x5F_in_x5F_AR_x5F_icon"
	 xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="24px" height="24px"
	 viewBox="0 0 24 24" enable-background="new 0 0 24 24" xml:space="preserve">
<rect id="Bounding_Box" x="0" y="0" fill="none" width="24" height="24"/>
<g id="Art_layer">
	<path d="M3,4c0-0.55,0.45-1,1-1h2V1H4C2.35,1,1,2.35,1,4v2h2V4z"/>
	<path d="M20,3c0.55,0,1,0.45,1,1v2h2V4c0-1.65-1.35-3-3-3h-2v2H20z"/>
	<path d="M4,21c-0.55,0-1-0.45-1-1v-2H1v2c0,1.65,1.35,3,3,3h2v-2H4z"/>
	<path d="M20,21c0.55,0,1-0.45,1-1v-2h2v2c0,1.65-1.35,3-3,3h-2v-2H20z"/>
	<g>
		<path d="M18.25,7.6l-5.5-3.18c-0.46-0.27-1.04-0.27-1.5,0L5.75,7.6C5.29,7.87,5,8.36,5,8.9v6.35c0,0.54,0.29,1.03,0.75,1.3
			l5.5,3.18c0.46,0.27,1.04,0.27,1.5,0l5.5-3.18c0.46-0.27,0.75-0.76,0.75-1.3V8.9C19,8.36,18.71,7.87,18.25,7.6z M7,14.96v-4.62
			l4,2.32v4.61L7,14.96z M12,10.93L8,8.61l4-2.31l4,2.31L12,10.93z M13,17.27v-4.61l4-2.32v4.62L13,17.27z"/>
	</g>
</g>
</svg>`;/* @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */const templateResult=x$1`
<style>
:host {
  display: block;
  position: relative;
  contain: strict;
  width: 300px;
  height: 150px;
}

.container {
  position: relative;
  overflow: hidden;
}

.userInput {
  width: 100%;
  height: 100%;
  display: none;
  position: relative;
  outline-offset: -1px;
  outline-width: 1px;
}

canvas {
  position: absolute;
  display: none;
  pointer-events: none;
  /* NOTE(cdata): Chrome 76 and below apparently have a bug
   * that causes our canvas not to display pixels unless it is
   * on its own render layer
   * @see https://github.com/google/model-viewer/pull/755#issuecomment-536597893
   */
  transform: translateZ(0);
}

.show {
  display: block;
}

/* Adapted from HTML5 Boilerplate
 *
 * @see https://github.com/h5bp/html5-boilerplate/blob/ceb4620c78fc82e13534fc44202a3f168754873f/dist/css/main.css#L122-L133 */
.screen-reader-only {
  border: 0;
  left: 0;
  top: 0;
  clip: rect(0, 0, 0, 0);
  height: 1px;
  margin: -1px;
  overflow: hidden;
  padding: 0;
  position: absolute;
  white-space: nowrap;
  width: 1px;
  pointer-events: none;
}

.slot {
  position: absolute;
  pointer-events: none;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
}

.slot > * {
  pointer-events: initial;
}

.annotation-wrapper ::slotted(*) {
  opacity: var(--max-hotspot-opacity, 1);
  transition: opacity 0.3s;
}

.pointer-tumbling .annotation-wrapper ::slotted(*) {
  pointer-events: none;
}

.annotation-wrapper ::slotted(*) {
  pointer-events: initial;
}

.annotation-wrapper.hide ::slotted(*) {
  opacity: var(--min-hotspot-opacity, 0.25);
}

.slot.poster {
  display: none;
  background-color: inherit;
}

.slot.poster.show {
  display: inherit;
}

.slot.poster > * {
  pointer-events: initial;
}

.slot.poster:not(.show) > * {
  pointer-events: none;
}

#default-poster {
  width: 100%;
  height: 100%;
  /* The default poster is a <button> so we need to set display
   * to prevent it from being affected by text-align: */
  display: block;
  position: absolute;
  border: none;
  padding: 0;
  background-size: contain;
  background-repeat: no-repeat;
  background-position: center;
  background-color: #fff0;
}

#default-progress-bar {
  display: block;
  position: relative;
  width: 100%;
  height: 100%;
  pointer-events: none;
  overflow: hidden;
}

#default-progress-bar > .bar {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: var(--progress-bar-height, 5px);
  background-color: var(--progress-bar-color, rgba(0, 0, 0, 0.4));
  transition: transform 0.09s;
  transform-origin: top left;
  transform: scaleX(0);
  overflow: hidden;
}

#default-progress-bar > .bar.hide {
  transition: opacity 0.3s 1s;
  opacity: 0;
}

.centered {
  align-items: center;
  justify-content: center;
}

.cover {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  pointer-events: none;
}

.slot.interaction-prompt {
  display: var(--interaction-prompt-display, flex);
  overflow: hidden;
  opacity: 0;
  will-change: opacity;
  transition: opacity 0.3s;
}

.slot.interaction-prompt.visible {
  opacity: 1;
}

.animated-container {
  will-change: transform, opacity;
  opacity: 0;
  transition: opacity 0.3s;
}

.slot.interaction-prompt > * {
  pointer-events: none;
}

.slot.ar-button {
  -moz-user-select: none;
  -webkit-tap-highlight-color: transparent;
  user-select: none;

  display: var(--ar-button-display, block);
}

.slot.ar-button:not(.enabled) {
  display: none;
}

.fab {
  display: flex;
  align-items: center;
  justify-content: center;
  box-sizing: border-box;
  width: 40px;
  height: 40px;
  cursor: pointer;
  background-color: #fff;
  box-shadow: 0px 0px 4px rgba(0, 0, 0, 0.15);
  border-radius: 100px;
}

.fab > * {
  opacity: 0.87;
}

#default-ar-button {
  position: absolute;
  bottom: 16px;
  right: 16px;
  transform: scale(var(--ar-button-scale, 1));
  transform-origin: bottom right;
}

.slot.pan-target {
  display: block;
  position: absolute;
  width: 0;
  height: 0;
  left: 50%;
  top: 50%;
  transform: translate3d(-50%, -50%, 0);
  background-color: transparent;
  opacity: 0;
  transition: opacity 0.3s;
}

#default-pan-target {
  width: 6px;
  height: 6px;
  border-radius: 6px;
  border: 1px solid white;
  box-shadow: 0px 0px 2px 1px rgba(0, 0, 0, 0.8);
}

.slot.default {
  pointer-events: none;
}

.slot.progress-bar {
  pointer-events: none;
}

.slot.exit-webxr-ar-button {
  pointer-events: none;
}

.slot.exit-webxr-ar-button:not(.enabled) {
  display: none;
}

#default-exit-webxr-ar-button {
  display: flex;
  align-items: center;
  justify-content: center;
  position: absolute;
  top: env(safe-area-inset-top, 16px);
  right: 16px;
  width: 40px;
  height: 40px;
  box-sizing: border-box;
}

#default-exit-webxr-ar-button > svg {
  fill: #fff;
}
</style>
<div class="container">
  <div class="userInput" tabindex="0" role="img"
      aria-label="3D model">
      <div class="slot canvas">
        <slot name="canvas">
          <canvas></canvas>
        </slot>
      </div>

  </div>

  <!-- NOTE(cdata): We need to wrap slots because browsers without ShadowDOM
        will have their <slot> elements removed by ShadyCSS -->
  <div class="slot poster">
    <slot name="poster">
      <button type="button" id="default-poster" aria-hidden="true" aria-label="Loading 3D model"></button>
    </slot>
  </div>

  <div class="slot ar-button">
    <slot name="ar-button">
      <a id="default-ar-button" part="default-ar-button" class="fab"
          tabindex="2"
          role="button"
          href="javascript:void(0);"
          aria-label="View in your space">
        ${ARGlyph}
      </a>
    </slot>
  </div>

  <div class="slot pan-target">
    <slot name="pan-target">
      <div id="default-pan-target">
      </div>
    </slot>
  </div>

  <div class="slot interaction-prompt cover centered">
    <div id="prompt" class="animated-container">
      <slot name="interaction-prompt" aria-hidden="true">
        ${ControlsPrompt}
      </slot>
    </div>
  </div>

  <div id="finger0" class="animated-container cover">
    <slot name="finger0" aria-hidden="true">
    </slot>
  </div>
  <div id="finger1" class="animated-container cover">
    <slot name="finger1" aria-hidden="true">
    </slot>
  </div>

  <div class="slot default">
    <slot></slot>

    <div class="slot progress-bar">
      <slot name="progress-bar">
        <div id="default-progress-bar" aria-hidden="true">
          <div class="bar" part="default-progress-bar"></div>
        </div>
      </slot>
    </div>

    <div class="slot exit-webxr-ar-button">
      <slot name="exit-webxr-ar-button">
        <a id="default-exit-webxr-ar-button" part="default-exit-webxr-ar-button"
            tabindex="3"
            aria-label="Exit AR"
            aria-hidden="true">
          ${CloseIcon}
        </a>
      </slot>
    </div>
  </div>
</div>
<div class="screen-reader-only" role="region" aria-label="Live announcements">
  <span id="status" role="status"></span>
</div>`,makeTemplate=F=>{B$1(templateResult,F)};var MeshoptDecoder=(function(){var F="b9H79Tebbbe8Fv9Gbb9Gvuuuuueu9Giuuub9Geueu9Giuuueuikqbeeedddillviebeoweuec:q:Odkr;leDo9TW9T9VV95dbH9F9F939H79T9F9J9H229F9Jt9VV7bb8A9TW79O9V9Wt9F9KW9J9V9KW9wWVtW949c919M9MWVbeY9TW79O9V9Wt9F9KW9J9V9KW69U9KW949c919M9MWVbdE9TW79O9V9Wt9F9KW9J9V9KW69U9KW949tWG91W9U9JWbiL9TW79O9V9Wt9F9KW9J9V9KWS9P2tWV9p9JtblK9TW79O9V9Wt9F9KW9J9V9KWS9P2tWV9r919HtbvL9TW79O9V9Wt9F9KW9J9V9KWS9P2tWVT949Wbol79IV9Rbrq;w8Wqdbk;esezu8Jjjjjbcj;eb9Rgv8Kjjjjbc9:hodnadcefal0mbcuhoaiRbbc:Ge9hmbavaialfgrad9Radz1jjjbhwcj;abad9Uc;WFbGgocjdaocjd6EhDaicefhocbhqdnindndndnaeaq9nmbaDaeaq9RaqaDfae6Egkcsfglcl4cifcd4hxalc9WGgmTmecbhPawcjdfhsaohzinaraz9Rax6mvarazaxfgo9RcK6mvczhlcbhHinalgic9WfgOawcj;cbffhldndndndndnazaOco4fRbbaHcoG4ciGPlbedibkal9cb83ibalcwf9cb83ibxikalaoRblaoRbbgOco4gAaAciSgAE86bbawcj;cbfaifglcGfaoclfaAfgARbbaOcl4ciGgCaCciSgCE86bbalcVfaAaCfgARbbaOcd4ciGgCaCciSgCE86bbalc7faAaCfgARbbaOciGgOaOciSgOE86bbalctfaAaOfgARbbaoRbegOco4gCaCciSgCE86bbalc91faAaCfgARbbaOcl4ciGgCaCciSgCE86bbalc4faAaCfgARbbaOcd4ciGgCaCciSgCE86bbalc93faAaCfgARbbaOciGgOaOciSgOE86bbalc94faAaOfgARbbaoRbdgOco4gCaCciSgCE86bbalc95faAaCfgARbbaOcl4ciGgCaCciSgCE86bbalc96faAaCfgARbbaOcd4ciGgCaCciSgCE86bbalc97faAaCfgARbbaOciGgOaOciSgOE86bbalc98faAaOfgORbbaoRbigoco4gAaAciSgAE86bbalc99faOaAfgORbbaocl4ciGgAaAciSgAE86bbalc9:faOaAfgORbbaocd4ciGgAaAciSgAE86bbalcufaOaAfglRbbaociGgoaociSgoE86bbalaofhoxdkalaoRbwaoRbbgOcl4gAaAcsSgAE86bbawcj;cbfaifglcGfaocwfaAfgARbbaOcsGgOaOcsSgOE86bbalcVfaAaOfgORbbaoRbegAcl4gCaCcsSgCE86bbalc7faOaCfgORbbaAcsGgAaAcsSgAE86bbalctfaOaAfgORbbaoRbdgAcl4gCaCcsSgCE86bbalc91faOaCfgORbbaAcsGgAaAcsSgAE86bbalc4faOaAfgORbbaoRbigAcl4gCaCcsSgCE86bbalc93faOaCfgORbbaAcsGgAaAcsSgAE86bbalc94faOaAfgORbbaoRblgAcl4gCaCcsSgCE86bbalc95faOaCfgORbbaAcsGgAaAcsSgAE86bbalc96faOaAfgORbbaoRbvgAcl4gCaCcsSgCE86bbalc97faOaCfgORbbaAcsGgAaAcsSgAE86bbalc98faOaAfgORbbaoRbogAcl4gCaCcsSgCE86bbalc99faOaCfgORbbaAcsGgAaAcsSgAE86bbalc9:faOaAfgORbbaoRbrgocl4gAaAcsSgAE86bbalcufaOaAfglRbbaocsGgoaocsSgoE86bbalaofhoxekalao8Pbb83bbalcwfaocwf8Pbb83bbaoczfhokdnaiam9pmbaHcdfhHaiczfhlarao9RcL0mekkaiam6mvaoTmvdnakTmbawaPfRbbhHawcj;cbfhlashiakhOinaialRbbgzce4cbazceG9R7aHfgH86bbaiadfhialcefhlaOcufgOmbkkascefhsaohzaPcefgPad9hmbxikkcbc99arao9Radcaadca0ESEhoxlkaoaxad2fhCdnakmbadhlinaoTmlarao9Rax6mlaoaxfhoalcufglmbkaChoxekcbhmawcjdfhAinarao9Rax6miawamfRbbhHawcj;cbfhlaAhiakhOinaialRbbgzce4cbazceG9R7aHfgH86bbaiadfhialcefhlaOcufgOmbkaAcefhAaoaxfhoamcefgmad9hmbkaChokabaqad2fawcjdfakad2z1jjjb8Aawawcjdfakcufad2fadz1jjjb8Aakaqfhqaombkc9:hoxekc9:hokavcj;ebf8Kjjjjbaok;cseHu8Jjjjjbc;ae9Rgv8Kjjjjbc9:hodnaeci9UgrcHfal0mbcuhoaiRbbgwc;WeGc;Ge9hmbawcsGgwce0mbavc;abfcFecjez:jjjjb8AavcUf9cu83ibavc8Wf9cu83ibavcyf9cu83ibavcaf9cu83ibavcKf9cu83ibavczf9cu83ibav9cu83iwav9cu83ibaialfc9WfhDaicefgqarfhidnaeTmbcmcsawceSEhkcbhxcbhmcbhPcbhwcbhlindnaiaD9nmbc9:hoxikdndnaqRbbgoc;Ve0mbavc;abfalaocu7gscl4fcsGcitfgzydlhrazydbhzdnaocsGgHak9pmbavawasfcsGcdtfydbaxaHEhoaHThsdndnadcd9hmbabaPcetfgHaz87ebaHclfao87ebaHcdfar87ebxekabaPcdtfgHazBdbaHcwfaoBdbaHclfarBdbkaxasfhxcdhHavawcdtfaoBdbawasfhwcehsalhOxdkdndnaHcsSmbaHc987aHamffcefhoxekaicefhoai8SbbgHcFeGhsdndnaHcu9mmbaohixekaicvfhiascFbGhscrhHdninao8SbbgOcFbGaHtasVhsaOcu9kmeaocefhoaHcrfgHc8J9hmbxdkkaocefhikasce4cbasceG9R7amfhokdndnadcd9hmbabaPcetfgHaz87ebaHclfao87ebaHcdfar87ebxekabaPcdtfgHazBdbaHcwfaoBdbaHclfarBdbkcdhHavawcdtfaoBdbcehsawcefhwalhOaohmxekdnaocpe0mbaxcefgHavawaDaocsGfRbbgocl49RcsGcdtfydbaocz6gzEhravawao9RcsGcdtfydbaHazfgAaocsGgHEhoaHThCdndnadcd9hmbabaPcetfgHax87ebaHclfao87ebaHcdfar87ebxekabaPcdtfgHaxBdbaHcwfaoBdbaHclfarBdbkcdhsavawcdtfaxBdbavawcefgwcsGcdtfarBdbcihHavc;abfalcitfgOaxBdlaOarBdbavawazfgwcsGcdtfaoBdbalcefcsGhOawaCfhwaxhzaAaCfhxxekaxcbaiRbbgOEgzaoc;:eSgHfhraOcsGhCaOcl4hAdndnaOcs0mbarcefhoxekarhoavawaA9RcsGcdtfydbhrkdndnaCmbaocefhxxekaohxavawaO9RcsGcdtfydbhokdndnaHTmbaicefhHxekaicdfhHai8SbegscFeGhzdnascu9kmbaicofhXazcFbGhzcrhidninaH8SbbgscFbGaitazVhzascu9kmeaHcefhHaicrfgic8J9hmbkaXhHxekaHcefhHkazce4cbazceG9R7amfgmhzkdndnaAcsSmbaHhsxekaHcefhsaH8SbbgicFeGhrdnaicu9kmbaHcvfhXarcFbGhrcrhidninas8SbbgHcFbGaitarVhraHcu9kmeascefhsaicrfgic8J9hmbkaXhsxekascefhskarce4cbarceG9R7amfgmhrkdndnaCcsSmbashixekascefhias8SbbgocFeGhHdnaocu9kmbascvfhXaHcFbGhHcrhodninai8SbbgscFbGaotaHVhHascu9kmeaicefhiaocrfgoc8J9hmbkaXhixekaicefhikaHce4cbaHceG9R7amfgmhokdndnadcd9hmbabaPcetfgHaz87ebaHclfao87ebaHcdfar87ebxekabaPcdtfgHazBdbaHcwfaoBdbaHclfarBdbkcdhsavawcdtfazBdbavawcefgwcsGcdtfarBdbcihHavc;abfalcitfgXazBdlaXarBdbavawaOcz6aAcsSVfgwcsGcdtfaoBdbawaCTaCcsSVfhwalcefcsGhOkaqcefhqavc;abfaOcitfgOarBdlaOaoBdbavc;abfalasfcsGcitfgraoBdlarazBdbawcsGhwalaHfcsGhlaPcifgPae6mbkkcbc99aiaDSEhokavc;aef8Kjjjjbaok:flevu8Jjjjjbcz9Rhvc9:hodnaecvfal0mbcuhoaiRbbc;:eGc;qe9hmbav9cb83iwaicefhraialfc98fhwdnaeTmbdnadcdSmbcbhDindnaraw6mbc9:skarcefhoar8SbbglcFeGhidndnalcu9mmbaohrxekarcvfhraicFbGhicrhldninao8SbbgdcFbGaltaiVhiadcu9kmeaocefhoalcrfglc8J9hmbxdkkaocefhrkabaDcdtfaic8Etc8F91aicd47avcwfaiceGcdtVgoydbfglBdbaoalBdbaDcefgDae9hmbxdkkcbhDindnaraw6mbc9:skarcefhoar8SbbglcFeGhidndnalcu9mmbaohrxekarcvfhraicFbGhicrhldninao8SbbgdcFbGaltaiVhiadcu9kmeaocefhoalcrfglc8J9hmbxdkkaocefhrkabaDcetfaic8Etc8F91aicd47avcwfaiceGcdtVgoydbfgl87ebaoalBdbaDcefgDae9hmbkkcbc99arawSEhokaok:Lvoeue99dud99eud99dndnadcl9hmbaeTmeindndnabcdfgd8Sbb:Yab8Sbbgi:Ygl:l:tabcefgv8Sbbgo:Ygr:l:tgwJbb;:9cawawNJbbbbawawJbbbb9GgDEgq:mgkaqaicb9iEalMgwawNakaqaocb9iEarMgqaqNMM:r:vglNJbbbZJbbb:;aDEMgr:lJbbb9p9DTmbar:Ohixekcjjjj94hikadai86bbdndnaqalNJbbbZJbbb:;aqJbbbb9GEMgq:lJbbb9p9DTmbaq:Ohdxekcjjjj94hdkavad86bbdndnawalNJbbbZJbbb:;awJbbbb9GEMgw:lJbbb9p9DTmbaw:Ohdxekcjjjj94hdkabad86bbabclfhbaecufgembxdkkaeTmbindndnabclfgd8Ueb:Yab8Uebgi:Ygl:l:tabcdfgv8Uebgo:Ygr:l:tgwJb;:FSawawNJbbbbawawJbbbb9GgDEgq:mgkaqaicb9iEalMgwawNakaqaocb9iEarMgqaqNMM:r:vglNJbbbZJbbb:;aDEMgr:lJbbb9p9DTmbar:Ohixekcjjjj94hikadai87ebdndnaqalNJbbbZJbbb:;aqJbbbb9GEMgq:lJbbb9p9DTmbaq:Ohdxekcjjjj94hdkavad87ebdndnawalNJbbbZJbbb:;awJbbbb9GEMgw:lJbbb9p9DTmbaw:Ohdxekcjjjj94hdkabad87ebabcwfhbaecufgembkkk;oiliui99iue99dnaeTmbcbhiabhlindndnJ;Zl81Zalcof8UebgvciV:Y:vgoal8Ueb:YNgrJb;:FSNJbbbZJbbb:;arJbbbb9GEMgw:lJbbb9p9DTmbaw:OhDxekcjjjj94hDkalclf8Uebhqalcdf8UebhkabaiavcefciGfcetfaD87ebdndnaoak:YNgwJb;:FSNJbbbZJbbb:;awJbbbb9GEMgx:lJbbb9p9DTmbax:OhDxekcjjjj94hDkabaiavciGfgkcd7cetfaD87ebdndnaoaq:YNgoJb;:FSNJbbbZJbbb:;aoJbbbb9GEMgx:lJbbb9p9DTmbax:OhDxekcjjjj94hDkabaiavcufciGfcetfaD87ebdndnJbbjZararN:tawawN:taoaoN:tgrJbbbbarJbbbb9GE:rJb;:FSNJbbbZMgr:lJbbb9p9DTmbar:Ohvxekcjjjj94hvkabakcetfav87ebalcwfhlaiclfhiaecufgembkkk9mbdnadcd4ae2gdTmbinababydbgecwtcw91:Yaece91cjjj98Gcjjj;8if::NUdbabclfhbadcufgdmbkkk9teiucbcbydj1jjbgeabcifc98GfgbBdj1jjbdndnabZbcztgd9nmbcuhiabad9RcFFifcz4nbcuSmekaehikaik;LeeeudndnaeabVciGTmbabhixekdndnadcz9pmbabhixekabhiinaiaeydbBdbaiclfaeclfydbBdbaicwfaecwfydbBdbaicxfaecxfydbBdbaeczfheaiczfhiadc9Wfgdcs0mbkkadcl6mbinaiaeydbBdbaeclfheaiclfhiadc98fgdci0mbkkdnadTmbinaiaeRbb86bbaicefhiaecefheadcufgdmbkkabk;aeedudndnabciGTmbabhixekaecFeGc:b:c:ew2hldndnadcz9pmbabhixekabhiinaialBdbaicxfalBdbaicwfalBdbaiclfalBdbaiczfhiadc9Wfgdcs0mbkkadcl6mbinaialBdbaiclfhiadc98fgdci0mbkkdnadTmbinaiae86bbaicefhiadcufgdmbkkabkkkebcjwklzNbb",w="b9H79TebbbeKl9Gbb9Gvuuuuueu9Giuuub9Geueuikqbbebeedddilve9Weeeviebeoweuec:q:6dkr;leDo9TW9T9VV95dbH9F9F939H79T9F9J9H229F9Jt9VV7bb8A9TW79O9V9Wt9F9KW9J9V9KW9wWVtW949c919M9MWVbdY9TW79O9V9Wt9F9KW9J9V9KW69U9KW949c919M9MWVblE9TW79O9V9Wt9F9KW9J9V9KW69U9KW949tWG91W9U9JWbvL9TW79O9V9Wt9F9KW9J9V9KWS9P2tWV9p9JtboK9TW79O9V9Wt9F9KW9J9V9KWS9P2tWV9r919HtbrL9TW79O9V9Wt9F9KW9J9V9KWS9P2tWVT949Wbwl79IV9RbDq:p9sqlbzik9:evu8Jjjjjbcz9Rhbcbheincbhdcbhiinabcwfadfaicjuaead4ceGglE86bbaialfhiadcefgdcw9hmbkaec:q:yjjbfai86bbaecitc:q1jjbfab8Piw83ibaecefgecjd9hmbkk:N8JlHud97euo978Jjjjjbcj;kb9Rgv8Kjjjjbc9:hodnadcefal0mbcuhoaiRbbc:Ge9hmbavaialfgrad9Rad;8qbbcj;abad9UhlaicefhodnaeTmbadTmbalc;WFbGglcjdalcjd6EhwcbhDinawaeaD9RaDawfae6Egqcsfglc9WGgkci2hxakcethmalcl4cifcd4hPabaDad2fhsakc;ab6hzcbhHincbhOaohAdndninaraA9RaP6meavcj;cbfaOak2fhCaAaPfhocbhidnazmbarao9Rc;Gb6mbcbhlinaCalfhidndndndndnaAalco4fRbbgXciGPlbedibkaipxbbbbbbbbbbbbbbbbpklbxikaiaopbblaopbbbgQclp:meaQpmbzeHdOiAlCvXoQrLgQcdp:meaQpmbzeHdOiAlCvXoQrLpxiiiiiiiiiiiiiiiip9ogLpxiiiiiiiiiiiiiiiip8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibaKc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spklbaoclfaYpQbfaKc:q:yjjbfRbbfhoxdkaiaopbbwaopbbbgQclp:meaQpmbzeHdOiAlCvXoQrLpxssssssssssssssssp9ogLpxssssssssssssssssp8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibaKc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spklbaocwfaYpQbfaKc:q:yjjbfRbbfhoxekaiaopbbbpklbaoczfhokdndndndndnaXcd4ciGPlbedibkaipxbbbbbbbbbbbbbbbbpklzxikaiaopbblaopbbbgQclp:meaQpmbzeHdOiAlCvXoQrLgQcdp:meaQpmbzeHdOiAlCvXoQrLpxiiiiiiiiiiiiiiiip9ogLpxiiiiiiiiiiiiiiiip8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibaKc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spklzaoclfaYpQbfaKc:q:yjjbfRbbfhoxdkaiaopbbwaopbbbgQclp:meaQpmbzeHdOiAlCvXoQrLpxssssssssssssssssp9ogLpxssssssssssssssssp8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibaKc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spklzaocwfaYpQbfaKc:q:yjjbfRbbfhoxekaiaopbbbpklzaoczfhokdndndndndnaXcl4ciGPlbedibkaipxbbbbbbbbbbbbbbbbpklaxikaiaopbblaopbbbgQclp:meaQpmbzeHdOiAlCvXoQrLgQcdp:meaQpmbzeHdOiAlCvXoQrLpxiiiiiiiiiiiiiiiip9ogLpxiiiiiiiiiiiiiiiip8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibaKc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spklaaoclfaYpQbfaKc:q:yjjbfRbbfhoxdkaiaopbbwaopbbbgQclp:meaQpmbzeHdOiAlCvXoQrLpxssssssssssssssssp9ogLpxssssssssssssssssp8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibaKc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spklaaocwfaYpQbfaKc:q:yjjbfRbbfhoxekaiaopbbbpklaaoczfhokdndndndndnaXco4Plbedibkaipxbbbbbbbbbbbbbbbbpkl8WxikaiaopbblaopbbbgQclp:meaQpmbzeHdOiAlCvXoQrLgQcdp:meaQpmbzeHdOiAlCvXoQrLpxiiiiiiiiiiiiiiiip9ogLpxiiiiiiiiiiiiiiiip8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgXcitc:q1jjbfpbibaXc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgXcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spkl8WaoclfaYpQbfaXc:q:yjjbfRbbfhoxdkaiaopbbwaopbbbgQclp:meaQpmbzeHdOiAlCvXoQrLpxssssssssssssssssp9ogLpxssssssssssssssssp8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgXcitc:q1jjbfpbibaXc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgXcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spkl8WaocwfaYpQbfaXc:q:yjjbfRbbfhoxekaiaopbbbpkl8Waoczfhokalc;abfhialcjefak0meaihlarao9Rc;Fb0mbkkdnaiak9pmbaici4hlinarao9RcK6miaCaifhXdndndndndnaAaico4fRbbalcoG4ciGPlbedibkaXpxbbbbbbbbbbbbbbbbpkbbxikaXaopbblaopbbbgQclp:meaQpmbzeHdOiAlCvXoQrLgQcdp:meaQpmbzeHdOiAlCvXoQrLpxiiiiiiiiiiiiiiiip9ogLpxiiiiiiiiiiiiiiiip8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibaKc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spkbbaoclfaYpQbfaKc:q:yjjbfRbbfhoxdkaXaopbbwaopbbbgQclp:meaQpmbzeHdOiAlCvXoQrLpxssssssssssssssssp9ogLpxssssssssssssssssp8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibaKc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spkbbaocwfaYpQbfaKc:q:yjjbfRbbfhoxekaXaopbbbpkbbaoczfhokalcdfhlaiczfgiak6mbkkaoTmeaohAaOcefgOclSmdxbkkc9:hoxlkdnakTmbavcjdfaHfhiavaHfpbdbhYcbhXinaiavcj;cbfaXfglpblbgLcep9TaLpxeeeeeeeeeeeeeeeegQp9op9Hp9rgLalakfpblbg8Acep9Ta8AaQp9op9Hp9rg8ApmbzeHdOiAlCvXoQrLgEalamfpblbg3cep9Ta3aQp9op9Hp9rg3alaxfpblbg5cep9Ta5aQp9op9Hp9rg5pmbzeHdOiAlCvXoQrLg8EpmbezHdiOAlvCXorQLgQaQpmbedibedibedibediaYp9UgYp9AdbbaiadfglaYaQaQpmlvorlvorlvorlvorp9UgYp9AdbbaladfglaYaQaQpmwDqkwDqkwDqkwDqkp9UgYp9AdbbaladfglaYaQaQpmxmPsxmPsxmPsxmPsp9UgYp9AdbbaladfglaYaEa8EpmwDKYqk8AExm35Ps8E8FgQaQpmbedibedibedibedip9UgYp9AdbbaladfglaYaQaQpmlvorlvorlvorlvorp9UgYp9AdbbaladfglaYaQaQpmwDqkwDqkwDqkwDqkp9UgYp9AdbbaladfglaYaQaQpmxmPsxmPsxmPsxmPsp9UgYp9AdbbaladfglaYaLa8ApmwKDYq8AkEx3m5P8Es8FgLa3a5pmwKDYq8AkEx3m5P8Es8Fg8ApmbezHdiOAlvCXorQLgQaQpmbedibedibedibedip9UgYp9AdbbaladfglaYaQaQpmlvorlvorlvorlvorp9UgYp9AdbbaladfglaYaQaQpmwDqkwDqkwDqkwDqkp9UgYp9AdbbaladfglaYaQaQpmxmPsxmPsxmPsxmPsp9UgYp9AdbbaladfglaYaLa8ApmwDKYqk8AExm35Ps8E8FgQaQpmbedibedibedibedip9UgYp9AdbbaladfglaYaQaQpmlvorlvorlvorlvorp9UgYp9AdbbaladfglaYaQaQpmwDqkwDqkwDqkwDqkp9UgYp9AdbbaladfglaYaQaQpmxmPsxmPsxmPsxmPsp9UgYp9AdbbaladfhiaXczfgXak6mbkkaHclfgHad6mbkasavcjdfaqad2;8qbbavavcjdfaqcufad2fad;8qbbaqaDfgDae6mbkkcbc99arao9Radcaadca0ESEhokavcj;kbf8Kjjjjbaokwbz:bjjjbk::seHu8Jjjjjbc;ae9Rgv8Kjjjjbc9:hodnaeci9UgrcHfal0mbcuhoaiRbbgwc;WeGc;Ge9hmbawcsGgwce0mbavc;abfcFecje;8kbavcUf9cu83ibavc8Wf9cu83ibavcyf9cu83ibavcaf9cu83ibavcKf9cu83ibavczf9cu83ibav9cu83iwav9cu83ibaialfc9WfhDaicefgqarfhidnaeTmbcmcsawceSEhkcbhxcbhmcbhPcbhwcbhlindnaiaD9nmbc9:hoxikdndnaqRbbgoc;Ve0mbavc;abfalaocu7gscl4fcsGcitfgzydlhrazydbhzdnaocsGgHak9pmbavawasfcsGcdtfydbaxaHEhoaHThsdndnadcd9hmbabaPcetfgHaz87ebaHclfao87ebaHcdfar87ebxekabaPcdtfgHazBdbaHcwfaoBdbaHclfarBdbkaxasfhxcdhHavawcdtfaoBdbawasfhwcehsalhOxdkdndnaHcsSmbaHc987aHamffcefhoxekaicefhoai8SbbgHcFeGhsdndnaHcu9mmbaohixekaicvfhiascFbGhscrhHdninao8SbbgOcFbGaHtasVhsaOcu9kmeaocefhoaHcrfgHc8J9hmbxdkkaocefhikasce4cbasceG9R7amfhokdndnadcd9hmbabaPcetfgHaz87ebaHclfao87ebaHcdfar87ebxekabaPcdtfgHazBdbaHcwfaoBdbaHclfarBdbkcdhHavawcdtfaoBdbcehsawcefhwalhOaohmxekdnaocpe0mbaxcefgHavawaDaocsGfRbbgocl49RcsGcdtfydbaocz6gzEhravawao9RcsGcdtfydbaHazfgAaocsGgHEhoaHThCdndnadcd9hmbabaPcetfgHax87ebaHclfao87ebaHcdfar87ebxekabaPcdtfgHaxBdbaHcwfaoBdbaHclfarBdbkcdhsavawcdtfaxBdbavawcefgwcsGcdtfarBdbcihHavc;abfalcitfgOaxBdlaOarBdbavawazfgwcsGcdtfaoBdbalcefcsGhOawaCfhwaxhzaAaCfhxxekaxcbaiRbbgOEgzaoc;:eSgHfhraOcsGhCaOcl4hAdndnaOcs0mbarcefhoxekarhoavawaA9RcsGcdtfydbhrkdndnaCmbaocefhxxekaohxavawaO9RcsGcdtfydbhokdndnaHTmbaicefhHxekaicdfhHai8SbegscFeGhzdnascu9kmbaicofhXazcFbGhzcrhidninaH8SbbgscFbGaitazVhzascu9kmeaHcefhHaicrfgic8J9hmbkaXhHxekaHcefhHkazce4cbazceG9R7amfgmhzkdndnaAcsSmbaHhsxekaHcefhsaH8SbbgicFeGhrdnaicu9kmbaHcvfhXarcFbGhrcrhidninas8SbbgHcFbGaitarVhraHcu9kmeascefhsaicrfgic8J9hmbkaXhsxekascefhskarce4cbarceG9R7amfgmhrkdndnaCcsSmbashixekascefhias8SbbgocFeGhHdnaocu9kmbascvfhXaHcFbGhHcrhodninai8SbbgscFbGaotaHVhHascu9kmeaicefhiaocrfgoc8J9hmbkaXhixekaicefhikaHce4cbaHceG9R7amfgmhokdndnadcd9hmbabaPcetfgHaz87ebaHclfao87ebaHcdfar87ebxekabaPcdtfgHazBdbaHcwfaoBdbaHclfarBdbkcdhsavawcdtfazBdbavawcefgwcsGcdtfarBdbcihHavc;abfalcitfgXazBdlaXarBdbavawaOcz6aAcsSVfgwcsGcdtfaoBdbawaCTaCcsSVfhwalcefcsGhOkaqcefhqavc;abfaOcitfgOarBdlaOaoBdbavc;abfalasfcsGcitfgraoBdlarazBdbawcsGhwalaHfcsGhlaPcifgPae6mbkkcbc99aiaDSEhokavc;aef8Kjjjjbaok:flevu8Jjjjjbcz9Rhvc9:hodnaecvfal0mbcuhoaiRbbc;:eGc;qe9hmbav9cb83iwaicefhraialfc98fhwdnaeTmbdnadcdSmbcbhDindnaraw6mbc9:skarcefhoar8SbbglcFeGhidndnalcu9mmbaohrxekarcvfhraicFbGhicrhldninao8SbbgdcFbGaltaiVhiadcu9kmeaocefhoalcrfglc8J9hmbxdkkaocefhrkabaDcdtfaic8Etc8F91aicd47avcwfaiceGcdtVgoydbfglBdbaoalBdbaDcefgDae9hmbxdkkcbhDindnaraw6mbc9:skarcefhoar8SbbglcFeGhidndnalcu9mmbaohrxekarcvfhraicFbGhicrhldninao8SbbgdcFbGaltaiVhiadcu9kmeaocefhoalcrfglc8J9hmbxdkkaocefhrkabaDcetfaic8Etc8F91aicd47avcwfaiceGcdtVgoydbfgl87ebaoalBdbaDcefgDae9hmbkkcbc99arawSEhokaok:wPliuo97eue978Jjjjjbca9Rhiaec98Ghldndnadcl9hmbdnalTmbcbhvabhdinadadpbbbgocKp:RecKp:Sep;6egraocwp:RecKp:Sep;6earp;Geaoczp:RecKp:Sep;6egwp;Gep;Kep;LegDpxbbbbbbbbbbbbbbbbp:2egqarpxbbbjbbbjbbbjbbbjgkp9op9rp;Kegrpxbb;:9cbb;:9cbb;:9cbb;:9cararp;MeaDaDp;Meawaqawakp9op9rp;Kegrarp;Mep;Kep;Kep;Jep;Negwp;Mepxbbn0bbn0bbn0bbn0gqp;KepxFbbbFbbbFbbbFbbbp9oaopxbbbFbbbFbbbFbbbFp9op9qarawp;Meaqp;Kecwp:RepxbFbbbFbbbFbbbFbbp9op9qaDawp;Meaqp;Keczp:RepxbbFbbbFbbbFbbbFbp9op9qpkbbadczfhdavclfgval6mbkkalaeSmeaipxbbbbbbbbbbbbbbbbgqpklbaiabalcdtfgdaeciGglcdtgv;8qbbdnalTmbaiaipblbgocKp:RecKp:Sep;6egraocwp:RecKp:Sep;6earp;Geaoczp:RecKp:Sep;6egwp;Gep;Kep;LegDaqp:2egqarpxbbbjbbbjbbbjbbbjgkp9op9rp;Kegrpxbb;:9cbb;:9cbb;:9cbb;:9cararp;MeaDaDp;Meawaqawakp9op9rp;Kegrarp;Mep;Kep;Kep;Jep;Negwp;Mepxbbn0bbn0bbn0bbn0gqp;KepxFbbbFbbbFbbbFbbbp9oaopxbbbFbbbFbbbFbbbFp9op9qarawp;Meaqp;Kecwp:RepxbFbbbFbbbFbbbFbbp9op9qaDawp;Meaqp;Keczp:RepxbbFbbbFbbbFbbbFbp9op9qpklbkadaiav;8qbbskdnalTmbcbhvabhdinadczfgxaxpbbbgopxbbbbbbFFbbbbbbFFgkp9oadpbbbgDaopmbediwDqkzHOAKY8AEgwczp:Reczp:Sep;6egraDaopmlvorxmPsCXQL358E8FpxFubbFubbFubbFubbp9op;6eawczp:Sep;6egwp;Gearp;Gep;Kep;Legopxbbbbbbbbbbbbbbbbp:2egqarpxbbbjbbbjbbbjbbbjgmp9op9rp;Kegrpxb;:FSb;:FSb;:FSb;:FSararp;Meaoaop;Meawaqawamp9op9rp;Kegrarp;Mep;Kep;Kep;Jep;Negwp;Mepxbbn0bbn0bbn0bbn0gqp;KepxFFbbFFbbFFbbFFbbp9oaoawp;Meaqp;Keczp:Rep9qgoarawp;Meaqp;KepxFFbbFFbbFFbbFFbbp9ogrpmwDKYqk8AExm35Ps8E8Fp9qpkbbadaDakp9oaoarpmbezHdiOAlvCXorQLp9qpkbbadcafhdavclfgval6mbkkalaeSmbaiaeciGgvcitgdfcbcaad9R;8kbaiabalcitfglad;8qbbdnavTmbaiaipblzgopxbbbbbbFFbbbbbbFFgkp9oaipblbgDaopmbediwDqkzHOAKY8AEgwczp:Reczp:Sep;6egraDaopmlvorxmPsCXQL358E8FpxFubbFubbFubbFubbp9op;6eawczp:Sep;6egwp;Gearp;Gep;Kep;Legopxbbbbbbbbbbbbbbbbp:2egqarpxbbbjbbbjbbbjbbbjgmp9op9rp;Kegrpxb;:FSb;:FSb;:FSb;:FSararp;Meaoaop;Meawaqawamp9op9rp;Kegrarp;Mep;Kep;Kep;Jep;Negwp;Mepxbbn0bbn0bbn0bbn0gqp;KepxFFbbFFbbFFbbFFbbp9oaoawp;Meaqp;Keczp:Rep9qgoarawp;Meaqp;KepxFFbbFFbbFFbbFFbbp9ogrpmwDKYqk8AExm35Ps8E8Fp9qpklzaiaDakp9oaoarpmbezHdiOAlvCXorQLp9qpklbkalaiad;8qbbkk;4wllue97euv978Jjjjjbc8W9Rhidnaec98GglTmbcbhvabhoinaiaopbbbgraoczfgwpbbbgDpmlvorxmPsCXQL358E8Fgqczp:Segkclp:RepklbaopxbbjZbbjZbbjZbbjZpx;Zl81Z;Zl81Z;Zl81Z;Zl81Zakpxibbbibbbibbbibbbp9qp;6ep;NegkaraDpmbediwDqkzHOAKY8AEgrczp:Reczp:Sep;6ep;MegDaDp;Meakarczp:Sep;6ep;Megxaxp;Meakaqczp:Reczp:Sep;6ep;Megqaqp;Mep;Kep;Kep;Lepxbbbbbbbbbbbbbbbbp:4ep;Jepxb;:FSb;:FSb;:FSb;:FSgkp;Mepxbbn0bbn0bbn0bbn0grp;KepxFFbbFFbbFFbbFFbbgmp9oaxakp;Mearp;Keczp:Rep9qgxaDakp;Mearp;Keamp9oaqakp;Mearp;Keczp:Rep9qgkpmbezHdiOAlvCXorQLgrp5baipblbpEb:T:j83ibaocwfarp5eaipblbpEe:T:j83ibawaxakpmwDKYqk8AExm35Ps8E8Fgkp5baipblbpEd:T:j83ibaocKfakp5eaipblbpEi:T:j83ibaocafhoavclfgval6mbkkdnalaeSmbaiaeciGgvcitgofcbcaao9R;8kbaiabalcitfgwao;8qbbdnavTmbaiaipblbgraipblzgDpmlvorxmPsCXQL358E8Fgqczp:Segkclp:RepklaaipxbbjZbbjZbbjZbbjZpx;Zl81Z;Zl81Z;Zl81Z;Zl81Zakpxibbbibbbibbbibbbp9qp;6ep;NegkaraDpmbediwDqkzHOAKY8AEgrczp:Reczp:Sep;6ep;MegDaDp;Meakarczp:Sep;6ep;Megxaxp;Meakaqczp:Reczp:Sep;6ep;Megqaqp;Mep;Kep;Kep;Lepxbbbbbbbbbbbbbbbbp:4ep;Jepxb;:FSb;:FSb;:FSb;:FSgkp;Mepxbbn0bbn0bbn0bbn0grp;KepxFFbbFFbbFFbbFFbbgmp9oaxakp;Mearp;Keczp:Rep9qgxaDakp;Mearp;Keamp9oaqakp;Mearp;Keczp:Rep9qgkpmbezHdiOAlvCXorQLgrp5baipblapEb:T:j83ibaiarp5eaipblapEe:T:j83iwaiaxakpmwDKYqk8AExm35Ps8E8Fgkp5baipblapEd:T:j83izaiakp5eaipblapEi:T:j83iKkawaiao;8qbbkk:Pddiue978Jjjjjbc;ab9Rhidnadcd4ae2glc98GgvTmbcbheabhdinadadpbbbgocwp:Recwp:Sep;6eaocep:SepxbbjFbbjFbbjFbbjFp9opxbbjZbbjZbbjZbbjZp:Uep;Mepkbbadczfhdaeclfgeav6mbkkdnavalSmbaialciGgecdtgdVcbc;abad9R;8kbaiabavcdtfgvad;8qbbdnaeTmbaiaipblbgocwp:Recwp:Sep;6eaocep:SepxbbjFbbjFbbjFbbjFp9opxbbjZbbjZbbjZbbjZp:Uep;Mepklbkavaiad;8qbbkk9teiucbcbydj1jjbgeabcifc98GfgbBdj1jjbdndnabZbcztgd9nmbcuhiabad9RcFFifcz4nbcuSmekaehikaikkkebcjwklz:Dbb",D=new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,3,2,0,0,5,3,1,0,1,12,1,0,10,22,2,12,0,65,0,65,0,65,0,252,10,0,0,11,7,0,65,0,253,15,26,11]),O=new Uint8Array([32,0,65,2,1,106,34,33,3,128,11,4,13,64,6,253,10,7,15,116,127,5,8,12,40,16,19,54,20,9,27,255,113,17,42,67,24,23,146,148,18,14,22,45,70,69,56,114,101,21,25,63,75,136,108,28,118,29,73,115]);if(typeof WebAssembly!="object")return{supported:!1};var U=WebAssembly.validate(D)?K(w):K(F),G,q=WebAssembly.instantiate(U,{}).then(function(he){G=he.instance,G.exports.__wasm_call_ctors()});function K(he){for(var pe=new Uint8Array(he.length),me=0;me<he.length;++me){var be=he.charCodeAt(me);pe[me]=be>96?be-97:be>64?be-39:be+4}for(var ge=0,me=0;me<he.length;++me)pe[ge++]=pe[me]<60?O[pe[me]]:(pe[me]-60)*64+pe[++me];return pe.buffer.slice(0,ge)}function ee(he,pe,me,be,ge,ve,Se){var Me=he.exports.sbrk,Ee=be+3&-4,we=Me(Ee*ge),Re=Me(ve.length),Le=new Uint8Array(he.exports.memory.buffer);Le.set(ve,Re);var Ne=pe(we,be,ge,Re,ve.length);if(Ne==0&&Se&&Se(we,Ee,ge),me.set(Le.subarray(we,we+be*ge)),Me(we-Me(0)),Ne!=0)throw new Error("Malformed buffer data: "+Ne)}var Z={NONE:"",OCTAHEDRAL:"meshopt_decodeFilterOct",QUATERNION:"meshopt_decodeFilterQuat",EXPONENTIAL:"meshopt_decodeFilterExp"},ie={ATTRIBUTES:"meshopt_decodeVertexBuffer",TRIANGLES:"meshopt_decodeIndexBuffer",INDICES:"meshopt_decodeIndexSequence"},Y=[],W=0;function ne(he){var pe={object:new Worker(he),pending:0,requests:{}};return pe.object.onmessage=function(me){var be=me.data;pe.pending-=be.count,pe.requests[be.id][be.action](be.value),delete pe.requests[be.id]},pe}function se(he){for(var pe="self.ready = WebAssembly.instantiate(new Uint8Array(["+new Uint8Array(U)+"]), {}).then(function(result) { result.instance.exports.__wasm_call_ctors(); return result.instance; });self.onmessage = "+ce.name+";"+ee.toString()+ce.toString(),me=new Blob([pe],{type:"text/javascript"}),be=URL.createObjectURL(me),ge=Y.length;ge<he;++ge)Y[ge]=ne(be);for(var ge=he;ge<Y.length;++ge)Y[ge].object.postMessage({});Y.length=he,URL.revokeObjectURL(be)}function le(he,pe,me,be,ge){for(var ve=Y[0],Se=1;Se<Y.length;++Se)Y[Se].pending<ve.pending&&(ve=Y[Se]);return new Promise(function(Me,Ee){var we=new Uint8Array(me),Re=++W;ve.pending+=he,ve.requests[Re]={resolve:Me,reject:Ee},ve.object.postMessage({id:Re,count:he,size:pe,source:we,mode:be,filter:ge},[we.buffer])})}function ce(he){var pe=he.data;if(!pe.id)return self.close();self.ready.then(function(me){try{var be=new Uint8Array(pe.count*pe.size);ee(me,me.exports[pe.mode],be,pe.count,pe.size,pe.source,me.exports[pe.filter]),self.postMessage({id:pe.id,count:pe.count,action:"resolve",value:be},[be.buffer])}catch(ge){self.postMessage({id:pe.id,count:pe.count,action:"reject",value:ge})}})}return{ready:q,supported:!0,useWorkers:function(he){se(he)},decodeVertexBuffer:function(he,pe,me,be,ge){ee(G,G.exports.meshopt_decodeVertexBuffer,he,pe,me,be,G.exports[Z[ge]])},decodeIndexBuffer:function(he,pe,me,be){ee(G,G.exports.meshopt_decodeIndexBuffer,he,pe,me,be)},decodeIndexSequence:function(he,pe,me,be){ee(G,G.exports.meshopt_decodeIndexSequence,he,pe,me,be)},decodeGltfBuffer:function(he,pe,me,be,ge,ve){ee(G,G.exports[ie[ge]],he,pe,me,be,G.exports[Z[ve]])},decodeGltfBufferAsync:function(he,pe,me,be,ge){return Y.length>0?le(he,pe,me,ie[be],Z[ge]):q.then(function(){var ve=new Uint8Array(he*pe);return ee(G,G.exports[ie[be]],ve,he,pe,me,G.exports[Z[ge]]),ve})}}})();const _taskCache$1=new WeakMap;class DRACOLoader extends Loader{constructor(w){super(w),this.decoderPath="",this.decoderConfig={},this.decoderBinary=null,this.decoderPending=null,this.workerLimit=4,this.workerPool=[],this.workerNextTaskID=1,this.workerSourceURL="",this.defaultAttributeIDs={position:"POSITION",normal:"NORMAL",color:"COLOR",uv:"TEX_COORD"},this.defaultAttributeTypes={position:"Float32Array",normal:"Float32Array",color:"Float32Array",uv:"Float32Array"}}setDecoderPath(w){return this.decoderPath=w,this}setDecoderConfig(w){return this.decoderConfig=w,this}setWorkerLimit(w){return this.workerLimit=w,this}load(w,D,O,U){const G=new FileLoader(this.manager);G.setPath(this.path),G.setResponseType("arraybuffer"),G.setRequestHeader(this.requestHeader),G.setWithCredentials(this.withCredentials),G.load(w,q=>{this.parse(q,D,U)},O,U)}parse(w,D,O=()=>{}){this.decodeDracoFile(w,D,null,null,SRGBColorSpace,O).catch(O)}decodeDracoFile(w,D,O,U,G=LinearSRGBColorSpace,q=()=>{}){const K={attributeIDs:O||this.defaultAttributeIDs,attributeTypes:U||this.defaultAttributeTypes,useUniqueIDs:!!O,vertexColorSpace:G};return this.decodeGeometry(w,K).then(D).catch(q)}decodeGeometry(w,D){const O=JSON.stringify(D);if(_taskCache$1.has(w)){const ee=_taskCache$1.get(w);if(ee.key===O)return ee.promise;if(w.byteLength===0)throw new Error("THREE.DRACOLoader: Unable to re-decode a buffer with different settings. Buffer has already been transferred.")}let U;const G=this.workerNextTaskID++,q=w.byteLength,K=this._getWorker(G,q).then(ee=>(U=ee,new Promise((Z,ie)=>{U._callbacks[G]={resolve:Z,reject:ie},U.postMessage({type:"decode",id:G,taskConfig:D,buffer:w},[w])}))).then(ee=>this._createGeometry(ee.geometry));return K.catch(()=>!0).then(()=>{U&&G&&this._releaseTask(U,G)}),_taskCache$1.set(w,{key:O,promise:K}),K}_createGeometry(w){const D=new BufferGeometry;w.index&&D.setIndex(new BufferAttribute(w.index.array,1));for(let O=0;O<w.attributes.length;O++){const{name:U,array:G,itemSize:q,stride:K,vertexColorSpace:ee}=w.attributes[O];let Z;if(q===K)Z=new BufferAttribute(G,q);else{const ie=new InterleavedBuffer(G,K);Z=new InterleavedBufferAttribute(ie,q,0)}U==="color"&&(this._assignVertexColorSpace(Z,ee),Z.normalized=!(G instanceof Float32Array)),D.setAttribute(U,Z)}return D}_assignVertexColorSpace(w,D){if(D!==SRGBColorSpace)return;const O=new Color;for(let U=0,G=w.count;U<G;U++)O.fromBufferAttribute(w,U),ColorManagement.colorSpaceToWorking(O,SRGBColorSpace),w.setXYZ(U,O.r,O.g,O.b)}_loadLibrary(w,D){const O=new FileLoader(this.manager);return O.setPath(this.decoderPath),O.setResponseType(D),O.setWithCredentials(this.withCredentials),new Promise((U,G)=>{O.load(w,U,void 0,G)})}preload(){return this._initDecoder(),this}_initDecoder(){if(this.decoderPending)return this.decoderPending;const w=typeof WebAssembly!="object"||this.decoderConfig.type==="js",D=[];return w?D.push(this._loadLibrary("draco_decoder.js","text")):(D.push(this._loadLibrary("draco_wasm_wrapper.js","text")),D.push(this._loadLibrary("draco_decoder.wasm","arraybuffer"))),this.decoderPending=Promise.all(D).then(O=>{const U=O[0];w||(this.decoderConfig.wasmBinary=O[1]);const G=DRACOWorker.toString(),q=["/* draco decoder */",U,"","/* worker */",G.substring(G.indexOf("{")+1,G.lastIndexOf("}"))].join(`
`);this.workerSourceURL=URL.createObjectURL(new Blob([q]))}),this.decoderPending}_getWorker(w,D){return this._initDecoder().then(()=>{if(this.workerPool.length<this.workerLimit){const U=new Worker(this.workerSourceURL);U._callbacks={},U._taskCosts={},U._taskLoad=0,U.postMessage({type:"init",decoderConfig:this.decoderConfig}),U.onmessage=function(G){const q=G.data;switch(q.type){case"decode":U._callbacks[q.id].resolve(q);break;case"error":U._callbacks[q.id].reject(q);break;default:console.error('THREE.DRACOLoader: Unexpected message, "'+q.type+'"')}},this.workerPool.push(U)}else this.workerPool.sort(function(U,G){return U._taskLoad>G._taskLoad?-1:1});const O=this.workerPool[this.workerPool.length-1];return O._taskCosts[w]=D,O._taskLoad+=D,O})}_releaseTask(w,D){w._taskLoad-=w._taskCosts[D],delete w._callbacks[D],delete w._taskCosts[D]}debug(){console.log("Task load: ",this.workerPool.map(w=>w._taskLoad))}dispose(){for(let w=0;w<this.workerPool.length;++w)this.workerPool[w].terminate();return this.workerPool.length=0,this.workerSourceURL!==""&&URL.revokeObjectURL(this.workerSourceURL),this}}function DRACOWorker(){let F,w;onmessage=function(q){const K=q.data;switch(K.type){case"init":F=K.decoderConfig,w=new Promise(function(ie){F.onModuleLoaded=function(Y){ie({draco:Y})},DracoDecoderModule(F)});break;case"decode":const ee=K.buffer,Z=K.taskConfig;w.then(ie=>{const Y=ie.draco,W=new Y.Decoder;try{const ne=D(Y,W,new Int8Array(ee),Z),se=ne.attributes.map(le=>le.array.buffer);ne.index&&se.push(ne.index.array.buffer),self.postMessage({type:"decode",id:K.id,geometry:ne},se)}catch(ne){console.error(ne),self.postMessage({type:"error",id:K.id,error:ne.message})}finally{Y.destroy(W)}});break}};function D(q,K,ee,Z){const ie=Z.attributeIDs,Y=Z.attributeTypes;let W,ne;const se=K.GetEncodedGeometryType(ee);if(se===q.TRIANGULAR_MESH)W=new q.Mesh,ne=K.DecodeArrayToMesh(ee,ee.byteLength,W);else if(se===q.POINT_CLOUD)W=new q.PointCloud,ne=K.DecodeArrayToPointCloud(ee,ee.byteLength,W);else throw new Error("THREE.DRACOLoader: Unexpected geometry type.");if(!ne.ok()||W.ptr===0)throw new Error("THREE.DRACOLoader: Decoding failed: "+ne.error_msg());const le={index:null,attributes:[]};for(const ce in ie){const he=self[Y[ce]];let pe,me;if(Z.useUniqueIDs)me=ie[ce],pe=K.GetAttributeByUniqueId(W,me);else{if(me=K.GetAttributeId(W,q[ie[ce]]),me===-1)continue;pe=K.GetAttribute(W,me)}const be=U(q,K,W,ce,he,pe);ce==="color"&&(be.vertexColorSpace=Z.vertexColorSpace),le.attributes.push(be)}return se===q.TRIANGULAR_MESH&&(le.index=O(q,K,W)),q.destroy(W),le}function O(q,K,ee){const ie=ee.num_faces()*3,Y=ie*4,W=q._malloc(Y);K.GetTrianglesUInt32Array(ee,Y,W);const ne=new Uint32Array(q.HEAPF32.buffer,W,ie).slice();return q._free(W),{array:ne,itemSize:1}}function U(q,K,ee,Z,ie,Y){const W=ee.num_points(),ne=Y.num_components(),se=G(q,ie),le=ne*ie.BYTES_PER_ELEMENT,ce=Math.ceil(le/4)*4,he=ce/ie.BYTES_PER_ELEMENT,pe=W*le,me=W*ce,be=q._malloc(pe);K.GetAttributeDataArrayForAllPoints(ee,Y,se,pe,be);const ge=new ie(q.HEAPF32.buffer,be,pe/ie.BYTES_PER_ELEMENT);let ve;if(le===ce)ve=ge.slice();else{ve=new ie(me/ie.BYTES_PER_ELEMENT);let Se=0;for(let Me=0,Ee=ge.length;Me<Ee;Me++){for(let we=0;we<ne;we++)ve[Se+we]=ge[Me*ne+we];Se+=he}}return q._free(be),{name:Z,count:W,itemSize:ne,array:ve,stride:he}}function G(q,K){switch(K){case Float32Array:return q.DT_FLOAT32;case Int8Array:return q.DT_INT8;case Int16Array:return q.DT_INT16;case Int32Array:return q.DT_INT32;case Uint8Array:return q.DT_UINT8;case Uint16Array:return q.DT_UINT16;case Uint32Array:return q.DT_UINT32}}}function toTrianglesDrawMode(F,w){if(w===TrianglesDrawMode)return console.warn("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles."),F;if(w===TriangleFanDrawMode||w===TriangleStripDrawMode){let D=F.getIndex();if(D===null){const q=[],K=F.getAttribute("position");if(K!==void 0){for(let ee=0;ee<K.count;ee++)q.push(ee);F.setIndex(q),D=F.getIndex()}else return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."),F}const O=D.count-2,U=[];if(w===TriangleFanDrawMode)for(let q=1;q<=O;q++)U.push(D.getX(0)),U.push(D.getX(q)),U.push(D.getX(q+1));else for(let q=0;q<O;q++)q%2===0?(U.push(D.getX(q)),U.push(D.getX(q+1)),U.push(D.getX(q+2))):(U.push(D.getX(q+2)),U.push(D.getX(q+1)),U.push(D.getX(q)));U.length/3!==O&&console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");const G=F.clone();return G.setIndex(U),G.clearGroups(),G}else return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:",w),F}class GLTFLoader extends Loader{constructor(w){super(w),this.dracoLoader=null,this.ktx2Loader=null,this.meshoptDecoder=null,this.pluginCallbacks=[],this.register(function(D){return new GLTFMaterialsClearcoatExtension$1(D)}),this.register(function(D){return new GLTFMaterialsDispersionExtension$1(D)}),this.register(function(D){return new GLTFTextureBasisUExtension(D)}),this.register(function(D){return new GLTFTextureWebPExtension(D)}),this.register(function(D){return new GLTFTextureAVIFExtension(D)}),this.register(function(D){return new GLTFMaterialsSheenExtension$1(D)}),this.register(function(D){return new GLTFMaterialsTransmissionExtension$1(D)}),this.register(function(D){return new GLTFMaterialsVolumeExtension$1(D)}),this.register(function(D){return new GLTFMaterialsIorExtension$1(D)}),this.register(function(D){return new GLTFMaterialsEmissiveStrengthExtension$1(D)}),this.register(function(D){return new GLTFMaterialsSpecularExtension$1(D)}),this.register(function(D){return new GLTFMaterialsIridescenceExtension$1(D)}),this.register(function(D){return new GLTFMaterialsAnisotropyExtension$1(D)}),this.register(function(D){return new GLTFMaterialsBumpExtension$1(D)}),this.register(function(D){return new GLTFLightsExtension(D)}),this.register(function(D){return new GLTFMeshoptCompression(D)}),this.register(function(D){return new GLTFMeshGpuInstancing$1(D)})}load(w,D,O,U){const G=this;let q;if(this.resourcePath!=="")q=this.resourcePath;else if(this.path!==""){const Z=LoaderUtils.extractUrlBase(w);q=LoaderUtils.resolveURL(Z,this.path)}else q=LoaderUtils.extractUrlBase(w);this.manager.itemStart(w);const K=function(Z){U?U(Z):console.error(Z),G.manager.itemError(w),G.manager.itemEnd(w)},ee=new FileLoader(this.manager);ee.setPath(this.path),ee.setResponseType("arraybuffer"),ee.setRequestHeader(this.requestHeader),ee.setWithCredentials(this.withCredentials),ee.load(w,function(Z){try{G.parse(Z,q,function(ie){D(ie),G.manager.itemEnd(w)},K)}catch(ie){K(ie)}},O,K)}setDRACOLoader(w){return this.dracoLoader=w,this}setKTX2Loader(w){return this.ktx2Loader=w,this}setMeshoptDecoder(w){return this.meshoptDecoder=w,this}register(w){return this.pluginCallbacks.indexOf(w)===-1&&this.pluginCallbacks.push(w),this}unregister(w){return this.pluginCallbacks.indexOf(w)!==-1&&this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(w),1),this}parse(w,D,O,U){let G;const q={},K={},ee=new TextDecoder;if(typeof w=="string")G=JSON.parse(w);else if(w instanceof ArrayBuffer)if(ee.decode(new Uint8Array(w,0,4))===BINARY_EXTENSION_HEADER_MAGIC){try{q[EXTENSIONS.KHR_BINARY_GLTF]=new GLTFBinaryExtension(w)}catch(Y){U&&U(Y);return}G=JSON.parse(q[EXTENSIONS.KHR_BINARY_GLTF].content)}else G=JSON.parse(ee.decode(w));else G=w;if(G.asset===void 0||G.asset.version[0]<2){U&&U(new Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported."));return}const Z=new GLTFParser(G,{path:D||this.resourcePath||"",crossOrigin:this.crossOrigin,requestHeader:this.requestHeader,manager:this.manager,ktx2Loader:this.ktx2Loader,meshoptDecoder:this.meshoptDecoder});Z.fileLoader.setRequestHeader(this.requestHeader);for(let ie=0;ie<this.pluginCallbacks.length;ie++){const Y=this.pluginCallbacks[ie](Z);Y.name||console.error("THREE.GLTFLoader: Invalid plugin found: missing name"),K[Y.name]=Y,q[Y.name]=!0}if(G.extensionsUsed)for(let ie=0;ie<G.extensionsUsed.length;++ie){const Y=G.extensionsUsed[ie],W=G.extensionsRequired||[];switch(Y){case EXTENSIONS.KHR_MATERIALS_UNLIT:q[Y]=new GLTFMaterialsUnlitExtension$1;break;case EXTENSIONS.KHR_DRACO_MESH_COMPRESSION:q[Y]=new GLTFDracoMeshCompressionExtension(G,this.dracoLoader);break;case EXTENSIONS.KHR_TEXTURE_TRANSFORM:q[Y]=new GLTFTextureTransformExtension;break;case EXTENSIONS.KHR_MESH_QUANTIZATION:q[Y]=new GLTFMeshQuantizationExtension;break;default:W.indexOf(Y)>=0&&K[Y]===void 0&&console.warn('THREE.GLTFLoader: Unknown extension "'+Y+'".')}}Z.setExtensions(q),Z.setPlugins(K),Z.parse(O,U)}parseAsync(w,D){const O=this;return new Promise(function(U,G){O.parse(w,D,U,G)})}}function GLTFRegistry(){let F={};return{get:function(w){return F[w]},add:function(w,D){F[w]=D},remove:function(w){delete F[w]},removeAll:function(){F={}}}}const EXTENSIONS={KHR_BINARY_GLTF:"KHR_binary_glTF",KHR_DRACO_MESH_COMPRESSION:"KHR_draco_mesh_compression",KHR_LIGHTS_PUNCTUAL:"KHR_lights_punctual",KHR_MATERIALS_CLEARCOAT:"KHR_materials_clearcoat",KHR_MATERIALS_DISPERSION:"KHR_materials_dispersion",KHR_MATERIALS_IOR:"KHR_materials_ior",KHR_MATERIALS_SHEEN:"KHR_materials_sheen",KHR_MATERIALS_SPECULAR:"KHR_materials_specular",KHR_MATERIALS_TRANSMISSION:"KHR_materials_transmission",KHR_MATERIALS_IRIDESCENCE:"KHR_materials_iridescence",KHR_MATERIALS_ANISOTROPY:"KHR_materials_anisotropy",KHR_MATERIALS_UNLIT:"KHR_materials_unlit",KHR_MATERIALS_VOLUME:"KHR_materials_volume",KHR_TEXTURE_BASISU:"KHR_texture_basisu",KHR_TEXTURE_TRANSFORM:"KHR_texture_transform",KHR_MESH_QUANTIZATION:"KHR_mesh_quantization",KHR_MATERIALS_EMISSIVE_STRENGTH:"KHR_materials_emissive_strength",EXT_MATERIALS_BUMP:"EXT_materials_bump",EXT_TEXTURE_WEBP:"EXT_texture_webp",EXT_TEXTURE_AVIF:"EXT_texture_avif",EXT_MESHOPT_COMPRESSION:"EXT_meshopt_compression",EXT_MESH_GPU_INSTANCING:"EXT_mesh_gpu_instancing"};class GLTFLightsExtension{constructor(w){this.parser=w,this.name=EXTENSIONS.KHR_LIGHTS_PUNCTUAL,this.cache={refs:{},uses:{}}}_markDefs(){const w=this.parser,D=this.parser.json.nodes||[];for(let O=0,U=D.length;O<U;O++){const G=D[O];G.extensions&&G.extensions[this.name]&&G.extensions[this.name].light!==void 0&&w._addNodeRef(this.cache,G.extensions[this.name].light)}}_loadLight(w){const D=this.parser,O="light:"+w;let U=D.cache.get(O);if(U)return U;const G=D.json,ee=((G.extensions&&G.extensions[this.name]||{}).lights||[])[w];let Z;const ie=new Color(16777215);ee.color!==void 0&&ie.setRGB(ee.color[0],ee.color[1],ee.color[2],LinearSRGBColorSpace);const Y=ee.range!==void 0?ee.range:0;switch(ee.type){case"directional":Z=new DirectionalLight(ie),Z.target.position.set(0,0,-1),Z.add(Z.target);break;case"point":Z=new PointLight(ie),Z.distance=Y;break;case"spot":Z=new SpotLight(ie),Z.distance=Y,ee.spot=ee.spot||{},ee.spot.innerConeAngle=ee.spot.innerConeAngle!==void 0?ee.spot.innerConeAngle:0,ee.spot.outerConeAngle=ee.spot.outerConeAngle!==void 0?ee.spot.outerConeAngle:Math.PI/4,Z.angle=ee.spot.outerConeAngle,Z.penumbra=1-ee.spot.innerConeAngle/ee.spot.outerConeAngle,Z.target.position.set(0,0,-1),Z.add(Z.target);break;default:throw new Error("THREE.GLTFLoader: Unexpected light type: "+ee.type)}return Z.position.set(0,0,0),assignExtrasToUserData(Z,ee),ee.intensity!==void 0&&(Z.intensity=ee.intensity),Z.name=D.createUniqueName(ee.name||"light_"+w),U=Promise.resolve(Z),D.cache.add(O,U),U}getDependency(w,D){if(w==="light")return this._loadLight(D)}createNodeAttachment(w){const D=this,O=this.parser,G=O.json.nodes[w],K=(G.extensions&&G.extensions[this.name]||{}).light;return K===void 0?null:this._loadLight(K).then(function(ee){return O._getNodeRef(D.cache,K,ee)})}}let GLTFMaterialsUnlitExtension$1=class{constructor(){this.name=EXTENSIONS.KHR_MATERIALS_UNLIT}getMaterialType(){return MeshBasicMaterial}extendParams(w,D,O){const U=[];w.color=new Color(1,1,1),w.opacity=1;const G=D.pbrMetallicRoughness;if(G){if(Array.isArray(G.baseColorFactor)){const q=G.baseColorFactor;w.color.setRGB(q[0],q[1],q[2],LinearSRGBColorSpace),w.opacity=q[3]}G.baseColorTexture!==void 0&&U.push(O.assignTexture(w,"map",G.baseColorTexture,SRGBColorSpace))}return Promise.all(U)}},GLTFMaterialsEmissiveStrengthExtension$1=class{constructor(w){this.parser=w,this.name=EXTENSIONS.KHR_MATERIALS_EMISSIVE_STRENGTH}extendMaterialParams(w,D){const U=this.parser.json.materials[w];if(!U.extensions||!U.extensions[this.name])return Promise.resolve();const G=U.extensions[this.name].emissiveStrength;return G!==void 0&&(D.emissiveIntensity=G),Promise.resolve()}},GLTFMaterialsClearcoatExtension$1=class{constructor(w){this.parser=w,this.name=EXTENSIONS.KHR_MATERIALS_CLEARCOAT}getMaterialType(w){const O=this.parser.json.materials[w];return!O.extensions||!O.extensions[this.name]?null:MeshPhysicalMaterial}extendMaterialParams(w,D){const O=this.parser,U=O.json.materials[w];if(!U.extensions||!U.extensions[this.name])return Promise.resolve();const G=[],q=U.extensions[this.name];if(q.clearcoatFactor!==void 0&&(D.clearcoat=q.clearcoatFactor),q.clearcoatTexture!==void 0&&G.push(O.assignTexture(D,"clearcoatMap",q.clearcoatTexture)),q.clearcoatRoughnessFactor!==void 0&&(D.clearcoatRoughness=q.clearcoatRoughnessFactor),q.clearcoatRoughnessTexture!==void 0&&G.push(O.assignTexture(D,"clearcoatRoughnessMap",q.clearcoatRoughnessTexture)),q.clearcoatNormalTexture!==void 0&&(G.push(O.assignTexture(D,"clearcoatNormalMap",q.clearcoatNormalTexture)),q.clearcoatNormalTexture.scale!==void 0)){const K=q.clearcoatNormalTexture.scale;D.clearcoatNormalScale=new Vector2(K,K)}return Promise.all(G)}},GLTFMaterialsDispersionExtension$1=class{constructor(w){this.parser=w,this.name=EXTENSIONS.KHR_MATERIALS_DISPERSION}getMaterialType(w){const O=this.parser.json.materials[w];return!O.extensions||!O.extensions[this.name]?null:MeshPhysicalMaterial}extendMaterialParams(w,D){const U=this.parser.json.materials[w];if(!U.extensions||!U.extensions[this.name])return Promise.resolve();const G=U.extensions[this.name];return D.dispersion=G.dispersion!==void 0?G.dispersion:0,Promise.resolve()}},GLTFMaterialsIridescenceExtension$1=class{constructor(w){this.parser=w,this.name=EXTENSIONS.KHR_MATERIALS_IRIDESCENCE}getMaterialType(w){const O=this.parser.json.materials[w];return!O.extensions||!O.extensions[this.name]?null:MeshPhysicalMaterial}extendMaterialParams(w,D){const O=this.parser,U=O.json.materials[w];if(!U.extensions||!U.extensions[this.name])return Promise.resolve();const G=[],q=U.extensions[this.name];return q.iridescenceFactor!==void 0&&(D.iridescence=q.iridescenceFactor),q.iridescenceTexture!==void 0&&G.push(O.assignTexture(D,"iridescenceMap",q.iridescenceTexture)),q.iridescenceIor!==void 0&&(D.iridescenceIOR=q.iridescenceIor),D.iridescenceThicknessRange===void 0&&(D.iridescenceThicknessRange=[100,400]),q.iridescenceThicknessMinimum!==void 0&&(D.iridescenceThicknessRange[0]=q.iridescenceThicknessMinimum),q.iridescenceThicknessMaximum!==void 0&&(D.iridescenceThicknessRange[1]=q.iridescenceThicknessMaximum),q.iridescenceThicknessTexture!==void 0&&G.push(O.assignTexture(D,"iridescenceThicknessMap",q.iridescenceThicknessTexture)),Promise.all(G)}},GLTFMaterialsSheenExtension$1=class{constructor(w){this.parser=w,this.name=EXTENSIONS.KHR_MATERIALS_SHEEN}getMaterialType(w){const O=this.parser.json.materials[w];return!O.extensions||!O.extensions[this.name]?null:MeshPhysicalMaterial}extendMaterialParams(w,D){const O=this.parser,U=O.json.materials[w];if(!U.extensions||!U.extensions[this.name])return Promise.resolve();const G=[];D.sheenColor=new Color(0,0,0),D.sheenRoughness=0,D.sheen=1;const q=U.extensions[this.name];if(q.sheenColorFactor!==void 0){const K=q.sheenColorFactor;D.sheenColor.setRGB(K[0],K[1],K[2],LinearSRGBColorSpace)}return q.sheenRoughnessFactor!==void 0&&(D.sheenRoughness=q.sheenRoughnessFactor),q.sheenColorTexture!==void 0&&G.push(O.assignTexture(D,"sheenColorMap",q.sheenColorTexture,SRGBColorSpace)),q.sheenRoughnessTexture!==void 0&&G.push(O.assignTexture(D,"sheenRoughnessMap",q.sheenRoughnessTexture)),Promise.all(G)}},GLTFMaterialsTransmissionExtension$1=class{constructor(w){this.parser=w,this.name=EXTENSIONS.KHR_MATERIALS_TRANSMISSION}getMaterialType(w){const O=this.parser.json.materials[w];return!O.extensions||!O.extensions[this.name]?null:MeshPhysicalMaterial}extendMaterialParams(w,D){const O=this.parser,U=O.json.materials[w];if(!U.extensions||!U.extensions[this.name])return Promise.resolve();const G=[],q=U.extensions[this.name];return q.transmissionFactor!==void 0&&(D.transmission=q.transmissionFactor),q.transmissionTexture!==void 0&&G.push(O.assignTexture(D,"transmissionMap",q.transmissionTexture)),Promise.all(G)}},GLTFMaterialsVolumeExtension$1=class{constructor(w){this.parser=w,this.name=EXTENSIONS.KHR_MATERIALS_VOLUME}getMaterialType(w){const O=this.parser.json.materials[w];return!O.extensions||!O.extensions[this.name]?null:MeshPhysicalMaterial}extendMaterialParams(w,D){const O=this.parser,U=O.json.materials[w];if(!U.extensions||!U.extensions[this.name])return Promise.resolve();const G=[],q=U.extensions[this.name];D.thickness=q.thicknessFactor!==void 0?q.thicknessFactor:0,q.thicknessTexture!==void 0&&G.push(O.assignTexture(D,"thicknessMap",q.thicknessTexture)),D.attenuationDistance=q.attenuationDistance||1/0;const K=q.attenuationColor||[1,1,1];return D.attenuationColor=new Color().setRGB(K[0],K[1],K[2],LinearSRGBColorSpace),Promise.all(G)}},GLTFMaterialsIorExtension$1=class{constructor(w){this.parser=w,this.name=EXTENSIONS.KHR_MATERIALS_IOR}getMaterialType(w){const O=this.parser.json.materials[w];return!O.extensions||!O.extensions[this.name]?null:MeshPhysicalMaterial}extendMaterialParams(w,D){const U=this.parser.json.materials[w];if(!U.extensions||!U.extensions[this.name])return Promise.resolve();const G=U.extensions[this.name];return D.ior=G.ior!==void 0?G.ior:1.5,Promise.resolve()}},GLTFMaterialsSpecularExtension$1=class{constructor(w){this.parser=w,this.name=EXTENSIONS.KHR_MATERIALS_SPECULAR}getMaterialType(w){const O=this.parser.json.materials[w];return!O.extensions||!O.extensions[this.name]?null:MeshPhysicalMaterial}extendMaterialParams(w,D){const O=this.parser,U=O.json.materials[w];if(!U.extensions||!U.extensions[this.name])return Promise.resolve();const G=[],q=U.extensions[this.name];D.specularIntensity=q.specularFactor!==void 0?q.specularFactor:1,q.specularTexture!==void 0&&G.push(O.assignTexture(D,"specularIntensityMap",q.specularTexture));const K=q.specularColorFactor||[1,1,1];return D.specularColor=new Color().setRGB(K[0],K[1],K[2],LinearSRGBColorSpace),q.specularColorTexture!==void 0&&G.push(O.assignTexture(D,"specularColorMap",q.specularColorTexture,SRGBColorSpace)),Promise.all(G)}},GLTFMaterialsBumpExtension$1=class{constructor(w){this.parser=w,this.name=EXTENSIONS.EXT_MATERIALS_BUMP}getMaterialType(w){const O=this.parser.json.materials[w];return!O.extensions||!O.extensions[this.name]?null:MeshPhysicalMaterial}extendMaterialParams(w,D){const O=this.parser,U=O.json.materials[w];if(!U.extensions||!U.extensions[this.name])return Promise.resolve();const G=[],q=U.extensions[this.name];return D.bumpScale=q.bumpFactor!==void 0?q.bumpFactor:1,q.bumpTexture!==void 0&&G.push(O.assignTexture(D,"bumpMap",q.bumpTexture)),Promise.all(G)}},GLTFMaterialsAnisotropyExtension$1=class{constructor(w){this.parser=w,this.name=EXTENSIONS.KHR_MATERIALS_ANISOTROPY}getMaterialType(w){const O=this.parser.json.materials[w];return!O.extensions||!O.extensions[this.name]?null:MeshPhysicalMaterial}extendMaterialParams(w,D){const O=this.parser,U=O.json.materials[w];if(!U.extensions||!U.extensions[this.name])return Promise.resolve();const G=[],q=U.extensions[this.name];return q.anisotropyStrength!==void 0&&(D.anisotropy=q.anisotropyStrength),q.anisotropyRotation!==void 0&&(D.anisotropyRotation=q.anisotropyRotation),q.anisotropyTexture!==void 0&&G.push(O.assignTexture(D,"anisotropyMap",q.anisotropyTexture)),Promise.all(G)}};class GLTFTextureBasisUExtension{constructor(w){this.parser=w,this.name=EXTENSIONS.KHR_TEXTURE_BASISU}loadTexture(w){const D=this.parser,O=D.json,U=O.textures[w];if(!U.extensions||!U.extensions[this.name])return null;const G=U.extensions[this.name],q=D.options.ktx2Loader;if(!q){if(O.extensionsRequired&&O.extensionsRequired.indexOf(this.name)>=0)throw new Error("THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures");return null}return D.loadTextureImage(w,G.source,q)}}class GLTFTextureWebPExtension{constructor(w){this.parser=w,this.name=EXTENSIONS.EXT_TEXTURE_WEBP}loadTexture(w){const D=this.name,O=this.parser,U=O.json,G=U.textures[w];if(!G.extensions||!G.extensions[D])return null;const q=G.extensions[D],K=U.images[q.source];let ee=O.textureLoader;if(K.uri){const Z=O.options.manager.getHandler(K.uri);Z!==null&&(ee=Z)}return O.loadTextureImage(w,q.source,ee)}}class GLTFTextureAVIFExtension{constructor(w){this.parser=w,this.name=EXTENSIONS.EXT_TEXTURE_AVIF}loadTexture(w){const D=this.name,O=this.parser,U=O.json,G=U.textures[w];if(!G.extensions||!G.extensions[D])return null;const q=G.extensions[D],K=U.images[q.source];let ee=O.textureLoader;if(K.uri){const Z=O.options.manager.getHandler(K.uri);Z!==null&&(ee=Z)}return O.loadTextureImage(w,q.source,ee)}}class GLTFMeshoptCompression{constructor(w){this.name=EXTENSIONS.EXT_MESHOPT_COMPRESSION,this.parser=w}loadBufferView(w){const D=this.parser.json,O=D.bufferViews[w];if(O.extensions&&O.extensions[this.name]){const U=O.extensions[this.name],G=this.parser.getDependency("buffer",U.buffer),q=this.parser.options.meshoptDecoder;if(!q||!q.supported){if(D.extensionsRequired&&D.extensionsRequired.indexOf(this.name)>=0)throw new Error("THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files");return null}return G.then(function(K){const ee=U.byteOffset||0,Z=U.byteLength||0,ie=U.count,Y=U.byteStride,W=new Uint8Array(K,ee,Z);return q.decodeGltfBufferAsync?q.decodeGltfBufferAsync(ie,Y,W,U.mode,U.filter).then(function(ne){return ne.buffer}):q.ready.then(function(){const ne=new ArrayBuffer(ie*Y);return q.decodeGltfBuffer(new Uint8Array(ne),ie,Y,W,U.mode,U.filter),ne})})}else return null}}let GLTFMeshGpuInstancing$1=class{constructor(w){this.name=EXTENSIONS.EXT_MESH_GPU_INSTANCING,this.parser=w}createNodeMesh(w){const D=this.parser.json,O=D.nodes[w];if(!O.extensions||!O.extensions[this.name]||O.mesh===void 0)return null;const U=D.meshes[O.mesh];for(const Z of U.primitives)if(Z.mode!==WEBGL_CONSTANTS$1.TRIANGLES&&Z.mode!==WEBGL_CONSTANTS$1.TRIANGLE_STRIP&&Z.mode!==WEBGL_CONSTANTS$1.TRIANGLE_FAN&&Z.mode!==void 0)return null;const q=O.extensions[this.name].attributes,K=[],ee={};for(const Z in q)K.push(this.parser.getDependency("accessor",q[Z]).then(ie=>(ee[Z]=ie,ee[Z])));return K.length<1?null:(K.push(this.parser.createNodeMesh(w)),Promise.all(K).then(Z=>{const ie=Z.pop(),Y=ie.isGroup?ie.children:[ie],W=Z[0].count,ne=[];for(const se of Y){const le=new Matrix4,ce=new Vector3,he=new Quaternion,pe=new Vector3(1,1,1),me=new InstancedMesh(se.geometry,se.material,W);for(let be=0;be<W;be++)ee.TRANSLATION&&ce.fromBufferAttribute(ee.TRANSLATION,be),ee.ROTATION&&he.fromBufferAttribute(ee.ROTATION,be),ee.SCALE&&pe.fromBufferAttribute(ee.SCALE,be),me.setMatrixAt(be,le.compose(ce,he,pe));for(const be in ee)if(be==="_COLOR_0"){const ge=ee[be];me.instanceColor=new InstancedBufferAttribute(ge.array,ge.itemSize,ge.normalized)}else be!=="TRANSLATION"&&be!=="ROTATION"&&be!=="SCALE"&&se.geometry.setAttribute(be,ee[be]);Object3D.prototype.copy.call(me,se),this.parser.assignFinalMaterial(me),ne.push(me)}return ie.isGroup?(ie.clear(),ie.add(...ne),ie):ne[0]}))}};const BINARY_EXTENSION_HEADER_MAGIC="glTF",BINARY_EXTENSION_HEADER_LENGTH=12,BINARY_EXTENSION_CHUNK_TYPES={JSON:1313821514,BIN:5130562};class GLTFBinaryExtension{constructor(w){this.name=EXTENSIONS.KHR_BINARY_GLTF,this.content=null,this.body=null;const D=new DataView(w,0,BINARY_EXTENSION_HEADER_LENGTH),O=new TextDecoder;if(this.header={magic:O.decode(new Uint8Array(w.slice(0,4))),version:D.getUint32(4,!0),length:D.getUint32(8,!0)},this.header.magic!==BINARY_EXTENSION_HEADER_MAGIC)throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");if(this.header.version<2)throw new Error("THREE.GLTFLoader: Legacy binary file detected.");const U=this.header.length-BINARY_EXTENSION_HEADER_LENGTH,G=new DataView(w,BINARY_EXTENSION_HEADER_LENGTH);let q=0;for(;q<U;){const K=G.getUint32(q,!0);q+=4;const ee=G.getUint32(q,!0);if(q+=4,ee===BINARY_EXTENSION_CHUNK_TYPES.JSON){const Z=new Uint8Array(w,BINARY_EXTENSION_HEADER_LENGTH+q,K);this.content=O.decode(Z)}else if(ee===BINARY_EXTENSION_CHUNK_TYPES.BIN){const Z=BINARY_EXTENSION_HEADER_LENGTH+q;this.body=w.slice(Z,Z+K)}q+=K}if(this.content===null)throw new Error("THREE.GLTFLoader: JSON content not found.")}}class GLTFDracoMeshCompressionExtension{constructor(w,D){if(!D)throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");this.name=EXTENSIONS.KHR_DRACO_MESH_COMPRESSION,this.json=w,this.dracoLoader=D,this.dracoLoader.preload()}decodePrimitive(w,D){const O=this.json,U=this.dracoLoader,G=w.extensions[this.name].bufferView,q=w.extensions[this.name].attributes,K={},ee={},Z={};for(const ie in q){const Y=ATTRIBUTES[ie]||ie.toLowerCase();K[Y]=q[ie]}for(const ie in w.attributes){const Y=ATTRIBUTES[ie]||ie.toLowerCase();if(q[ie]!==void 0){const W=O.accessors[w.attributes[ie]],ne=WEBGL_COMPONENT_TYPES[W.componentType];Z[Y]=ne.name,ee[Y]=W.normalized===!0}}return D.getDependency("bufferView",G).then(function(ie){return new Promise(function(Y,W){U.decodeDracoFile(ie,function(ne){for(const se in ne.attributes){const le=ne.attributes[se],ce=ee[se];ce!==void 0&&(le.normalized=ce)}Y(ne)},K,Z,LinearSRGBColorSpace,W)})})}}class GLTFTextureTransformExtension{constructor(){this.name=EXTENSIONS.KHR_TEXTURE_TRANSFORM}extendTexture(w,D){return(D.texCoord===void 0||D.texCoord===w.channel)&&D.offset===void 0&&D.rotation===void 0&&D.scale===void 0||(w=w.clone(),D.texCoord!==void 0&&(w.channel=D.texCoord),D.offset!==void 0&&w.offset.fromArray(D.offset),D.rotation!==void 0&&(w.rotation=D.rotation),D.scale!==void 0&&w.repeat.fromArray(D.scale),w.needsUpdate=!0),w}}class GLTFMeshQuantizationExtension{constructor(){this.name=EXTENSIONS.KHR_MESH_QUANTIZATION}}class GLTFCubicSplineInterpolant extends Interpolant{constructor(w,D,O,U){super(w,D,O,U)}copySampleValue_(w){const D=this.resultBuffer,O=this.sampleValues,U=this.valueSize,G=w*U*3+U;for(let q=0;q!==U;q++)D[q]=O[G+q];return D}interpolate_(w,D,O,U){const G=this.resultBuffer,q=this.sampleValues,K=this.valueSize,ee=K*2,Z=K*3,ie=U-D,Y=(O-D)/ie,W=Y*Y,ne=W*Y,se=w*Z,le=se-Z,ce=-2*ne+3*W,he=ne-W,pe=1-ce,me=he-W+Y;for(let be=0;be!==K;be++){const ge=q[le+be+K],ve=q[le+be+ee]*ie,Se=q[se+be+K],Me=q[se+be]*ie;G[be]=pe*ge+me*ve+ce*Se+he*Me}return G}}const _quaternion=new Quaternion;class GLTFCubicSplineQuaternionInterpolant extends GLTFCubicSplineInterpolant{interpolate_(w,D,O,U){const G=super.interpolate_(w,D,O,U);return _quaternion.fromArray(G).normalize().toArray(G),G}}const WEBGL_CONSTANTS$1={POINTS:0,LINES:1,LINE_LOOP:2,LINE_STRIP:3,TRIANGLES:4,TRIANGLE_STRIP:5,TRIANGLE_FAN:6},WEBGL_COMPONENT_TYPES={5120:Int8Array,5121:Uint8Array,5122:Int16Array,5123:Uint16Array,5125:Uint32Array,5126:Float32Array},WEBGL_FILTERS={9728:NearestFilter,9729:LinearFilter,9984:NearestMipmapNearestFilter,9985:LinearMipmapNearestFilter,9986:NearestMipmapLinearFilter,9987:LinearMipmapLinearFilter},WEBGL_WRAPPINGS={33071:ClampToEdgeWrapping,33648:MirroredRepeatWrapping,10497:RepeatWrapping},WEBGL_TYPE_SIZES={SCALAR:1,VEC2:2,VEC3:3,VEC4:4,MAT2:4,MAT3:9,MAT4:16},ATTRIBUTES={POSITION:"position",NORMAL:"normal",TANGENT:"tangent",TEXCOORD_0:"uv",TEXCOORD_1:"uv1",TEXCOORD_2:"uv2",TEXCOORD_3:"uv3",COLOR_0:"color",WEIGHTS_0:"skinWeight",JOINTS_0:"skinIndex"},PATH_PROPERTIES$1={scale:"scale",translation:"position",rotation:"quaternion",weights:"morphTargetInfluences"},INTERPOLATION={CUBICSPLINE:void 0,LINEAR:InterpolateLinear,STEP:InterpolateDiscrete},ALPHA_MODES={OPAQUE:"OPAQUE",MASK:"MASK",BLEND:"BLEND"};function createDefaultMaterial(F){return F.DefaultMaterial===void 0&&(F.DefaultMaterial=new MeshStandardMaterial({color:16777215,emissive:0,metalness:1,roughness:1,transparent:!1,depthTest:!0,side:FrontSide})),F.DefaultMaterial}function addUnknownExtensionsToUserData(F,w,D){for(const O in D.extensions)F[O]===void 0&&(w.userData.gltfExtensions=w.userData.gltfExtensions||{},w.userData.gltfExtensions[O]=D.extensions[O])}function assignExtrasToUserData(F,w){w.extras!==void 0&&(typeof w.extras=="object"?Object.assign(F.userData,w.extras):console.warn("THREE.GLTFLoader: Ignoring primitive type .extras, "+w.extras))}function addMorphTargets(F,w,D){let O=!1,U=!1,G=!1;for(let Z=0,ie=w.length;Z<ie;Z++){const Y=w[Z];if(Y.POSITION!==void 0&&(O=!0),Y.NORMAL!==void 0&&(U=!0),Y.COLOR_0!==void 0&&(G=!0),O&&U&&G)break}if(!O&&!U&&!G)return Promise.resolve(F);const q=[],K=[],ee=[];for(let Z=0,ie=w.length;Z<ie;Z++){const Y=w[Z];if(O){const W=Y.POSITION!==void 0?D.getDependency("accessor",Y.POSITION):F.attributes.position;q.push(W)}if(U){const W=Y.NORMAL!==void 0?D.getDependency("accessor",Y.NORMAL):F.attributes.normal;K.push(W)}if(G){const W=Y.COLOR_0!==void 0?D.getDependency("accessor",Y.COLOR_0):F.attributes.color;ee.push(W)}}return Promise.all([Promise.all(q),Promise.all(K),Promise.all(ee)]).then(function(Z){const ie=Z[0],Y=Z[1],W=Z[2];return O&&(F.morphAttributes.position=ie),U&&(F.morphAttributes.normal=Y),G&&(F.morphAttributes.color=W),F.morphTargetsRelative=!0,F})}function updateMorphTargets(F,w){if(F.updateMorphTargets(),w.weights!==void 0)for(let D=0,O=w.weights.length;D<O;D++)F.morphTargetInfluences[D]=w.weights[D];if(w.extras&&Array.isArray(w.extras.targetNames)){const D=w.extras.targetNames;if(F.morphTargetInfluences.length===D.length){F.morphTargetDictionary={};for(let O=0,U=D.length;O<U;O++)F.morphTargetDictionary[D[O]]=O}else console.warn("THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.")}}function createPrimitiveKey(F){let w;const D=F.extensions&&F.extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION];if(D?w="draco:"+D.bufferView+":"+D.indices+":"+createAttributesKey(D.attributes):w=F.indices+":"+createAttributesKey(F.attributes)+":"+F.mode,F.targets!==void 0)for(let O=0,U=F.targets.length;O<U;O++)w+=":"+createAttributesKey(F.targets[O]);return w}function createAttributesKey(F){let w="";const D=Object.keys(F).sort();for(let O=0,U=D.length;O<U;O++)w+=D[O]+":"+F[D[O]]+";";return w}function getNormalizedComponentScale(F){switch(F){case Int8Array:return 1/127;case Uint8Array:return 1/255;case Int16Array:return 1/32767;case Uint16Array:return 1/65535;default:throw new Error("THREE.GLTFLoader: Unsupported normalized accessor component type.")}}function getImageURIMimeType(F){return F.search(/\.jpe?g($|\?)/i)>0||F.search(/^data\:image\/jpeg/)===0?"image/jpeg":F.search(/\.webp($|\?)/i)>0||F.search(/^data\:image\/webp/)===0?"image/webp":F.search(/\.ktx2($|\?)/i)>0||F.search(/^data\:image\/ktx2/)===0?"image/ktx2":"image/png"}const _identityMatrix=new Matrix4;class GLTFParser{constructor(w={},D={}){this.json=w,this.extensions={},this.plugins={},this.options=D,this.cache=new GLTFRegistry,this.associations=new Map,this.primitiveCache={},this.nodeCache={},this.meshCache={refs:{},uses:{}},this.cameraCache={refs:{},uses:{}},this.lightCache={refs:{},uses:{}},this.sourceCache={},this.textureCache={},this.nodeNamesUsed={};let O=!1,U=-1,G=!1,q=-1;if(typeof navigator<"u"){const K=navigator.userAgent;O=/^((?!chrome|android).)*safari/i.test(K)===!0;const ee=K.match(/Version\/(\d+)/);U=O&&ee?parseInt(ee[1],10):-1,G=K.indexOf("Firefox")>-1,q=G?K.match(/Firefox\/([0-9]+)\./)[1]:-1}typeof createImageBitmap>"u"||O&&U<17||G&&q<98?this.textureLoader=new TextureLoader(this.options.manager):this.textureLoader=new ImageBitmapLoader(this.options.manager),this.textureLoader.setCrossOrigin(this.options.crossOrigin),this.textureLoader.setRequestHeader(this.options.requestHeader),this.fileLoader=new FileLoader(this.options.manager),this.fileLoader.setResponseType("arraybuffer"),this.options.crossOrigin==="use-credentials"&&this.fileLoader.setWithCredentials(!0)}setExtensions(w){this.extensions=w}setPlugins(w){this.plugins=w}parse(w,D){const O=this,U=this.json,G=this.extensions;this.cache.removeAll(),this.nodeCache={},this._invokeAll(function(q){return q._markDefs&&q._markDefs()}),Promise.all(this._invokeAll(function(q){return q.beforeRoot&&q.beforeRoot()})).then(function(){return Promise.all([O.getDependencies("scene"),O.getDependencies("animation"),O.getDependencies("camera")])}).then(function(q){const K={scene:q[0][U.scene||0],scenes:q[0],animations:q[1],cameras:q[2],asset:U.asset,parser:O,userData:{}};return addUnknownExtensionsToUserData(G,K,U),assignExtrasToUserData(K,U),Promise.all(O._invokeAll(function(ee){return ee.afterRoot&&ee.afterRoot(K)})).then(function(){for(const ee of K.scenes)ee.updateMatrixWorld();w(K)})}).catch(D)}_markDefs(){const w=this.json.nodes||[],D=this.json.skins||[],O=this.json.meshes||[];for(let U=0,G=D.length;U<G;U++){const q=D[U].joints;for(let K=0,ee=q.length;K<ee;K++)w[q[K]].isBone=!0}for(let U=0,G=w.length;U<G;U++){const q=w[U];q.mesh!==void 0&&(this._addNodeRef(this.meshCache,q.mesh),q.skin!==void 0&&(O[q.mesh].isSkinnedMesh=!0)),q.camera!==void 0&&this._addNodeRef(this.cameraCache,q.camera)}}_addNodeRef(w,D){D!==void 0&&(w.refs[D]===void 0&&(w.refs[D]=w.uses[D]=0),w.refs[D]++)}_getNodeRef(w,D,O){if(w.refs[D]<=1)return O;const U=O.clone(),G=(q,K)=>{const ee=this.associations.get(q);ee!=null&&this.associations.set(K,ee);for(const[Z,ie]of q.children.entries())G(ie,K.children[Z])};return G(O,U),U.name+="_instance_"+w.uses[D]++,U}_invokeOne(w){const D=Object.values(this.plugins);D.push(this);for(let O=0;O<D.length;O++){const U=w(D[O]);if(U)return U}return null}_invokeAll(w){const D=Object.values(this.plugins);D.unshift(this);const O=[];for(let U=0;U<D.length;U++){const G=w(D[U]);G&&O.push(G)}return O}getDependency(w,D){const O=w+":"+D;let U=this.cache.get(O);if(!U){switch(w){case"scene":U=this.loadScene(D);break;case"node":U=this._invokeOne(function(G){return G.loadNode&&G.loadNode(D)});break;case"mesh":U=this._invokeOne(function(G){return G.loadMesh&&G.loadMesh(D)});break;case"accessor":U=this.loadAccessor(D);break;case"bufferView":U=this._invokeOne(function(G){return G.loadBufferView&&G.loadBufferView(D)});break;case"buffer":U=this.loadBuffer(D);break;case"material":U=this._invokeOne(function(G){return G.loadMaterial&&G.loadMaterial(D)});break;case"texture":U=this._invokeOne(function(G){return G.loadTexture&&G.loadTexture(D)});break;case"skin":U=this.loadSkin(D);break;case"animation":U=this._invokeOne(function(G){return G.loadAnimation&&G.loadAnimation(D)});break;case"camera":U=this.loadCamera(D);break;default:if(U=this._invokeOne(function(G){return G!=this&&G.getDependency&&G.getDependency(w,D)}),!U)throw new Error("Unknown type: "+w);break}this.cache.add(O,U)}return U}getDependencies(w){let D=this.cache.get(w);if(!D){const O=this,U=this.json[w+(w==="mesh"?"es":"s")]||[];D=Promise.all(U.map(function(G,q){return O.getDependency(w,q)})),this.cache.add(w,D)}return D}loadBuffer(w){const D=this.json.buffers[w],O=this.fileLoader;if(D.type&&D.type!=="arraybuffer")throw new Error("THREE.GLTFLoader: "+D.type+" buffer type is not supported.");if(D.uri===void 0&&w===0)return Promise.resolve(this.extensions[EXTENSIONS.KHR_BINARY_GLTF].body);const U=this.options;return new Promise(function(G,q){O.load(LoaderUtils.resolveURL(D.uri,U.path),G,void 0,function(){q(new Error('THREE.GLTFLoader: Failed to load buffer "'+D.uri+'".'))})})}loadBufferView(w){const D=this.json.bufferViews[w];return this.getDependency("buffer",D.buffer).then(function(O){const U=D.byteLength||0,G=D.byteOffset||0;return O.slice(G,G+U)})}loadAccessor(w){const D=this,O=this.json,U=this.json.accessors[w];if(U.bufferView===void 0&&U.sparse===void 0){const q=WEBGL_TYPE_SIZES[U.type],K=WEBGL_COMPONENT_TYPES[U.componentType],ee=U.normalized===!0,Z=new K(U.count*q);return Promise.resolve(new BufferAttribute(Z,q,ee))}const G=[];return U.bufferView!==void 0?G.push(this.getDependency("bufferView",U.bufferView)):G.push(null),U.sparse!==void 0&&(G.push(this.getDependency("bufferView",U.sparse.indices.bufferView)),G.push(this.getDependency("bufferView",U.sparse.values.bufferView))),Promise.all(G).then(function(q){const K=q[0],ee=WEBGL_TYPE_SIZES[U.type],Z=WEBGL_COMPONENT_TYPES[U.componentType],ie=Z.BYTES_PER_ELEMENT,Y=ie*ee,W=U.byteOffset||0,ne=U.bufferView!==void 0?O.bufferViews[U.bufferView].byteStride:void 0,se=U.normalized===!0;let le,ce;if(ne&&ne!==Y){const he=Math.floor(W/ne),pe="InterleavedBuffer:"+U.bufferView+":"+U.componentType+":"+he+":"+U.count;let me=D.cache.get(pe);me||(le=new Z(K,he*ne,U.count*ne/ie),me=new InterleavedBuffer(le,ne/ie),D.cache.add(pe,me)),ce=new InterleavedBufferAttribute(me,ee,W%ne/ie,se)}else K===null?le=new Z(U.count*ee):le=new Z(K,W,U.count*ee),ce=new BufferAttribute(le,ee,se);if(U.sparse!==void 0){const he=WEBGL_TYPE_SIZES.SCALAR,pe=WEBGL_COMPONENT_TYPES[U.sparse.indices.componentType],me=U.sparse.indices.byteOffset||0,be=U.sparse.values.byteOffset||0,ge=new pe(q[1],me,U.sparse.count*he),ve=new Z(q[2],be,U.sparse.count*ee);K!==null&&(ce=new BufferAttribute(ce.array.slice(),ce.itemSize,ce.normalized)),ce.normalized=!1;for(let Se=0,Me=ge.length;Se<Me;Se++){const Ee=ge[Se];if(ce.setX(Ee,ve[Se*ee]),ee>=2&&ce.setY(Ee,ve[Se*ee+1]),ee>=3&&ce.setZ(Ee,ve[Se*ee+2]),ee>=4&&ce.setW(Ee,ve[Se*ee+3]),ee>=5)throw new Error("THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.")}ce.normalized=se}return ce})}loadTexture(w){const D=this.json,O=this.options,G=D.textures[w].source,q=D.images[G];let K=this.textureLoader;if(q.uri){const ee=O.manager.getHandler(q.uri);ee!==null&&(K=ee)}return this.loadTextureImage(w,G,K)}loadTextureImage(w,D,O){const U=this,G=this.json,q=G.textures[w],K=G.images[D],ee=(K.uri||K.bufferView)+":"+q.sampler;if(this.textureCache[ee])return this.textureCache[ee];const Z=this.loadImageSource(D,O).then(function(ie){ie.flipY=!1,ie.name=q.name||K.name||"",ie.name===""&&typeof K.uri=="string"&&K.uri.startsWith("data:image/")===!1&&(ie.name=K.uri);const W=(G.samplers||{})[q.sampler]||{};return ie.magFilter=WEBGL_FILTERS[W.magFilter]||LinearFilter,ie.minFilter=WEBGL_FILTERS[W.minFilter]||LinearMipmapLinearFilter,ie.wrapS=WEBGL_WRAPPINGS[W.wrapS]||RepeatWrapping,ie.wrapT=WEBGL_WRAPPINGS[W.wrapT]||RepeatWrapping,ie.generateMipmaps=!ie.isCompressedTexture&&ie.minFilter!==NearestFilter&&ie.minFilter!==LinearFilter,U.associations.set(ie,{textures:w}),ie}).catch(function(){return null});return this.textureCache[ee]=Z,Z}loadImageSource(w,D){const O=this,U=this.json,G=this.options;if(this.sourceCache[w]!==void 0)return this.sourceCache[w].then(Y=>Y.clone());const q=U.images[w],K=self.URL||self.webkitURL;let ee=q.uri||"",Z=!1;if(q.bufferView!==void 0)ee=O.getDependency("bufferView",q.bufferView).then(function(Y){Z=!0;const W=new Blob([Y],{type:q.mimeType});return ee=K.createObjectURL(W),ee});else if(q.uri===void 0)throw new Error("THREE.GLTFLoader: Image "+w+" is missing URI and bufferView");const ie=Promise.resolve(ee).then(function(Y){return new Promise(function(W,ne){let se=W;D.isImageBitmapLoader===!0&&(se=function(le){const ce=new Texture$1(le);ce.needsUpdate=!0,W(ce)}),D.load(LoaderUtils.resolveURL(Y,G.path),se,void 0,ne)})}).then(function(Y){return Z===!0&&K.revokeObjectURL(ee),assignExtrasToUserData(Y,q),Y.userData.mimeType=q.mimeType||getImageURIMimeType(q.uri),Y}).catch(function(Y){throw console.error("THREE.GLTFLoader: Couldn't load texture",ee),Y});return this.sourceCache[w]=ie,ie}assignTexture(w,D,O,U){const G=this;return this.getDependency("texture",O.index).then(function(q){if(!q)return null;if(O.texCoord!==void 0&&O.texCoord>0&&(q=q.clone(),q.channel=O.texCoord),G.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM]){const K=O.extensions!==void 0?O.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM]:void 0;if(K){const ee=G.associations.get(q);q=G.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM].extendTexture(q,K),G.associations.set(q,ee)}}return U!==void 0&&(q.colorSpace=U),w[D]=q,q})}assignFinalMaterial(w){const D=w.geometry;let O=w.material;const U=D.attributes.tangent===void 0,G=D.attributes.color!==void 0,q=D.attributes.normal===void 0;if(w.isPoints){const K="PointsMaterial:"+O.uuid;let ee=this.cache.get(K);ee||(ee=new PointsMaterial,Material$1.prototype.copy.call(ee,O),ee.color.copy(O.color),ee.map=O.map,ee.sizeAttenuation=!1,this.cache.add(K,ee)),O=ee}else if(w.isLine){const K="LineBasicMaterial:"+O.uuid;let ee=this.cache.get(K);ee||(ee=new LineBasicMaterial,Material$1.prototype.copy.call(ee,O),ee.color.copy(O.color),ee.map=O.map,this.cache.add(K,ee)),O=ee}if(U||G||q){let K="ClonedMaterial:"+O.uuid+":";U&&(K+="derivative-tangents:"),G&&(K+="vertex-colors:"),q&&(K+="flat-shading:");let ee=this.cache.get(K);ee||(ee=O.clone(),G&&(ee.vertexColors=!0),q&&(ee.flatShading=!0),U&&(ee.normalScale&&(ee.normalScale.y*=-1),ee.clearcoatNormalScale&&(ee.clearcoatNormalScale.y*=-1)),this.cache.add(K,ee),this.associations.set(ee,this.associations.get(O))),O=ee}w.material=O}getMaterialType(){return MeshStandardMaterial}loadMaterial(w){const D=this,O=this.json,U=this.extensions,G=O.materials[w];let q;const K={},ee=G.extensions||{},Z=[];if(ee[EXTENSIONS.KHR_MATERIALS_UNLIT]){const Y=U[EXTENSIONS.KHR_MATERIALS_UNLIT];q=Y.getMaterialType(),Z.push(Y.extendParams(K,G,D))}else{const Y=G.pbrMetallicRoughness||{};if(K.color=new Color(1,1,1),K.opacity=1,Array.isArray(Y.baseColorFactor)){const W=Y.baseColorFactor;K.color.setRGB(W[0],W[1],W[2],LinearSRGBColorSpace),K.opacity=W[3]}Y.baseColorTexture!==void 0&&Z.push(D.assignTexture(K,"map",Y.baseColorTexture,SRGBColorSpace)),K.metalness=Y.metallicFactor!==void 0?Y.metallicFactor:1,K.roughness=Y.roughnessFactor!==void 0?Y.roughnessFactor:1,Y.metallicRoughnessTexture!==void 0&&(Z.push(D.assignTexture(K,"metalnessMap",Y.metallicRoughnessTexture)),Z.push(D.assignTexture(K,"roughnessMap",Y.metallicRoughnessTexture))),q=this._invokeOne(function(W){return W.getMaterialType&&W.getMaterialType(w)}),Z.push(Promise.all(this._invokeAll(function(W){return W.extendMaterialParams&&W.extendMaterialParams(w,K)})))}G.doubleSided===!0&&(K.side=DoubleSide);const ie=G.alphaMode||ALPHA_MODES.OPAQUE;if(ie===ALPHA_MODES.BLEND?(K.transparent=!0,K.depthWrite=!1):(K.transparent=!1,ie===ALPHA_MODES.MASK&&(K.alphaTest=G.alphaCutoff!==void 0?G.alphaCutoff:.5)),G.normalTexture!==void 0&&q!==MeshBasicMaterial&&(Z.push(D.assignTexture(K,"normalMap",G.normalTexture)),K.normalScale=new Vector2(1,1),G.normalTexture.scale!==void 0)){const Y=G.normalTexture.scale;K.normalScale.set(Y,Y)}if(G.occlusionTexture!==void 0&&q!==MeshBasicMaterial&&(Z.push(D.assignTexture(K,"aoMap",G.occlusionTexture)),G.occlusionTexture.strength!==void 0&&(K.aoMapIntensity=G.occlusionTexture.strength)),G.emissiveFactor!==void 0&&q!==MeshBasicMaterial){const Y=G.emissiveFactor;K.emissive=new Color().setRGB(Y[0],Y[1],Y[2],LinearSRGBColorSpace)}return G.emissiveTexture!==void 0&&q!==MeshBasicMaterial&&Z.push(D.assignTexture(K,"emissiveMap",G.emissiveTexture,SRGBColorSpace)),Promise.all(Z).then(function(){const Y=new q(K);return G.name&&(Y.name=G.name),assignExtrasToUserData(Y,G),D.associations.set(Y,{materials:w}),G.extensions&&addUnknownExtensionsToUserData(U,Y,G),Y})}createUniqueName(w){const D=PropertyBinding.sanitizeNodeName(w||"");return D in this.nodeNamesUsed?D+"_"+ ++this.nodeNamesUsed[D]:(this.nodeNamesUsed[D]=0,D)}loadGeometries(w){const D=this,O=this.extensions,U=this.primitiveCache;function G(K){return O[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(K,D).then(function(ee){return addPrimitiveAttributes(ee,K,D)})}const q=[];for(let K=0,ee=w.length;K<ee;K++){const Z=w[K],ie=createPrimitiveKey(Z),Y=U[ie];if(Y)q.push(Y.promise);else{let W;Z.extensions&&Z.extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION]?W=G(Z):W=addPrimitiveAttributes(new BufferGeometry,Z,D),U[ie]={primitive:Z,promise:W},q.push(W)}}return Promise.all(q)}loadMesh(w){const D=this,O=this.json,U=this.extensions,G=O.meshes[w],q=G.primitives,K=[];for(let ee=0,Z=q.length;ee<Z;ee++){const ie=q[ee].material===void 0?createDefaultMaterial(this.cache):this.getDependency("material",q[ee].material);K.push(ie)}return K.push(D.loadGeometries(q)),Promise.all(K).then(function(ee){const Z=ee.slice(0,ee.length-1),ie=ee[ee.length-1],Y=[];for(let ne=0,se=ie.length;ne<se;ne++){const le=ie[ne],ce=q[ne];let he;const pe=Z[ne];if(ce.mode===WEBGL_CONSTANTS$1.TRIANGLES||ce.mode===WEBGL_CONSTANTS$1.TRIANGLE_STRIP||ce.mode===WEBGL_CONSTANTS$1.TRIANGLE_FAN||ce.mode===void 0)he=G.isSkinnedMesh===!0?new SkinnedMesh(le,pe):new Mesh(le,pe),he.isSkinnedMesh===!0&&he.normalizeSkinWeights(),ce.mode===WEBGL_CONSTANTS$1.TRIANGLE_STRIP?he.geometry=toTrianglesDrawMode(he.geometry,TriangleStripDrawMode):ce.mode===WEBGL_CONSTANTS$1.TRIANGLE_FAN&&(he.geometry=toTrianglesDrawMode(he.geometry,TriangleFanDrawMode));else if(ce.mode===WEBGL_CONSTANTS$1.LINES)he=new LineSegments(le,pe);else if(ce.mode===WEBGL_CONSTANTS$1.LINE_STRIP)he=new Line(le,pe);else if(ce.mode===WEBGL_CONSTANTS$1.LINE_LOOP)he=new LineLoop(le,pe);else if(ce.mode===WEBGL_CONSTANTS$1.POINTS)he=new Points(le,pe);else throw new Error("THREE.GLTFLoader: Primitive mode unsupported: "+ce.mode);Object.keys(he.geometry.morphAttributes).length>0&&updateMorphTargets(he,G),he.name=D.createUniqueName(G.name||"mesh_"+w),assignExtrasToUserData(he,G),ce.extensions&&addUnknownExtensionsToUserData(U,he,ce),D.assignFinalMaterial(he),Y.push(he)}for(let ne=0,se=Y.length;ne<se;ne++)D.associations.set(Y[ne],{meshes:w,primitives:ne});if(Y.length===1)return G.extensions&&addUnknownExtensionsToUserData(U,Y[0],G),Y[0];const W=new Group;G.extensions&&addUnknownExtensionsToUserData(U,W,G),D.associations.set(W,{meshes:w});for(let ne=0,se=Y.length;ne<se;ne++)W.add(Y[ne]);return W})}loadCamera(w){let D;const O=this.json.cameras[w],U=O[O.type];if(!U){console.warn("THREE.GLTFLoader: Missing camera parameters.");return}return O.type==="perspective"?D=new PerspectiveCamera(MathUtils.radToDeg(U.yfov),U.aspectRatio||1,U.znear||1,U.zfar||2e6):O.type==="orthographic"&&(D=new OrthographicCamera(-U.xmag,U.xmag,U.ymag,-U.ymag,U.znear,U.zfar)),O.name&&(D.name=this.createUniqueName(O.name)),assignExtrasToUserData(D,O),Promise.resolve(D)}loadSkin(w){const D=this.json.skins[w],O=[];for(let U=0,G=D.joints.length;U<G;U++)O.push(this._loadNodeShallow(D.joints[U]));return D.inverseBindMatrices!==void 0?O.push(this.getDependency("accessor",D.inverseBindMatrices)):O.push(null),Promise.all(O).then(function(U){const G=U.pop(),q=U,K=[],ee=[];for(let Z=0,ie=q.length;Z<ie;Z++){const Y=q[Z];if(Y){K.push(Y);const W=new Matrix4;G!==null&&W.fromArray(G.array,Z*16),ee.push(W)}else console.warn('THREE.GLTFLoader: Joint "%s" could not be found.',D.joints[Z])}return new Skeleton(K,ee)})}loadAnimation(w){const D=this.json,O=this,U=D.animations[w],G=U.name?U.name:"animation_"+w,q=[],K=[],ee=[],Z=[],ie=[];for(let Y=0,W=U.channels.length;Y<W;Y++){const ne=U.channels[Y],se=U.samplers[ne.sampler],le=ne.target,ce=le.node,he=U.parameters!==void 0?U.parameters[se.input]:se.input,pe=U.parameters!==void 0?U.parameters[se.output]:se.output;le.node!==void 0&&(q.push(this.getDependency("node",ce)),K.push(this.getDependency("accessor",he)),ee.push(this.getDependency("accessor",pe)),Z.push(se),ie.push(le))}return Promise.all([Promise.all(q),Promise.all(K),Promise.all(ee),Promise.all(Z),Promise.all(ie)]).then(function(Y){const W=Y[0],ne=Y[1],se=Y[2],le=Y[3],ce=Y[4],he=[];for(let me=0,be=W.length;me<be;me++){const ge=W[me],ve=ne[me],Se=se[me],Me=le[me],Ee=ce[me];if(ge===void 0)continue;ge.updateMatrix&&ge.updateMatrix();const we=O._createAnimationTracks(ge,ve,Se,Me,Ee);if(we)for(let Re=0;Re<we.length;Re++)he.push(we[Re])}const pe=new AnimationClip(G,void 0,he);return assignExtrasToUserData(pe,U),pe})}createNodeMesh(w){const D=this.json,O=this,U=D.nodes[w];return U.mesh===void 0?null:O.getDependency("mesh",U.mesh).then(function(G){const q=O._getNodeRef(O.meshCache,U.mesh,G);return U.weights!==void 0&&q.traverse(function(K){if(K.isMesh)for(let ee=0,Z=U.weights.length;ee<Z;ee++)K.morphTargetInfluences[ee]=U.weights[ee]}),q})}loadNode(w){const D=this.json,O=this,U=D.nodes[w],G=O._loadNodeShallow(w),q=[],K=U.children||[];for(let Z=0,ie=K.length;Z<ie;Z++)q.push(O.getDependency("node",K[Z]));const ee=U.skin===void 0?Promise.resolve(null):O.getDependency("skin",U.skin);return Promise.all([G,Promise.all(q),ee]).then(function(Z){const ie=Z[0],Y=Z[1],W=Z[2];W!==null&&ie.traverse(function(ne){ne.isSkinnedMesh&&ne.bind(W,_identityMatrix)});for(let ne=0,se=Y.length;ne<se;ne++)ie.add(Y[ne]);return ie})}_loadNodeShallow(w){const D=this.json,O=this.extensions,U=this;if(this.nodeCache[w]!==void 0)return this.nodeCache[w];const G=D.nodes[w],q=G.name?U.createUniqueName(G.name):"",K=[],ee=U._invokeOne(function(Z){return Z.createNodeMesh&&Z.createNodeMesh(w)});return ee&&K.push(ee),G.camera!==void 0&&K.push(U.getDependency("camera",G.camera).then(function(Z){return U._getNodeRef(U.cameraCache,G.camera,Z)})),U._invokeAll(function(Z){return Z.createNodeAttachment&&Z.createNodeAttachment(w)}).forEach(function(Z){K.push(Z)}),this.nodeCache[w]=Promise.all(K).then(function(Z){let ie;if(G.isBone===!0?ie=new Bone:Z.length>1?ie=new Group:Z.length===1?ie=Z[0]:ie=new Object3D,ie!==Z[0])for(let Y=0,W=Z.length;Y<W;Y++)ie.add(Z[Y]);if(G.name&&(ie.userData.name=G.name,ie.name=q),assignExtrasToUserData(ie,G),G.extensions&&addUnknownExtensionsToUserData(O,ie,G),G.matrix!==void 0){const Y=new Matrix4;Y.fromArray(G.matrix),ie.applyMatrix4(Y)}else G.translation!==void 0&&ie.position.fromArray(G.translation),G.rotation!==void 0&&ie.quaternion.fromArray(G.rotation),G.scale!==void 0&&ie.scale.fromArray(G.scale);if(!U.associations.has(ie))U.associations.set(ie,{});else if(G.mesh!==void 0&&U.meshCache.refs[G.mesh]>1){const Y=U.associations.get(ie);U.associations.set(ie,{...Y})}return U.associations.get(ie).nodes=w,ie}),this.nodeCache[w]}loadScene(w){const D=this.extensions,O=this.json.scenes[w],U=this,G=new Group;O.name&&(G.name=U.createUniqueName(O.name)),assignExtrasToUserData(G,O),O.extensions&&addUnknownExtensionsToUserData(D,G,O);const q=O.nodes||[],K=[];for(let ee=0,Z=q.length;ee<Z;ee++)K.push(U.getDependency("node",q[ee]));return Promise.all(K).then(function(ee){for(let ie=0,Y=ee.length;ie<Y;ie++)G.add(ee[ie]);const Z=ie=>{const Y=new Map;for(const[W,ne]of U.associations)(W instanceof Material$1||W instanceof Texture$1)&&Y.set(W,ne);return ie.traverse(W=>{const ne=U.associations.get(W);ne!=null&&Y.set(W,ne)}),Y};return U.associations=Z(G),G})}_createAnimationTracks(w,D,O,U,G){const q=[],K=w.name?w.name:w.uuid,ee=[];PATH_PROPERTIES$1[G.path]===PATH_PROPERTIES$1.weights?w.traverse(function(W){W.morphTargetInfluences&&ee.push(W.name?W.name:W.uuid)}):ee.push(K);let Z;switch(PATH_PROPERTIES$1[G.path]){case PATH_PROPERTIES$1.weights:Z=NumberKeyframeTrack;break;case PATH_PROPERTIES$1.rotation:Z=QuaternionKeyframeTrack;break;case PATH_PROPERTIES$1.translation:case PATH_PROPERTIES$1.scale:Z=VectorKeyframeTrack;break;default:switch(O.itemSize){case 1:Z=NumberKeyframeTrack;break;case 2:case 3:default:Z=VectorKeyframeTrack;break}break}const ie=U.interpolation!==void 0?INTERPOLATION[U.interpolation]:InterpolateLinear,Y=this._getArrayFromAccessor(O);for(let W=0,ne=ee.length;W<ne;W++){const se=new Z(ee[W]+"."+PATH_PROPERTIES$1[G.path],D.array,Y,ie);U.interpolation==="CUBICSPLINE"&&this._createCubicSplineTrackInterpolant(se),q.push(se)}return q}_getArrayFromAccessor(w){let D=w.array;if(w.normalized){const O=getNormalizedComponentScale(D.constructor),U=new Float32Array(D.length);for(let G=0,q=D.length;G<q;G++)U[G]=D[G]*O;D=U}return D}_createCubicSplineTrackInterpolant(w){w.createInterpolant=function(O){const U=this instanceof QuaternionKeyframeTrack?GLTFCubicSplineQuaternionInterpolant:GLTFCubicSplineInterpolant;return new U(this.times,this.values,this.getValueSize()/3,O)},w.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline=!0}}function computeBounds(F,w,D){const O=w.attributes,U=new Box3;if(O.POSITION!==void 0){const K=D.json.accessors[O.POSITION],ee=K.min,Z=K.max;if(ee!==void 0&&Z!==void 0){if(U.set(new Vector3(ee[0],ee[1],ee[2]),new Vector3(Z[0],Z[1],Z[2])),K.normalized){const ie=getNormalizedComponentScale(WEBGL_COMPONENT_TYPES[K.componentType]);U.min.multiplyScalar(ie),U.max.multiplyScalar(ie)}}else{console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");return}}else return;const G=w.targets;if(G!==void 0){const K=new Vector3,ee=new Vector3;for(let Z=0,ie=G.length;Z<ie;Z++){const Y=G[Z];if(Y.POSITION!==void 0){const W=D.json.accessors[Y.POSITION],ne=W.min,se=W.max;if(ne!==void 0&&se!==void 0){if(ee.setX(Math.max(Math.abs(ne[0]),Math.abs(se[0]))),ee.setY(Math.max(Math.abs(ne[1]),Math.abs(se[1]))),ee.setZ(Math.max(Math.abs(ne[2]),Math.abs(se[2]))),W.normalized){const le=getNormalizedComponentScale(WEBGL_COMPONENT_TYPES[W.componentType]);ee.multiplyScalar(le)}K.max(ee)}else console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.")}}U.expandByVector(K)}F.boundingBox=U;const q=new Sphere;U.getCenter(q.center),q.radius=U.min.distanceTo(U.max)/2,F.boundingSphere=q}function addPrimitiveAttributes(F,w,D){const O=w.attributes,U=[];function G(q,K){return D.getDependency("accessor",q).then(function(ee){F.setAttribute(K,ee)})}for(const q in O){const K=ATTRIBUTES[q]||q.toLowerCase();K in F.attributes||U.push(G(O[q],K))}if(w.indices!==void 0&&!F.index){const q=D.getDependency("accessor",w.indices).then(function(K){F.setIndex(K)});U.push(q)}return ColorManagement.workingColorSpace!==LinearSRGBColorSpace&&"COLOR_0"in O&&console.warn(`THREE.GLTFLoader: Converting vertex colors from "srgb-linear" to "${ColorManagement.workingColorSpace}" not supported.`),assignExtrasToUserData(F,w),computeBounds(F,w,D),Promise.all(U).then(function(){return w.targets!==void 0?addMorphTargets(F,w.targets,D):F})}class WorkerPool{constructor(w=4){this.pool=w,this.queue=[],this.workers=[],this.workersResolve=[],this.workerStatus=0,this.workerCreator=null}_initWorker(w){if(!this.workers[w]){const D=this.workerCreator();D.addEventListener("message",this._onMessage.bind(this,w)),this.workers[w]=D}}_getIdleWorker(){for(let w=0;w<this.pool;w++)if(!(this.workerStatus&1<<w))return w;return-1}_onMessage(w,D){const O=this.workersResolve[w];if(O&&O(D),this.queue.length){const{resolve:U,msg:G,transfer:q}=this.queue.shift();this.workersResolve[w]=U,this.workers[w].postMessage(G,q)}else this.workerStatus^=1<<w}setWorkerCreator(w){this.workerCreator=w}setWorkerLimit(w){this.pool=w}postMessage(w,D){return new Promise(O=>{const U=this._getIdleWorker();U!==-1?(this._initWorker(U),this.workerStatus|=1<<U,this.workersResolve[U]=O,this.workers[U].postMessage(w,D)):this.queue.push({resolve:O,msg:w,transfer:D})})}dispose(){this.workers.forEach(w=>w.terminate()),this.workersResolve.length=0,this.workers.length=0,this.queue.length=0,this.workerStatus=0}}const t=0,n=2,u=1,y=2,S=0,E=1,X$1=10,it=0,ht=9,gt=15,xt=16,dt=22,Ft=37,Et=43,te$1=76,ae=83,ue=97,ye=100,de=103,Ae=109,We=122,He=123,qe=131,Je=132,Qe=133,Ze=134,en=137,nn=138,sn=139,an=140,rn=141,on=142,cn=145,Un=146,pn=148,xn=152,Dn=157,wn=158,Vn=165,Cn=166,ri=1000054e3,oi=1000054001,ci=1000054004,Ui=1000054005,_i=1000066e3,yi=1000066004;class Ci{constructor(w,D,O,U){this._dataView=void 0,this._littleEndian=void 0,this._offset=void 0,this._dataView=new DataView(w.buffer,w.byteOffset+D,O),this._littleEndian=U,this._offset=0}_nextUint8(){const w=this._dataView.getUint8(this._offset);return this._offset+=1,w}_nextUint16(){const w=this._dataView.getUint16(this._offset,this._littleEndian);return this._offset+=2,w}_nextUint32(){const w=this._dataView.getUint32(this._offset,this._littleEndian);return this._offset+=4,w}_nextUint64(){const w=this._dataView.getUint32(this._offset,this._littleEndian)+4294967296*this._dataView.getUint32(this._offset+4,this._littleEndian);return this._offset+=8,w}_nextInt32(){const w=this._dataView.getInt32(this._offset,this._littleEndian);return this._offset+=4,w}_nextUint8Array(w){const D=new Uint8Array(this._dataView.buffer,this._dataView.byteOffset+this._offset,w);return this._offset+=w,D}_skip(w){return this._offset+=w,this}_scan(w,D=0){const O=this._offset;let U=0;for(;this._dataView.getUint8(this._offset)!==D&&U<w;)U++,this._offset++;return U<w&&this._offset++,new Uint8Array(this._dataView.buffer,this._dataView.byteOffset+O,U)}}const Oi=[171,75,84,88,32,50,48,187,13,10,26,10];function Si(F){return new TextDecoder().decode(F)}function Mi(F){const w=new Uint8Array(F.buffer,F.byteOffset,Oi.length);if(w[0]!==Oi[0]||w[1]!==Oi[1]||w[2]!==Oi[2]||w[3]!==Oi[3]||w[4]!==Oi[4]||w[5]!==Oi[5]||w[6]!==Oi[6]||w[7]!==Oi[7]||w[8]!==Oi[8]||w[9]!==Oi[9]||w[10]!==Oi[10]||w[11]!==Oi[11])throw new Error("Missing KTX 2.0 identifier.");const D={vkFormat:0,typeSize:1,pixelWidth:0,pixelHeight:0,pixelDepth:0,layerCount:0,faceCount:1,levelCount:0,supercompressionScheme:0,levels:[],dataFormatDescriptor:[{vendorId:0,descriptorType:0,versionNumber:2,colorModel:0,colorPrimaries:1,transferFunction:2,flags:0,texelBlockDimension:[0,0,0,0],bytesPlane:[0,0,0,0,0,0,0,0],samples:[]}],keyValue:{},globalData:null},O=17*Uint32Array.BYTES_PER_ELEMENT,U=new Ci(F,Oi.length,O,!0);D.vkFormat=U._nextUint32(),D.typeSize=U._nextUint32(),D.pixelWidth=U._nextUint32(),D.pixelHeight=U._nextUint32(),D.pixelDepth=U._nextUint32(),D.layerCount=U._nextUint32(),D.faceCount=U._nextUint32(),D.levelCount=U._nextUint32(),D.supercompressionScheme=U._nextUint32();const G=U._nextUint32(),q=U._nextUint32(),K=U._nextUint32(),ee=U._nextUint32(),Z=U._nextUint64(),ie=U._nextUint64(),Y=3*Math.max(D.levelCount,1)*8,W=new Ci(F,Oi.length+O,Y,!0);for(let ke=0,rt=Math.max(D.levelCount,1);ke<rt;ke++)D.levels.push({levelData:new Uint8Array(F.buffer,F.byteOffset+W._nextUint64(),W._nextUint64()),uncompressedByteLength:W._nextUint64()});const ne=new Ci(F,G,q,!0);ne._skip(4);const se=ne._nextUint16(),le=ne._nextUint16(),ce=ne._nextUint16(),he=ne._nextUint16(),pe={vendorId:se,descriptorType:le,versionNumber:ce,colorModel:ne._nextUint8(),colorPrimaries:ne._nextUint8(),transferFunction:ne._nextUint8(),flags:ne._nextUint8(),texelBlockDimension:[ne._nextUint8(),ne._nextUint8(),ne._nextUint8(),ne._nextUint8()],bytesPlane:[ne._nextUint8(),ne._nextUint8(),ne._nextUint8(),ne._nextUint8(),ne._nextUint8(),ne._nextUint8(),ne._nextUint8(),ne._nextUint8()],samples:[]},me=(he/4-6)/4;for(let ke=0;ke<me;ke++){const rt={bitOffset:ne._nextUint16(),bitLength:ne._nextUint8(),channelType:ne._nextUint8(),samplePosition:[ne._nextUint8(),ne._nextUint8(),ne._nextUint8(),ne._nextUint8()],sampleLower:Number.NEGATIVE_INFINITY,sampleUpper:Number.POSITIVE_INFINITY};64&rt.channelType?(rt.sampleLower=ne._nextInt32(),rt.sampleUpper=ne._nextInt32()):(rt.sampleLower=ne._nextUint32(),rt.sampleUpper=ne._nextUint32()),pe.samples[ke]=rt}D.dataFormatDescriptor.length=0,D.dataFormatDescriptor.push(pe);const be=new Ci(F,K,ee,!0);for(;be._offset<ee;){const ke=be._nextUint32(),rt=be._scan(ke),St=Si(rt);if(D.keyValue[St]=be._nextUint8Array(ke-rt.byteLength-1),St.match(/^ktx/i)){const Lt=Si(D.keyValue[St]);D.keyValue[St]=Lt.substring(0,Lt.lastIndexOf("\0"))}be._skip(ke%4?4-ke%4:0)}if(ie<=0)return D;const ge=new Ci(F,Z,ie,!0),ve=ge._nextUint16(),Se=ge._nextUint16(),Me=ge._nextUint32(),Ee=ge._nextUint32(),we=ge._nextUint32(),Re=ge._nextUint32(),Le=[];for(let ke=0,rt=Math.max(D.levelCount,1);ke<rt;ke++)Le.push({imageFlags:ge._nextUint32(),rgbSliceByteOffset:ge._nextUint32(),rgbSliceByteLength:ge._nextUint32(),alphaSliceByteOffset:ge._nextUint32(),alphaSliceByteLength:ge._nextUint32()});const Ne=Z+ge._offset,Oe=Ne+Me,Pe=Oe+Ee,Ce=Pe+we,Be=new Uint8Array(F.buffer,F.byteOffset+Ne,Me),ze=new Uint8Array(F.buffer,F.byteOffset+Oe,Ee),Xe=new Uint8Array(F.buffer,F.byteOffset+Pe,we),lt=new Uint8Array(F.buffer,F.byteOffset+Ce,Re);return D.globalData={endpointCount:ve,selectorCount:Se,imageDescs:Le,endpointsData:Be,selectorsData:ze,tablesData:Xe,extendedData:lt},D}let A,I,B;const g={env:{emscripten_notify_memory_growth:function(F){B=new Uint8Array(I.exports.memory.buffer)}}};class Q{init(){return A||(A=typeof fetch<"u"?fetch("data:application/wasm;base64,"+C).then(w=>w.arrayBuffer()).then(w=>WebAssembly.instantiate(w,g)).then(this._init):WebAssembly.instantiate(Buffer.from(C,"base64"),g).then(this._init),A)}_init(w){I=w.instance,g.env.emscripten_notify_memory_growth(0)}decode(w,D=0){if(!I)throw new Error("ZSTDDecoder: Await .init() before decoding.");const O=w.byteLength,U=I.exports.malloc(O);B.set(w,U),D=D||Number(I.exports.ZSTD_findDecompressedSize(U,O));const G=I.exports.malloc(D),q=I.exports.ZSTD_decompress(G,D,U,O),K=B.slice(G,G+q);return I.exports.free(U),I.exports.free(G),K}}const C="AGFzbQEAAAABpQEVYAF/AX9gAn9/AGADf39/AX9gBX9/f39/AX9gAX8AYAJ/fwF/YAR/f39/AX9gA39/fwBgBn9/f39/fwF/YAd/f39/f39/AX9gAn9/AX5gAn5+AX5gAABgBX9/f39/AGAGf39/f39/AGAIf39/f39/f38AYAl/f39/f39/f38AYAABf2AIf39/f39/f38Bf2ANf39/f39/f39/f39/fwF/YAF/AX4CJwEDZW52H2Vtc2NyaXB0ZW5fbm90aWZ5X21lbW9yeV9ncm93dGgABANpaAEFAAAFAgEFCwACAQABAgIFBQcAAwABDgsBAQcAEhMHAAUBDAQEAAANBwQCAgYCBAgDAwMDBgEACQkHBgICAAYGAgQUBwYGAwIGAAMCAQgBBwUGCgoEEQAEBAEIAwgDBQgDEA8IAAcABAUBcAECAgUEAQCAAgYJAX8BQaCgwAILB2AHBm1lbW9yeQIABm1hbGxvYwAoBGZyZWUAJgxaU1REX2lzRXJyb3IAaBlaU1REX2ZpbmREZWNvbXByZXNzZWRTaXplAFQPWlNURF9kZWNvbXByZXNzAEoGX3N0YXJ0ACQJBwEAQQELASQKussBaA8AIAAgACgCBCABajYCBAsZACAAKAIAIAAoAgRBH3F0QQAgAWtBH3F2CwgAIABBiH9LC34BBH9BAyEBIAAoAgQiA0EgTQRAIAAoAggiASAAKAIQTwRAIAAQDQ8LIAAoAgwiAiABRgRAQQFBAiADQSBJGw8LIAAgASABIAJrIANBA3YiBCABIARrIAJJIgEbIgJrIgQ2AgggACADIAJBA3RrNgIEIAAgBCgAADYCAAsgAQsUAQF/IAAgARACIQIgACABEAEgAgv3AQECfyACRQRAIABCADcCACAAQQA2AhAgAEIANwIIQbh/DwsgACABNgIMIAAgAUEEajYCECACQQRPBEAgACABIAJqIgFBfGoiAzYCCCAAIAMoAAA2AgAgAUF/ai0AACIBBEAgAEEIIAEQFGs2AgQgAg8LIABBADYCBEF/DwsgACABNgIIIAAgAS0AACIDNgIAIAJBfmoiBEEBTQRAIARBAWtFBEAgACABLQACQRB0IANyIgM2AgALIAAgAS0AAUEIdCADajYCAAsgASACakF/ai0AACIBRQRAIABBADYCBEFsDwsgAEEoIAEQFCACQQN0ams2AgQgAgsWACAAIAEpAAA3AAAgACABKQAINwAICy8BAX8gAUECdEGgHWooAgAgACgCAEEgIAEgACgCBGprQR9xdnEhAiAAIAEQASACCyEAIAFCz9bTvtLHq9lCfiAAfEIfiUKHla+vmLbem55/fgsdAQF/IAAoAgggACgCDEYEfyAAKAIEQSBGBUEACwuCBAEDfyACQYDAAE8EQCAAIAEgAhBnIAAPCyAAIAJqIQMCQCAAIAFzQQNxRQRAAkAgAkEBSARAIAAhAgwBCyAAQQNxRQRAIAAhAgwBCyAAIQIDQCACIAEtAAA6AAAgAUEBaiEBIAJBAWoiAiADTw0BIAJBA3ENAAsLAkAgA0F8cSIEQcAASQ0AIAIgBEFAaiIFSw0AA0AgAiABKAIANgIAIAIgASgCBDYCBCACIAEoAgg2AgggAiABKAIMNgIMIAIgASgCEDYCECACIAEoAhQ2AhQgAiABKAIYNgIYIAIgASgCHDYCHCACIAEoAiA2AiAgAiABKAIkNgIkIAIgASgCKDYCKCACIAEoAiw2AiwgAiABKAIwNgIwIAIgASgCNDYCNCACIAEoAjg2AjggAiABKAI8NgI8IAFBQGshASACQUBrIgIgBU0NAAsLIAIgBE8NAQNAIAIgASgCADYCACABQQRqIQEgAkEEaiICIARJDQALDAELIANBBEkEQCAAIQIMAQsgA0F8aiIEIABJBEAgACECDAELIAAhAgNAIAIgAS0AADoAACACIAEtAAE6AAEgAiABLQACOgACIAIgAS0AAzoAAyABQQRqIQEgAkEEaiICIARNDQALCyACIANJBEADQCACIAEtAAA6AAAgAUEBaiEBIAJBAWoiAiADRw0ACwsgAAsMACAAIAEpAAA3AAALQQECfyAAKAIIIgEgACgCEEkEQEEDDwsgACAAKAIEIgJBB3E2AgQgACABIAJBA3ZrIgE2AgggACABKAAANgIAQQALDAAgACABKAIANgAAC/cCAQJ/AkAgACABRg0AAkAgASACaiAASwRAIAAgAmoiBCABSw0BCyAAIAEgAhALDwsgACABc0EDcSEDAkACQCAAIAFJBEAgAwRAIAAhAwwDCyAAQQNxRQRAIAAhAwwCCyAAIQMDQCACRQ0EIAMgAS0AADoAACABQQFqIQEgAkF/aiECIANBAWoiA0EDcQ0ACwwBCwJAIAMNACAEQQNxBEADQCACRQ0FIAAgAkF/aiICaiIDIAEgAmotAAA6AAAgA0EDcQ0ACwsgAkEDTQ0AA0AgACACQXxqIgJqIAEgAmooAgA2AgAgAkEDSw0ACwsgAkUNAgNAIAAgAkF/aiICaiABIAJqLQAAOgAAIAINAAsMAgsgAkEDTQ0AIAIhBANAIAMgASgCADYCACABQQRqIQEgA0EEaiEDIARBfGoiBEEDSw0ACyACQQNxIQILIAJFDQADQCADIAEtAAA6AAAgA0EBaiEDIAFBAWohASACQX9qIgINAAsLIAAL8wICAn8BfgJAIAJFDQAgACACaiIDQX9qIAE6AAAgACABOgAAIAJBA0kNACADQX5qIAE6AAAgACABOgABIANBfWogAToAACAAIAE6AAIgAkEHSQ0AIANBfGogAToAACAAIAE6AAMgAkEJSQ0AIABBACAAa0EDcSIEaiIDIAFB/wFxQYGChAhsIgE2AgAgAyACIARrQXxxIgRqIgJBfGogATYCACAEQQlJDQAgAyABNgIIIAMgATYCBCACQXhqIAE2AgAgAkF0aiABNgIAIARBGUkNACADIAE2AhggAyABNgIUIAMgATYCECADIAE2AgwgAkFwaiABNgIAIAJBbGogATYCACACQWhqIAE2AgAgAkFkaiABNgIAIAQgA0EEcUEYciIEayICQSBJDQAgAa0iBUIghiAFhCEFIAMgBGohAQNAIAEgBTcDGCABIAU3AxAgASAFNwMIIAEgBTcDACABQSBqIQEgAkFgaiICQR9LDQALCyAACy8BAn8gACgCBCAAKAIAQQJ0aiICLQACIQMgACACLwEAIAEgAi0AAxAIajYCACADCy8BAn8gACgCBCAAKAIAQQJ0aiICLQACIQMgACACLwEAIAEgAi0AAxAFajYCACADCx8AIAAgASACKAIEEAg2AgAgARAEGiAAIAJBCGo2AgQLCAAgAGdBH3MLugUBDX8jAEEQayIKJAACfyAEQQNNBEAgCkEANgIMIApBDGogAyAEEAsaIAAgASACIApBDGpBBBAVIgBBbCAAEAMbIAAgACAESxsMAQsgAEEAIAEoAgBBAXRBAmoQECENQVQgAygAACIGQQ9xIgBBCksNABogAiAAQQVqNgIAIAMgBGoiAkF8aiEMIAJBeWohDiACQXtqIRAgAEEGaiELQQQhBSAGQQR2IQRBICAAdCIAQQFyIQkgASgCACEPQQAhAiADIQYCQANAIAlBAkggAiAPS3JFBEAgAiEHAkAgCARAA0AgBEH//wNxQf//A0YEQCAHQRhqIQcgBiAQSQR/IAZBAmoiBigAACAFdgUgBUEQaiEFIARBEHYLIQQMAQsLA0AgBEEDcSIIQQNGBEAgBUECaiEFIARBAnYhBCAHQQNqIQcMAQsLIAcgCGoiByAPSw0EIAVBAmohBQNAIAIgB0kEQCANIAJBAXRqQQA7AQAgAkEBaiECDAELCyAGIA5LQQAgBiAFQQN1aiIHIAxLG0UEQCAHKAAAIAVBB3EiBXYhBAwCCyAEQQJ2IQQLIAYhBwsCfyALQX9qIAQgAEF/anEiBiAAQQF0QX9qIgggCWsiEUkNABogBCAIcSIEQQAgESAEIABIG2shBiALCyEIIA0gAkEBdGogBkF/aiIEOwEAIAlBASAGayAEIAZBAUgbayEJA0AgCSAASARAIABBAXUhACALQX9qIQsMAQsLAn8gByAOS0EAIAcgBSAIaiIFQQN1aiIGIAxLG0UEQCAFQQdxDAELIAUgDCIGIAdrQQN0awshBSACQQFqIQIgBEUhCCAGKAAAIAVBH3F2IQQMAQsLQWwgCUEBRyAFQSBKcg0BGiABIAJBf2o2AgAgBiAFQQdqQQN1aiADawwBC0FQCyEAIApBEGokACAACwkAQQFBBSAAGwsMACAAIAEoAAA2AAALqgMBCn8jAEHwAGsiCiQAIAJBAWohDiAAQQhqIQtBgIAEIAVBf2p0QRB1IQxBACECQQEhBkEBIAV0IglBf2oiDyEIA0AgAiAORkUEQAJAIAEgAkEBdCINai8BACIHQf//A0YEQCALIAhBA3RqIAI2AgQgCEF/aiEIQQEhBwwBCyAGQQAgDCAHQRB0QRB1ShshBgsgCiANaiAHOwEAIAJBAWohAgwBCwsgACAFNgIEIAAgBjYCACAJQQN2IAlBAXZqQQNqIQxBACEAQQAhBkEAIQIDQCAGIA5GBEADQAJAIAAgCUYNACAKIAsgAEEDdGoiASgCBCIGQQF0aiICIAIvAQAiAkEBajsBACABIAUgAhAUayIIOgADIAEgAiAIQf8BcXQgCWs7AQAgASAEIAZBAnQiAmooAgA6AAIgASACIANqKAIANgIEIABBAWohAAwBCwsFIAEgBkEBdGouAQAhDUEAIQcDQCAHIA1ORQRAIAsgAkEDdGogBjYCBANAIAIgDGogD3EiAiAISw0ACyAHQQFqIQcMAQsLIAZBAWohBgwBCwsgCkHwAGokAAsjAEIAIAEQCSAAhUKHla+vmLbem55/fkLj3MqV/M7y9YV/fAsQACAAQn43AwggACABNgIACyQBAX8gAARAIAEoAgQiAgRAIAEoAgggACACEQEADwsgABAmCwsfACAAIAEgAi8BABAINgIAIAEQBBogACACQQRqNgIEC0oBAX9BoCAoAgAiASAAaiIAQX9MBEBBiCBBMDYCAEF/DwsCQCAAPwBBEHRNDQAgABBmDQBBiCBBMDYCAEF/DwtBoCAgADYCACABC9cBAQh/Qbp/IQoCQCACKAIEIgggAigCACIJaiIOIAEgAGtLDQBBbCEKIAkgBCADKAIAIgtrSw0AIAAgCWoiBCACKAIIIgxrIQ0gACABQWBqIg8gCyAJQQAQKSADIAkgC2o2AgACQAJAIAwgBCAFa00EQCANIQUMAQsgDCAEIAZrSw0CIAcgDSAFayIAaiIBIAhqIAdNBEAgBCABIAgQDxoMAgsgBCABQQAgAGsQDyEBIAIgACAIaiIINgIEIAEgAGshBAsgBCAPIAUgCEEBECkLIA4hCgsgCgubAgEBfyMAQYABayINJAAgDSADNgJ8AkAgAkEDSwRAQX8hCQwBCwJAAkACQAJAIAJBAWsOAwADAgELIAZFBEBBuH8hCQwEC0FsIQkgBS0AACICIANLDQMgACAHIAJBAnQiAmooAgAgAiAIaigCABA7IAEgADYCAEEBIQkMAwsgASAJNgIAQQAhCQwCCyAKRQRAQWwhCQwCC0EAIQkgC0UgDEEZSHINAUEIIAR0QQhqIQBBACECA0AgAiAATw0CIAJBQGshAgwAAAsAC0FsIQkgDSANQfwAaiANQfgAaiAFIAYQFSICEAMNACANKAJ4IgMgBEsNACAAIA0gDSgCfCAHIAggAxAYIAEgADYCACACIQkLIA1BgAFqJAAgCQsLACAAIAEgAhALGgsQACAALwAAIAAtAAJBEHRyCy8AAn9BuH8gAUEISQ0AGkFyIAAoAAQiAEF3Sw0AGkG4fyAAQQhqIgAgACABSxsLCwkAIAAgATsAAAsDAAELigYBBX8gACAAKAIAIgVBfnE2AgBBACAAIAVBAXZqQYQgKAIAIgQgAEYbIQECQAJAIAAoAgQiAkUNACACKAIAIgNBAXENACACQQhqIgUgA0EBdkF4aiIDQQggA0EISxtnQR9zQQJ0QYAfaiIDKAIARgRAIAMgAigCDDYCAAsgAigCCCIDBEAgAyACKAIMNgIECyACKAIMIgMEQCADIAIoAgg2AgALIAIgAigCACAAKAIAQX5xajYCAEGEICEAAkACQCABRQ0AIAEgAjYCBCABKAIAIgNBAXENASADQQF2QXhqIgNBCCADQQhLG2dBH3NBAnRBgB9qIgMoAgAgAUEIakYEQCADIAEoAgw2AgALIAEoAggiAwRAIAMgASgCDDYCBAsgASgCDCIDBEAgAyABKAIINgIAQYQgKAIAIQQLIAIgAigCACABKAIAQX5xajYCACABIARGDQAgASABKAIAQQF2akEEaiEACyAAIAI2AgALIAIoAgBBAXZBeGoiAEEIIABBCEsbZ0Efc0ECdEGAH2oiASgCACEAIAEgBTYCACACIAA2AgwgAkEANgIIIABFDQEgACAFNgIADwsCQCABRQ0AIAEoAgAiAkEBcQ0AIAJBAXZBeGoiAkEIIAJBCEsbZ0Efc0ECdEGAH2oiAigCACABQQhqRgRAIAIgASgCDDYCAAsgASgCCCICBEAgAiABKAIMNgIECyABKAIMIgIEQCACIAEoAgg2AgBBhCAoAgAhBAsgACAAKAIAIAEoAgBBfnFqIgI2AgACQCABIARHBEAgASABKAIAQQF2aiAANgIEIAAoAgAhAgwBC0GEICAANgIACyACQQF2QXhqIgFBCCABQQhLG2dBH3NBAnRBgB9qIgIoAgAhASACIABBCGoiAjYCACAAIAE2AgwgAEEANgIIIAFFDQEgASACNgIADwsgBUEBdkF4aiIBQQggAUEISxtnQR9zQQJ0QYAfaiICKAIAIQEgAiAAQQhqIgI2AgAgACABNgIMIABBADYCCCABRQ0AIAEgAjYCAAsLDgAgAARAIABBeGoQJQsLgAIBA38CQCAAQQ9qQXhxQYQgKAIAKAIAQQF2ayICEB1Bf0YNAAJAQYQgKAIAIgAoAgAiAUEBcQ0AIAFBAXZBeGoiAUEIIAFBCEsbZ0Efc0ECdEGAH2oiASgCACAAQQhqRgRAIAEgACgCDDYCAAsgACgCCCIBBEAgASAAKAIMNgIECyAAKAIMIgFFDQAgASAAKAIINgIAC0EBIQEgACAAKAIAIAJBAXRqIgI2AgAgAkEBcQ0AIAJBAXZBeGoiAkEIIAJBCEsbZ0Efc0ECdEGAH2oiAygCACECIAMgAEEIaiIDNgIAIAAgAjYCDCAAQQA2AgggAkUNACACIAM2AgALIAELtwIBA38CQAJAIABBASAAGyICEDgiAA0AAkACQEGEICgCACIARQ0AIAAoAgAiA0EBcQ0AIAAgA0EBcjYCACADQQF2QXhqIgFBCCABQQhLG2dBH3NBAnRBgB9qIgEoAgAgAEEIakYEQCABIAAoAgw2AgALIAAoAggiAQRAIAEgACgCDDYCBAsgACgCDCIBBEAgASAAKAIINgIACyACECchAkEAIQFBhCAoAgAhACACDQEgACAAKAIAQX5xNgIAQQAPCyACQQ9qQXhxIgMQHSICQX9GDQIgAkEHakF4cSIAIAJHBEAgACACaxAdQX9GDQMLAkBBhCAoAgAiAUUEQEGAICAANgIADAELIAAgATYCBAtBhCAgADYCACAAIANBAXRBAXI2AgAMAQsgAEUNAQsgAEEIaiEBCyABC7kDAQJ/IAAgA2ohBQJAIANBB0wEQANAIAAgBU8NAiAAIAItAAA6AAAgAEEBaiEAIAJBAWohAgwAAAsACyAEQQFGBEACQCAAIAJrIgZBB00EQCAAIAItAAA6AAAgACACLQABOgABIAAgAi0AAjoAAiAAIAItAAM6AAMgAEEEaiACIAZBAnQiBkHAHmooAgBqIgIQFyACIAZB4B5qKAIAayECDAELIAAgAhAMCyACQQhqIQIgAEEIaiEACwJAAkACQAJAIAUgAU0EQCAAIANqIQEgBEEBRyAAIAJrQQ9Kcg0BA0AgACACEAwgAkEIaiECIABBCGoiACABSQ0ACwwFCyAAIAFLBEAgACEBDAQLIARBAUcgACACa0EPSnINASAAIQMgAiEEA0AgAyAEEAwgBEEIaiEEIANBCGoiAyABSQ0ACwwCCwNAIAAgAhAHIAJBEGohAiAAQRBqIgAgAUkNAAsMAwsgACEDIAIhBANAIAMgBBAHIARBEGohBCADQRBqIgMgAUkNAAsLIAIgASAAa2ohAgsDQCABIAVPDQEgASACLQAAOgAAIAFBAWohASACQQFqIQIMAAALAAsLQQECfyAAIAAoArjgASIDNgLE4AEgACgCvOABIQQgACABNgK84AEgACABIAJqNgK44AEgACABIAQgA2tqNgLA4AELpgEBAX8gACAAKALs4QEQFjYCyOABIABCADcD+OABIABCADcDuOABIABBwOABakIANwMAIABBqNAAaiIBQYyAgOAANgIAIABBADYCmOIBIABCADcDiOEBIABCAzcDgOEBIABBrNABakHgEikCADcCACAAQbTQAWpB6BIoAgA2AgAgACABNgIMIAAgAEGYIGo2AgggACAAQaAwajYCBCAAIABBEGo2AgALYQEBf0G4fyEDAkAgAUEDSQ0AIAIgABAhIgFBA3YiADYCCCACIAFBAXE2AgQgAiABQQF2QQNxIgM2AgACQCADQX9qIgFBAksNAAJAIAFBAWsOAgEAAgtBbA8LIAAhAwsgAwsMACAAIAEgAkEAEC4LiAQCA38CfiADEBYhBCAAQQBBKBAQIQAgBCACSwRAIAQPCyABRQRAQX8PCwJAAkAgA0EBRg0AIAEoAAAiBkGo6r5pRg0AQXYhAyAGQXBxQdDUtMIBRw0BQQghAyACQQhJDQEgAEEAQSgQECEAIAEoAAQhASAAQQE2AhQgACABrTcDAEEADwsgASACIAMQLyIDIAJLDQAgACADNgIYQXIhAyABIARqIgVBf2otAAAiAkEIcQ0AIAJBIHEiBkUEQEFwIQMgBS0AACIFQacBSw0BIAVBB3GtQgEgBUEDdkEKaq2GIgdCA4h+IAd8IQggBEEBaiEECyACQQZ2IQMgAkECdiEFAkAgAkEDcUF/aiICQQJLBEBBACECDAELAkACQAJAIAJBAWsOAgECAAsgASAEai0AACECIARBAWohBAwCCyABIARqLwAAIQIgBEECaiEEDAELIAEgBGooAAAhAiAEQQRqIQQLIAVBAXEhBQJ+AkACQAJAIANBf2oiA0ECTQRAIANBAWsOAgIDAQtCfyAGRQ0DGiABIARqMQAADAMLIAEgBGovAACtQoACfAwCCyABIARqKAAArQwBCyABIARqKQAACyEHIAAgBTYCICAAIAI2AhwgACAHNwMAQQAhAyAAQQA2AhQgACAHIAggBhsiBzcDCCAAIAdCgIAIIAdCgIAIVBs+AhALIAMLWwEBf0G4fyEDIAIQFiICIAFNBH8gACACakF/ai0AACIAQQNxQQJ0QaAeaigCACACaiAAQQZ2IgFBAnRBsB5qKAIAaiAAQSBxIgBFaiABRSAAQQV2cWoFQbh/CwsdACAAKAKQ4gEQWiAAQQA2AqDiASAAQgA3A5DiAQu1AwEFfyMAQZACayIKJABBuH8hBgJAIAVFDQAgBCwAACIIQf8BcSEHAkAgCEF/TARAIAdBgn9qQQF2IgggBU8NAkFsIQYgB0GBf2oiBUGAAk8NAiAEQQFqIQdBACEGA0AgBiAFTwRAIAUhBiAIIQcMAwUgACAGaiAHIAZBAXZqIgQtAABBBHY6AAAgACAGQQFyaiAELQAAQQ9xOgAAIAZBAmohBgwBCwAACwALIAcgBU8NASAAIARBAWogByAKEFMiBhADDQELIAYhBEEAIQYgAUEAQTQQECEJQQAhBQNAIAQgBkcEQCAAIAZqIggtAAAiAUELSwRAQWwhBgwDBSAJIAFBAnRqIgEgASgCAEEBajYCACAGQQFqIQZBASAILQAAdEEBdSAFaiEFDAILAAsLQWwhBiAFRQ0AIAUQFEEBaiIBQQxLDQAgAyABNgIAQQFBASABdCAFayIDEBQiAXQgA0cNACAAIARqIAFBAWoiADoAACAJIABBAnRqIgAgACgCAEEBajYCACAJKAIEIgBBAkkgAEEBcXINACACIARBAWo2AgAgB0EBaiEGCyAKQZACaiQAIAYLxhEBDH8jAEHwAGsiBSQAQWwhCwJAIANBCkkNACACLwAAIQogAi8AAiEJIAIvAAQhByAFQQhqIAQQDgJAIAMgByAJIApqakEGaiIMSQ0AIAUtAAohCCAFQdgAaiACQQZqIgIgChAGIgsQAw0BIAVBQGsgAiAKaiICIAkQBiILEAMNASAFQShqIAIgCWoiAiAHEAYiCxADDQEgBUEQaiACIAdqIAMgDGsQBiILEAMNASAAIAFqIg9BfWohECAEQQRqIQZBASELIAAgAUEDakECdiIDaiIMIANqIgIgA2oiDiEDIAIhBCAMIQcDQCALIAMgEElxBEAgACAGIAVB2ABqIAgQAkECdGoiCS8BADsAACAFQdgAaiAJLQACEAEgCS0AAyELIAcgBiAFQUBrIAgQAkECdGoiCS8BADsAACAFQUBrIAktAAIQASAJLQADIQogBCAGIAVBKGogCBACQQJ0aiIJLwEAOwAAIAVBKGogCS0AAhABIAktAAMhCSADIAYgBUEQaiAIEAJBAnRqIg0vAQA7AAAgBUEQaiANLQACEAEgDS0AAyENIAAgC2oiCyAGIAVB2ABqIAgQAkECdGoiAC8BADsAACAFQdgAaiAALQACEAEgAC0AAyEAIAcgCmoiCiAGIAVBQGsgCBACQQJ0aiIHLwEAOwAAIAVBQGsgBy0AAhABIActAAMhByAEIAlqIgkgBiAFQShqIAgQAkECdGoiBC8BADsAACAFQShqIAQtAAIQASAELQADIQQgAyANaiIDIAYgBUEQaiAIEAJBAnRqIg0vAQA7AAAgBUEQaiANLQACEAEgACALaiEAIAcgCmohByAEIAlqIQQgAyANLQADaiEDIAVB2ABqEA0gBUFAaxANciAFQShqEA1yIAVBEGoQDXJFIQsMAQsLIAQgDksgByACS3INAEFsIQsgACAMSw0BIAxBfWohCQNAQQAgACAJSSAFQdgAahAEGwRAIAAgBiAFQdgAaiAIEAJBAnRqIgovAQA7AAAgBUHYAGogCi0AAhABIAAgCi0AA2oiACAGIAVB2ABqIAgQAkECdGoiCi8BADsAACAFQdgAaiAKLQACEAEgACAKLQADaiEADAEFIAxBfmohCgNAIAVB2ABqEAQgACAKS3JFBEAgACAGIAVB2ABqIAgQAkECdGoiCS8BADsAACAFQdgAaiAJLQACEAEgACAJLQADaiEADAELCwNAIAAgCk0EQCAAIAYgBUHYAGogCBACQQJ0aiIJLwEAOwAAIAVB2ABqIAktAAIQASAAIAktAANqIQAMAQsLAkAgACAMTw0AIAAgBiAFQdgAaiAIEAIiAEECdGoiDC0AADoAACAMLQADQQFGBEAgBUHYAGogDC0AAhABDAELIAUoAlxBH0sNACAFQdgAaiAGIABBAnRqLQACEAEgBSgCXEEhSQ0AIAVBIDYCXAsgAkF9aiEMA0BBACAHIAxJIAVBQGsQBBsEQCAHIAYgBUFAayAIEAJBAnRqIgAvAQA7AAAgBUFAayAALQACEAEgByAALQADaiIAIAYgBUFAayAIEAJBAnRqIgcvAQA7AAAgBUFAayAHLQACEAEgACAHLQADaiEHDAEFIAJBfmohDANAIAVBQGsQBCAHIAxLckUEQCAHIAYgBUFAayAIEAJBAnRqIgAvAQA7AAAgBUFAayAALQACEAEgByAALQADaiEHDAELCwNAIAcgDE0EQCAHIAYgBUFAayAIEAJBAnRqIgAvAQA7AAAgBUFAayAALQACEAEgByAALQADaiEHDAELCwJAIAcgAk8NACAHIAYgBUFAayAIEAIiAEECdGoiAi0AADoAACACLQADQQFGBEAgBUFAayACLQACEAEMAQsgBSgCREEfSw0AIAVBQGsgBiAAQQJ0ai0AAhABIAUoAkRBIUkNACAFQSA2AkQLIA5BfWohAgNAQQAgBCACSSAFQShqEAQbBEAgBCAGIAVBKGogCBACQQJ0aiIALwEAOwAAIAVBKGogAC0AAhABIAQgAC0AA2oiACAGIAVBKGogCBACQQJ0aiIELwEAOwAAIAVBKGogBC0AAhABIAAgBC0AA2ohBAwBBSAOQX5qIQIDQCAFQShqEAQgBCACS3JFBEAgBCAGIAVBKGogCBACQQJ0aiIALwEAOwAAIAVBKGogAC0AAhABIAQgAC0AA2ohBAwBCwsDQCAEIAJNBEAgBCAGIAVBKGogCBACQQJ0aiIALwEAOwAAIAVBKGogAC0AAhABIAQgAC0AA2ohBAwBCwsCQCAEIA5PDQAgBCAGIAVBKGogCBACIgBBAnRqIgItAAA6AAAgAi0AA0EBRgRAIAVBKGogAi0AAhABDAELIAUoAixBH0sNACAFQShqIAYgAEECdGotAAIQASAFKAIsQSFJDQAgBUEgNgIsCwNAQQAgAyAQSSAFQRBqEAQbBEAgAyAGIAVBEGogCBACQQJ0aiIALwEAOwAAIAVBEGogAC0AAhABIAMgAC0AA2oiACAGIAVBEGogCBACQQJ0aiICLwEAOwAAIAVBEGogAi0AAhABIAAgAi0AA2ohAwwBBSAPQX5qIQIDQCAFQRBqEAQgAyACS3JFBEAgAyAGIAVBEGogCBACQQJ0aiIALwEAOwAAIAVBEGogAC0AAhABIAMgAC0AA2ohAwwBCwsDQCADIAJNBEAgAyAGIAVBEGogCBACQQJ0aiIALwEAOwAAIAVBEGogAC0AAhABIAMgAC0AA2ohAwwBCwsCQCADIA9PDQAgAyAGIAVBEGogCBACIgBBAnRqIgItAAA6AAAgAi0AA0EBRgRAIAVBEGogAi0AAhABDAELIAUoAhRBH0sNACAFQRBqIAYgAEECdGotAAIQASAFKAIUQSFJDQAgBUEgNgIUCyABQWwgBUHYAGoQCiAFQUBrEApxIAVBKGoQCnEgBUEQahAKcRshCwwJCwAACwALAAALAAsAAAsACwAACwALQWwhCwsgBUHwAGokACALC7UEAQ5/IwBBEGsiBiQAIAZBBGogABAOQVQhBQJAIARB3AtJDQAgBi0ABCEHIANB8ARqQQBB7AAQECEIIAdBDEsNACADQdwJaiIJIAggBkEIaiAGQQxqIAEgAhAxIhAQA0UEQCAGKAIMIgQgB0sNASADQdwFaiEPIANBpAVqIREgAEEEaiESIANBqAVqIQEgBCEFA0AgBSICQX9qIQUgCCACQQJ0aigCAEUNAAsgAkEBaiEOQQEhBQNAIAUgDk9FBEAgCCAFQQJ0IgtqKAIAIQwgASALaiAKNgIAIAVBAWohBSAKIAxqIQoMAQsLIAEgCjYCAEEAIQUgBigCCCELA0AgBSALRkUEQCABIAUgCWotAAAiDEECdGoiDSANKAIAIg1BAWo2AgAgDyANQQF0aiINIAw6AAEgDSAFOgAAIAVBAWohBQwBCwtBACEBIANBADYCqAUgBEF/cyAHaiEJQQEhBQNAIAUgDk9FBEAgCCAFQQJ0IgtqKAIAIQwgAyALaiABNgIAIAwgBSAJanQgAWohASAFQQFqIQUMAQsLIAcgBEEBaiIBIAJrIgRrQQFqIQgDQEEBIQUgBCAIT0UEQANAIAUgDk9FBEAgBUECdCIJIAMgBEE0bGpqIAMgCWooAgAgBHY2AgAgBUEBaiEFDAELCyAEQQFqIQQMAQsLIBIgByAPIAogESADIAIgARBkIAZBAToABSAGIAc6AAYgACAGKAIENgIACyAQIQULIAZBEGokACAFC8ENAQt/IwBB8ABrIgUkAEFsIQkCQCADQQpJDQAgAi8AACEKIAIvAAIhDCACLwAEIQYgBUEIaiAEEA4CQCADIAYgCiAMampBBmoiDUkNACAFLQAKIQcgBUHYAGogAkEGaiICIAoQBiIJEAMNASAFQUBrIAIgCmoiAiAMEAYiCRADDQEgBUEoaiACIAxqIgIgBhAGIgkQAw0BIAVBEGogAiAGaiADIA1rEAYiCRADDQEgACABaiIOQX1qIQ8gBEEEaiEGQQEhCSAAIAFBA2pBAnYiAmoiCiACaiIMIAJqIg0hAyAMIQQgCiECA0AgCSADIA9JcQRAIAYgBUHYAGogBxACQQF0aiIILQAAIQsgBUHYAGogCC0AARABIAAgCzoAACAGIAVBQGsgBxACQQF0aiIILQAAIQsgBUFAayAILQABEAEgAiALOgAAIAYgBUEoaiAHEAJBAXRqIggtAAAhCyAFQShqIAgtAAEQASAEIAs6AAAgBiAFQRBqIAcQAkEBdGoiCC0AACELIAVBEGogCC0AARABIAMgCzoAACAGIAVB2ABqIAcQAkEBdGoiCC0AACELIAVB2ABqIAgtAAEQASAAIAs6AAEgBiAFQUBrIAcQAkEBdGoiCC0AACELIAVBQGsgCC0AARABIAIgCzoAASAGIAVBKGogBxACQQF0aiIILQAAIQsgBUEoaiAILQABEAEgBCALOgABIAYgBUEQaiAHEAJBAXRqIggtAAAhCyAFQRBqIAgtAAEQASADIAs6AAEgA0ECaiEDIARBAmohBCACQQJqIQIgAEECaiEAIAkgBUHYAGoQDUVxIAVBQGsQDUVxIAVBKGoQDUVxIAVBEGoQDUVxIQkMAQsLIAQgDUsgAiAMS3INAEFsIQkgACAKSw0BIApBfWohCQNAIAVB2ABqEAQgACAJT3JFBEAgBiAFQdgAaiAHEAJBAXRqIggtAAAhCyAFQdgAaiAILQABEAEgACALOgAAIAYgBUHYAGogBxACQQF0aiIILQAAIQsgBUHYAGogCC0AARABIAAgCzoAASAAQQJqIQAMAQsLA0AgBUHYAGoQBCAAIApPckUEQCAGIAVB2ABqIAcQAkEBdGoiCS0AACEIIAVB2ABqIAktAAEQASAAIAg6AAAgAEEBaiEADAELCwNAIAAgCkkEQCAGIAVB2ABqIAcQAkEBdGoiCS0AACEIIAVB2ABqIAktAAEQASAAIAg6AAAgAEEBaiEADAELCyAMQX1qIQADQCAFQUBrEAQgAiAAT3JFBEAgBiAFQUBrIAcQAkEBdGoiCi0AACEJIAVBQGsgCi0AARABIAIgCToAACAGIAVBQGsgBxACQQF0aiIKLQAAIQkgBUFAayAKLQABEAEgAiAJOgABIAJBAmohAgwBCwsDQCAFQUBrEAQgAiAMT3JFBEAgBiAFQUBrIAcQAkEBdGoiAC0AACEKIAVBQGsgAC0AARABIAIgCjoAACACQQFqIQIMAQsLA0AgAiAMSQRAIAYgBUFAayAHEAJBAXRqIgAtAAAhCiAFQUBrIAAtAAEQASACIAo6AAAgAkEBaiECDAELCyANQX1qIQADQCAFQShqEAQgBCAAT3JFBEAgBiAFQShqIAcQAkEBdGoiAi0AACEKIAVBKGogAi0AARABIAQgCjoAACAGIAVBKGogBxACQQF0aiICLQAAIQogBUEoaiACLQABEAEgBCAKOgABIARBAmohBAwBCwsDQCAFQShqEAQgBCANT3JFBEAgBiAFQShqIAcQAkEBdGoiAC0AACECIAVBKGogAC0AARABIAQgAjoAACAEQQFqIQQMAQsLA0AgBCANSQRAIAYgBUEoaiAHEAJBAXRqIgAtAAAhAiAFQShqIAAtAAEQASAEIAI6AAAgBEEBaiEEDAELCwNAIAVBEGoQBCADIA9PckUEQCAGIAVBEGogBxACQQF0aiIALQAAIQIgBUEQaiAALQABEAEgAyACOgAAIAYgBUEQaiAHEAJBAXRqIgAtAAAhAiAFQRBqIAAtAAEQASADIAI6AAEgA0ECaiEDDAELCwNAIAVBEGoQBCADIA5PckUEQCAGIAVBEGogBxACQQF0aiIALQAAIQIgBUEQaiAALQABEAEgAyACOgAAIANBAWohAwwBCwsDQCADIA5JBEAgBiAFQRBqIAcQAkEBdGoiAC0AACECIAVBEGogAC0AARABIAMgAjoAACADQQFqIQMMAQsLIAFBbCAFQdgAahAKIAVBQGsQCnEgBUEoahAKcSAFQRBqEApxGyEJDAELQWwhCQsgBUHwAGokACAJC8oCAQR/IwBBIGsiBSQAIAUgBBAOIAUtAAIhByAFQQhqIAIgAxAGIgIQA0UEQCAEQQRqIQIgACABaiIDQX1qIQQDQCAFQQhqEAQgACAET3JFBEAgAiAFQQhqIAcQAkEBdGoiBi0AACEIIAVBCGogBi0AARABIAAgCDoAACACIAVBCGogBxACQQF0aiIGLQAAIQggBUEIaiAGLQABEAEgACAIOgABIABBAmohAAwBCwsDQCAFQQhqEAQgACADT3JFBEAgAiAFQQhqIAcQAkEBdGoiBC0AACEGIAVBCGogBC0AARABIAAgBjoAACAAQQFqIQAMAQsLA0AgACADT0UEQCACIAVBCGogBxACQQF0aiIELQAAIQYgBUEIaiAELQABEAEgACAGOgAAIABBAWohAAwBCwsgAUFsIAVBCGoQChshAgsgBUEgaiQAIAILtgMBCX8jAEEQayIGJAAgBkEANgIMIAZBADYCCEFUIQQCQAJAIANBQGsiDCADIAZBCGogBkEMaiABIAIQMSICEAMNACAGQQRqIAAQDiAGKAIMIgcgBi0ABEEBaksNASAAQQRqIQogBkEAOgAFIAYgBzoABiAAIAYoAgQ2AgAgB0EBaiEJQQEhBANAIAQgCUkEQCADIARBAnRqIgEoAgAhACABIAU2AgAgACAEQX9qdCAFaiEFIARBAWohBAwBCwsgB0EBaiEHQQAhBSAGKAIIIQkDQCAFIAlGDQEgAyAFIAxqLQAAIgRBAnRqIgBBASAEdEEBdSILIAAoAgAiAWoiADYCACAHIARrIQhBACEEAkAgC0EDTQRAA0AgBCALRg0CIAogASAEakEBdGoiACAIOgABIAAgBToAACAEQQFqIQQMAAALAAsDQCABIABPDQEgCiABQQF0aiIEIAg6AAEgBCAFOgAAIAQgCDoAAyAEIAU6AAIgBCAIOgAFIAQgBToABCAEIAg6AAcgBCAFOgAGIAFBBGohAQwAAAsACyAFQQFqIQUMAAALAAsgAiEECyAGQRBqJAAgBAutAQECfwJAQYQgKAIAIABHIAAoAgBBAXYiAyABa0F4aiICQXhxQQhHcgR/IAIFIAMQJ0UNASACQQhqC0EQSQ0AIAAgACgCACICQQFxIAAgAWpBD2pBeHEiASAAa0EBdHI2AgAgASAANgIEIAEgASgCAEEBcSAAIAJBAXZqIAFrIgJBAXRyNgIAQYQgIAEgAkH/////B3FqQQRqQYQgKAIAIABGGyABNgIAIAEQJQsLygIBBX8CQAJAAkAgAEEIIABBCEsbZ0EfcyAAaUEBR2oiAUEESSAAIAF2cg0AIAFBAnRB/B5qKAIAIgJFDQADQCACQXhqIgMoAgBBAXZBeGoiBSAATwRAIAIgBUEIIAVBCEsbZ0Efc0ECdEGAH2oiASgCAEYEQCABIAIoAgQ2AgALDAMLIARBHksNASAEQQFqIQQgAigCBCICDQALC0EAIQMgAUEgTw0BA0AgAUECdEGAH2ooAgAiAkUEQCABQR5LIQIgAUEBaiEBIAJFDQEMAwsLIAIgAkF4aiIDKAIAQQF2QXhqIgFBCCABQQhLG2dBH3NBAnRBgB9qIgEoAgBGBEAgASACKAIENgIACwsgAigCACIBBEAgASACKAIENgIECyACKAIEIgEEQCABIAIoAgA2AgALIAMgAygCAEEBcjYCACADIAAQNwsgAwvhCwINfwV+IwBB8ABrIgckACAHIAAoAvDhASIINgJcIAEgAmohDSAIIAAoAoDiAWohDwJAAkAgBUUEQCABIQQMAQsgACgCxOABIRAgACgCwOABIREgACgCvOABIQ4gAEEBNgKM4QFBACEIA0AgCEEDRwRAIAcgCEECdCICaiAAIAJqQazQAWooAgA2AkQgCEEBaiEIDAELC0FsIQwgB0EYaiADIAQQBhADDQEgB0EsaiAHQRhqIAAoAgAQEyAHQTRqIAdBGGogACgCCBATIAdBPGogB0EYaiAAKAIEEBMgDUFgaiESIAEhBEEAIQwDQCAHKAIwIAcoAixBA3RqKQIAIhRCEIinQf8BcSEIIAcoAkAgBygCPEEDdGopAgAiFUIQiKdB/wFxIQsgBygCOCAHKAI0QQN0aikCACIWQiCIpyEJIBVCIIghFyAUQiCIpyECAkAgFkIQiKdB/wFxIgNBAk8EQAJAIAZFIANBGUlyRQRAIAkgB0EYaiADQSAgBygCHGsiCiAKIANLGyIKEAUgAyAKayIDdGohCSAHQRhqEAQaIANFDQEgB0EYaiADEAUgCWohCQwBCyAHQRhqIAMQBSAJaiEJIAdBGGoQBBoLIAcpAkQhGCAHIAk2AkQgByAYNwNIDAELAkAgA0UEQCACBEAgBygCRCEJDAMLIAcoAkghCQwBCwJAAkAgB0EYakEBEAUgCSACRWpqIgNBA0YEQCAHKAJEQX9qIgMgA0VqIQkMAQsgA0ECdCAHaigCRCIJIAlFaiEJIANBAUYNAQsgByAHKAJINgJMCwsgByAHKAJENgJIIAcgCTYCRAsgF6chAyALBEAgB0EYaiALEAUgA2ohAwsgCCALakEUTwRAIAdBGGoQBBoLIAgEQCAHQRhqIAgQBSACaiECCyAHQRhqEAQaIAcgB0EYaiAUQhiIp0H/AXEQCCAUp0H//wNxajYCLCAHIAdBGGogFUIYiKdB/wFxEAggFadB//8DcWo2AjwgB0EYahAEGiAHIAdBGGogFkIYiKdB/wFxEAggFqdB//8DcWo2AjQgByACNgJgIAcoAlwhCiAHIAk2AmggByADNgJkAkACQAJAIAQgAiADaiILaiASSw0AIAIgCmoiEyAPSw0AIA0gBGsgC0Egak8NAQsgByAHKQNoNwMQIAcgBykDYDcDCCAEIA0gB0EIaiAHQdwAaiAPIA4gESAQEB4hCwwBCyACIARqIQggBCAKEAcgAkERTwRAIARBEGohAgNAIAIgCkEQaiIKEAcgAkEQaiICIAhJDQALCyAIIAlrIQIgByATNgJcIAkgCCAOa0sEQCAJIAggEWtLBEBBbCELDAILIBAgAiAOayICaiIKIANqIBBNBEAgCCAKIAMQDxoMAgsgCCAKQQAgAmsQDyEIIAcgAiADaiIDNgJkIAggAmshCCAOIQILIAlBEE8EQCADIAhqIQMDQCAIIAIQByACQRBqIQIgCEEQaiIIIANJDQALDAELAkAgCUEHTQRAIAggAi0AADoAACAIIAItAAE6AAEgCCACLQACOgACIAggAi0AAzoAAyAIQQRqIAIgCUECdCIDQcAeaigCAGoiAhAXIAIgA0HgHmooAgBrIQIgBygCZCEDDAELIAggAhAMCyADQQlJDQAgAyAIaiEDIAhBCGoiCCACQQhqIgJrQQ9MBEADQCAIIAIQDCACQQhqIQIgCEEIaiIIIANJDQAMAgALAAsDQCAIIAIQByACQRBqIQIgCEEQaiIIIANJDQALCyAHQRhqEAQaIAsgDCALEAMiAhshDCAEIAQgC2ogAhshBCAFQX9qIgUNAAsgDBADDQFBbCEMIAdBGGoQBEECSQ0BQQAhCANAIAhBA0cEQCAAIAhBAnQiAmpBrNABaiACIAdqKAJENgIAIAhBAWohCAwBCwsgBygCXCEIC0G6fyEMIA8gCGsiACANIARrSw0AIAQEfyAEIAggABALIABqBUEACyABayEMCyAHQfAAaiQAIAwLkRcCFn8FfiMAQdABayIHJAAgByAAKALw4QEiCDYCvAEgASACaiESIAggACgCgOIBaiETAkACQCAFRQRAIAEhAwwBCyAAKALE4AEhESAAKALA4AEhFSAAKAK84AEhDyAAQQE2AozhAUEAIQgDQCAIQQNHBEAgByAIQQJ0IgJqIAAgAmpBrNABaigCADYCVCAIQQFqIQgMAQsLIAcgETYCZCAHIA82AmAgByABIA9rNgJoQWwhECAHQShqIAMgBBAGEAMNASAFQQQgBUEESBshFyAHQTxqIAdBKGogACgCABATIAdBxABqIAdBKGogACgCCBATIAdBzABqIAdBKGogACgCBBATQQAhBCAHQeAAaiEMIAdB5ABqIQoDQCAHQShqEARBAksgBCAXTnJFBEAgBygCQCAHKAI8QQN0aikCACIdQhCIp0H/AXEhCyAHKAJQIAcoAkxBA3RqKQIAIh5CEIinQf8BcSEJIAcoAkggBygCREEDdGopAgAiH0IgiKchCCAeQiCIISAgHUIgiKchAgJAIB9CEIinQf8BcSIDQQJPBEACQCAGRSADQRlJckUEQCAIIAdBKGogA0EgIAcoAixrIg0gDSADSxsiDRAFIAMgDWsiA3RqIQggB0EoahAEGiADRQ0BIAdBKGogAxAFIAhqIQgMAQsgB0EoaiADEAUgCGohCCAHQShqEAQaCyAHKQJUISEgByAINgJUIAcgITcDWAwBCwJAIANFBEAgAgRAIAcoAlQhCAwDCyAHKAJYIQgMAQsCQAJAIAdBKGpBARAFIAggAkVqaiIDQQNGBEAgBygCVEF/aiIDIANFaiEIDAELIANBAnQgB2ooAlQiCCAIRWohCCADQQFGDQELIAcgBygCWDYCXAsLIAcgBygCVDYCWCAHIAg2AlQLICCnIQMgCQRAIAdBKGogCRAFIANqIQMLIAkgC2pBFE8EQCAHQShqEAQaCyALBEAgB0EoaiALEAUgAmohAgsgB0EoahAEGiAHIAcoAmggAmoiCSADajYCaCAKIAwgCCAJSxsoAgAhDSAHIAdBKGogHUIYiKdB/wFxEAggHadB//8DcWo2AjwgByAHQShqIB5CGIinQf8BcRAIIB6nQf//A3FqNgJMIAdBKGoQBBogB0EoaiAfQhiIp0H/AXEQCCEOIAdB8ABqIARBBHRqIgsgCSANaiAIazYCDCALIAg2AgggCyADNgIEIAsgAjYCACAHIA4gH6dB//8DcWo2AkQgBEEBaiEEDAELCyAEIBdIDQEgEkFgaiEYIAdB4ABqIRogB0HkAGohGyABIQMDQCAHQShqEARBAksgBCAFTnJFBEAgBygCQCAHKAI8QQN0aikCACIdQhCIp0H/AXEhCyAHKAJQIAcoAkxBA3RqKQIAIh5CEIinQf8BcSEIIAcoAkggBygCREEDdGopAgAiH0IgiKchCSAeQiCIISAgHUIgiKchDAJAIB9CEIinQf8BcSICQQJPBEACQCAGRSACQRlJckUEQCAJIAdBKGogAkEgIAcoAixrIgogCiACSxsiChAFIAIgCmsiAnRqIQkgB0EoahAEGiACRQ0BIAdBKGogAhAFIAlqIQkMAQsgB0EoaiACEAUgCWohCSAHQShqEAQaCyAHKQJUISEgByAJNgJUIAcgITcDWAwBCwJAIAJFBEAgDARAIAcoAlQhCQwDCyAHKAJYIQkMAQsCQAJAIAdBKGpBARAFIAkgDEVqaiICQQNGBEAgBygCVEF/aiICIAJFaiEJDAELIAJBAnQgB2ooAlQiCSAJRWohCSACQQFGDQELIAcgBygCWDYCXAsLIAcgBygCVDYCWCAHIAk2AlQLICCnIRQgCARAIAdBKGogCBAFIBRqIRQLIAggC2pBFE8EQCAHQShqEAQaCyALBEAgB0EoaiALEAUgDGohDAsgB0EoahAEGiAHIAcoAmggDGoiGSAUajYCaCAbIBogCSAZSxsoAgAhHCAHIAdBKGogHUIYiKdB/wFxEAggHadB//8DcWo2AjwgByAHQShqIB5CGIinQf8BcRAIIB6nQf//A3FqNgJMIAdBKGoQBBogByAHQShqIB9CGIinQf8BcRAIIB+nQf//A3FqNgJEIAcgB0HwAGogBEEDcUEEdGoiDSkDCCIdNwPIASAHIA0pAwAiHjcDwAECQAJAAkAgBygCvAEiDiAepyICaiIWIBNLDQAgAyAHKALEASIKIAJqIgtqIBhLDQAgEiADayALQSBqTw0BCyAHIAcpA8gBNwMQIAcgBykDwAE3AwggAyASIAdBCGogB0G8AWogEyAPIBUgERAeIQsMAQsgAiADaiEIIAMgDhAHIAJBEU8EQCADQRBqIQIDQCACIA5BEGoiDhAHIAJBEGoiAiAISQ0ACwsgCCAdpyIOayECIAcgFjYCvAEgDiAIIA9rSwRAIA4gCCAVa0sEQEFsIQsMAgsgESACIA9rIgJqIhYgCmogEU0EQCAIIBYgChAPGgwCCyAIIBZBACACaxAPIQggByACIApqIgo2AsQBIAggAmshCCAPIQILIA5BEE8EQCAIIApqIQoDQCAIIAIQByACQRBqIQIgCEEQaiIIIApJDQALDAELAkAgDkEHTQRAIAggAi0AADoAACAIIAItAAE6AAEgCCACLQACOgACIAggAi0AAzoAAyAIQQRqIAIgDkECdCIKQcAeaigCAGoiAhAXIAIgCkHgHmooAgBrIQIgBygCxAEhCgwBCyAIIAIQDAsgCkEJSQ0AIAggCmohCiAIQQhqIgggAkEIaiICa0EPTARAA0AgCCACEAwgAkEIaiECIAhBCGoiCCAKSQ0ADAIACwALA0AgCCACEAcgAkEQaiECIAhBEGoiCCAKSQ0ACwsgCxADBEAgCyEQDAQFIA0gDDYCACANIBkgHGogCWs2AgwgDSAJNgIIIA0gFDYCBCAEQQFqIQQgAyALaiEDDAILAAsLIAQgBUgNASAEIBdrIQtBACEEA0AgCyAFSARAIAcgB0HwAGogC0EDcUEEdGoiAikDCCIdNwPIASAHIAIpAwAiHjcDwAECQAJAAkAgBygCvAEiDCAepyICaiIKIBNLDQAgAyAHKALEASIJIAJqIhBqIBhLDQAgEiADayAQQSBqTw0BCyAHIAcpA8gBNwMgIAcgBykDwAE3AxggAyASIAdBGGogB0G8AWogEyAPIBUgERAeIRAMAQsgAiADaiEIIAMgDBAHIAJBEU8EQCADQRBqIQIDQCACIAxBEGoiDBAHIAJBEGoiAiAISQ0ACwsgCCAdpyIGayECIAcgCjYCvAEgBiAIIA9rSwRAIAYgCCAVa0sEQEFsIRAMAgsgESACIA9rIgJqIgwgCWogEU0EQCAIIAwgCRAPGgwCCyAIIAxBACACaxAPIQggByACIAlqIgk2AsQBIAggAmshCCAPIQILIAZBEE8EQCAIIAlqIQYDQCAIIAIQByACQRBqIQIgCEEQaiIIIAZJDQALDAELAkAgBkEHTQRAIAggAi0AADoAACAIIAItAAE6AAEgCCACLQACOgACIAggAi0AAzoAAyAIQQRqIAIgBkECdCIGQcAeaigCAGoiAhAXIAIgBkHgHmooAgBrIQIgBygCxAEhCQwBCyAIIAIQDAsgCUEJSQ0AIAggCWohBiAIQQhqIgggAkEIaiICa0EPTARAA0AgCCACEAwgAkEIaiECIAhBCGoiCCAGSQ0ADAIACwALA0AgCCACEAcgAkEQaiECIAhBEGoiCCAGSQ0ACwsgEBADDQMgC0EBaiELIAMgEGohAwwBCwsDQCAEQQNHBEAgACAEQQJ0IgJqQazQAWogAiAHaigCVDYCACAEQQFqIQQMAQsLIAcoArwBIQgLQbp/IRAgEyAIayIAIBIgA2tLDQAgAwR/IAMgCCAAEAsgAGoFQQALIAFrIRALIAdB0AFqJAAgEAslACAAQgA3AgAgAEEAOwEIIABBADoACyAAIAE2AgwgACACOgAKC7QFAQN/IwBBMGsiBCQAIABB/wFqIgVBfWohBgJAIAMvAQIEQCAEQRhqIAEgAhAGIgIQAw0BIARBEGogBEEYaiADEBwgBEEIaiAEQRhqIAMQHCAAIQMDQAJAIARBGGoQBCADIAZPckUEQCADIARBEGogBEEYahASOgAAIAMgBEEIaiAEQRhqEBI6AAEgBEEYahAERQ0BIANBAmohAwsgBUF+aiEFAn8DQEG6fyECIAMiASAFSw0FIAEgBEEQaiAEQRhqEBI6AAAgAUEBaiEDIARBGGoQBEEDRgRAQQIhAiAEQQhqDAILIAMgBUsNBSABIARBCGogBEEYahASOgABIAFBAmohA0EDIQIgBEEYahAEQQNHDQALIARBEGoLIQUgAyAFIARBGGoQEjoAACABIAJqIABrIQIMAwsgAyAEQRBqIARBGGoQEjoAAiADIARBCGogBEEYahASOgADIANBBGohAwwAAAsACyAEQRhqIAEgAhAGIgIQAw0AIARBEGogBEEYaiADEBwgBEEIaiAEQRhqIAMQHCAAIQMDQAJAIARBGGoQBCADIAZPckUEQCADIARBEGogBEEYahAROgAAIAMgBEEIaiAEQRhqEBE6AAEgBEEYahAERQ0BIANBAmohAwsgBUF+aiEFAn8DQEG6fyECIAMiASAFSw0EIAEgBEEQaiAEQRhqEBE6AAAgAUEBaiEDIARBGGoQBEEDRgRAQQIhAiAEQQhqDAILIAMgBUsNBCABIARBCGogBEEYahAROgABIAFBAmohA0EDIQIgBEEYahAEQQNHDQALIARBEGoLIQUgAyAFIARBGGoQEToAACABIAJqIABrIQIMAgsgAyAEQRBqIARBGGoQEToAAiADIARBCGogBEEYahAROgADIANBBGohAwwAAAsACyAEQTBqJAAgAgtpAQF/An8CQAJAIAJBB00NACABKAAAQbfIwuF+Rw0AIAAgASgABDYCmOIBQWIgAEEQaiABIAIQPiIDEAMNAhogAEKBgICAEDcDiOEBIAAgASADaiACIANrECoMAQsgACABIAIQKgtBAAsLrQMBBn8jAEGAAWsiAyQAQWIhCAJAIAJBCUkNACAAQZjQAGogAUEIaiIEIAJBeGogAEGY0AAQMyIFEAMiBg0AIANBHzYCfCADIANB/ABqIANB+ABqIAQgBCAFaiAGGyIEIAEgAmoiAiAEaxAVIgUQAw0AIAMoAnwiBkEfSw0AIAMoAngiB0EJTw0AIABBiCBqIAMgBkGAC0GADCAHEBggA0E0NgJ8IAMgA0H8AGogA0H4AGogBCAFaiIEIAIgBGsQFSIFEAMNACADKAJ8IgZBNEsNACADKAJ4IgdBCk8NACAAQZAwaiADIAZBgA1B4A4gBxAYIANBIzYCfCADIANB/ABqIANB+ABqIAQgBWoiBCACIARrEBUiBRADDQAgAygCfCIGQSNLDQAgAygCeCIHQQpPDQAgACADIAZBwBBB0BEgBxAYIAQgBWoiBEEMaiIFIAJLDQAgAiAFayEFQQAhAgNAIAJBA0cEQCAEKAAAIgZBf2ogBU8NAiAAIAJBAnRqQZzQAWogBjYCACACQQFqIQIgBEEEaiEEDAELCyAEIAFrIQgLIANBgAFqJAAgCAtGAQN/IABBCGohAyAAKAIEIQJBACEAA0AgACACdkUEQCABIAMgAEEDdGotAAJBFktqIQEgAEEBaiEADAELCyABQQggAmt0C4YDAQV/Qbh/IQcCQCADRQ0AIAItAAAiBEUEQCABQQA2AgBBAUG4fyADQQFGGw8LAn8gAkEBaiIFIARBGHRBGHUiBkF/Sg0AGiAGQX9GBEAgA0EDSA0CIAUvAABBgP4BaiEEIAJBA2oMAQsgA0ECSA0BIAItAAEgBEEIdHJBgIB+aiEEIAJBAmoLIQUgASAENgIAIAVBAWoiASACIANqIgNLDQBBbCEHIABBEGogACAFLQAAIgVBBnZBI0EJIAEgAyABa0HAEEHQEUHwEiAAKAKM4QEgACgCnOIBIAQQHyIGEAMiCA0AIABBmCBqIABBCGogBUEEdkEDcUEfQQggASABIAZqIAgbIgEgAyABa0GAC0GADEGAFyAAKAKM4QEgACgCnOIBIAQQHyIGEAMiCA0AIABBoDBqIABBBGogBUECdkEDcUE0QQkgASABIAZqIAgbIgEgAyABa0GADUHgDkGQGSAAKAKM4QEgACgCnOIBIAQQHyIAEAMNACAAIAFqIAJrIQcLIAcLrQMBCn8jAEGABGsiCCQAAn9BUiACQf8BSw0AGkFUIANBDEsNABogAkEBaiELIABBBGohCUGAgAQgA0F/anRBEHUhCkEAIQJBASEEQQEgA3QiB0F/aiIMIQUDQCACIAtGRQRAAkAgASACQQF0Ig1qLwEAIgZB//8DRgRAIAkgBUECdGogAjoAAiAFQX9qIQVBASEGDAELIARBACAKIAZBEHRBEHVKGyEECyAIIA1qIAY7AQAgAkEBaiECDAELCyAAIAQ7AQIgACADOwEAIAdBA3YgB0EBdmpBA2ohBkEAIQRBACECA0AgBCALRkUEQCABIARBAXRqLgEAIQpBACEAA0AgACAKTkUEQCAJIAJBAnRqIAQ6AAIDQCACIAZqIAxxIgIgBUsNAAsgAEEBaiEADAELCyAEQQFqIQQMAQsLQX8gAg0AGkEAIQIDfyACIAdGBH9BAAUgCCAJIAJBAnRqIgAtAAJBAXRqIgEgAS8BACIBQQFqOwEAIAAgAyABEBRrIgU6AAMgACABIAVB/wFxdCAHazsBACACQQFqIQIMAQsLCyEFIAhBgARqJAAgBQvjBgEIf0FsIQcCQCACQQNJDQACQAJAAkACQCABLQAAIgNBA3EiCUEBaw4DAwEAAgsgACgCiOEBDQBBYg8LIAJBBUkNAkEDIQYgASgAACEFAn8CQAJAIANBAnZBA3EiCEF+aiIEQQFNBEAgBEEBaw0BDAILIAVBDnZB/wdxIQQgBUEEdkH/B3EhAyAIRQwCCyAFQRJ2IQRBBCEGIAVBBHZB//8AcSEDQQAMAQsgBUEEdkH//w9xIgNBgIAISw0DIAEtAARBCnQgBUEWdnIhBEEFIQZBAAshBSAEIAZqIgogAksNAgJAIANBgQZJDQAgACgCnOIBRQ0AQQAhAgNAIAJBg4ABSw0BIAJBQGshAgwAAAsACwJ/IAlBA0YEQCABIAZqIQEgAEHw4gFqIQIgACgCDCEGIAUEQCACIAMgASAEIAYQXwwCCyACIAMgASAEIAYQXQwBCyAAQbjQAWohAiABIAZqIQEgAEHw4gFqIQYgAEGo0ABqIQggBQRAIAggBiADIAEgBCACEF4MAQsgCCAGIAMgASAEIAIQXAsQAw0CIAAgAzYCgOIBIABBATYCiOEBIAAgAEHw4gFqNgLw4QEgCUECRgRAIAAgAEGo0ABqNgIMCyAAIANqIgBBiOMBakIANwAAIABBgOMBakIANwAAIABB+OIBakIANwAAIABB8OIBakIANwAAIAoPCwJ/AkACQAJAIANBAnZBA3FBf2oiBEECSw0AIARBAWsOAgACAQtBASEEIANBA3YMAgtBAiEEIAEvAABBBHYMAQtBAyEEIAEQIUEEdgsiAyAEaiIFQSBqIAJLBEAgBSACSw0CIABB8OIBaiABIARqIAMQCyEBIAAgAzYCgOIBIAAgATYC8OEBIAEgA2oiAEIANwAYIABCADcAECAAQgA3AAggAEIANwAAIAUPCyAAIAM2AoDiASAAIAEgBGo2AvDhASAFDwsCfwJAAkACQCADQQJ2QQNxQX9qIgRBAksNACAEQQFrDgIAAgELQQEhByADQQN2DAILQQIhByABLwAAQQR2DAELIAJBBEkgARAhIgJBj4CAAUtyDQFBAyEHIAJBBHYLIQIgAEHw4gFqIAEgB2otAAAgAkEgahAQIQEgACACNgKA4gEgACABNgLw4QEgB0EBaiEHCyAHC0sAIABC+erQ0OfJoeThADcDICAAQgA3AxggAELP1tO+0ser2UI3AxAgAELW64Lu6v2J9eAANwMIIABCADcDACAAQShqQQBBKBAQGgviAgICfwV+IABBKGoiASAAKAJIaiECAn4gACkDACIDQiBaBEAgACkDECIEQgeJIAApAwgiBUIBiXwgACkDGCIGQgyJfCAAKQMgIgdCEol8IAUQGSAEEBkgBhAZIAcQGQwBCyAAKQMYQsXP2bLx5brqJ3wLIAN8IQMDQCABQQhqIgAgAk0EQEIAIAEpAAAQCSADhUIbiUKHla+vmLbem55/fkLj3MqV/M7y9YV/fCEDIAAhAQwBCwsCQCABQQRqIgAgAksEQCABIQAMAQsgASgAAK1Ch5Wvr5i23puef34gA4VCF4lCz9bTvtLHq9lCfkL5893xmfaZqxZ8IQMLA0AgACACSQRAIAAxAABCxc/ZsvHluuonfiADhUILiUKHla+vmLbem55/fiEDIABBAWohAAwBCwsgA0IhiCADhULP1tO+0ser2UJ+IgNCHYggA4VC+fPd8Zn2masWfiIDQiCIIAOFC+8CAgJ/BH4gACAAKQMAIAKtfDcDAAJAAkAgACgCSCIDIAJqIgRBH00EQCABRQ0BIAAgA2pBKGogASACECAgACgCSCACaiEEDAELIAEgAmohAgJ/IAMEQCAAQShqIgQgA2ogAUEgIANrECAgACAAKQMIIAQpAAAQCTcDCCAAIAApAxAgACkAMBAJNwMQIAAgACkDGCAAKQA4EAk3AxggACAAKQMgIABBQGspAAAQCTcDICAAKAJIIQMgAEEANgJIIAEgA2tBIGohAQsgAUEgaiACTQsEQCACQWBqIQMgACkDICEFIAApAxghBiAAKQMQIQcgACkDCCEIA0AgCCABKQAAEAkhCCAHIAEpAAgQCSEHIAYgASkAEBAJIQYgBSABKQAYEAkhBSABQSBqIgEgA00NAAsgACAFNwMgIAAgBjcDGCAAIAc3AxAgACAINwMICyABIAJPDQEgAEEoaiABIAIgAWsiBBAgCyAAIAQ2AkgLCy8BAX8gAEUEQEG2f0EAIAMbDwtBun8hBCADIAFNBH8gACACIAMQEBogAwVBun8LCy8BAX8gAEUEQEG2f0EAIAMbDwtBun8hBCADIAFNBH8gACACIAMQCxogAwVBun8LC6gCAQZ/IwBBEGsiByQAIABB2OABaikDAEKAgIAQViEIQbh/IQUCQCAEQf//B0sNACAAIAMgBBBCIgUQAyIGDQAgACgCnOIBIQkgACAHQQxqIAMgAyAFaiAGGyIKIARBACAFIAYbayIGEEAiAxADBEAgAyEFDAELIAcoAgwhBCABRQRAQbp/IQUgBEEASg0BCyAGIANrIQUgAyAKaiEDAkAgCQRAIABBADYCnOIBDAELAkACQAJAIARBBUgNACAAQdjgAWopAwBCgICACFgNAAwBCyAAQQA2ApziAQwBCyAAKAIIED8hBiAAQQA2ApziASAGQRRPDQELIAAgASACIAMgBSAEIAgQOSEFDAELIAAgASACIAMgBSAEIAgQOiEFCyAHQRBqJAAgBQtnACAAQdDgAWogASACIAAoAuzhARAuIgEQAwRAIAEPC0G4fyECAkAgAQ0AIABB7OABaigCACIBBEBBYCECIAAoApjiASABRw0BC0EAIQIgAEHw4AFqKAIARQ0AIABBkOEBahBDCyACCycBAX8QVyIERQRAQUAPCyAEIAAgASACIAMgBBBLEE8hACAEEFYgAAs/AQF/AkACQAJAIAAoAqDiAUEBaiIBQQJLDQAgAUEBaw4CAAECCyAAEDBBAA8LIABBADYCoOIBCyAAKAKU4gELvAMCB38BfiMAQRBrIgkkAEG4fyEGAkAgBCgCACIIQQVBCSAAKALs4QEiBRtJDQAgAygCACIHQQFBBSAFGyAFEC8iBRADBEAgBSEGDAELIAggBUEDakkNACAAIAcgBRBJIgYQAw0AIAEgAmohCiAAQZDhAWohCyAIIAVrIQIgBSAHaiEHIAEhBQNAIAcgAiAJECwiBhADDQEgAkF9aiICIAZJBEBBuH8hBgwCCyAJKAIAIghBAksEQEFsIQYMAgsgB0EDaiEHAn8CQAJAAkAgCEEBaw4CAgABCyAAIAUgCiAFayAHIAYQSAwCCyAFIAogBWsgByAGEEcMAQsgBSAKIAVrIActAAAgCSgCCBBGCyIIEAMEQCAIIQYMAgsgACgC8OABBEAgCyAFIAgQRQsgAiAGayECIAYgB2ohByAFIAhqIQUgCSgCBEUNAAsgACkD0OABIgxCf1IEQEFsIQYgDCAFIAFrrFINAQsgACgC8OABBEBBaiEGIAJBBEkNASALEEQhDCAHKAAAIAynRw0BIAdBBGohByACQXxqIQILIAMgBzYCACAEIAI2AgAgBSABayEGCyAJQRBqJAAgBgsuACAAECsCf0EAQQAQAw0AGiABRSACRXJFBEBBYiAAIAEgAhA9EAMNARoLQQALCzcAIAEEQCAAIAAoAsTgASABKAIEIAEoAghqRzYCnOIBCyAAECtBABADIAFFckUEQCAAIAEQWwsL0QIBB38jAEEQayIGJAAgBiAENgIIIAYgAzYCDCAFBEAgBSgCBCEKIAUoAgghCQsgASEIAkACQANAIAAoAuzhARAWIQsCQANAIAQgC0kNASADKAAAQXBxQdDUtMIBRgRAIAMgBBAiIgcQAw0EIAQgB2shBCADIAdqIQMMAQsLIAYgAzYCDCAGIAQ2AggCQCAFBEAgACAFEE5BACEHQQAQA0UNAQwFCyAAIAogCRBNIgcQAw0ECyAAIAgQUCAMQQFHQQAgACAIIAIgBkEMaiAGQQhqEEwiByIDa0EAIAMQAxtBCkdyRQRAQbh/IQcMBAsgBxADDQMgAiAHayECIAcgCGohCEEBIQwgBigCDCEDIAYoAgghBAwBCwsgBiADNgIMIAYgBDYCCEG4fyEHIAQNASAIIAFrIQcMAQsgBiADNgIMIAYgBDYCCAsgBkEQaiQAIAcLRgECfyABIAAoArjgASICRwRAIAAgAjYCxOABIAAgATYCuOABIAAoArzgASEDIAAgATYCvOABIAAgASADIAJrajYCwOABCwutAgIEfwF+IwBBQGoiBCQAAkACQCACQQhJDQAgASgAAEFwcUHQ1LTCAUcNACABIAIQIiEBIABCADcDCCAAQQA2AgQgACABNgIADAELIARBGGogASACEC0iAxADBEAgACADEBoMAQsgAwRAIABBuH8QGgwBCyACIAQoAjAiA2shAiABIANqIQMDQAJAIAAgAyACIARBCGoQLCIFEAMEfyAFBSACIAVBA2oiBU8NAUG4fwsQGgwCCyAGQQFqIQYgAiAFayECIAMgBWohAyAEKAIMRQ0ACyAEKAI4BEAgAkEDTQRAIABBuH8QGgwCCyADQQRqIQMLIAQoAighAiAEKQMYIQcgAEEANgIEIAAgAyABazYCACAAIAIgBmytIAcgB0J/URs3AwgLIARBQGskAAslAQF/IwBBEGsiAiQAIAIgACABEFEgAigCACEAIAJBEGokACAAC30BBH8jAEGQBGsiBCQAIARB/wE2AggCQCAEQRBqIARBCGogBEEMaiABIAIQFSIGEAMEQCAGIQUMAQtBVCEFIAQoAgwiB0EGSw0AIAMgBEEQaiAEKAIIIAcQQSIFEAMNACAAIAEgBmogAiAGayADEDwhBQsgBEGQBGokACAFC4cBAgJ/An5BABAWIQMCQANAIAEgA08EQAJAIAAoAABBcHFB0NS0wgFGBEAgACABECIiAhADRQ0BQn4PCyAAIAEQVSIEQn1WDQMgBCAFfCIFIARUIQJCfiEEIAINAyAAIAEQUiICEAMNAwsgASACayEBIAAgAmohAAwBCwtCfiAFIAEbIQQLIAQLPwIBfwF+IwBBMGsiAiQAAn5CfiACQQhqIAAgARAtDQAaQgAgAigCHEEBRg0AGiACKQMICyEDIAJBMGokACADC40BAQJ/IwBBMGsiASQAAkAgAEUNACAAKAKI4gENACABIABB/OEBaigCADYCKCABIAApAvThATcDICAAEDAgACgCqOIBIQIgASABKAIoNgIYIAEgASkDIDcDECACIAFBEGoQGyAAQQA2AqjiASABIAEoAig2AgggASABKQMgNwMAIAAgARAbCyABQTBqJAALKgECfyMAQRBrIgAkACAAQQA2AgggAEIANwMAIAAQWCEBIABBEGokACABC4cBAQN/IwBBEGsiAiQAAkAgACgCAEUgACgCBEVzDQAgAiAAKAIINgIIIAIgACkCADcDAAJ/IAIoAgAiAQRAIAIoAghBqOMJIAERBQAMAQtBqOMJECgLIgFFDQAgASAAKQIANwL04QEgAUH84QFqIAAoAgg2AgAgARBZIAEhAwsgAkEQaiQAIAMLywEBAn8jAEEgayIBJAAgAEGBgIDAADYCtOIBIABBADYCiOIBIABBADYC7OEBIABCADcDkOIBIABBADYCpOMJIABBADYC3OIBIABCADcCzOIBIABBADYCvOIBIABBADYCxOABIABCADcCnOIBIABBpOIBakIANwIAIABBrOIBakEANgIAIAFCADcCECABQgA3AhggASABKQMYNwMIIAEgASkDEDcDACABKAIIQQh2QQFxIQIgAEEANgLg4gEgACACNgKM4gEgAUEgaiQAC3YBA38jAEEwayIBJAAgAARAIAEgAEHE0AFqIgIoAgA2AiggASAAKQK80AE3AyAgACgCACEDIAEgAigCADYCGCABIAApArzQATcDECADIAFBEGoQGyABIAEoAig2AgggASABKQMgNwMAIAAgARAbCyABQTBqJAALzAEBAX8gACABKAK00AE2ApjiASAAIAEoAgQiAjYCwOABIAAgAjYCvOABIAAgAiABKAIIaiICNgK44AEgACACNgLE4AEgASgCuNABBEAgAEKBgICAEDcDiOEBIAAgAUGk0ABqNgIMIAAgAUGUIGo2AgggACABQZwwajYCBCAAIAFBDGo2AgAgAEGs0AFqIAFBqNABaigCADYCACAAQbDQAWogAUGs0AFqKAIANgIAIABBtNABaiABQbDQAWooAgA2AgAPCyAAQgA3A4jhAQs7ACACRQRAQbp/DwsgBEUEQEFsDwsgAiAEEGAEQCAAIAEgAiADIAQgBRBhDwsgACABIAIgAyAEIAUQZQtGAQF/IwBBEGsiBSQAIAVBCGogBBAOAn8gBS0ACQRAIAAgASACIAMgBBAyDAELIAAgASACIAMgBBA0CyEAIAVBEGokACAACzQAIAAgAyAEIAUQNiIFEAMEQCAFDwsgBSAESQR/IAEgAiADIAVqIAQgBWsgABA1BUG4fwsLRgEBfyMAQRBrIgUkACAFQQhqIAQQDgJ/IAUtAAkEQCAAIAEgAiADIAQQYgwBCyAAIAEgAiADIAQQNQshACAFQRBqJAAgAAtZAQF/QQ8hAiABIABJBEAgAUEEdCAAbiECCyAAQQh2IgEgAkEYbCIAQYwIaigCAGwgAEGICGooAgBqIgJBA3YgAmogAEGACGooAgAgAEGECGooAgAgAWxqSQs3ACAAIAMgBCAFQYAQEDMiBRADBEAgBQ8LIAUgBEkEfyABIAIgAyAFaiAEIAVrIAAQMgVBuH8LC78DAQN/IwBBIGsiBSQAIAVBCGogAiADEAYiAhADRQRAIAAgAWoiB0F9aiEGIAUgBBAOIARBBGohAiAFLQACIQMDQEEAIAAgBkkgBUEIahAEGwRAIAAgAiAFQQhqIAMQAkECdGoiBC8BADsAACAFQQhqIAQtAAIQASAAIAQtAANqIgQgAiAFQQhqIAMQAkECdGoiAC8BADsAACAFQQhqIAAtAAIQASAEIAAtAANqIQAMAQUgB0F+aiEEA0AgBUEIahAEIAAgBEtyRQRAIAAgAiAFQQhqIAMQAkECdGoiBi8BADsAACAFQQhqIAYtAAIQASAAIAYtAANqIQAMAQsLA0AgACAES0UEQCAAIAIgBUEIaiADEAJBAnRqIgYvAQA7AAAgBUEIaiAGLQACEAEgACAGLQADaiEADAELCwJAIAAgB08NACAAIAIgBUEIaiADEAIiA0ECdGoiAC0AADoAACAALQADQQFGBEAgBUEIaiAALQACEAEMAQsgBSgCDEEfSw0AIAVBCGogAiADQQJ0ai0AAhABIAUoAgxBIUkNACAFQSA2AgwLIAFBbCAFQQhqEAobIQILCwsgBUEgaiQAIAILkgIBBH8jAEFAaiIJJAAgCSADQTQQCyEDAkAgBEECSA0AIAMgBEECdGooAgAhCSADQTxqIAgQIyADQQE6AD8gAyACOgA+QQAhBCADKAI8IQoDQCAEIAlGDQEgACAEQQJ0aiAKNgEAIARBAWohBAwAAAsAC0EAIQkDQCAGIAlGRQRAIAMgBSAJQQF0aiIKLQABIgtBAnRqIgwoAgAhBCADQTxqIAotAABBCHQgCGpB//8DcRAjIANBAjoAPyADIAcgC2siCiACajoAPiAEQQEgASAKa3RqIQogAygCPCELA0AgACAEQQJ0aiALNgEAIARBAWoiBCAKSQ0ACyAMIAo2AgAgCUEBaiEJDAELCyADQUBrJAALowIBCX8jAEHQAGsiCSQAIAlBEGogBUE0EAsaIAcgBmshDyAHIAFrIRADQAJAIAMgCkcEQEEBIAEgByACIApBAXRqIgYtAAEiDGsiCGsiC3QhDSAGLQAAIQ4gCUEQaiAMQQJ0aiIMKAIAIQYgCyAPTwRAIAAgBkECdGogCyAIIAUgCEE0bGogCCAQaiIIQQEgCEEBShsiCCACIAQgCEECdGooAgAiCEEBdGogAyAIayAHIA4QYyAGIA1qIQgMAgsgCUEMaiAOECMgCUEBOgAPIAkgCDoADiAGIA1qIQggCSgCDCELA0AgBiAITw0CIAAgBkECdGogCzYBACAGQQFqIQYMAAALAAsgCUHQAGokAA8LIAwgCDYCACAKQQFqIQoMAAALAAs0ACAAIAMgBCAFEDYiBRADBEAgBQ8LIAUgBEkEfyABIAIgAyAFaiAEIAVrIAAQNAVBuH8LCyMAIAA/AEEQdGtB//8DakEQdkAAQX9GBEBBAA8LQQAQAEEBCzsBAX8gAgRAA0AgACABIAJBgCAgAkGAIEkbIgMQCyEAIAFBgCBqIQEgAEGAIGohACACIANrIgINAAsLCwYAIAAQAwsLqBUJAEGICAsNAQAAAAEAAAACAAAAAgBBoAgLswYBAAAAAQAAAAIAAAACAAAAJgAAAIIAAAAhBQAASgAAAGcIAAAmAAAAwAEAAIAAAABJBQAASgAAAL4IAAApAAAALAIAAIAAAABJBQAASgAAAL4IAAAvAAAAygIAAIAAAACKBQAASgAAAIQJAAA1AAAAcwMAAIAAAACdBQAASgAAAKAJAAA9AAAAgQMAAIAAAADrBQAASwAAAD4KAABEAAAAngMAAIAAAABNBgAASwAAAKoKAABLAAAAswMAAIAAAADBBgAATQAAAB8NAABNAAAAUwQAAIAAAAAjCAAAUQAAAKYPAABUAAAAmQQAAIAAAABLCQAAVwAAALESAABYAAAA2gQAAIAAAABvCQAAXQAAACMUAABUAAAARQUAAIAAAABUCgAAagAAAIwUAABqAAAArwUAAIAAAAB2CQAAfAAAAE4QAAB8AAAA0gIAAIAAAABjBwAAkQAAAJAHAACSAAAAAAAAAAEAAAABAAAABQAAAA0AAAAdAAAAPQAAAH0AAAD9AAAA/QEAAP0DAAD9BwAA/Q8AAP0fAAD9PwAA/X8AAP3/AAD9/wEA/f8DAP3/BwD9/w8A/f8fAP3/PwD9/38A/f//AP3//wH9//8D/f//B/3//w/9//8f/f//P/3//38AAAAAAQAAAAIAAAADAAAABAAAAAUAAAAGAAAABwAAAAgAAAAJAAAACgAAAAsAAAAMAAAADQAAAA4AAAAPAAAAEAAAABEAAAASAAAAEwAAABQAAAAVAAAAFgAAABcAAAAYAAAAGQAAABoAAAAbAAAAHAAAAB0AAAAeAAAAHwAAAAMAAAAEAAAABQAAAAYAAAAHAAAACAAAAAkAAAAKAAAACwAAAAwAAAANAAAADgAAAA8AAAAQAAAAEQAAABIAAAATAAAAFAAAABUAAAAWAAAAFwAAABgAAAAZAAAAGgAAABsAAAAcAAAAHQAAAB4AAAAfAAAAIAAAACEAAAAiAAAAIwAAACUAAAAnAAAAKQAAACsAAAAvAAAAMwAAADsAAABDAAAAUwAAAGMAAACDAAAAAwEAAAMCAAADBAAAAwgAAAMQAAADIAAAA0AAAAOAAAADAAEAQeAPC1EBAAAAAQAAAAEAAAABAAAAAgAAAAIAAAADAAAAAwAAAAQAAAAEAAAABQAAAAcAAAAIAAAACQAAAAoAAAALAAAADAAAAA0AAAAOAAAADwAAABAAQcQQC4sBAQAAAAIAAAADAAAABAAAAAUAAAAGAAAABwAAAAgAAAAJAAAACgAAAAsAAAAMAAAADQAAAA4AAAAPAAAAEAAAABIAAAAUAAAAFgAAABgAAAAcAAAAIAAAACgAAAAwAAAAQAAAAIAAAAAAAQAAAAIAAAAEAAAACAAAABAAAAAgAAAAQAAAAIAAAAAAAQBBkBIL5gQBAAAAAQAAAAEAAAABAAAAAgAAAAIAAAADAAAAAwAAAAQAAAAGAAAABwAAAAgAAAAJAAAACgAAAAsAAAAMAAAADQAAAA4AAAAPAAAAEAAAAAEAAAAEAAAACAAAAAAAAAABAAEBBgAAAAAAAAQAAAAAEAAABAAAAAAgAAAFAQAAAAAAAAUDAAAAAAAABQQAAAAAAAAFBgAAAAAAAAUHAAAAAAAABQkAAAAAAAAFCgAAAAAAAAUMAAAAAAAABg4AAAAAAAEFEAAAAAAAAQUUAAAAAAABBRYAAAAAAAIFHAAAAAAAAwUgAAAAAAAEBTAAAAAgAAYFQAAAAAAABwWAAAAAAAAIBgABAAAAAAoGAAQAAAAADAYAEAAAIAAABAAAAAAAAAAEAQAAAAAAAAUCAAAAIAAABQQAAAAAAAAFBQAAACAAAAUHAAAAAAAABQgAAAAgAAAFCgAAAAAAAAULAAAAAAAABg0AAAAgAAEFEAAAAAAAAQUSAAAAIAABBRYAAAAAAAIFGAAAACAAAwUgAAAAAAADBSgAAAAAAAYEQAAAABAABgRAAAAAIAAHBYAAAAAAAAkGAAIAAAAACwYACAAAMAAABAAAAAAQAAAEAQAAACAAAAUCAAAAIAAABQMAAAAgAAAFBQAAACAAAAUGAAAAIAAABQgAAAAgAAAFCQAAACAAAAULAAAAIAAABQwAAAAAAAAGDwAAACAAAQUSAAAAIAABBRQAAAAgAAIFGAAAACAAAgUcAAAAIAADBSgAAAAgAAQFMAAAAAAAEAYAAAEAAAAPBgCAAAAAAA4GAEAAAAAADQYAIABBgBcLhwIBAAEBBQAAAAAAAAUAAAAAAAAGBD0AAAAAAAkF/QEAAAAADwX9fwAAAAAVBf3/HwAAAAMFBQAAAAAABwR9AAAAAAAMBf0PAAAAABIF/f8DAAAAFwX9/38AAAAFBR0AAAAAAAgE/QAAAAAADgX9PwAAAAAUBf3/DwAAAAIFAQAAABAABwR9AAAAAAALBf0HAAAAABEF/f8BAAAAFgX9/z8AAAAEBQ0AAAAQAAgE/QAAAAAADQX9HwAAAAATBf3/BwAAAAEFAQAAABAABgQ9AAAAAAAKBf0DAAAAABAF/f8AAAAAHAX9//8PAAAbBf3//wcAABoF/f//AwAAGQX9//8BAAAYBf3//wBBkBkLhgQBAAEBBgAAAAAAAAYDAAAAAAAABAQAAAAgAAAFBQAAAAAAAAUGAAAAAAAABQgAAAAAAAAFCQAAAAAAAAULAAAAAAAABg0AAAAAAAAGEAAAAAAAAAYTAAAAAAAABhYAAAAAAAAGGQAAAAAAAAYcAAAAAAAABh8AAAAAAAAGIgAAAAAAAQYlAAAAAAABBikAAAAAAAIGLwAAAAAAAwY7AAAAAAAEBlMAAAAAAAcGgwAAAAAACQYDAgAAEAAABAQAAAAAAAAEBQAAACAAAAUGAAAAAAAABQcAAAAgAAAFCQAAAAAAAAUKAAAAAAAABgwAAAAAAAAGDwAAAAAAAAYSAAAAAAAABhUAAAAAAAAGGAAAAAAAAAYbAAAAAAAABh4AAAAAAAAGIQAAAAAAAQYjAAAAAAABBicAAAAAAAIGKwAAAAAAAwYzAAAAAAAEBkMAAAAAAAUGYwAAAAAACAYDAQAAIAAABAQAAAAwAAAEBAAAABAAAAQFAAAAIAAABQcAAAAgAAAFCAAAACAAAAUKAAAAIAAABQsAAAAAAAAGDgAAAAAAAAYRAAAAAAAABhQAAAAAAAAGFwAAAAAAAAYaAAAAAAAABh0AAAAAAAAGIAAAAAAAEAYDAAEAAAAPBgOAAAAAAA4GA0AAAAAADQYDIAAAAAAMBgMQAAAAAAsGAwgAAAAACgYDBABBpB0L2QEBAAAAAwAAAAcAAAAPAAAAHwAAAD8AAAB/AAAA/wAAAP8BAAD/AwAA/wcAAP8PAAD/HwAA/z8AAP9/AAD//wAA//8BAP//AwD//wcA//8PAP//HwD//z8A//9/AP///wD///8B////A////wf///8P////H////z////9/AAAAAAEAAAACAAAABAAAAAAAAAACAAAABAAAAAgAAAAAAAAAAQAAAAIAAAABAAAABAAAAAQAAAAEAAAABAAAAAgAAAAIAAAACAAAAAcAAAAIAAAACQAAAAoAAAALAEGgIAsDwBBQ",DisplayP3ColorSpace="display-p3",LinearDisplayP3ColorSpace="display-p3-linear";({...ColorManagement.spaces[SRGBColorSpace]});const _taskCache=new WeakMap;let _activeLoaders=0,_zstd;class KTX2Loader extends Loader{constructor(w){super(w),this.transcoderPath="",this.transcoderBinary=null,this.transcoderPending=null,this.workerPool=new WorkerPool,this.workerSourceURL="",this.workerConfig=null,typeof MSC_TRANSCODER<"u"&&console.warn('THREE.KTX2Loader: Please update to latest "basis_transcoder". "msc_basis_transcoder" is no longer supported in three.js r125+.')}setTranscoderPath(w){return this.transcoderPath=w,this}setWorkerLimit(w){return this.workerPool.setWorkerLimit(w),this}async detectSupportAsync(w){return console.warn('KTX2Loader: "detectSupportAsync()" has been deprecated. Use "detectSupport()" and "await renderer.init();" when creating the renderer.'),await w.init(),this.detectSupport(w)}detectSupport(w){return w.isWebGPURenderer===!0?this.workerConfig={astcSupported:w.hasFeature("texture-compression-astc"),astcHDRSupported:!1,etc1Supported:w.hasFeature("texture-compression-etc1"),etc2Supported:w.hasFeature("texture-compression-etc2"),dxtSupported:w.hasFeature("texture-compression-s3tc"),bptcSupported:w.hasFeature("texture-compression-bc"),pvrtcSupported:w.hasFeature("texture-compression-pvrtc")}:(this.workerConfig={astcSupported:w.extensions.has("WEBGL_compressed_texture_astc"),astcHDRSupported:w.extensions.has("WEBGL_compressed_texture_astc")&&w.extensions.get("WEBGL_compressed_texture_astc").getSupportedProfiles().includes("hdr"),etc1Supported:w.extensions.has("WEBGL_compressed_texture_etc1"),etc2Supported:w.extensions.has("WEBGL_compressed_texture_etc"),dxtSupported:w.extensions.has("WEBGL_compressed_texture_s3tc"),bptcSupported:w.extensions.has("EXT_texture_compression_bptc"),pvrtcSupported:w.extensions.has("WEBGL_compressed_texture_pvrtc")||w.extensions.has("WEBKIT_WEBGL_compressed_texture_pvrtc")},typeof navigator<"u"&&navigator.platform.indexOf("Linux")>=0&&navigator.userAgent.indexOf("Firefox")>=0&&this.workerConfig.astcSupported&&this.workerConfig.etc2Supported&&this.workerConfig.bptcSupported&&this.workerConfig.dxtSupported&&(this.workerConfig.astcSupported=!1,this.workerConfig.etc2Supported=!1)),this}init(){if(!this.transcoderPending){const w=new FileLoader(this.manager);w.setPath(this.transcoderPath),w.setWithCredentials(this.withCredentials);const D=w.loadAsync("basis_transcoder.js"),O=new FileLoader(this.manager);O.setPath(this.transcoderPath),O.setResponseType("arraybuffer"),O.setWithCredentials(this.withCredentials);const U=O.loadAsync("basis_transcoder.wasm");this.transcoderPending=Promise.all([D,U]).then(([G,q])=>{const K=KTX2Loader.BasisWorker.toString(),ee=["/* constants */","let _EngineFormat = "+JSON.stringify(KTX2Loader.EngineFormat),"let _EngineType = "+JSON.stringify(KTX2Loader.EngineType),"let _TranscoderFormat = "+JSON.stringify(KTX2Loader.TranscoderFormat),"let _BasisFormat = "+JSON.stringify(KTX2Loader.BasisFormat),"/* basis_transcoder.js */",G,"/* worker */",K.substring(K.indexOf("{")+1,K.lastIndexOf("}"))].join(`
`);this.workerSourceURL=URL.createObjectURL(new Blob([ee])),this.transcoderBinary=q,this.workerPool.setWorkerCreator(()=>{const Z=new Worker(this.workerSourceURL),ie=this.transcoderBinary.slice(0);return Z.postMessage({type:"init",config:this.workerConfig,transcoderBinary:ie},[ie]),Z})}),_activeLoaders>0&&console.warn("THREE.KTX2Loader: Multiple active KTX2 loaders may cause performance issues. Use a single KTX2Loader instance, or call .dispose() on old instances."),_activeLoaders++}return this.transcoderPending}load(w,D,O,U){if(this.workerConfig===null)throw new Error("THREE.KTX2Loader: Missing initialization with `.detectSupport( renderer )`.");const G=new FileLoader(this.manager);G.setPath(this.path),G.setCrossOrigin(this.crossOrigin),G.setWithCredentials(this.withCredentials),G.setRequestHeader(this.requestHeader),G.setResponseType("arraybuffer"),G.load(w,q=>{this.parse(q,D,U)},O,U)}parse(w,D,O){if(this.workerConfig===null)throw new Error("THREE.KTX2Loader: Missing initialization with `.detectSupport( renderer )`.");if(_taskCache.has(w))return _taskCache.get(w).promise.then(D).catch(O);this._createTexture(w).then(U=>D?D(U):null).catch(O)}_createTextureFrom(w,D){const{type:O,error:U,data:{faces:G,width:q,height:K,format:ee,type:Z,dfdFlags:ie}}=w;if(O==="error")return Promise.reject(U);let Y;if(D.faceCount===6)Y=new CompressedCubeTexture(G,ee,Z);else{const W=G[0].mipmaps;Y=D.layerCount>1?new CompressedArrayTexture(W,q,K,D.layerCount,ee,Z):new CompressedTexture(W,q,K,ee,Z)}return Y.minFilter=G[0].mipmaps.length===1?LinearFilter:LinearMipmapLinearFilter,Y.magFilter=LinearFilter,Y.generateMipmaps=!1,Y.needsUpdate=!0,Y.colorSpace=parseColorSpace(D),Y.premultiplyAlpha=!!(ie&u),Y}async _createTexture(w,D={}){const O=Mi(new Uint8Array(w)),U=O.vkFormat===_i&&O.dataFormatDescriptor[0].colorModel===167;if(!(O.vkFormat===it||U&&!this.workerConfig.astcHDRSupported))return createRawTexture(O);const q=D,K=this.init().then(()=>this.workerPool.postMessage({type:"transcode",buffer:w,taskConfig:q},[w])).then(ee=>this._createTextureFrom(ee.data,O));return _taskCache.set(w,{promise:K}),K}dispose(){this.workerPool.dispose(),this.workerSourceURL&&URL.revokeObjectURL(this.workerSourceURL),_activeLoaders--}}KTX2Loader.BasisFormat={ETC1S:0,UASTC:1,UASTC_HDR:2};KTX2Loader.TranscoderFormat={ETC1:0,ETC2:1,BC1:2,BC3:3,BC4:4,BC5:5,BC7_M6_OPAQUE_ONLY:6,BC7_M5:7,PVRTC1_4_RGB:8,PVRTC1_4_RGBA:9,ASTC_4x4:10,ATC_RGB:11,ATC_RGBA_INTERPOLATED_ALPHA:12,RGBA32:13,RGB565:14,BGR565:15,RGBA4444:16,BC6H:22,RGB_HALF:24,RGBA_HALF:25};KTX2Loader.EngineFormat={RGBAFormat,RGBA_ASTC_4x4_Format,RGB_BPTC_UNSIGNED_Format,RGBA_BPTC_Format,RGBA_ETC2_EAC_Format,RGBA_PVRTC_4BPPV1_Format,RGBA_S3TC_DXT5_Format,RGB_ETC1_Format,RGB_ETC2_Format,RGB_PVRTC_4BPPV1_Format,RGBA_S3TC_DXT1_Format};KTX2Loader.EngineType={UnsignedByteType,HalfFloatType,FloatType};KTX2Loader.BasisWorker=function(){let F,w,D;const O=_EngineFormat,U=_EngineType,G=_TranscoderFormat,q=_BasisFormat;self.addEventListener("message",function(se){const le=se.data;switch(le.type){case"init":F=le.config,K(le.transcoderBinary);break;case"transcode":w.then(()=>{try{const{faces:ce,buffers:he,width:pe,height:me,hasAlpha:be,format:ge,type:ve,dfdFlags:Se}=ee(le.buffer);self.postMessage({type:"transcode",id:le.id,data:{faces:ce,width:pe,height:me,hasAlpha:be,format:ge,type:ve,dfdFlags:Se}},he)}catch(ce){console.error(ce),self.postMessage({type:"error",id:le.id,error:ce.message})}});break}});function K(se){w=new Promise(le=>{D={wasmBinary:se,onRuntimeInitialized:le},BASIS(D)}).then(()=>{D.initializeBasis(),D.KTX2File===void 0&&console.warn("THREE.KTX2Loader: Please update Basis Universal transcoder.")})}function ee(se){const le=new D.KTX2File(new Uint8Array(se));function ce(){le.close(),le.delete()}if(!le.isValid())throw ce(),new Error("THREE.KTX2Loader:	Invalid or unsupported .ktx2 file");let he;if(le.isUASTC())he=q.UASTC;else if(le.isETC1S())he=q.ETC1S;else if(le.isHDR())he=q.UASTC_HDR;else throw new Error("THREE.KTX2Loader: Unknown Basis encoding");const pe=le.getWidth(),me=le.getHeight(),be=le.getLayers()||1,ge=le.getLevels(),ve=le.getFaces(),Se=le.getHasAlpha(),Me=le.getDFDFlags(),{transcoderFormat:Ee,engineFormat:we,engineType:Re}=Y(he,pe,me,Se);if(!pe||!me||!ge)throw ce(),new Error("THREE.KTX2Loader:	Invalid texture");if(!le.startTranscoding())throw ce(),new Error("THREE.KTX2Loader: .startTranscoding failed");const Le=[],Ne=[];for(let Oe=0;Oe<ve;Oe++){const Pe=[];for(let Ce=0;Ce<ge;Ce++){const Be=[];let ze,Xe;for(let ke=0;ke<be;ke++){const rt=le.getImageLevelInfo(Ce,ke,Oe);Oe===0&&Ce===0&&ke===0&&(rt.origWidth%4!==0||rt.origHeight%4!==0)&&console.warn("THREE.KTX2Loader: ETC1S and UASTC textures should use multiple-of-four dimensions."),ge>1?(ze=rt.origWidth,Xe=rt.origHeight):(ze=rt.width,Xe=rt.height);let St=new Uint8Array(le.getImageTranscodedSizeInBytes(Ce,ke,0,Ee));const Lt=le.transcodeImage(St,Ce,ke,Oe,Ee,0,-1,-1);if(Re===U.HalfFloatType&&(St=new Uint16Array(St.buffer,St.byteOffset,St.byteLength/Uint16Array.BYTES_PER_ELEMENT)),!Lt)throw ce(),new Error("THREE.KTX2Loader: .transcodeImage failed.");Be.push(St)}const lt=ne(Be);Pe.push({data:lt,width:ze,height:Xe}),Ne.push(lt.buffer)}Le.push({mipmaps:Pe,width:pe,height:me,format:we,type:Re})}return ce(),{faces:Le,buffers:Ne,width:pe,height:me,hasAlpha:Se,dfdFlags:Me,format:we,type:Re}}const Z=[{if:"astcSupported",basisFormat:[q.UASTC],transcoderFormat:[G.ASTC_4x4,G.ASTC_4x4],engineFormat:[O.RGBA_ASTC_4x4_Format,O.RGBA_ASTC_4x4_Format],engineType:[U.UnsignedByteType],priorityETC1S:1/0,priorityUASTC:1,needsPowerOfTwo:!1},{if:"bptcSupported",basisFormat:[q.ETC1S,q.UASTC],transcoderFormat:[G.BC7_M5,G.BC7_M5],engineFormat:[O.RGBA_BPTC_Format,O.RGBA_BPTC_Format],engineType:[U.UnsignedByteType],priorityETC1S:3,priorityUASTC:2,needsPowerOfTwo:!1},{if:"dxtSupported",basisFormat:[q.ETC1S,q.UASTC],transcoderFormat:[G.BC1,G.BC3],engineFormat:[O.RGBA_S3TC_DXT1_Format,O.RGBA_S3TC_DXT5_Format],engineType:[U.UnsignedByteType],priorityETC1S:4,priorityUASTC:5,needsPowerOfTwo:!1},{if:"etc2Supported",basisFormat:[q.ETC1S,q.UASTC],transcoderFormat:[G.ETC1,G.ETC2],engineFormat:[O.RGB_ETC2_Format,O.RGBA_ETC2_EAC_Format],engineType:[U.UnsignedByteType],priorityETC1S:1,priorityUASTC:3,needsPowerOfTwo:!1},{if:"etc1Supported",basisFormat:[q.ETC1S,q.UASTC],transcoderFormat:[G.ETC1],engineFormat:[O.RGB_ETC1_Format],engineType:[U.UnsignedByteType],priorityETC1S:2,priorityUASTC:4,needsPowerOfTwo:!1},{if:"pvrtcSupported",basisFormat:[q.ETC1S,q.UASTC],transcoderFormat:[G.PVRTC1_4_RGB,G.PVRTC1_4_RGBA],engineFormat:[O.RGB_PVRTC_4BPPV1_Format,O.RGBA_PVRTC_4BPPV1_Format],engineType:[U.UnsignedByteType],priorityETC1S:5,priorityUASTC:6,needsPowerOfTwo:!0},{if:"bptcSupported",basisFormat:[q.UASTC_HDR],transcoderFormat:[G.BC6H],engineFormat:[O.RGB_BPTC_UNSIGNED_Format],engineType:[U.HalfFloatType],priorityHDR:1,needsPowerOfTwo:!1},{basisFormat:[q.ETC1S,q.UASTC],transcoderFormat:[G.RGBA32,G.RGBA32],engineFormat:[O.RGBAFormat,O.RGBAFormat],engineType:[U.UnsignedByteType,U.UnsignedByteType],priorityETC1S:100,priorityUASTC:100,needsPowerOfTwo:!1},{basisFormat:[q.UASTC_HDR],transcoderFormat:[G.RGBA_HALF],engineFormat:[O.RGBAFormat],engineType:[U.HalfFloatType],priorityHDR:100,needsPowerOfTwo:!1}],ie={[q.ETC1S]:Z.filter(se=>se.basisFormat.includes(q.ETC1S)).sort((se,le)=>se.priorityETC1S-le.priorityETC1S),[q.UASTC]:Z.filter(se=>se.basisFormat.includes(q.UASTC)).sort((se,le)=>se.priorityUASTC-le.priorityUASTC),[q.UASTC_HDR]:Z.filter(se=>se.basisFormat.includes(q.UASTC_HDR)).sort((se,le)=>se.priorityHDR-le.priorityHDR)};function Y(se,le,ce,he){const pe=ie[se];for(let me=0;me<pe.length;me++){const be=pe[me];if(be.if&&!F[be.if]||!be.basisFormat.includes(se)||he&&be.transcoderFormat.length<2||be.needsPowerOfTwo&&!(W(le)&&W(ce)))continue;const ge=be.transcoderFormat[he?1:0],ve=be.engineFormat[he?1:0],Se=be.engineType[0];return{transcoderFormat:ge,engineFormat:ve,engineType:Se}}throw new Error("THREE.KTX2Loader: Failed to identify transcoding target.")}function W(se){return se<=2?!0:(se&se-1)===0&&se!==0}function ne(se){if(se.length===1)return se[0];let le=0;for(let pe=0;pe<se.length;pe++){const me=se[pe];le+=me.byteLength}const ce=new Uint8Array(le);let he=0;for(let pe=0;pe<se.length;pe++){const me=se[pe];ce.set(me,he),he+=me.byteLength}return ce}};const UNCOMPRESSED_FORMATS=new Set([RGBAFormat,RGBFormat,RGFormat,RedFormat]),FORMAT_MAP={[Ae]:RGBAFormat,[de]:RGFormat,[ye]:RedFormat,[ue]:RGBAFormat,[ae]:RGFormat,[te$1]:RedFormat,[Et]:RGBAFormat,[Ft]:RGBAFormat,[dt]:RGFormat,[xt]:RGFormat,[gt]:RedFormat,[ht]:RedFormat,[He]:RGBFormat,[We]:RGBFormat,[xn]:RGBA_ETC2_EAC_Format,[pn]:RGB_ETC2_Format,[_i]:RGBA_ASTC_4x4_Format,[wn]:RGBA_ASTC_4x4_Format,[Dn]:RGBA_ASTC_4x4_Format,[yi]:RGBA_ASTC_6x6_Format,[Cn]:RGBA_ASTC_6x6_Format,[Vn]:RGBA_ASTC_6x6_Format,[Ze]:RGBA_S3TC_DXT1_Format,[Qe]:RGBA_S3TC_DXT1_Format,[Je]:RGB_S3TC_DXT1_Format,[qe]:RGB_S3TC_DXT1_Format,[nn]:RGBA_S3TC_DXT3_Format,[en]:RGBA_S3TC_DXT3_Format,[an]:SIGNED_RED_RGTC1_Format,[sn]:RED_RGTC1_Format,[on]:SIGNED_RED_GREEN_RGTC2_Format,[rn]:RED_GREEN_RGTC2_Format,[Un]:RGBA_BPTC_Format,[cn]:RGBA_BPTC_Format,[Ui]:RGBA_PVRTC_4BPPV1_Format,[oi]:RGBA_PVRTC_4BPPV1_Format,[ci]:RGBA_PVRTC_2BPPV1_Format,[ri]:RGBA_PVRTC_2BPPV1_Format},TYPE_MAP={[Ae]:FloatType,[de]:FloatType,[ye]:FloatType,[ue]:HalfFloatType,[ae]:HalfFloatType,[te$1]:HalfFloatType,[Et]:UnsignedByteType,[Ft]:UnsignedByteType,[dt]:UnsignedByteType,[xt]:UnsignedByteType,[gt]:UnsignedByteType,[ht]:UnsignedByteType,[He]:UnsignedInt5999Type,[We]:UnsignedInt101111Type,[xn]:UnsignedByteType,[pn]:UnsignedByteType,[_i]:HalfFloatType,[wn]:UnsignedByteType,[Dn]:UnsignedByteType,[yi]:HalfFloatType,[Cn]:UnsignedByteType,[Vn]:UnsignedByteType,[Ze]:UnsignedByteType,[Qe]:UnsignedByteType,[Je]:UnsignedByteType,[qe]:UnsignedByteType,[nn]:UnsignedByteType,[en]:UnsignedByteType,[an]:UnsignedByteType,[sn]:UnsignedByteType,[on]:UnsignedByteType,[rn]:UnsignedByteType,[Un]:UnsignedByteType,[cn]:UnsignedByteType,[Ui]:UnsignedByteType,[oi]:UnsignedByteType,[ci]:UnsignedByteType,[ri]:UnsignedByteType};async function createRawTexture(F){const{vkFormat:w}=F;if(FORMAT_MAP[w]===void 0)throw new Error("THREE.KTX2Loader: Unsupported vkFormat: "+w);TYPE_MAP[w]===void 0&&console.warn('THREE.KTX2Loader: Missing ".type" for vkFormat: '+w);let D;F.supercompressionScheme===n&&(_zstd||(_zstd=new Promise(async q=>{const K=new Q;await K.init(),q(K)})),D=await _zstd);const O=[];for(let q=0;q<F.levels.length;q++){const K=Math.max(1,F.pixelWidth>>q),ee=Math.max(1,F.pixelHeight>>q),Z=F.pixelDepth?Math.max(1,F.pixelDepth>>q):0,ie=F.levels[q];let Y;if(F.supercompressionScheme===t)Y=ie.levelData;else if(F.supercompressionScheme===n)Y=D.decode(ie.levelData,ie.uncompressedByteLength);else throw new Error("THREE.KTX2Loader: Unsupported supercompressionScheme.");let W;TYPE_MAP[w]===FloatType?W=new Float32Array(Y.buffer,Y.byteOffset,Y.byteLength/Float32Array.BYTES_PER_ELEMENT):TYPE_MAP[w]===HalfFloatType?W=new Uint16Array(Y.buffer,Y.byteOffset,Y.byteLength/Uint16Array.BYTES_PER_ELEMENT):TYPE_MAP[w]===UnsignedInt5999Type||TYPE_MAP[w]===UnsignedInt101111Type?W=new Uint32Array(Y.buffer,Y.byteOffset,Y.byteLength/Uint32Array.BYTES_PER_ELEMENT):W=Y,O.push({data:W,width:K,height:ee,depth:Z})}const U=F.levelCount===0||O.length>1;let G;if(UNCOMPRESSED_FORMATS.has(FORMAT_MAP[w]))G=F.pixelDepth===0?new DataTexture(O[0].data,F.pixelWidth,F.pixelHeight):new Data3DTexture(O[0].data,F.pixelWidth,F.pixelHeight,F.pixelDepth),G.minFilter=U?NearestMipmapNearestFilter:NearestFilter,G.magFilter=NearestFilter,G.generateMipmaps=F.levelCount===0;else{if(F.pixelDepth>0)throw new Error("THREE.KTX2Loader: Unsupported pixelDepth.");G=new CompressedTexture(O,F.pixelWidth,F.pixelHeight),G.minFilter=U?LinearMipmapLinearFilter:LinearFilter,G.magFilter=LinearFilter}return G.mipmaps=O,G.type=TYPE_MAP[w],G.format=FORMAT_MAP[w],G.colorSpace=parseColorSpace(F),G.needsUpdate=!0,Promise.resolve(G)}function parseColorSpace(F){const w=F.dataFormatDescriptor[0];return w.colorPrimaries===E?w.transferFunction===y?SRGBColorSpace:LinearSRGBColorSpace:w.colorPrimaries===X$1?w.transferFunction===y?DisplayP3ColorSpace:LinearDisplayP3ColorSpace:(w.colorPrimaries===S||console.warn(`THREE.KTX2Loader: Unsupported color primaries, "${w.colorPrimaries}"`),NoColorSpace)}/* @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */var _a$9,_b$9;const $retainerCount=Symbol("retainerCount"),$recentlyUsed=Symbol("recentlyUsed"),$evict=Symbol("evict"),$evictionThreshold=Symbol("evictionThreshold"),$cache=Symbol("cache");class CacheEvictionPolicy{constructor(w,D=5){this[_a$9]=new Map,this[_b$9]=[],this[$cache]=w,this[$evictionThreshold]=D}set evictionThreshold(w){this[$evictionThreshold]=w,this[$evict]()}get evictionThreshold(){return this[$evictionThreshold]}get cache(){return this[$cache]}retainerCount(w){return this[$retainerCount].get(w)||0}reset(){this[$retainerCount].clear(),this[$recentlyUsed]=[]}retain(w){this[$retainerCount].has(w)||this[$retainerCount].set(w,0),this[$retainerCount].set(w,this[$retainerCount].get(w)+1);const D=this[$recentlyUsed].indexOf(w);D!==-1&&this[$recentlyUsed].splice(D,1),this[$recentlyUsed].unshift(w),this[$evict]()}release(w){this[$retainerCount].has(w)&&this[$retainerCount].set(w,Math.max(this[$retainerCount].get(w)-1,0)),this[$evict]()}[(_a$9=$retainerCount,_b$9=$recentlyUsed,$evict)](){if(!(this[$recentlyUsed].length<this[$evictionThreshold]))for(let w=this[$recentlyUsed].length-1;w>=this[$evictionThreshold];--w){const D=this[$recentlyUsed][w];this[$retainerCount].get(D)===0&&(this[$cache].delete(D),this[$recentlyUsed].splice(w,1))}}}/* @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */const ensureUniqueNames=F=>{const w=[],D=new Set;for(const O of F){let U=O,G=0;for(;D.has(U);)U=O+"."+ ++G;D.add(U),w.push(U)}return w},mappingsArrayToTable=F=>{const w=new Map;for(const D of F.mappings)for(const O of D.variants)w.set(O,{material:null,gltfMaterialIndex:D.material});return w};class GLTFMaterialsVariantsExtension{constructor(w){this.parser=w,this.name="KHR_materials_variants"}afterRoot(w){const D=this.parser,O=D.json;if(O.extensions===void 0||O.extensions[this.name]===void 0)return null;const G=O.extensions[this.name].variants||[],q=ensureUniqueNames(G.map(K=>K.name));for(const K of w.scenes)K.traverse(ee=>{const Z=ee;if(!Z.material)return;const ie=D.associations.get(Z);if(ie==null||ie.meshes==null||ie.primitives==null)return;const se=O.meshes[ie.meshes].primitives[ie.primitives].extensions;!se||!se[this.name]||(Z.userData.variantMaterials=mappingsArrayToTable(se[this.name]))});return w.userData.variants=q,Promise.resolve()}}/* @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */var _a$8,_b$8;Texture$1.DEFAULT_ANISOTROPY=4;const loadWithLoader=(F,w,D=()=>{})=>{const O=U=>{const G=U.loaded/U.total;D(Math.max(0,Math.min(1,isFinite(G)?G:1)))};return new Promise((U,G)=>{w.load(F,U,O,G)})},fetchScript=F=>new Promise((w,D)=>{const O=document.createElement("script");document.body.appendChild(O),O.onload=w,O.onerror=D,O.async=!0,O.src=F}),cache=new Map,preloaded=new Map;let dracoDecoderLocation;const dracoLoader=new DRACOLoader;let ktx2TranscoderLocation;const ktx2Loader=new KTX2Loader;let meshoptDecoderLocation,meshoptDecoder;const $loader=Symbol("loader"),$evictionPolicy=Symbol("evictionPolicy"),$GLTFInstance=Symbol("GLTFInstance");class CachingGLTFLoader extends EventDispatcher{static setDRACODecoderLocation(w){dracoDecoderLocation=w,dracoLoader.setDecoderPath(w)}static getDRACODecoderLocation(){return dracoDecoderLocation}static setKTX2TranscoderLocation(w){ktx2TranscoderLocation=w,ktx2Loader.setTranscoderPath(w)}static getKTX2TranscoderLocation(){return ktx2TranscoderLocation}static setMeshoptDecoderLocation(w){meshoptDecoderLocation!==w&&(meshoptDecoderLocation=w,meshoptDecoder=fetchScript(w).then(()=>MeshoptDecoder.ready).then(()=>MeshoptDecoder))}static getMeshoptDecoderLocation(){return meshoptDecoderLocation}static initializeKTX2Loader(w){ktx2Loader.detectSupport(w)}static get cache(){return cache}static clearCache(){cache.forEach((w,D)=>{this.delete(D)}),this[$evictionPolicy].reset()}static has(w){return cache.has(w)}static async delete(w){if(!this.has(w))return;const D=cache.get(w);preloaded.delete(w),cache.delete(w),(await D).dispose()}static hasFinishedLoading(w){return!!preloaded.get(w)}constructor(w){super(),this[_b$8]=new GLTFLoader().register(D=>new GLTFMaterialsVariantsExtension(D)),this[$GLTFInstance]=w,this[$loader].setDRACOLoader(dracoLoader),this[$loader].setKTX2Loader(ktx2Loader)}get[(_a$8=$evictionPolicy,_b$8=$loader,$evictionPolicy)](){return this.constructor[$evictionPolicy]}async preload(w,D,O=()=>{}){if(this[$loader].setWithCredentials(D.withCredentials),this.dispatchEvent({type:"preload",element:D,src:w}),!cache.has(w)){meshoptDecoder!=null&&this[$loader].setMeshoptDecoder(await meshoptDecoder);const U=loadWithLoader(w,this[$loader],K=>{O(K*.8)}),G=this[$GLTFInstance],q=U.then(K=>G.prepare(K)).then(K=>(O(.9),new G(K))).catch((K=>(console.error(K),new G)));cache.set(w,q)}await cache.get(w),preloaded.set(w,!0),O&&O(1)}async load(w,D,O=()=>{}){await this.preload(w,D,O);const G=await(await cache.get(w)).clone();return this[$evictionPolicy].retain(w),G.dispose=()=>{this[$evictionPolicy].release(w)},G}}CachingGLTFLoader[_a$8]=new CacheEvictionPolicy(CachingGLTFLoader);class CSS2DObject extends Object3D{constructor(w=document.createElement("div")){super(),this.isCSS2DObject=!0,this.element=w,this.element.style.position="absolute",this.element.style.userSelect="none",this.element.setAttribute("draggable",!1),this.center=new Vector2(.5,.5),this.addEventListener("removed",function(){this.traverse(function(D){D.element&&D.element instanceof D.element.ownerDocument.defaultView.Element&&D.element.parentNode!==null&&D.element.remove()})})}copy(w,D){return super.copy(w,D),this.element=w.element.cloneNode(!0),this.center=w.center,this}}const _vector=new Vector3,_viewMatrix=new Matrix4,_viewProjectionMatrix=new Matrix4,_a$7=new Vector3,_b$7=new Vector3;class CSS2DRenderer{constructor(w={}){const D=this;let O,U,G,q;const K={objects:new WeakMap},ee=w.element!==void 0?w.element:document.createElement("div");ee.style.overflow="hidden",this.domElement=ee,this.sortObjects=!0,this.getSize=function(){return{width:O,height:U}},this.render=function(se,le){se.matrixWorldAutoUpdate===!0&&se.updateMatrixWorld(),le.parent===null&&le.matrixWorldAutoUpdate===!0&&le.updateMatrixWorld(),_viewMatrix.copy(le.matrixWorldInverse),_viewProjectionMatrix.multiplyMatrices(le.projectionMatrix,_viewMatrix),ie(se,se,le),this.sortObjects&&ne(se)},this.setSize=function(se,le){O=se,U=le,G=O/2,q=U/2,ee.style.width=se+"px",ee.style.height=le+"px"};function Z(se){se.isCSS2DObject&&(se.element.style.display="none");for(let le=0,ce=se.children.length;le<ce;le++)Z(se.children[le])}function ie(se,le,ce){if(se.visible===!1){Z(se);return}if(se.isCSS2DObject){_vector.setFromMatrixPosition(se.matrixWorld),_vector.applyMatrix4(_viewProjectionMatrix);const he=_vector.z>=-1&&_vector.z<=1&&se.layers.test(ce.layers)===!0,pe=se.element;pe.style.display=he===!0?"":"none",he===!0&&(se.onBeforeRender(D,le,ce),pe.style.transform="translate("+-100*se.center.x+"%,"+-100*se.center.y+"%)translate("+(_vector.x*G+G)+"px,"+(-_vector.y*q+q)+"px)",pe.parentNode!==ee&&ee.appendChild(pe),se.onAfterRender(D,le,ce));const me={distanceToCameraSquared:Y(ce,se)};K.objects.set(se,me)}for(let he=0,pe=se.children.length;he<pe;he++)ie(se.children[he],le,ce)}function Y(se,le){return _a$7.setFromMatrixPosition(se.matrixWorld),_b$7.setFromMatrixPosition(le.matrixWorld),_a$7.distanceToSquared(_b$7)}function W(se){const le=[];return se.traverseVisible(function(ce){ce.isCSS2DObject&&le.push(ce)}),le}function ne(se){const le=W(se).sort(function(he,pe){if(he.renderOrder!==pe.renderOrder)return pe.renderOrder-he.renderOrder;const me=K.objects.get(he).distanceToCameraSquared,be=K.objects.get(pe).distanceToCameraSquared;return me-be}),ce=le.length;for(let he=0,pe=le.length;he<pe;he++)le[he].element.style.zIndex=ce-he}}}function reduceVertices(F,w,D){let O=D;const U=new Vector3;return F.updateWorldMatrix(!0,!0),F.traverseVisible(G=>{const{geometry:q}=G;if(q!==void 0){const{position:K}=q.attributes;if(K!==void 0)for(let ee=0,Z=K.count;ee<Z;ee++)G.isMesh?G.getVertexPosition(ee,U):U.fromBufferAttribute(K,ee),G.isSkinnedMesh||U.applyMatrix4(G.matrixWorld),O=w(O,U)}}),O}const KHR_mesh_quantization_ExtraAttrTypes={POSITION:["byte","byte normalized","unsigned byte","unsigned byte normalized","short","short normalized","unsigned short","unsigned short normalized"],NORMAL:["byte normalized","short normalized"],TANGENT:["byte normalized","short normalized"],TEXCOORD:["byte","byte normalized","unsigned byte","short","short normalized","unsigned short"]};class GLTFExporter{constructor(){this.textureUtils=null,this.pluginCallbacks=[],this.register(function(w){return new GLTFLightExtension(w)}),this.register(function(w){return new GLTFMaterialsUnlitExtension(w)}),this.register(function(w){return new GLTFMaterialsTransmissionExtension(w)}),this.register(function(w){return new GLTFMaterialsVolumeExtension(w)}),this.register(function(w){return new GLTFMaterialsIorExtension(w)}),this.register(function(w){return new GLTFMaterialsSpecularExtension(w)}),this.register(function(w){return new GLTFMaterialsClearcoatExtension(w)}),this.register(function(w){return new GLTFMaterialsDispersionExtension(w)}),this.register(function(w){return new GLTFMaterialsIridescenceExtension(w)}),this.register(function(w){return new GLTFMaterialsSheenExtension(w)}),this.register(function(w){return new GLTFMaterialsAnisotropyExtension(w)}),this.register(function(w){return new GLTFMaterialsEmissiveStrengthExtension(w)}),this.register(function(w){return new GLTFMaterialsBumpExtension(w)}),this.register(function(w){return new GLTFMeshGpuInstancing(w)})}register(w){return this.pluginCallbacks.indexOf(w)===-1&&this.pluginCallbacks.push(w),this}unregister(w){return this.pluginCallbacks.indexOf(w)!==-1&&this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(w),1),this}setTextureUtils(w){return this.textureUtils=w,this}parse(w,D,O,U){const G=new GLTFWriter,q=[];for(let K=0,ee=this.pluginCallbacks.length;K<ee;K++)q.push(this.pluginCallbacks[K](G));G.setPlugins(q),G.setTextureUtils(this.textureUtils),G.writeAsync(w,D,U).catch(O)}parseAsync(w,D){const O=this;return new Promise(function(U,G){O.parse(w,U,G,D)})}}const WEBGL_CONSTANTS={POINTS:0,LINES:1,LINE_LOOP:2,LINE_STRIP:3,TRIANGLES:4,BYTE:5120,UNSIGNED_BYTE:5121,SHORT:5122,UNSIGNED_SHORT:5123,INT:5124,UNSIGNED_INT:5125,FLOAT:5126,ARRAY_BUFFER:34962,ELEMENT_ARRAY_BUFFER:34963,NEAREST:9728,LINEAR:9729,NEAREST_MIPMAP_NEAREST:9984,LINEAR_MIPMAP_NEAREST:9985,NEAREST_MIPMAP_LINEAR:9986,LINEAR_MIPMAP_LINEAR:9987,CLAMP_TO_EDGE:33071,MIRRORED_REPEAT:33648,REPEAT:10497},KHR_MESH_QUANTIZATION="KHR_mesh_quantization",THREE_TO_WEBGL={};THREE_TO_WEBGL[NearestFilter]=WEBGL_CONSTANTS.NEAREST;THREE_TO_WEBGL[NearestMipmapNearestFilter]=WEBGL_CONSTANTS.NEAREST_MIPMAP_NEAREST;THREE_TO_WEBGL[NearestMipmapLinearFilter]=WEBGL_CONSTANTS.NEAREST_MIPMAP_LINEAR;THREE_TO_WEBGL[LinearFilter]=WEBGL_CONSTANTS.LINEAR;THREE_TO_WEBGL[LinearMipmapNearestFilter]=WEBGL_CONSTANTS.LINEAR_MIPMAP_NEAREST;THREE_TO_WEBGL[LinearMipmapLinearFilter]=WEBGL_CONSTANTS.LINEAR_MIPMAP_LINEAR;THREE_TO_WEBGL[ClampToEdgeWrapping]=WEBGL_CONSTANTS.CLAMP_TO_EDGE;THREE_TO_WEBGL[RepeatWrapping]=WEBGL_CONSTANTS.REPEAT;THREE_TO_WEBGL[MirroredRepeatWrapping]=WEBGL_CONSTANTS.MIRRORED_REPEAT;const PATH_PROPERTIES={scale:"scale",position:"translation",quaternion:"rotation",morphTargetInfluences:"weights"},DEFAULT_SPECULAR_COLOR=new Color,GLB_HEADER_BYTES=12,GLB_HEADER_MAGIC=1179937895,GLB_VERSION=2,GLB_CHUNK_PREFIX_BYTES=8,GLB_CHUNK_TYPE_JSON=1313821514,GLB_CHUNK_TYPE_BIN=5130562;function equalArray(F,w){return F.length===w.length&&F.every(function(D,O){return D===w[O]})}function stringToArrayBuffer(F){return new TextEncoder().encode(F).buffer}function isIdentityMatrix(F){return equalArray(F.elements,[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1])}function getMinMax(F,w,D){const O={min:new Array(F.itemSize).fill(Number.POSITIVE_INFINITY),max:new Array(F.itemSize).fill(Number.NEGATIVE_INFINITY)};for(let U=w;U<w+D;U++)for(let G=0;G<F.itemSize;G++){let q;F.itemSize>4?q=F.array[U*F.itemSize+G]:(G===0?q=F.getX(U):G===1?q=F.getY(U):G===2?q=F.getZ(U):G===3&&(q=F.getW(U)),F.normalized===!0&&(q=MathUtils.normalize(q,F.array))),O.min[G]=Math.min(O.min[G],q),O.max[G]=Math.max(O.max[G],q)}return O}function getPaddedBufferSize(F){return Math.ceil(F/4)*4}function getPaddedArrayBuffer(F,w=0){const D=getPaddedBufferSize(F.byteLength);if(D!==F.byteLength){const O=new Uint8Array(D);if(O.set(new Uint8Array(F)),w!==0)for(let U=F.byteLength;U<D;U++)O[U]=w;return O.buffer}return F}function getCanvas(){return typeof document>"u"&&typeof OffscreenCanvas<"u"?new OffscreenCanvas(1,1):document.createElement("canvas")}function getToBlobPromise(F,w){if(typeof OffscreenCanvas<"u"&&F instanceof OffscreenCanvas){let D;return w==="image/jpeg"?D=.92:w==="image/webp"&&(D=.8),F.convertToBlob({type:w,quality:D})}else return new Promise(D=>F.toBlob(D,w))}class GLTFWriter{constructor(){this.plugins=[],this.options={},this.pending=[],this.buffers=[],this.byteOffset=0,this.buffers=[],this.nodeMap=new Map,this.skins=[],this.extensionsUsed={},this.extensionsRequired={},this.uids=new Map,this.uid=0,this.json={asset:{version:"2.0",generator:"THREE.GLTFExporter r"+REVISION}},this.cache={meshes:new Map,attributes:new Map,attributesNormalized:new Map,materials:new Map,textures:new Map,images:new Map},this.textureUtils=null}setPlugins(w){this.plugins=w}setTextureUtils(w){this.textureUtils=w}async writeAsync(w,D,O={}){this.options=Object.assign({binary:!1,trs:!1,onlyVisible:!0,maxTextureSize:1/0,animations:[],includeCustomExtensions:!1},O),this.options.animations.length>0&&(this.options.trs=!0),await this.processInputAsync(w),await Promise.all(this.pending);const U=this,G=U.buffers,q=U.json;O=U.options;const K=U.extensionsUsed,ee=U.extensionsRequired,Z=new Blob(G,{type:"application/octet-stream"}),ie=Object.keys(K),Y=Object.keys(ee);if(ie.length>0&&(q.extensionsUsed=ie),Y.length>0&&(q.extensionsRequired=Y),q.buffers&&q.buffers.length>0&&(q.buffers[0].byteLength=Z.size),O.binary===!0){const W=new FileReader;W.readAsArrayBuffer(Z),W.onloadend=function(){const ne=getPaddedArrayBuffer(W.result),se=new DataView(new ArrayBuffer(GLB_CHUNK_PREFIX_BYTES));se.setUint32(0,ne.byteLength,!0),se.setUint32(4,GLB_CHUNK_TYPE_BIN,!0);const le=getPaddedArrayBuffer(stringToArrayBuffer(JSON.stringify(q)),32),ce=new DataView(new ArrayBuffer(GLB_CHUNK_PREFIX_BYTES));ce.setUint32(0,le.byteLength,!0),ce.setUint32(4,GLB_CHUNK_TYPE_JSON,!0);const he=new ArrayBuffer(GLB_HEADER_BYTES),pe=new DataView(he);pe.setUint32(0,GLB_HEADER_MAGIC,!0),pe.setUint32(4,GLB_VERSION,!0);const me=GLB_HEADER_BYTES+ce.byteLength+le.byteLength+se.byteLength+ne.byteLength;pe.setUint32(8,me,!0);const be=new Blob([he,ce,le,se,ne],{type:"application/octet-stream"}),ge=new FileReader;ge.readAsArrayBuffer(be),ge.onloadend=function(){D(ge.result)}}}else if(q.buffers&&q.buffers.length>0){const W=new FileReader;W.readAsDataURL(Z),W.onloadend=function(){const ne=W.result;q.buffers[0].uri=ne,D(q)}}else D(q)}serializeUserData(w,D){if(Object.keys(w.userData).length===0)return;const O=this.options,U=this.extensionsUsed;try{const G=JSON.parse(JSON.stringify(w.userData));if(O.includeCustomExtensions&&G.gltfExtensions){D.extensions===void 0&&(D.extensions={});for(const q in G.gltfExtensions)D.extensions[q]=G.gltfExtensions[q],U[q]=!0;delete G.gltfExtensions}Object.keys(G).length>0&&(D.extras=G)}catch(G){console.warn("THREE.GLTFExporter: userData of '"+w.name+"' won't be serialized because of JSON.stringify error - "+G.message)}}getUID(w,D=!1){if(this.uids.has(w)===!1){const U=new Map;U.set(!0,this.uid++),U.set(!1,this.uid++),this.uids.set(w,U)}return this.uids.get(w).get(D)}isNormalizedNormalAttribute(w){if(this.cache.attributesNormalized.has(w))return!1;const O=new Vector3;for(let U=0,G=w.count;U<G;U++)if(Math.abs(O.fromBufferAttribute(w,U).length()-1)>5e-4)return!1;return!0}createNormalizedNormalAttribute(w){const D=this.cache;if(D.attributesNormalized.has(w))return D.attributesNormalized.get(w);const O=w.clone(),U=new Vector3;for(let G=0,q=O.count;G<q;G++)U.fromBufferAttribute(O,G),U.x===0&&U.y===0&&U.z===0?U.setX(1):U.normalize(),O.setXYZ(G,U.x,U.y,U.z);return D.attributesNormalized.set(w,O),O}applyTextureTransform(w,D){let O=!1;const U={};(D.offset.x!==0||D.offset.y!==0)&&(U.offset=D.offset.toArray(),O=!0),D.rotation!==0&&(U.rotation=D.rotation,O=!0),(D.repeat.x!==1||D.repeat.y!==1)&&(U.scale=D.repeat.toArray(),O=!0),O&&(w.extensions=w.extensions||{},w.extensions.KHR_texture_transform=U,this.extensionsUsed.KHR_texture_transform=!0)}async buildMetalRoughTextureAsync(w,D){if(w===D)return w;function O(ne){return ne.colorSpace===SRGBColorSpace?function(le){return le<.04045?le*.0773993808:Math.pow(le*.9478672986+.0521327014,2.4)}:function(le){return le}}w instanceof CompressedTexture&&(w=await this.decompressTextureAsync(w)),D instanceof CompressedTexture&&(D=await this.decompressTextureAsync(D));const U=w?w.image:null,G=D?D.image:null,q=Math.max(U?U.width:0,G?G.width:0),K=Math.max(U?U.height:0,G?G.height:0),ee=getCanvas();ee.width=q,ee.height=K;const Z=ee.getContext("2d",{willReadFrequently:!0});Z.fillStyle="#00ffff",Z.fillRect(0,0,q,K);const ie=Z.getImageData(0,0,q,K);if(U){Z.drawImage(U,0,0,q,K);const ne=O(w),se=Z.getImageData(0,0,q,K).data;for(let le=2;le<se.length;le+=4)ie.data[le]=ne(se[le]/256)*256}if(G){Z.drawImage(G,0,0,q,K);const ne=O(D),se=Z.getImageData(0,0,q,K).data;for(let le=1;le<se.length;le+=4)ie.data[le]=ne(se[le]/256)*256}Z.putImageData(ie,0,0);const W=(w||D).clone();return W.source=new Source(ee),W.colorSpace=NoColorSpace,W.channel=(w||D).channel,w&&D&&w.channel!==D.channel&&console.warn("THREE.GLTFExporter: UV channels for metalnessMap and roughnessMap textures must match."),console.warn("THREE.GLTFExporter: Merged metalnessMap and roughnessMap textures."),W}async decompressTextureAsync(w,D=1/0){if(this.textureUtils===null)throw new Error("THREE.GLTFExporter: setTextureUtils() must be called to process compressed textures.");return await this.textureUtils.decompress(w,D)}processBuffer(w){const D=this.json,O=this.buffers;return D.buffers||(D.buffers=[{byteLength:0}]),O.push(w),0}processBufferView(w,D,O,U,G){const q=this.json;q.bufferViews||(q.bufferViews=[]);let K;switch(D){case WEBGL_CONSTANTS.BYTE:case WEBGL_CONSTANTS.UNSIGNED_BYTE:K=1;break;case WEBGL_CONSTANTS.SHORT:case WEBGL_CONSTANTS.UNSIGNED_SHORT:K=2;break;default:K=4}let ee=w.itemSize*K;G===WEBGL_CONSTANTS.ARRAY_BUFFER&&(ee=Math.ceil(ee/4)*4);const Z=getPaddedBufferSize(U*ee),ie=new DataView(new ArrayBuffer(Z));let Y=0;for(let se=O;se<O+U;se++){for(let le=0;le<w.itemSize;le++){let ce;w.itemSize>4?ce=w.array[se*w.itemSize+le]:(le===0?ce=w.getX(se):le===1?ce=w.getY(se):le===2?ce=w.getZ(se):le===3&&(ce=w.getW(se)),w.normalized===!0&&(ce=MathUtils.normalize(ce,w.array))),D===WEBGL_CONSTANTS.FLOAT?ie.setFloat32(Y,ce,!0):D===WEBGL_CONSTANTS.INT?ie.setInt32(Y,ce,!0):D===WEBGL_CONSTANTS.UNSIGNED_INT?ie.setUint32(Y,ce,!0):D===WEBGL_CONSTANTS.SHORT?ie.setInt16(Y,ce,!0):D===WEBGL_CONSTANTS.UNSIGNED_SHORT?ie.setUint16(Y,ce,!0):D===WEBGL_CONSTANTS.BYTE?ie.setInt8(Y,ce):D===WEBGL_CONSTANTS.UNSIGNED_BYTE&&ie.setUint8(Y,ce),Y+=K}Y%ee!==0&&(Y+=ee-Y%ee)}const W={buffer:this.processBuffer(ie.buffer),byteOffset:this.byteOffset,byteLength:Z};return G!==void 0&&(W.target=G),G===WEBGL_CONSTANTS.ARRAY_BUFFER&&(W.byteStride=ee),this.byteOffset+=Z,q.bufferViews.push(W),{id:q.bufferViews.length-1,byteLength:0}}processBufferViewImage(w){const D=this,O=D.json;return O.bufferViews||(O.bufferViews=[]),new Promise(function(U){const G=new FileReader;G.readAsArrayBuffer(w),G.onloadend=function(){const q=getPaddedArrayBuffer(G.result),K={buffer:D.processBuffer(q),byteOffset:D.byteOffset,byteLength:q.byteLength};D.byteOffset+=q.byteLength,U(O.bufferViews.push(K)-1)}})}processAccessor(w,D,O,U){const G=this.json,q={1:"SCALAR",2:"VEC2",3:"VEC3",4:"VEC4",9:"MAT3",16:"MAT4"};let K;if(w.array.constructor===Float32Array)K=WEBGL_CONSTANTS.FLOAT;else if(w.array.constructor===Int32Array)K=WEBGL_CONSTANTS.INT;else if(w.array.constructor===Uint32Array)K=WEBGL_CONSTANTS.UNSIGNED_INT;else if(w.array.constructor===Int16Array)K=WEBGL_CONSTANTS.SHORT;else if(w.array.constructor===Uint16Array)K=WEBGL_CONSTANTS.UNSIGNED_SHORT;else if(w.array.constructor===Int8Array)K=WEBGL_CONSTANTS.BYTE;else if(w.array.constructor===Uint8Array)K=WEBGL_CONSTANTS.UNSIGNED_BYTE;else throw new Error("THREE.GLTFExporter: Unsupported bufferAttribute component type: "+w.array.constructor.name);if(O===void 0&&(O=0),(U===void 0||U===1/0)&&(U=w.count),U===0)return null;const ee=getMinMax(w,O,U);let Z;D!==void 0&&(Z=w===D.index?WEBGL_CONSTANTS.ELEMENT_ARRAY_BUFFER:WEBGL_CONSTANTS.ARRAY_BUFFER);const ie=this.processBufferView(w,K,O,U,Z),Y={bufferView:ie.id,byteOffset:ie.byteOffset,componentType:K,count:U,max:ee.max,min:ee.min,type:q[w.itemSize]};return w.normalized===!0&&(Y.normalized=!0),G.accessors||(G.accessors=[]),G.accessors.push(Y)-1}processImage(w,D,O,U="image/png"){if(w!==null){const G=this,q=G.cache,K=G.json,ee=G.options,Z=G.pending;q.images.has(w)||q.images.set(w,{});const ie=q.images.get(w),Y=U+":flipY/"+O.toString();if(ie[Y]!==void 0)return ie[Y];K.images||(K.images=[]);const W={mimeType:U},ne=getCanvas();ne.width=Math.min(w.width,ee.maxTextureSize),ne.height=Math.min(w.height,ee.maxTextureSize);const se=ne.getContext("2d",{willReadFrequently:!0});if(O===!0&&(se.translate(0,ne.height),se.scale(1,-1)),w.data!==void 0){D!==RGBAFormat&&console.error("GLTFExporter: Only RGBAFormat is supported.",D),(w.width>ee.maxTextureSize||w.height>ee.maxTextureSize)&&console.warn("GLTFExporter: Image size is bigger than maxTextureSize",w);const ce=new Uint8ClampedArray(w.height*w.width*4);for(let he=0;he<ce.length;he+=4)ce[he+0]=w.data[he+0],ce[he+1]=w.data[he+1],ce[he+2]=w.data[he+2],ce[he+3]=w.data[he+3];se.putImageData(new ImageData(ce,w.width,w.height),0,0)}else if(typeof HTMLImageElement<"u"&&w instanceof HTMLImageElement||typeof HTMLCanvasElement<"u"&&w instanceof HTMLCanvasElement||typeof ImageBitmap<"u"&&w instanceof ImageBitmap||typeof OffscreenCanvas<"u"&&w instanceof OffscreenCanvas)se.drawImage(w,0,0,ne.width,ne.height);else throw new Error("THREE.GLTFExporter: Invalid image type. Use HTMLImageElement, HTMLCanvasElement, ImageBitmap or OffscreenCanvas.");ee.binary===!0?Z.push(getToBlobPromise(ne,U).then(ce=>G.processBufferViewImage(ce)).then(ce=>{W.bufferView=ce})):W.uri=ImageUtils.getDataURL(ne,U);const le=K.images.push(W)-1;return ie[Y]=le,le}else throw new Error("THREE.GLTFExporter: No valid image data found. Unable to process texture.")}processSampler(w){const D=this.json;D.samplers||(D.samplers=[]);const O={magFilter:THREE_TO_WEBGL[w.magFilter],minFilter:THREE_TO_WEBGL[w.minFilter],wrapS:THREE_TO_WEBGL[w.wrapS],wrapT:THREE_TO_WEBGL[w.wrapT]};return D.samplers.push(O)-1}async processTextureAsync(w){const O=this.options,U=this.cache,G=this.json;if(U.textures.has(w))return U.textures.get(w);G.textures||(G.textures=[]),w instanceof CompressedTexture&&(w=await this.decompressTextureAsync(w,O.maxTextureSize));let q=w.userData.mimeType;q==="image/webp"&&(q="image/png");const K={sampler:this.processSampler(w),source:this.processImage(w.image,w.format,w.flipY,q)};w.name&&(K.name=w.name),await this._invokeAllAsync(async function(Z){Z.writeTexture&&await Z.writeTexture(w,K)});const ee=G.textures.push(K)-1;return U.textures.set(w,ee),ee}async processMaterialAsync(w){const D=this.cache,O=this.json;if(D.materials.has(w))return D.materials.get(w);if(w.isShaderMaterial)return console.warn("GLTFExporter: THREE.ShaderMaterial not supported."),null;O.materials||(O.materials=[]);const U={pbrMetallicRoughness:{}};w.isMeshStandardMaterial!==!0&&w.isMeshBasicMaterial!==!0&&console.warn("GLTFExporter: Use MeshStandardMaterial or MeshBasicMaterial for best results.");const G=w.color.toArray().concat([w.opacity]);if(equalArray(G,[1,1,1,1])||(U.pbrMetallicRoughness.baseColorFactor=G),w.isMeshStandardMaterial?(U.pbrMetallicRoughness.metallicFactor=w.metalness,U.pbrMetallicRoughness.roughnessFactor=w.roughness):(U.pbrMetallicRoughness.metallicFactor=0,U.pbrMetallicRoughness.roughnessFactor=1),w.metalnessMap||w.roughnessMap){const K=await this.buildMetalRoughTextureAsync(w.metalnessMap,w.roughnessMap),ee={index:await this.processTextureAsync(K),texCoord:K.channel};this.applyTextureTransform(ee,K),U.pbrMetallicRoughness.metallicRoughnessTexture=ee}if(w.map){const K={index:await this.processTextureAsync(w.map),texCoord:w.map.channel};this.applyTextureTransform(K,w.map),U.pbrMetallicRoughness.baseColorTexture=K}if(w.emissive){const K=w.emissive;if(Math.max(K.r,K.g,K.b)>0&&(U.emissiveFactor=w.emissive.toArray()),w.emissiveMap){const Z={index:await this.processTextureAsync(w.emissiveMap),texCoord:w.emissiveMap.channel};this.applyTextureTransform(Z,w.emissiveMap),U.emissiveTexture=Z}}if(w.normalMap){const K={index:await this.processTextureAsync(w.normalMap),texCoord:w.normalMap.channel};w.normalScale&&w.normalScale.x!==1&&(K.scale=w.normalScale.x),this.applyTextureTransform(K,w.normalMap),U.normalTexture=K}if(w.aoMap){const K={index:await this.processTextureAsync(w.aoMap),texCoord:w.aoMap.channel};w.aoMapIntensity!==1&&(K.strength=w.aoMapIntensity),this.applyTextureTransform(K,w.aoMap),U.occlusionTexture=K}w.transparent?U.alphaMode="BLEND":w.alphaTest>0&&(U.alphaMode="MASK",U.alphaCutoff=w.alphaTest),w.side===DoubleSide&&(U.doubleSided=!0),w.name!==""&&(U.name=w.name),this.serializeUserData(w,U),await this._invokeAllAsync(async function(K){K.writeMaterialAsync&&await K.writeMaterialAsync(w,U)});const q=O.materials.push(U)-1;return D.materials.set(w,q),q}async processMeshAsync(w){const D=this.cache,O=this.json,U=[w.geometry.uuid];if(Array.isArray(w.material))for(let be=0,ge=w.material.length;be<ge;be++)U.push(w.material[be].uuid);else U.push(w.material.uuid);const G=U.join(":");if(D.meshes.has(G))return D.meshes.get(G);const q=w.geometry;let K;w.isLineSegments?K=WEBGL_CONSTANTS.LINES:w.isLineLoop?K=WEBGL_CONSTANTS.LINE_LOOP:w.isLine?K=WEBGL_CONSTANTS.LINE_STRIP:w.isPoints?K=WEBGL_CONSTANTS.POINTS:K=w.material.wireframe?WEBGL_CONSTANTS.LINES:WEBGL_CONSTANTS.TRIANGLES;const ee={},Z={},ie=[],Y=[],W={uv:"TEXCOORD_0",uv1:"TEXCOORD_1",uv2:"TEXCOORD_2",uv3:"TEXCOORD_3",color:"COLOR_0",skinWeight:"WEIGHTS_0",skinIndex:"JOINTS_0"},ne=q.getAttribute("normal");ne!==void 0&&!this.isNormalizedNormalAttribute(ne)&&(console.warn("THREE.GLTFExporter: Creating normalized normal attribute from the non-normalized one."),q.setAttribute("normal",this.createNormalizedNormalAttribute(ne)));let se=null;for(let be in q.attributes){if(be.slice(0,5)==="morph")continue;const ge=q.attributes[be];if(be=W[be]||be.toUpperCase(),/^(POSITION|NORMAL|TANGENT|TEXCOORD_\d+|COLOR_\d+|JOINTS_\d+|WEIGHTS_\d+)$/.test(be)||(be="_"+be),D.attributes.has(this.getUID(ge))){Z[be]=D.attributes.get(this.getUID(ge));continue}se=null;const Se=ge.array;be==="JOINTS_0"&&!(Se instanceof Uint16Array)&&!(Se instanceof Uint8Array)?(console.warn('GLTFExporter: Attribute "skinIndex" converted to type UNSIGNED_SHORT.'),se=new BufferAttribute(new Uint16Array(Se),ge.itemSize,ge.normalized)):(Se instanceof Uint32Array||Se instanceof Int32Array)&&!be.startsWith("_")&&(console.warn(`GLTFExporter: Attribute "${be}" converted to type FLOAT.`),se=GLTFExporter.Utils.toFloat32BufferAttribute(ge));const Me=this.processAccessor(se||ge,q);Me!==null&&(be.startsWith("_")||this.detectMeshQuantization(be,ge),Z[be]=Me,D.attributes.set(this.getUID(ge),Me))}if(ne!==void 0&&q.setAttribute("normal",ne),Object.keys(Z).length===0)return null;if(w.morphTargetInfluences!==void 0&&w.morphTargetInfluences.length>0){const be=[],ge=[],ve={};if(w.morphTargetDictionary!==void 0)for(const Se in w.morphTargetDictionary)ve[w.morphTargetDictionary[Se]]=Se;for(let Se=0;Se<w.morphTargetInfluences.length;++Se){const Me={};let Ee=!1;for(const we in q.morphAttributes){if(we!=="position"&&we!=="normal"){Ee||(console.warn("GLTFExporter: Only POSITION and NORMAL morph are supported."),Ee=!0);continue}const Re=q.morphAttributes[we][Se],Le=we.toUpperCase(),Ne=q.attributes[we];if(D.attributes.has(this.getUID(Re,!0))){Me[Le]=D.attributes.get(this.getUID(Re,!0));continue}const Oe=Re.clone();if(!q.morphTargetsRelative)for(let Pe=0,Ce=Re.count;Pe<Ce;Pe++)for(let Be=0;Be<Re.itemSize;Be++)Be===0&&Oe.setX(Pe,Re.getX(Pe)-Ne.getX(Pe)),Be===1&&Oe.setY(Pe,Re.getY(Pe)-Ne.getY(Pe)),Be===2&&Oe.setZ(Pe,Re.getZ(Pe)-Ne.getZ(Pe)),Be===3&&Oe.setW(Pe,Re.getW(Pe)-Ne.getW(Pe));Me[Le]=this.processAccessor(Oe,q),D.attributes.set(this.getUID(Ne,!0),Me[Le])}Y.push(Me),be.push(w.morphTargetInfluences[Se]),w.morphTargetDictionary!==void 0&&ge.push(ve[Se])}ee.weights=be,ge.length>0&&(ee.extras={},ee.extras.targetNames=ge)}const le=Array.isArray(w.material);if(le&&q.groups.length===0)return null;let ce=!1;if(le&&q.index===null){const be=[];for(let ge=0,ve=q.attributes.position.count;ge<ve;ge++)be[ge]=ge;q.setIndex(be),ce=!0}const he=le?w.material:[w.material],pe=le?q.groups:[{materialIndex:0,start:void 0,count:void 0}];for(let be=0,ge=pe.length;be<ge;be++){const ve={mode:K,attributes:Z};if(this.serializeUserData(q,ve),Y.length>0&&(ve.targets=Y),q.index!==null){let Me=this.getUID(q.index);(pe[be].start!==void 0||pe[be].count!==void 0)&&(Me+=":"+pe[be].start+":"+pe[be].count),D.attributes.has(Me)?ve.indices=D.attributes.get(Me):(ve.indices=this.processAccessor(q.index,q,pe[be].start,pe[be].count),D.attributes.set(Me,ve.indices)),ve.indices===null&&delete ve.indices}const Se=await this.processMaterialAsync(he[pe[be].materialIndex]);Se!==null&&(ve.material=Se),ie.push(ve)}ce===!0&&q.setIndex(null),ee.primitives=ie,O.meshes||(O.meshes=[]),await this._invokeAllAsync(function(be){be.writeMesh&&be.writeMesh(w,ee)});const me=O.meshes.push(ee)-1;return D.meshes.set(G,me),me}detectMeshQuantization(w,D){if(this.extensionsUsed[KHR_MESH_QUANTIZATION])return;let O;switch(D.array.constructor){case Int8Array:O="byte";break;case Uint8Array:O="unsigned byte";break;case Int16Array:O="short";break;case Uint16Array:O="unsigned short";break;default:return}D.normalized&&(O+=" normalized");const U=w.split("_",1)[0];KHR_mesh_quantization_ExtraAttrTypes[U]&&KHR_mesh_quantization_ExtraAttrTypes[U].includes(O)&&(this.extensionsUsed[KHR_MESH_QUANTIZATION]=!0,this.extensionsRequired[KHR_MESH_QUANTIZATION]=!0)}processCamera(w){const D=this.json;D.cameras||(D.cameras=[]);const O=w.isOrthographicCamera,U={type:O?"orthographic":"perspective"};return O?U.orthographic={xmag:w.right*2,ymag:w.top*2,zfar:w.far<=0?.001:w.far,znear:w.near<0?0:w.near}:U.perspective={aspectRatio:w.aspect,yfov:MathUtils.degToRad(w.fov),zfar:w.far<=0?.001:w.far,znear:w.near<0?0:w.near},w.name!==""&&(U.name=w.type),D.cameras.push(U)-1}processAnimation(w,D){const O=this.json,U=this.nodeMap;O.animations||(O.animations=[]),w=GLTFExporter.Utils.mergeMorphTargetTracks(w.clone(),D);const G=w.tracks,q=[],K=[];for(let Z=0;Z<G.length;++Z){const ie=G[Z],Y=PropertyBinding.parseTrackName(ie.name);let W=PropertyBinding.findNode(D,Y.nodeName);const ne=PATH_PROPERTIES[Y.propertyName];if(Y.objectName==="bones"&&(W.isSkinnedMesh===!0?W=W.skeleton.getBoneByName(Y.objectIndex):W=void 0),!W||!ne){console.warn('THREE.GLTFExporter: Could not export animation track "%s".',ie.name);continue}const se=1;let le=ie.values.length/ie.times.length;ne===PATH_PROPERTIES.morphTargetInfluences&&(le/=W.morphTargetInfluences.length);let ce;ie.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline===!0?(ce="CUBICSPLINE",le/=3):ie.getInterpolation()===InterpolateDiscrete?ce="STEP":ce="LINEAR",K.push({input:this.processAccessor(new BufferAttribute(ie.times,se)),output:this.processAccessor(new BufferAttribute(ie.values,le)),interpolation:ce}),q.push({sampler:K.length-1,target:{node:U.get(W),path:ne}})}const ee={name:w.name||"clip_"+O.animations.length,samplers:K,channels:q};return this.serializeUserData(w,ee),O.animations.push(ee),O.animations.length-1}processSkin(w){const D=this.json,O=this.nodeMap,U=D.nodes[O.get(w)],G=w.skeleton;if(G===void 0)return null;const q=w.skeleton.bones[0];if(q===void 0)return null;const K=[],ee=new Float32Array(G.bones.length*16),Z=new Matrix4;for(let Y=0;Y<G.bones.length;++Y)K.push(O.get(G.bones[Y])),Z.copy(G.boneInverses[Y]),Z.multiply(w.bindMatrix).toArray(ee,Y*16);return D.skins===void 0&&(D.skins=[]),D.skins.push({inverseBindMatrices:this.processAccessor(new BufferAttribute(ee,16)),joints:K,skeleton:O.get(q)}),U.skin=D.skins.length-1}async processNodeAsync(w){const D=this.json,O=this.options,U=this.nodeMap;D.nodes||(D.nodes=[]);const G={};if(O.trs){const K=w.quaternion.toArray(),ee=w.position.toArray(),Z=w.scale.toArray();equalArray(K,[0,0,0,1])||(G.rotation=K),equalArray(ee,[0,0,0])||(G.translation=ee),equalArray(Z,[1,1,1])||(G.scale=Z)}else w.matrixAutoUpdate&&w.updateMatrix(),isIdentityMatrix(w.matrix)===!1&&(G.matrix=w.matrix.elements);if(w.name!==""&&(G.name=String(w.name)),this.serializeUserData(w,G),w.isMesh||w.isLine||w.isPoints){const K=await this.processMeshAsync(w);K!==null&&(G.mesh=K)}else w.isCamera&&(G.camera=this.processCamera(w));w.isSkinnedMesh&&this.skins.push(w);const q=D.nodes.push(G)-1;if(U.set(w,q),w.children.length>0){const K=[];for(let ee=0,Z=w.children.length;ee<Z;ee++){const ie=w.children[ee];if(ie.visible||O.onlyVisible===!1){const Y=await this.processNodeAsync(ie);Y!==null&&K.push(Y)}}K.length>0&&(G.children=K)}return await this._invokeAllAsync(function(K){K.writeNode&&K.writeNode(w,G)}),q}async processSceneAsync(w){const D=this.json,O=this.options;D.scenes||(D.scenes=[],D.scene=0);const U={};w.name!==""&&(U.name=w.name),D.scenes.push(U);const G=[];for(let q=0,K=w.children.length;q<K;q++){const ee=w.children[q];if(ee.visible||O.onlyVisible===!1){const Z=await this.processNodeAsync(ee);Z!==null&&G.push(Z)}}G.length>0&&(U.nodes=G),this.serializeUserData(w,U)}async processObjectsAsync(w){const D=new Scene;D.name="AuxScene";for(let O=0;O<w.length;O++)D.children.push(w[O]);await this.processSceneAsync(D)}async processInputAsync(w){const D=this.options;w=w instanceof Array?w:[w],await this._invokeAllAsync(function(U){U.beforeParse&&U.beforeParse(w)});const O=[];for(let U=0;U<w.length;U++)w[U]instanceof Scene?await this.processSceneAsync(w[U]):O.push(w[U]);O.length>0&&await this.processObjectsAsync(O);for(let U=0;U<this.skins.length;++U)this.processSkin(this.skins[U]);for(let U=0;U<D.animations.length;++U)this.processAnimation(D.animations[U],w[0]);await this._invokeAllAsync(function(U){U.afterParse&&U.afterParse(w)})}async _invokeAllAsync(w){for(let D=0,O=this.plugins.length;D<O;D++)await w(this.plugins[D])}}class GLTFLightExtension{constructor(w){this.writer=w,this.name="KHR_lights_punctual"}writeNode(w,D){if(!w.isLight)return;if(!w.isDirectionalLight&&!w.isPointLight&&!w.isSpotLight){console.warn("THREE.GLTFExporter: Only directional, point, and spot lights are supported.",w);return}const O=this.writer,U=O.json,G=O.extensionsUsed,q={};w.name&&(q.name=w.name),q.color=w.color.toArray(),q.intensity=w.intensity,w.isDirectionalLight?q.type="directional":w.isPointLight?(q.type="point",w.distance>0&&(q.range=w.distance)):w.isSpotLight&&(q.type="spot",w.distance>0&&(q.range=w.distance),q.spot={},q.spot.innerConeAngle=(1-w.penumbra)*w.angle,q.spot.outerConeAngle=w.angle),w.decay!==void 0&&w.decay!==2&&console.warn("THREE.GLTFExporter: Light decay may be lost. glTF is physically-based, and expects light.decay=2."),w.target&&(w.target.parent!==w||w.target.position.x!==0||w.target.position.y!==0||w.target.position.z!==-1)&&console.warn("THREE.GLTFExporter: Light direction may be lost. For best results, make light.target a child of the light with position 0,0,-1."),G[this.name]||(U.extensions=U.extensions||{},U.extensions[this.name]={lights:[]},G[this.name]=!0);const K=U.extensions[this.name].lights;K.push(q),D.extensions=D.extensions||{},D.extensions[this.name]={light:K.length-1}}}class GLTFMaterialsUnlitExtension{constructor(w){this.writer=w,this.name="KHR_materials_unlit"}async writeMaterialAsync(w,D){if(!w.isMeshBasicMaterial)return;const U=this.writer.extensionsUsed;D.extensions=D.extensions||{},D.extensions[this.name]={},U[this.name]=!0,D.pbrMetallicRoughness.metallicFactor=0,D.pbrMetallicRoughness.roughnessFactor=.9}}class GLTFMaterialsClearcoatExtension{constructor(w){this.writer=w,this.name="KHR_materials_clearcoat"}async writeMaterialAsync(w,D){if(!w.isMeshPhysicalMaterial||w.clearcoat===0)return;const O=this.writer,U=O.extensionsUsed,G={};if(G.clearcoatFactor=w.clearcoat,w.clearcoatMap){const q={index:await O.processTextureAsync(w.clearcoatMap),texCoord:w.clearcoatMap.channel};O.applyTextureTransform(q,w.clearcoatMap),G.clearcoatTexture=q}if(G.clearcoatRoughnessFactor=w.clearcoatRoughness,w.clearcoatRoughnessMap){const q={index:await O.processTextureAsync(w.clearcoatRoughnessMap),texCoord:w.clearcoatRoughnessMap.channel};O.applyTextureTransform(q,w.clearcoatRoughnessMap),G.clearcoatRoughnessTexture=q}if(w.clearcoatNormalMap){const q={index:await O.processTextureAsync(w.clearcoatNormalMap),texCoord:w.clearcoatNormalMap.channel};w.clearcoatNormalScale.x!==1&&(q.scale=w.clearcoatNormalScale.x),O.applyTextureTransform(q,w.clearcoatNormalMap),G.clearcoatNormalTexture=q}D.extensions=D.extensions||{},D.extensions[this.name]=G,U[this.name]=!0}}class GLTFMaterialsDispersionExtension{constructor(w){this.writer=w,this.name="KHR_materials_dispersion"}async writeMaterialAsync(w,D){if(!w.isMeshPhysicalMaterial||w.dispersion===0)return;const U=this.writer.extensionsUsed,G={};G.dispersion=w.dispersion,D.extensions=D.extensions||{},D.extensions[this.name]=G,U[this.name]=!0}}class GLTFMaterialsIridescenceExtension{constructor(w){this.writer=w,this.name="KHR_materials_iridescence"}async writeMaterialAsync(w,D){if(!w.isMeshPhysicalMaterial||w.iridescence===0)return;const O=this.writer,U=O.extensionsUsed,G={};if(G.iridescenceFactor=w.iridescence,w.iridescenceMap){const q={index:await O.processTextureAsync(w.iridescenceMap),texCoord:w.iridescenceMap.channel};O.applyTextureTransform(q,w.iridescenceMap),G.iridescenceTexture=q}if(G.iridescenceIor=w.iridescenceIOR,G.iridescenceThicknessMinimum=w.iridescenceThicknessRange[0],G.iridescenceThicknessMaximum=w.iridescenceThicknessRange[1],w.iridescenceThicknessMap){const q={index:await O.processTextureAsync(w.iridescenceThicknessMap),texCoord:w.iridescenceThicknessMap.channel};O.applyTextureTransform(q,w.iridescenceThicknessMap),G.iridescenceThicknessTexture=q}D.extensions=D.extensions||{},D.extensions[this.name]=G,U[this.name]=!0}}class GLTFMaterialsTransmissionExtension{constructor(w){this.writer=w,this.name="KHR_materials_transmission"}async writeMaterialAsync(w,D){if(!w.isMeshPhysicalMaterial||w.transmission===0)return;const O=this.writer,U=O.extensionsUsed,G={};if(G.transmissionFactor=w.transmission,w.transmissionMap){const q={index:await O.processTextureAsync(w.transmissionMap),texCoord:w.transmissionMap.channel};O.applyTextureTransform(q,w.transmissionMap),G.transmissionTexture=q}D.extensions=D.extensions||{},D.extensions[this.name]=G,U[this.name]=!0}}class GLTFMaterialsVolumeExtension{constructor(w){this.writer=w,this.name="KHR_materials_volume"}async writeMaterialAsync(w,D){if(!w.isMeshPhysicalMaterial||w.transmission===0)return;const O=this.writer,U=O.extensionsUsed,G={};if(G.thicknessFactor=w.thickness,w.thicknessMap){const q={index:await O.processTextureAsync(w.thicknessMap),texCoord:w.thicknessMap.channel};O.applyTextureTransform(q,w.thicknessMap),G.thicknessTexture=q}w.attenuationDistance!==1/0&&(G.attenuationDistance=w.attenuationDistance),G.attenuationColor=w.attenuationColor.toArray(),D.extensions=D.extensions||{},D.extensions[this.name]=G,U[this.name]=!0}}class GLTFMaterialsIorExtension{constructor(w){this.writer=w,this.name="KHR_materials_ior"}async writeMaterialAsync(w,D){if(!w.isMeshPhysicalMaterial||w.ior===1.5)return;const U=this.writer.extensionsUsed,G={};G.ior=w.ior,D.extensions=D.extensions||{},D.extensions[this.name]=G,U[this.name]=!0}}class GLTFMaterialsSpecularExtension{constructor(w){this.writer=w,this.name="KHR_materials_specular"}async writeMaterialAsync(w,D){if(!w.isMeshPhysicalMaterial||w.specularIntensity===1&&w.specularColor.equals(DEFAULT_SPECULAR_COLOR)&&!w.specularIntensityMap&&!w.specularColorMap)return;const O=this.writer,U=O.extensionsUsed,G={};if(w.specularIntensityMap){const q={index:await O.processTextureAsync(w.specularIntensityMap),texCoord:w.specularIntensityMap.channel};O.applyTextureTransform(q,w.specularIntensityMap),G.specularTexture=q}if(w.specularColorMap){const q={index:await O.processTextureAsync(w.specularColorMap),texCoord:w.specularColorMap.channel};O.applyTextureTransform(q,w.specularColorMap),G.specularColorTexture=q}G.specularFactor=w.specularIntensity,G.specularColorFactor=w.specularColor.toArray(),D.extensions=D.extensions||{},D.extensions[this.name]=G,U[this.name]=!0}}class GLTFMaterialsSheenExtension{constructor(w){this.writer=w,this.name="KHR_materials_sheen"}async writeMaterialAsync(w,D){if(!w.isMeshPhysicalMaterial||w.sheen==0)return;const O=this.writer,U=O.extensionsUsed,G={};if(w.sheenRoughnessMap){const q={index:await O.processTextureAsync(w.sheenRoughnessMap),texCoord:w.sheenRoughnessMap.channel};O.applyTextureTransform(q,w.sheenRoughnessMap),G.sheenRoughnessTexture=q}if(w.sheenColorMap){const q={index:await O.processTextureAsync(w.sheenColorMap),texCoord:w.sheenColorMap.channel};O.applyTextureTransform(q,w.sheenColorMap),G.sheenColorTexture=q}G.sheenRoughnessFactor=w.sheenRoughness,G.sheenColorFactor=w.sheenColor.toArray(),D.extensions=D.extensions||{},D.extensions[this.name]=G,U[this.name]=!0}}class GLTFMaterialsAnisotropyExtension{constructor(w){this.writer=w,this.name="KHR_materials_anisotropy"}async writeMaterialAsync(w,D){if(!w.isMeshPhysicalMaterial||w.anisotropy==0)return;const O=this.writer,U=O.extensionsUsed,G={};if(w.anisotropyMap){const q={index:await O.processTextureAsync(w.anisotropyMap)};O.applyTextureTransform(q,w.anisotropyMap),G.anisotropyTexture=q}G.anisotropyStrength=w.anisotropy,G.anisotropyRotation=w.anisotropyRotation,D.extensions=D.extensions||{},D.extensions[this.name]=G,U[this.name]=!0}}class GLTFMaterialsEmissiveStrengthExtension{constructor(w){this.writer=w,this.name="KHR_materials_emissive_strength"}async writeMaterialAsync(w,D){if(!w.isMeshStandardMaterial||w.emissiveIntensity===1)return;const U=this.writer.extensionsUsed,G={};G.emissiveStrength=w.emissiveIntensity,D.extensions=D.extensions||{},D.extensions[this.name]=G,U[this.name]=!0}}class GLTFMaterialsBumpExtension{constructor(w){this.writer=w,this.name="EXT_materials_bump"}async writeMaterialAsync(w,D){if(!w.isMeshStandardMaterial||w.bumpScale===1&&!w.bumpMap)return;const O=this.writer,U=O.extensionsUsed,G={};if(w.bumpMap){const q={index:await O.processTextureAsync(w.bumpMap),texCoord:w.bumpMap.channel};O.applyTextureTransform(q,w.bumpMap),G.bumpTexture=q}G.bumpFactor=w.bumpScale,D.extensions=D.extensions||{},D.extensions[this.name]=G,U[this.name]=!0}}class GLTFMeshGpuInstancing{constructor(w){this.writer=w,this.name="EXT_mesh_gpu_instancing"}writeNode(w,D){if(!w.isInstancedMesh)return;const O=this.writer,U=w,G=new Float32Array(U.count*3),q=new Float32Array(U.count*4),K=new Float32Array(U.count*3),ee=new Matrix4,Z=new Vector3,ie=new Quaternion,Y=new Vector3;for(let ne=0;ne<U.count;ne++)U.getMatrixAt(ne,ee),ee.decompose(Z,ie,Y),Z.toArray(G,ne*3),ie.toArray(q,ne*4),Y.toArray(K,ne*3);const W={TRANSLATION:O.processAccessor(new BufferAttribute(G,3)),ROTATION:O.processAccessor(new BufferAttribute(q,4)),SCALE:O.processAccessor(new BufferAttribute(K,3))};U.instanceColor&&(W._COLOR_0=O.processAccessor(U.instanceColor)),D.extensions=D.extensions||{},D.extensions[this.name]={attributes:W},O.extensionsUsed[this.name]=!0,O.extensionsRequired[this.name]=!0}}GLTFExporter.Utils={insertKeyframe:function(F,w){const O=F.getValueSize(),U=new F.TimeBufferType(F.times.length+1),G=new F.ValueBufferType(F.values.length+O),q=F.createInterpolant(new F.ValueBufferType(O));let K;if(F.times.length===0){U[0]=w;for(let ee=0;ee<O;ee++)G[ee]=0;K=0}else if(w<F.times[0]){if(Math.abs(F.times[0]-w)<.001)return 0;U[0]=w,U.set(F.times,1),G.set(q.evaluate(w),0),G.set(F.values,O),K=0}else if(w>F.times[F.times.length-1]){if(Math.abs(F.times[F.times.length-1]-w)<.001)return F.times.length-1;U[U.length-1]=w,U.set(F.times,0),G.set(F.values,0),G.set(q.evaluate(w),F.values.length),K=U.length-1}else for(let ee=0;ee<F.times.length;ee++){if(Math.abs(F.times[ee]-w)<.001)return ee;if(F.times[ee]<w&&F.times[ee+1]>w){U.set(F.times.slice(0,ee+1),0),U[ee+1]=w,U.set(F.times.slice(ee+1),ee+2),G.set(F.values.slice(0,(ee+1)*O),0),G.set(q.evaluate(w),(ee+1)*O),G.set(F.values.slice((ee+1)*O),(ee+2)*O),K=ee+1;break}}return F.times=U,F.values=G,K},mergeMorphTargetTracks:function(F,w){const D=[],O={},U=F.tracks;for(let G=0;G<U.length;++G){let q=U[G];const K=PropertyBinding.parseTrackName(q.name),ee=PropertyBinding.findNode(w,K.nodeName);if(K.propertyName!=="morphTargetInfluences"||K.propertyIndex===void 0){D.push(q);continue}if(q.createInterpolant!==q.InterpolantFactoryMethodDiscrete&&q.createInterpolant!==q.InterpolantFactoryMethodLinear){if(q.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline)throw new Error("THREE.GLTFExporter: Cannot merge tracks with glTF CUBICSPLINE interpolation.");console.warn("THREE.GLTFExporter: Morph target interpolation mode not yet supported. Using LINEAR instead."),q=q.clone(),q.setInterpolation(InterpolateLinear)}const Z=ee.morphTargetInfluences.length,ie=ee.morphTargetDictionary[K.propertyIndex];if(ie===void 0)throw new Error("THREE.GLTFExporter: Morph target name not found: "+K.propertyIndex);let Y;if(O[ee.uuid]===void 0){Y=q.clone();const ne=new Y.ValueBufferType(Z*Y.times.length);for(let se=0;se<Y.times.length;se++)ne[se*Z+ie]=Y.values[se];Y.name=(K.nodeName||"")+".morphTargetInfluences",Y.values=ne,O[ee.uuid]=Y,D.push(Y);continue}const W=q.createInterpolant(new q.ValueBufferType(1));Y=O[ee.uuid];for(let ne=0;ne<Y.times.length;ne++)Y.values[ne*Z+ie]=W.evaluate(Y.times[ne]);for(let ne=0;ne<q.times.length;ne++){const se=this.insertKeyframe(Y,q.times[ne]);Y.values[se*Z+ie]=q.values[ne]}}return F.tracks=D,F},toFloat32BufferAttribute:function(F){const w=new BufferAttribute(new Float32Array(F.count*F.itemSize),F.itemSize,!1);if(!F.normalized&&!F.isInterleavedBufferAttribute)return w.array.set(F.array),w;for(let D=0,O=F.count;D<O;D++)for(let U=0;U<F.itemSize;U++)w.setComponent(D,U,F.getComponent(D,U));return w}};/* @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */const compatibleObject=F=>F.material!==void 0&&F.userData&&F.userData.variantMaterials&&!!Array.from(F.userData.variantMaterials.values()).filter(w=>compatibleMaterial(w.material)),compatibleMaterial=F=>F&&F.isMaterial&&!Array.isArray(F);class GLTFExporterMaterialsVariantsExtension{constructor(w){this.writer=w,this.name="KHR_materials_variants",this.variantNames=[]}beforeParse(w){const D=new Set,O=U=>{if(!compatibleObject(U))return;const G=U.userData.variantMaterials,q=U.userData.variantData;for(const[K,ee]of q){const Z=G.get(ee.index);Z&&compatibleMaterial(Z.material)&&D.add(K)}};if(Array.isArray(w))for(const U of w)U.traverse(O);else w.traverse(O);D.forEach(U=>this.variantNames.push(U))}async writeMesh(w,D){if(!compatibleObject(w))return;const O=w.userData,U=O.variantMaterials,G=O.variantData,q=new Map,K=new Map,ee=Array.from(G.values()).sort((Y,W)=>Y.index-W.index);for(const[Y,W]of ee.entries())K.set(W.index,Y);for(const Y of G.values()){const W=U.get(Y.index);if(!W||!compatibleMaterial(W.material))continue;const ne=await this.writer.processMaterialAsync(W.material);q.has(ne)||q.set(ne,{material:ne,variants:[]}),q.get(ne).variants.push(K.get(Y.index))}const Z=Array.from(q.values()).map((Y=>Y.variants.sort((W,ne)=>W-ne)&&Y)).sort((Y,W)=>Y.material-W.material);if(Z.length===0)return;const ie=compatibleMaterial(O.originalMaterial)?await this.writer.processMaterialAsync(O.originalMaterial):-1;for(const Y of D.primitives)ie>=0&&(Y.material=ie),Y.extensions=Y.extensions||{},Y.extensions[this.name]={mappings:Z}}afterParse(){if(this.variantNames.length===0)return;const w=this.writer.json;w.extensions=w.extensions||{};const D=this.variantNames.map(O=>({name:O}));w.extensions[this.name]={variants:D},this.writer.extensionsUsed[this.name]=!0}}class SessionLightProbe{constructor(w,D,O,U,G){this.xrLight=w,this.renderer=D,this.lightProbe=O,this.xrWebGLBinding=null,this.estimationStartCallback=G,this.frameCallback=this.onXRFrame.bind(this);const q=D.xr.getSession();if(U&&"XRWebGLBinding"in window){const K=new WebGLCubeRenderTarget(16);w.environment=K.texture;const ee=D.getContext();switch(q.preferredReflectionFormat){case"srgba8":ee.getExtension("EXT_sRGB");break;case"rgba16f":ee.getExtension("OES_texture_half_float");break}this.xrWebGLBinding=new XRWebGLBinding(q,ee),this.lightProbe.addEventListener("reflectionchange",()=>{this.updateReflection()})}q.requestAnimationFrame(this.frameCallback)}updateReflection(){const w=this.renderer.properties.get(this.xrLight.environment);if(w){const D=this.xrWebGLBinding.getReflectionCubeMap(this.lightProbe);D&&(w.__webglTexture=D,this.xrLight.environment.needsPMREMUpdate=!0)}}onXRFrame(w,D){if(!this.xrLight)return;D.session.requestAnimationFrame(this.frameCallback);const U=D.getLightEstimate(this.lightProbe);if(U){this.xrLight.lightProbe.sh.fromArray(U.sphericalHarmonicsCoefficients),this.xrLight.lightProbe.intensity=1;const G=Math.max(1,Math.max(U.primaryLightIntensity.x,Math.max(U.primaryLightIntensity.y,U.primaryLightIntensity.z)));this.xrLight.directionalLight.color.setRGB(U.primaryLightIntensity.x/G,U.primaryLightIntensity.y/G,U.primaryLightIntensity.z/G),this.xrLight.directionalLight.intensity=G,this.xrLight.directionalLight.position.copy(U.primaryLightDirection),this.estimationStartCallback&&(this.estimationStartCallback(),this.estimationStartCallback=null)}}dispose(){this.xrLight=null,this.renderer=null,this.lightProbe=null,this.xrWebGLBinding=null}}class XREstimatedLight extends Group{constructor(w,D=!0){super(),this.lightProbe=new LightProbe,this.lightProbe.intensity=0,this.add(this.lightProbe),this.directionalLight=new DirectionalLight,this.directionalLight.intensity=0,this.add(this.directionalLight),this.environment=null;let O=null,U=!1;w.xr.addEventListener("sessionstart",()=>{const G=w.xr.getSession();"requestLightProbe"in G&&G.requestLightProbe({reflectionFormat:G.preferredReflectionFormat}).then(q=>{O=new SessionLightProbe(this,w,q,D,()=>{U=!0,this.dispatchEvent({type:"estimationstart"})})})}),w.xr.addEventListener("sessionend",()=>{O&&(O.dispose(),O=null),U&&this.dispatchEvent({type:"estimationend"})}),this.dispose=()=>{O&&(O.dispose(),O=null),this.remove(this.lightProbe),this.lightProbe=null,this.remove(this.directionalLight),this.directionalLight=null,this.environment=null}}}/* @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */const SETTLING_TIME=1e4,MIN_DECAY_MILLISECONDS=.001,DECAY_MILLISECONDS=50;class Damper{constructor(w=DECAY_MILLISECONDS){this.velocity=0,this.naturalFrequency=0,this.setDecayTime(w)}setDecayTime(w){this.naturalFrequency=1/Math.max(MIN_DECAY_MILLISECONDS,w)}update(w,D,O,U){const G=2e-4*this.naturalFrequency;if(w==null||U===0||w===D&&this.velocity===0)return D;if(O<0)return w;const q=w-D,K=this.velocity+this.naturalFrequency*q,ee=q+O*K,Z=Math.exp(-this.naturalFrequency*O),ie=(K-this.naturalFrequency*ee)*Z,Y=-this.naturalFrequency*(ie+K*Z);return Math.abs(ie)<G*Math.abs(U)&&Y*q>=0?(this.velocity=0,D):(this.velocity=ie,D+ee*Z)}}/* @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */const RADIUS=.2,LINE_WIDTH=.03,MAX_OPACITY=.75,SEGMENTS=12,DELTA_PHI=Math.PI/(2*SEGMENTS),vector2$1=new Vector2,addCorner=(F,w,D)=>{let O=w>0?D>0?0:-Math.PI/2:D>0?Math.PI/2:Math.PI;for(let U=0;U<=SEGMENTS;++U)F.push(w+(RADIUS-LINE_WIDTH)*Math.cos(O),D+(RADIUS-LINE_WIDTH)*Math.sin(O),0,w+RADIUS*Math.cos(O),D+RADIUS*Math.sin(O),0),O+=DELTA_PHI};class PlacementBox extends Mesh{constructor(w,D){const O=new BufferGeometry,U=[],G=[],{size:q,boundingBox:K}=w,ee=q.x/2,Z=(D==="back"?q.y:q.z)/2;addCorner(G,ee,Z),addCorner(G,-ee,Z),addCorner(G,-ee,-Z),addCorner(G,ee,-Z);const ie=G.length/3;for(let ne=0;ne<ie-2;ne+=2)U.push(ne,ne+1,ne+3,ne,ne+3,ne+2);const Y=ie-2;U.push(Y,Y+1,1,Y,1,0),O.setAttribute("position",new Float32BufferAttribute(G,3)),O.setIndex(U),super(O),this.side=D;const W=this.material;switch(W.side=DoubleSide,W.transparent=!0,W.opacity=0,this.goalOpacity=0,this.opacityDamper=new Damper,this.hitPlane=new Mesh(new PlaneGeometry(2*(ee+RADIUS),2*(Z+RADIUS))),this.hitPlane.visible=!1,this.hitPlane.material.side=DoubleSide,this.add(this.hitPlane),this.hitBox=new Mesh(new BoxGeometry(q.x+2*RADIUS,q.y+RADIUS,q.z+2*RADIUS)),this.hitBox.visible=!1,this.hitBox.material.side=DoubleSide,this.add(this.hitBox),K.getCenter(this.position),D){case"bottom":this.rotateX(-Math.PI/2),this.shadowHeight=K.min.y,this.position.y=this.shadowHeight;break;case"back":this.shadowHeight=K.min.z,this.position.z=this.shadowHeight}w.target.add(this),this.hitBox.position.y=(q.y+RADIUS)/2+K.min.y,w.target.add(this.hitBox),this.offsetHeight=0}getHit(w,D,O){vector2$1.set(D,-O),this.hitPlane.visible=!0;const U=w.positionAndNormalFromPoint(vector2$1,this.hitPlane);return this.hitPlane.visible=!1,U==null?null:U.position}getExpandedHit(w,D,O){this.hitPlane.scale.set(1e3,1e3,1e3),this.hitPlane.updateMatrixWorld();const U=this.getHit(w,D,O);return this.hitPlane.scale.set(1,1,1),U}controllerIntersection(w,D){this.hitBox.visible=!0;const O=w.hitFromController(D,this.hitBox);return this.hitBox.visible=!1,O}set offsetHeight(w){w-=.001,this.side==="back"?this.position.z=this.shadowHeight+w:this.position.y=this.shadowHeight+w}get offsetHeight(){return this.side==="back"?this.position.z-this.shadowHeight:this.position.y-this.shadowHeight}set show(w){this.goalOpacity=w?MAX_OPACITY:0}updateOpacity(w){const D=this.material;D.opacity=this.opacityDamper.update(D.opacity,this.goalOpacity,w,1),this.visible=D.opacity>0}dispose(){const{geometry:w,material:D}=this.hitPlane;w.dispose(),D.dispose(),this.hitBox.geometry.dispose(),this.hitBox.material.dispose(),this.geometry.dispose(),this.material.dispose(),this.hitBox.removeFromParent(),this.removeFromParent()}}/* @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */const numberNode=(F,w)=>({type:"number",number:F,unit:w}),parseExpressions=(()=>{const F={};return D=>{const O=D;if(O in F)return F[O];const U=[];let G=0;for(;D;){if(++G>1e3){D="";break}const q=parseExpression(D),K=q.nodes[0];if(K==null||K.terms.length===0)break;U.push(K),D=q.remainingInput}return F[O]=U}})(),parseExpression=(()=>{const F=/^(\-\-|[a-z\u0240-\uffff])/i,w=/^([\*\+\/]|[\-]\s)/i,D=/^[\),]/;return G=>{const q=[];for(;G.length&&(G=G.trim(),!D.test(G));)if(G[0]==="("){const{nodes:K,remainingInput:ee}=parseFunctionArguments(G);G=ee,q.push({type:"function",name:{type:"ident",value:"calc"},arguments:K})}else if(F.test(G)){const K=parseIdent(G),ee=K.nodes[0];if(G=K.remainingInput,G[0]==="("){const{nodes:Z,remainingInput:ie}=parseFunctionArguments(G);q.push({type:"function",name:ee,arguments:Z}),G=ie}else q.push(ee)}else if(w.test(G))q.push({type:"operator",value:G[0]}),G=G.slice(1);else{const{nodes:K,remainingInput:ee}=G[0]==="#"?parseHex$1(G):parseNumber(G);if(K.length===0)break;q.push(K[0]),G=ee}return{nodes:[{type:"expression",terms:q}],remainingInput:G}}})(),parseIdent=(()=>{const F=/[^a-z0-9_\-\u0240-\uffff]/i;return w=>{const D=w.match(F),O=D==null?w:w.substr(0,D.index),U=D==null?"":w.substr(D.index);return{nodes:[{type:"ident",value:O}],remainingInput:U}}})(),parseNumber=(()=>{const F=/[\+\-]?(\d+[\.]\d+|\d+|[\.]\d+)([eE][\+\-]?\d+)?/,w=/^[a-z%]+/i,D=/^(m|mm|cm|rad|deg|[%])$/;return O=>{const U=O.match(F),G=U==null?"0":U[0];O=G==null?O:O.slice(G.length);const q=O.match(w);let K=q!=null&&q[0]!==""?q[0]:null;const ee=q==null?O:O.slice(K.length);return K!=null&&!D.test(K)&&(K=null),{nodes:[{type:"number",number:parseFloat(G)||0,unit:K}],remainingInput:ee}}})(),parseHex$1=(()=>{const F=/^[a-f0-9]*/i;return w=>{w=w.slice(1).trim();const D=w.match(F);return{nodes:D==null?[]:[{type:"hex",value:D[0]}],remainingInput:D==null?w:w.slice(D[0].length)}}})(),parseFunctionArguments=F=>{const w=[];for(F=F.slice(1).trim();F.length;){const D=parseExpression(F);if(w.push(D.nodes[0]),F=D.remainingInput.trim(),F[0]===",")F=F.slice(1).trim();else if(F[0]===")"){F=F.slice(1);break}}return{nodes:w,remainingInput:F}},$visitedTypes=Symbol("visitedTypes");class ASTWalker{constructor(w){this[$visitedTypes]=w}walk(w,D){const O=w.slice();for(;O.length;){const U=O.shift();switch(this[$visitedTypes].indexOf(U.type)>-1&&D(U),U.type){case"expression":O.unshift(...U.terms);break;case"function":O.unshift(U.name,...U.arguments);break}}}}const ZERO=Object.freeze({type:"number",number:0,unit:null});/* @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */const degreesToRadians=(F,w=0)=>{let{number:D,unit:O}=F;if(!isFinite(D))D=w,O="rad";else if(F.unit==="rad"||F.unit==null)return F;return{type:"number",number:(O==="deg"&&D!=null?D:0)*Math.PI/180,unit:"rad"}},lengthToBaseMeters=(F,w=0)=>{let{number:D,unit:O}=F;if(!isFinite(D))D=w,O="m";else if(F.unit==="m")return F;let U;switch(O){default:U=1;break;case"cm":U=1/100;break;case"mm":U=1/1e3;break}return{type:"number",number:U*D,unit:"m"}},normalizeUnit=(()=>{const F=D=>D,w={rad:F,deg:degreesToRadians,m:F,mm:lengthToBaseMeters,cm:lengthToBaseMeters};return(D,O=ZERO)=>{isFinite(D.number)||(D.number=O.number,D.unit=O.unit);const{unit:U}=D;if(U==null)return D;const G=w[U];return G==null?O:G(D)}})();/* @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */var _a$6,_b$6,_c$4;const $evaluate=Symbol("evaluate"),$lastValue=Symbol("lastValue");class Evaluator{constructor(){this[_a$6]=null}static evaluatableFor(w,D=ZERO){if(w instanceof Evaluator)return w;if(w.type==="number")return w.unit==="%"?new PercentageEvaluator(w,D):w;switch(w.name.value){case"calc":return new CalcEvaluator(w,D);case"env":return new EnvEvaluator(w)}return ZERO}static evaluate(w){return w instanceof Evaluator?w.evaluate():w}static isConstant(w){return w instanceof Evaluator?w.isConstant:!0}static applyIntrinsics(w,D){const{basis:O,keywords:U}=D,{auto:G}=U;return O.map((q,K)=>{const ee=G[K]==null?q:G[K];let Z=w[K]?w[K]:ee;if(Z.type==="ident"){const ie=Z.value;ie in U&&(Z=U[ie][K])}return(Z==null||Z.type==="ident")&&(Z=ee),Z.unit==="%"?numberNode(Z.number/100*q.number,q.unit):(Z=normalizeUnit(Z,q),Z.unit!==q.unit?q:Z)})}get isConstant(){return!1}evaluate(){return(!this.isConstant||this[$lastValue]==null)&&(this[$lastValue]=this[$evaluate]()),this[$lastValue]}}_a$6=$lastValue;const $percentage=Symbol("percentage"),$basis=Symbol("basis");class PercentageEvaluator extends Evaluator{constructor(w,D){super(),this[$percentage]=w,this[$basis]=D}get isConstant(){return!0}[$evaluate](){return numberNode(this[$percentage].number/100*this[$basis].number,this[$basis].unit)}}const $identNode=Symbol("identNode");class EnvEvaluator extends Evaluator{constructor(w){super(),this[_b$6]=null;const D=w.arguments.length?w.arguments[0].terms[0]:null;D!=null&&D.type==="ident"&&(this[$identNode]=D)}get isConstant(){return!1}[(_b$6=$identNode,$evaluate)](){if(this[$identNode]!=null)switch(this[$identNode].value){case"window-scroll-y":const w=window.pageYOffset,D=Math.max(document.body.scrollHeight,document.body.offsetHeight,document.documentElement.clientHeight,document.documentElement.scrollHeight,document.documentElement.offsetHeight);return{type:"number",number:w/(D-window.innerHeight)||0,unit:null}}return ZERO}}const IS_MULTIPLICATION_RE=/[\*\/]/,$evaluator=Symbol("evaluator");class CalcEvaluator extends Evaluator{constructor(w,D=ZERO){if(super(),this[_c$4]=null,w.arguments.length!==1)return;const O=w.arguments[0].terms.slice(),U=[];for(;O.length;){const G=O.shift();if(U.length>0){const q=U[U.length-1];if(q.type==="operator"&&IS_MULTIPLICATION_RE.test(q.value)){const K=U.pop(),ee=U.pop();if(ee==null)return;U.push(new OperatorEvaluator(K,Evaluator.evaluatableFor(ee,D),Evaluator.evaluatableFor(G,D)));continue}}U.push(G.type==="operator"?G:Evaluator.evaluatableFor(G,D))}for(;U.length>2;){const[G,q,K]=U.splice(0,3);if(q.type!=="operator")return;U.unshift(new OperatorEvaluator(q,Evaluator.evaluatableFor(G,D),Evaluator.evaluatableFor(K,D)))}U.length===1&&(this[$evaluator]=U[0])}get isConstant(){return this[$evaluator]==null||Evaluator.isConstant(this[$evaluator])}[(_c$4=$evaluator,$evaluate)](){return this[$evaluator]!=null?Evaluator.evaluate(this[$evaluator]):ZERO}}const $operator=Symbol("operator"),$left=Symbol("left"),$right=Symbol("right");class OperatorEvaluator extends Evaluator{constructor(w,D,O){super(),this[$operator]=w,this[$left]=D,this[$right]=O}get isConstant(){return Evaluator.isConstant(this[$left])&&Evaluator.isConstant(this[$right])}[$evaluate](){const w=normalizeUnit(Evaluator.evaluate(this[$left])),D=normalizeUnit(Evaluator.evaluate(this[$right])),{number:O,unit:U}=w,{number:G,unit:q}=D;if(q!=null&&U!=null&&q!=U)return ZERO;const K=U||q;let ee;switch(this[$operator].value){case"+":ee=O+G;break;case"-":ee=O-G;break;case"/":ee=O/G;break;case"*":ee=O*G;break;default:return ZERO}return{type:"number",number:ee,unit:K}}}const $evaluatables=Symbol("evaluatables"),$intrinsics=Symbol("intrinsics");class StyleEvaluator extends Evaluator{constructor(w,D){super(),this[$intrinsics]=D;const O=w[0],U=O!=null?O.terms:[];this[$evaluatables]=D.basis.map((G,q)=>{const K=U[q];return K==null?{type:"ident",value:"auto"}:K.type==="ident"?K:Evaluator.evaluatableFor(K,G)})}get isConstant(){for(const w of this[$evaluatables])if(!Evaluator.isConstant(w))return!1;return!0}[$evaluate](){const w=this[$evaluatables].map(D=>Evaluator.evaluate(D));return Evaluator.applyIntrinsics(w,this[$intrinsics]).map(D=>D.number)}}/* @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */var _a$5,_b$5,_c$3,_d$2;const $instances=Symbol("instances"),$activateListener=Symbol("activateListener"),$deactivateListener=Symbol("deactivateListener"),$notifyInstances=Symbol("notifyInstances"),$notify=Symbol("notify"),$scrollCallback=Symbol("callback");class ScrollObserver{static[$notifyInstances](){for(const w of ScrollObserver[$instances])w[$notify]()}static[(_a$5=$instances,$activateListener)](){window.addEventListener("scroll",this[$notifyInstances],{passive:!0})}static[$deactivateListener](){window.removeEventListener("scroll",this[$notifyInstances])}constructor(w){this[$scrollCallback]=w}observe(){ScrollObserver[$instances].size===0&&ScrollObserver[$activateListener](),ScrollObserver[$instances].add(this)}disconnect(){ScrollObserver[$instances].delete(this),ScrollObserver[$instances].size===0&&ScrollObserver[$deactivateListener]()}[$notify](){this[$scrollCallback]()}}ScrollObserver[_a$5]=new Set;const $computeStyleCallback=Symbol("computeStyleCallback"),$astWalker=Symbol("astWalker"),$dependencies=Symbol("dependencies"),$onScroll=Symbol("onScroll");class StyleEffector{constructor(w){this[_b$5]={},this[_c$3]=new ASTWalker(["function"]),this[_d$2]=()=>{this[$computeStyleCallback]({relatedState:"window-scroll"})},this[$computeStyleCallback]=w}observeEffectsFor(w){const D={},O=this[$dependencies];this[$astWalker].walk(w,U=>{const{name:G}=U,K=U.arguments[0].terms[0];if(!(G.value!=="env"||K==null||K.type!=="ident"))switch(K.value){case"window-scroll-y":if(D["window-scroll"]==null){const ee="window-scroll"in O?O["window-scroll"]:new ScrollObserver(this[$onScroll]);ee.observe(),delete O["window-scroll"],D["window-scroll"]=ee}break}});for(const U in O)O[U].disconnect();this[$dependencies]=D}dispose(){for(const w in this[$dependencies])this[$dependencies][w].disconnect()}}_b$5=$dependencies,_c$3=$astWalker,_d$2=$onScroll;/* @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */const style=F=>{const w=F.observeEffects||!1,D=F.intrinsics instanceof Function?F.intrinsics:(()=>F.intrinsics);return(O,U)=>{const G=O.updated,q=O.connectedCallback,K=O.disconnectedCallback,ee=Symbol(`${U}StyleEffector`),Z=Symbol(`${U}StyleEvaluator`),ie=Symbol(`${U}UpdateEvaluator`),Y=Symbol(`${U}EvaluateAndSync`);Object.defineProperties(O,{[ee]:{value:null,writable:!0},[Z]:{value:null,writable:!0},[ie]:{value:function(){const W=parseExpressions(this[U]);this[Z]=new StyleEvaluator(W,D(this)),this[ee]==null&&w&&(this[ee]=new StyleEffector(()=>this[Y]())),this[ee]!=null&&this[ee].observeEffectsFor(W)}},[Y]:{value:function(){if(this[Z]==null)return;const W=this[Z].evaluate();this[F.updateHandler](W)}},updated:{value:function(W){W.has(U)&&(this[ie](),this[Y]()),G.call(this,W)}},connectedCallback:{value:function(){q.call(this),this.requestUpdate(U,this[U])}},disconnectedCallback:{value:function(){K.call(this),this[ee]!=null&&(this[ee].dispose(),this[ee]=null)}}})}};/* @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */const easeInOutQuad=F=>F<.5?2*F*F:-1+(4-2*F)*F,interpolate$2=(F,w,D=easeInOutQuad)=>O=>F+(w-F)*D(O),sequence=(F,w)=>{const D=(U=>G=>U+=G),O=w.map(D(0));return U=>{U=clamp$1(U,0,1),U*=O[O.length-1];const G=O.findIndex(ee=>ee>=U),q=G<1?0:O[G-1],K=O[G];return F[G]((U-q)/(K-q))}},timeline=F=>{const w=[],D=[];let O=F.initialValue;for(let U=0;U<F.keyframes.length;++U){const G=F.keyframes[U],{value:q,frames:K}=G,ee=G.ease||easeInOutQuad,Z=interpolate$2(O,q,ee);w.push(Z),D.push(K),O=q}return sequence(w,D)};/* @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */var __decorate$6=function(F,w,D,O){var U=arguments.length,G=U<3?w:O===null?O=Object.getOwnPropertyDescriptor(w,D):O,q;if(typeof Reflect=="object"&&typeof Reflect.decorate=="function")G=Reflect.decorate(F,w,D,O);else for(var K=F.length-1;K>=0;K--)(q=F[K])&&(G=(U<3?q(G):U>3?q(w,D,G):q(w,D))||G);return U>3&&G&&Object.defineProperty(w,D,G),G};const PROMPT_ANIMATION_TIME=5e3,wiggle=timeline({initialValue:0,keyframes:[{frames:5,value:-1},{frames:1,value:-1},{frames:8,value:1},{frames:1,value:1},{frames:5,value:0},{frames:18,value:0}]}),fade=timeline({initialValue:0,keyframes:[{frames:1,value:1},{frames:5,value:1},{frames:1,value:0},{frames:6,value:0}]}),DEFAULT_FOV_DEG=30,DEFAULT_MIN_FOV_DEG=12,DEFAULT_CAMERA_ORBIT="0deg 75deg 105%",DEFAULT_CAMERA_TARGET="auto auto auto",DEFAULT_FIELD_OF_VIEW="auto",MINIMUM_RADIUS_RATIO=2.2,AZIMUTHAL_QUADRANT_LABELS=["front","right","back","left"],POLAR_TRIENT_LABELS=["upper-","","lower-"],DEFAULT_INTERACTION_PROMPT_THRESHOLD=3e3,INTERACTION_PROMPT=". Use mouse, touch or arrow keys to move.",InteractionPromptStrategy={AUTO:"auto"},InteractionPromptStyle={BASIC:"basic",WIGGLE:"wiggle"},TouchAction={NONE:"none"},fieldOfViewIntrinsics=()=>({basis:[degreesToRadians(numberNode(DEFAULT_FOV_DEG,"deg"))],keywords:{auto:[null]}}),minFieldOfViewIntrinsics=()=>({basis:[degreesToRadians(numberNode(DEFAULT_MIN_FOV_DEG,"deg"))],keywords:{auto:[null]}}),cameraOrbitIntrinsics=(()=>{const F=parseExpressions(DEFAULT_CAMERA_ORBIT)[0].terms,w=normalizeUnit(F[0]),D=normalizeUnit(F[1]);return O=>{const U=O[$scene].idealCameraDistance();return{basis:[w,D,numberNode(U,"m")],keywords:{auto:[null,null,numberNode(105,"%")]}}}})(),minCameraOrbitIntrinsics=F=>{const w=MINIMUM_RADIUS_RATIO*F[$scene].boundingSphere.radius;return{basis:[numberNode(-1/0,"rad"),numberNode(0,"rad"),numberNode(w,"m")],keywords:{auto:[null,null,null]}}},maxCameraOrbitIntrinsics=F=>{const w=cameraOrbitIntrinsics(F),O=new StyleEvaluator([],w).evaluate()[2];return{basis:[numberNode(1/0,"rad"),numberNode(Math.PI,"rad"),numberNode(O,"m")],keywords:{auto:[null,null,null]}}},cameraTargetIntrinsics=F=>{const w=F[$scene].boundingBox.getCenter(new Vector3);return{basis:[numberNode(w.x,"m"),numberNode(w.y,"m"),numberNode(w.z,"m")],keywords:{auto:[null,null,null]}}},HALF_PI=Math.PI/2,THIRD_PI=Math.PI/3,QUARTER_PI=HALF_PI/2,TAU=2*Math.PI,$controls=Symbol("controls"),$panElement=Symbol("panElement"),$promptElement=Symbol("promptElement"),$promptAnimatedContainer=Symbol("promptAnimatedContainer"),$fingerAnimatedContainers=Symbol("fingerAnimatedContainers"),$deferInteractionPrompt=Symbol("deferInteractionPrompt"),$updateAria=Symbol("updateAria"),$a11y=Symbol("a11y"),$updateA11y=Symbol("updateA11y"),$updateCameraForRadius=Symbol("updateCameraForRadius"),$cancelPrompts=Symbol("cancelPrompts"),$onChange=Symbol("onChange"),$onPointerChange=Symbol("onPointerChange"),$waitingToPromptUser=Symbol("waitingToPromptUser"),$userHasInteracted=Symbol("userHasInteracted"),$promptElementVisibleTime=Symbol("promptElementVisibleTime"),$lastPromptOffset=Symbol("lastPromptOffset"),$cancellationSource=Symbol("cancellationSource"),$lastSpherical=Symbol("lastSpherical"),$jumpCamera=Symbol("jumpCamera"),$initialized=Symbol("initialized"),$maintainThetaPhi=Symbol("maintainThetaPhi"),$syncCameraOrbit=Symbol("syncCameraOrbit"),$syncFieldOfView=Symbol("syncFieldOfView"),$syncCameraTarget=Symbol("syncCameraTarget"),$syncMinCameraOrbit=Symbol("syncMinCameraOrbit"),$syncMaxCameraOrbit=Symbol("syncMaxCameraOrbit"),$syncMinFieldOfView=Symbol("syncMinFieldOfView"),$syncMaxFieldOfView=Symbol("syncMaxFieldOfView"),ControlsMixin=F=>{var w,D,O,U,G,q,K,ee,Z,ie,Y,W,ne,se,le,ce,he,pe;class me extends F{constructor(){super(...arguments),this.cameraControls=!1,this.cameraOrbit=DEFAULT_CAMERA_ORBIT,this.cameraTarget=DEFAULT_CAMERA_TARGET,this.fieldOfView=DEFAULT_FIELD_OF_VIEW,this.minCameraOrbit="auto",this.maxCameraOrbit="auto",this.minFieldOfView="auto",this.maxFieldOfView="auto",this.interactionPromptThreshold=DEFAULT_INTERACTION_PROMPT_THRESHOLD,this.interactionPrompt=InteractionPromptStrategy.AUTO,this.interactionPromptStyle=InteractionPromptStyle.WIGGLE,this.orbitSensitivity=1,this.zoomSensitivity=1,this.panSensitivity=1,this.touchAction=TouchAction.NONE,this.disableZoom=!1,this.disablePan=!1,this.disableTap=!1,this.interpolationDecay=DECAY_MILLISECONDS,this.a11y=null,this[w]=this.shadowRoot.querySelector(".interaction-prompt"),this[D]=this.shadowRoot.querySelector("#prompt"),this[O]=[this.shadowRoot.querySelector("#finger0"),this.shadowRoot.querySelector("#finger1")],this[U]=this.shadowRoot.querySelector(".pan-target"),this[G]=0,this[q]=1/0,this[K]=!1,this[ee]=!1,this[Z]=ChangeSource.AUTOMATIC,this[ie]=new SmoothControls(this[$scene].camera,this[$userInputElement],this[$scene]),this[Y]=new Spherical,this[W]=!1,this[ne]=!1,this[se]=!1,this[le]={},this[ce]=()=>{const ge=this[$controls].changeSource;this[$cancellationSource]=ge,ge===ChangeSource.USER_INTERACTION&&(this[$userHasInteracted]=!0,this[$deferInteractionPrompt]())},this[he]=()=>{this[$updateAria](),this[$needsRender]();const ge=this[$controls].changeSource;this.dispatchEvent(new CustomEvent("camera-change",{detail:{source:ge}}))},this[pe]=ge=>{this[$container].classList.toggle("pointer-tumbling",ge.type==="pointer-change-start")}}get inputSensitivity(){return this[$controls].inputSensitivity}set inputSensitivity(ge){this[$controls].inputSensitivity=ge}getCameraOrbit(){const{theta:ge,phi:ve,radius:Se}=this[$lastSpherical];return{theta:ge,phi:ve,radius:Se,toString(){return`${this.theta}rad ${this.phi}rad ${this.radius}m`}}}getCameraTarget(){return toVector3D(this[$renderer].isPresenting?this[$renderer].arRenderer.target:this[$scene].getDynamicTarget())}getFieldOfView(){return this[$controls].getFieldOfView()}getMinimumFieldOfView(){return this[$controls].options.minimumFieldOfView}getMaximumFieldOfView(){return this[$controls].options.maximumFieldOfView}getIdealAspect(){return this[$scene].idealAspect}jumpCameraToGoal(){this[$jumpCamera]=!0,this.requestUpdate($jumpCamera,!1)}resetInteractionPrompt(){this[$lastPromptOffset]=0,this[$promptElementVisibleTime]=1/0,this[$userHasInteracted]=!1,this[$waitingToPromptUser]=this.interactionPrompt===InteractionPromptStrategy.AUTO&&this.cameraControls}zoom(ge){const ve=new WheelEvent("wheel",{deltaY:-30*ge});this[$userInputElement].dispatchEvent(ve)}connectedCallback(){super.connectedCallback(),this[$controls].addEventListener("user-interaction",this[$cancelPrompts]),this[$controls].addEventListener("pointer-change-start",this[$onPointerChange]),this[$controls].addEventListener("pointer-change-end",this[$onPointerChange])}disconnectedCallback(){super.disconnectedCallback(),this[$controls].removeEventListener("user-interaction",this[$cancelPrompts]),this[$controls].removeEventListener("pointer-change-start",this[$onPointerChange]),this[$controls].removeEventListener("pointer-change-end",this[$onPointerChange])}updated(ge){super.updated(ge);const ve=this[$controls],Se=this[$scene];if(ge.has("cameraControls")&&(this.cameraControls?(ve.enableInteraction(),this.interactionPrompt===InteractionPromptStrategy.AUTO&&(this[$waitingToPromptUser]=!0)):(ve.disableInteraction(),this[$deferInteractionPrompt]()),this[$userInputElement].setAttribute("aria-label",this[$ariaLabel])),ge.has("disableZoom")&&(ve.disableZoom=this.disableZoom),ge.has("disablePan")&&(ve.enablePan=!this.disablePan),ge.has("disableTap")&&(ve.enableTap=!this.disableTap),(ge.has("interactionPrompt")||ge.has("cameraControls")||ge.has("src"))&&(this.interactionPrompt===InteractionPromptStrategy.AUTO&&this.cameraControls&&!this[$userHasInteracted]?this[$waitingToPromptUser]=!0:this[$deferInteractionPrompt]()),ge.has("interactionPromptStyle")&&(this[$promptAnimatedContainer].style.opacity=this.interactionPromptStyle==InteractionPromptStyle.BASIC?"1":"0"),ge.has("touchAction")){const Me=this.touchAction;ve.applyOptions({touchAction:Me}),ve.updateTouchActionStyle()}ge.has("orbitSensitivity")&&(ve.orbitSensitivity=this.orbitSensitivity),ge.has("zoomSensitivity")&&(ve.zoomSensitivity=this.zoomSensitivity),ge.has("panSensitivity")&&(ve.panSensitivity=this.panSensitivity),ge.has("interpolationDecay")&&(ve.setDamperDecayTime(this.interpolationDecay),Se.setTargetDamperDecayTime(this.interpolationDecay)),ge.has("a11y")&&this[$updateA11y](),this[$jumpCamera]===!0&&Promise.resolve().then(()=>{ve.jumpToGoal(),Se.jumpToGoal(),this[$onChange](),this[$jumpCamera]=!1})}async updateFraming(){const ge=this[$scene],ve=ge.adjustedFoV(ge.framedFoVDeg);await ge.updateFraming();const Se=ge.adjustedFoV(ge.framedFoVDeg),Me=this[$controls].getFieldOfView()/ve;this[$controls].setFieldOfView(Se*Me),this[$maintainThetaPhi]=!0,this.requestUpdate("maxFieldOfView"),this.requestUpdate("fieldOfView"),this.requestUpdate("minCameraOrbit"),this.requestUpdate("maxCameraOrbit"),this.requestUpdate("cameraOrbit"),await this.updateComplete}interact(ge,ve,Se){const Me=this[$userInputElement],Ee=this[$fingerAnimatedContainers];if(Ee[0].style.opacity==="1"){console.warn("interact() failed because an existing interaction is running.");return}const we=new Array;we.push({x:timeline(ve.x),y:timeline(ve.y)});const Re=[{x:we[0].x(0),y:we[0].y(0)}];Se!=null&&(we.push({x:timeline(Se.x),y:timeline(Se.y)}),Re.push({x:we[1].x(0),y:we[1].y(0)}));let Le=performance.now();const{width:Ne,height:Oe}=this[$scene],Pe=this.getBoundingClientRect(),Ce=Xe=>{for(const[lt,ke]of Re.entries()){const{style:rt}=Ee[lt];rt.transform=`translateX(${Ne*ke.x}px) translateY(${Oe*ke.y}px)`,Xe==="pointerdown"?rt.opacity="1":Xe==="pointerup"&&(rt.opacity="0");const St={pointerId:lt-5678,pointerType:"touch",target:Me,clientX:Ne*ke.x+Pe.x,clientY:Oe*ke.y+Pe.y,altKey:!0};Me.dispatchEvent(new PointerEvent(Xe,St))}},Be=()=>{const Xe=this[$cancellationSource];if(Xe!==ChangeSource.AUTOMATIC||!Me.isConnected){for(const ke of this[$fingerAnimatedContainers])ke.style.opacity="0";Ce("pointercancel"),this.dispatchEvent(new CustomEvent("interact-stopped",{detail:{source:Xe}})),document.removeEventListener("visibilitychange",ze);return}const lt=Math.min(1,(performance.now()-Le)/ge);for(const[ke,rt]of Re.entries())rt.x=we[ke].x(lt),rt.y=we[ke].y(lt);Ce("pointermove"),lt<1?requestAnimationFrame(Be):(Ce("pointerup"),this.dispatchEvent(new CustomEvent("interact-stopped",{detail:{source:ChangeSource.AUTOMATIC}})),document.removeEventListener("visibilitychange",ze))},ze=()=>{let Xe=0;document.visibilityState==="hidden"?Xe=performance.now()-Le:Le=performance.now()-Xe};document.addEventListener("visibilitychange",ze),Ce("pointerdown"),this[$cancellationSource]=ChangeSource.AUTOMATIC,requestAnimationFrame(Be)}[(w=$promptElement,D=$promptAnimatedContainer,O=$fingerAnimatedContainers,U=$panElement,G=$lastPromptOffset,q=$promptElementVisibleTime,K=$userHasInteracted,ee=$waitingToPromptUser,Z=$cancellationSource,ie=$controls,Y=$lastSpherical,W=$jumpCamera,ne=$initialized,se=$maintainThetaPhi,le=$a11y,$syncFieldOfView)](ge){const ve=this[$controls],Se=this[$scene];Se.framedFoVDeg=ge[0]*180/Math.PI,ve.changeSource=ChangeSource.NONE,ve.setFieldOfView(Se.adjustedFoV(Se.framedFoVDeg)),this[$cancelPrompts]()}[$syncCameraOrbit](ge){const ve=this[$controls];if(this[$maintainThetaPhi]){const{theta:Se,phi:Me}=this.getCameraOrbit();ge[0]=Se,ge[1]=Me,this[$maintainThetaPhi]=!1}ve.changeSource=ChangeSource.NONE,ve.setOrbit(ge[0],ge[1],ge[2]),this[$cancelPrompts]()}[$syncMinCameraOrbit](ge){this[$controls].applyOptions({minimumAzimuthalAngle:ge[0],minimumPolarAngle:ge[1],minimumRadius:ge[2]}),this.jumpCameraToGoal()}[$syncMaxCameraOrbit](ge){this[$controls].applyOptions({maximumAzimuthalAngle:ge[0],maximumPolarAngle:ge[1],maximumRadius:ge[2]}),this[$updateCameraForRadius](ge[2]),this.jumpCameraToGoal()}[$syncMinFieldOfView](ge){this[$controls].applyOptions({minimumFieldOfView:ge[0]*180/Math.PI}),this.jumpCameraToGoal()}[$syncMaxFieldOfView](ge){const ve=this[$scene].adjustedFoV(ge[0]*180/Math.PI);this[$controls].applyOptions({maximumFieldOfView:ve}),this.jumpCameraToGoal()}[$syncCameraTarget](ge){const[ve,Se,Me]=ge;this[$renderer].arRenderer.isPresenting||this[$scene].setTarget(ve,Se,Me),this[$controls].changeSource=ChangeSource.NONE,this[$renderer].arRenderer.updateTarget(),this[$cancelPrompts]()}[$tick](ge,ve){if(super[$tick](ge,ve),this[$renderer].isPresenting||!this[$getModelIsVisible]())return;const Se=this[$controls],Me=this[$scene],Ee=performance.now();if(this[$waitingToPromptUser]&&this.loaded&&Ee>this[$loadedTime]+this.interactionPromptThreshold&&(this[$waitingToPromptUser]=!1,this[$promptElementVisibleTime]=Ee,this[$promptElement].classList.add("visible")),isFinite(this[$promptElementVisibleTime])&&this.interactionPromptStyle===InteractionPromptStyle.WIGGLE){const Le=(Ee-this[$promptElementVisibleTime])/PROMPT_ANIMATION_TIME%1,Ne=wiggle(Le),Oe=fade(Le);if(this[$promptAnimatedContainer].style.opacity=`${Oe}`,Ne!==this[$lastPromptOffset]){const Pe=Ne*Me.width*.05,Ce=(Ne-this[$lastPromptOffset])*Math.PI/16;this[$promptAnimatedContainer].style.transform=`translateX(${Pe}px)`,Se.changeSource=ChangeSource.AUTOMATIC,Se.adjustOrbit(Ce,0,0),this[$lastPromptOffset]=Ne}}const we=Se.update(ge,ve),Re=Me.updateTarget(ve);(we||Re)&&this[$onChange]()}[$deferInteractionPrompt](){this[$waitingToPromptUser]=!1,this[$promptElement].classList.remove("visible"),this[$promptElementVisibleTime]=1/0}[$updateCameraForRadius](ge){const ve=Math.max(this[$scene].farRadius(),ge),Se=0,Me=Math.abs(2*ve);this[$controls].updateNearFar(Se,Me)}[$updateAria](){const{theta:ge,phi:ve}=this[$controls].getCameraSpherical(this[$lastSpherical]),Se=(4+Math.floor((ge%TAU+QUARTER_PI)/HALF_PI))%4,Me=Math.floor(ve/THIRD_PI),Ee=AZIMUTHAL_QUADRANT_LABELS[Se],Re=`${POLAR_TRIENT_LABELS[Me]}${Ee}`,Le=Re;Le in this[$a11y]?this[$updateStatus](this[$a11y][Le]):this[$updateStatus](`View from stage ${Re}`)}get[$ariaLabel](){let ge=INTERACTION_PROMPT;return"interaction-prompt"in this[$a11y]&&(ge=`. ${this[$a11y]["interaction-prompt"]}`),super[$ariaLabel].replace(/\.$/,"")+(this.cameraControls?ge:"")}async[$onResize](ge){const ve=this[$controls],Se=this[$scene],Me=Se.adjustedFoV(Se.framedFoVDeg);super[$onResize](ge);const Ee=Se.adjustedFoV(Se.framedFoVDeg)/Me,we=ve.getFieldOfView()*(isFinite(Ee)?Ee:1);ve.updateAspect(this[$scene].aspect),this.requestUpdate("maxFieldOfView",this.maxFieldOfView),await this.updateComplete,this[$controls].setFieldOfView(we),this.jumpCameraToGoal()}[$onModelLoad](){super[$onModelLoad](),this[$initialized]?this[$maintainThetaPhi]=!0:this[$initialized]=!0,this.requestUpdate("maxFieldOfView",this.maxFieldOfView),this.requestUpdate("fieldOfView",this.fieldOfView),this.requestUpdate("minCameraOrbit",this.minCameraOrbit),this.requestUpdate("maxCameraOrbit",this.maxCameraOrbit),this.requestUpdate("cameraOrbit",this.cameraOrbit),this.requestUpdate("cameraTarget",this.cameraTarget),this.jumpCameraToGoal()}[(ce=$cancelPrompts,he=$onChange,pe=$onPointerChange,$updateA11y)](){if(typeof this.a11y=="string")if(this.a11y.startsWith("{"))try{this[$a11y]=JSON.parse(this.a11y)}catch(ge){console.warn("Error parsing a11y JSON:",ge)}else this.a11y.length>0?console.warn("Error not supported format, should be a JSON string:",this.a11y):this[$a11y]={};else typeof this.a11y=="object"&&this.a11y!=null?this[$a11y]=Object.assign({},this.a11y):this[$a11y]={};this[$userInputElement].setAttribute("aria-label",this[$ariaLabel])}}return __decorate$6([n$2({type:Boolean,attribute:"camera-controls"})],me.prototype,"cameraControls",void 0),__decorate$6([style({intrinsics:cameraOrbitIntrinsics,observeEffects:!0,updateHandler:$syncCameraOrbit}),n$2({type:String,attribute:"camera-orbit",hasChanged:()=>!0})],me.prototype,"cameraOrbit",void 0),__decorate$6([style({intrinsics:cameraTargetIntrinsics,observeEffects:!0,updateHandler:$syncCameraTarget}),n$2({type:String,attribute:"camera-target",hasChanged:()=>!0})],me.prototype,"cameraTarget",void 0),__decorate$6([style({intrinsics:fieldOfViewIntrinsics,observeEffects:!0,updateHandler:$syncFieldOfView}),n$2({type:String,attribute:"field-of-view",hasChanged:()=>!0})],me.prototype,"fieldOfView",void 0),__decorate$6([style({intrinsics:minCameraOrbitIntrinsics,updateHandler:$syncMinCameraOrbit}),n$2({type:String,attribute:"min-camera-orbit",hasChanged:()=>!0})],me.prototype,"minCameraOrbit",void 0),__decorate$6([style({intrinsics:maxCameraOrbitIntrinsics,updateHandler:$syncMaxCameraOrbit}),n$2({type:String,attribute:"max-camera-orbit",hasChanged:()=>!0})],me.prototype,"maxCameraOrbit",void 0),__decorate$6([style({intrinsics:minFieldOfViewIntrinsics,updateHandler:$syncMinFieldOfView}),n$2({type:String,attribute:"min-field-of-view",hasChanged:()=>!0})],me.prototype,"minFieldOfView",void 0),__decorate$6([style({intrinsics:fieldOfViewIntrinsics,updateHandler:$syncMaxFieldOfView}),n$2({type:String,attribute:"max-field-of-view",hasChanged:()=>!0})],me.prototype,"maxFieldOfView",void 0),__decorate$6([n$2({type:Number,attribute:"interaction-prompt-threshold"})],me.prototype,"interactionPromptThreshold",void 0),__decorate$6([n$2({type:String,attribute:"interaction-prompt"})],me.prototype,"interactionPrompt",void 0),__decorate$6([n$2({type:String,attribute:"interaction-prompt-style"})],me.prototype,"interactionPromptStyle",void 0),__decorate$6([n$2({type:Number,attribute:"orbit-sensitivity"})],me.prototype,"orbitSensitivity",void 0),__decorate$6([n$2({type:Number,attribute:"zoom-sensitivity"})],me.prototype,"zoomSensitivity",void 0),__decorate$6([n$2({type:Number,attribute:"pan-sensitivity"})],me.prototype,"panSensitivity",void 0),__decorate$6([n$2({type:String,attribute:"touch-action"})],me.prototype,"touchAction",void 0),__decorate$6([n$2({type:Boolean,attribute:"disable-zoom"})],me.prototype,"disableZoom",void 0),__decorate$6([n$2({type:Boolean,attribute:"disable-pan"})],me.prototype,"disablePan",void 0),__decorate$6([n$2({type:Boolean,attribute:"disable-tap"})],me.prototype,"disableTap",void 0),__decorate$6([n$2({type:Number,attribute:"interpolation-decay"})],me.prototype,"interpolationDecay",void 0),__decorate$6([n$2()],me.prototype,"a11y",void 0),me};/* @license
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */const PAN_SENSITIVITY=.018,TAP_DISTANCE=2,TAP_MS=300,vector2=new Vector2,vector3$2=new Vector3,DEFAULT_OPTIONS=Object.freeze({minimumRadius:0,maximumRadius:1/0,minimumPolarAngle:0,maximumPolarAngle:Math.PI,minimumAzimuthalAngle:-1/0,maximumAzimuthalAngle:1/0,minimumFieldOfView:10,maximumFieldOfView:45,touchAction:"none"}),KEYBOARD_ORBIT_INCREMENT=Math.PI/8,ZOOM_SENSITIVITY=.04,PAN_KEY_INCREMENT=10,ChangeSource={USER_INTERACTION:"user-interaction",NONE:"none",AUTOMATIC:"automatic"};class SmoothControls extends EventDispatcher{constructor(w,D,O){super(),this.camera=w,this.element=D,this.scene=O,this.orbitSensitivity=1,this.zoomSensitivity=1,this.panSensitivity=1,this.inputSensitivity=1,this.changeSource=ChangeSource.NONE,this._interactionEnabled=!1,this._disableZoom=!1,this.isUserPointing=!1,this.enablePan=!0,this.enableTap=!0,this.panProjection=new Matrix3,this.panPerPixel=0,this.spherical=new Spherical,this.goalSpherical=new Spherical,this.thetaDamper=new Damper,this.phiDamper=new Damper,this.radiusDamper=new Damper,this.logFov=Math.log(DEFAULT_OPTIONS.maximumFieldOfView),this.goalLogFov=this.logFov,this.fovDamper=new Damper,this.touchMode=null,this.pointers=[],this.startTime=0,this.startPointerPosition={clientX:0,clientY:0},this.lastSeparation=0,this.touchDecided=!1,this.onContext=U=>{if(this.enablePan)U.preventDefault();else for(const G of this.pointers)this.onPointerUp(new PointerEvent("pointercancel",Object.assign(Object.assign({},this.startPointerPosition),{pointerId:G.id})))},this.touchModeZoom=(U,G)=>{if(!this._disableZoom){const q=this.twoTouchDistance(this.pointers[0],this.pointers[1]),K=ZOOM_SENSITIVITY*this.zoomSensitivity*(this.lastSeparation-q)*50/this.scene.height;this.lastSeparation=q,this.userAdjustOrbit(0,0,K)}this.panPerPixel>0&&this.movePan(U,G)},this.disableScroll=U=>{U.preventDefault()},this.touchModeRotate=(U,G)=>{const{touchAction:q}=this._options;if(!this.touchDecided&&q!=="none"){this.touchDecided=!0;const K=Math.abs(U),ee=Math.abs(G);if(this.changeSource===ChangeSource.USER_INTERACTION&&(q==="pan-y"&&ee>K||q==="pan-x"&&K>ee)){this.touchMode=null;return}else this.element.addEventListener("touchmove",this.disableScroll,{passive:!1})}this.handleSinglePointerMove(U,G)},this.onPointerDown=U=>{if(this.pointers.length>2)return;const{element:G}=this;this.pointers.length===0&&(G.addEventListener("pointermove",this.onPointerMove),G.addEventListener("pointerup",this.onPointerUp),this.touchMode=null,this.touchDecided=!1,this.startPointerPosition.clientX=U.clientX,this.startPointerPosition.clientY=U.clientY,this.startTime=performance.now());try{G.setPointerCapture(U.pointerId)}catch{}this.pointers.push({clientX:U.clientX,clientY:U.clientY,id:U.pointerId}),this.isUserPointing=!1,U.pointerType==="touch"?(this.changeSource=U.altKey?ChangeSource.AUTOMATIC:ChangeSource.USER_INTERACTION,this.onTouchChange(U)):(this.changeSource=ChangeSource.USER_INTERACTION,this.onMouseDown(U)),this.changeSource===ChangeSource.USER_INTERACTION&&this.dispatchEvent({type:"user-interaction"})},this.onPointerMove=U=>{const G=this.pointers.find(Z=>Z.id===U.pointerId);if(G==null)return;if(U.pointerType==="mouse"&&U.buttons===0){this.onPointerUp(U);return}const q=this.pointers.length,K=(U.clientX-G.clientX)/q,ee=(U.clientY-G.clientY)/q;K===0&&ee===0||(G.clientX=U.clientX,G.clientY=U.clientY,U.pointerType==="touch"?(this.changeSource=U.altKey?ChangeSource.AUTOMATIC:ChangeSource.USER_INTERACTION,this.touchMode!==null&&this.touchMode(K,ee)):(this.changeSource=ChangeSource.USER_INTERACTION,this.panPerPixel>0?this.movePan(K,ee):this.handleSinglePointerMove(K,ee)))},this.onPointerUp=U=>{const{element:G}=this,q=this.pointers.findIndex(K=>K.id===U.pointerId);q!==-1&&this.pointers.splice(q,1),this.panPerPixel>0&&!U.altKey&&this.resetRadius(),this.pointers.length===0?(G.removeEventListener("pointermove",this.onPointerMove),G.removeEventListener("pointerup",this.onPointerUp),G.removeEventListener("touchmove",this.disableScroll),this.enablePan&&this.enableTap&&this.recenter(U)):this.touchMode!==null&&this.onTouchChange(U),this.scene.element[$panElement].style.opacity=0,G.style.cursor="grab",this.panPerPixel=0,this.isUserPointing&&this.dispatchEvent({type:"pointer-change-end"})},this.onWheel=U=>{this.changeSource=ChangeSource.USER_INTERACTION;const G=U.deltaY*(U.deltaMode==1?18:1)*ZOOM_SENSITIVITY*this.zoomSensitivity/30;this.userAdjustOrbit(0,0,G),U.preventDefault(),this.dispatchEvent({type:"user-interaction"})},this.onKeyDown=U=>{const{changeSource:G}=this;this.changeSource=ChangeSource.USER_INTERACTION,(U.shiftKey&&this.enablePan?this.panKeyCodeHandler(U):this.orbitZoomKeyCodeHandler(U))?(U.preventDefault(),this.dispatchEvent({type:"user-interaction"})):this.changeSource=G},this._options=Object.assign({},DEFAULT_OPTIONS),this.setOrbit(0,Math.PI/2,1),this.setFieldOfView(100),this.jumpToGoal()}get interactionEnabled(){return this._interactionEnabled}enableInteraction(){if(this._interactionEnabled===!1){const{element:w}=this;w.addEventListener("pointerdown",this.onPointerDown),w.addEventListener("pointercancel",this.onPointerUp),this._disableZoom||w.addEventListener("wheel",this.onWheel),w.addEventListener("keydown",this.onKeyDown),w.addEventListener("touchmove",()=>{},{passive:!1}),w.addEventListener("contextmenu",this.onContext),this.element.style.cursor="grab",this._interactionEnabled=!0,this.updateTouchActionStyle()}}disableInteraction(){if(this._interactionEnabled===!0){const{element:w}=this;w.removeEventListener("pointerdown",this.onPointerDown),w.removeEventListener("pointermove",this.onPointerMove),w.removeEventListener("pointerup",this.onPointerUp),w.removeEventListener("pointercancel",this.onPointerUp),w.removeEventListener("wheel",this.onWheel),w.removeEventListener("keydown",this.onKeyDown),w.removeEventListener("contextmenu",this.onContext),w.style.cursor="",this.touchMode=null,this._interactionEnabled=!1,this.updateTouchActionStyle()}}get options(){return this._options}set disableZoom(w){this._disableZoom!=w&&(this._disableZoom=w,w===!0?this.element.removeEventListener("wheel",this.onWheel):this.element.addEventListener("wheel",this.onWheel),this.updateTouchActionStyle())}getCameraSpherical(w=new Spherical){return w.copy(this.spherical)}getFieldOfView(){return this.camera.fov}applyOptions(w){Object.assign(this._options,w),this.setOrbit(),this.setFieldOfView(Math.exp(this.goalLogFov))}updateNearFar(w,D){this.camera.far=D===0?2:D,this.camera.near=Math.max(w,this.camera.far/1e3),this.camera.updateProjectionMatrix()}updateAspect(w){this.camera.aspect=w,this.camera.updateProjectionMatrix()}setOrbit(w=this.goalSpherical.theta,D=this.goalSpherical.phi,O=this.goalSpherical.radius){const{minimumAzimuthalAngle:U,maximumAzimuthalAngle:G,minimumPolarAngle:q,maximumPolarAngle:K,minimumRadius:ee,maximumRadius:Z}=this._options,{theta:ie,phi:Y,radius:W}=this.goalSpherical,ne=clamp$1(w,U,G);!isFinite(U)&&!isFinite(G)&&(this.spherical.theta=this.wrapAngle(this.spherical.theta-ne)+ne);const se=clamp$1(D,q,K),le=clamp$1(O,ee,Z);return ne===ie&&se===Y&&le===W||!isFinite(ne)||!isFinite(se)||!isFinite(le)?!1:(this.goalSpherical.theta=ne,this.goalSpherical.phi=se,this.goalSpherical.radius=le,this.goalSpherical.makeSafe(),!0)}setRadius(w){this.goalSpherical.radius=w,this.setOrbit()}setFieldOfView(w){const{minimumFieldOfView:D,maximumFieldOfView:O}=this._options;w=clamp$1(w,D,O),this.goalLogFov=Math.log(w)}setDamperDecayTime(w){this.thetaDamper.setDecayTime(w),this.phiDamper.setDecayTime(w),this.radiusDamper.setDecayTime(w),this.fovDamper.setDecayTime(w)}adjustOrbit(w,D,O){const{theta:U,phi:G,radius:q}=this.goalSpherical,{minimumRadius:K,maximumRadius:ee,minimumFieldOfView:Z,maximumFieldOfView:ie}=this._options,Y=this.spherical.theta-U,W=Math.PI-.001,ne=U-clamp$1(w,-W-Y,W-Y),se=G-D,le=O===0?0:((O>0?ee:K)-q)/(Math.log(O>0?ie:Z)-this.goalLogFov),ce=q+O*(isFinite(le)?le:(ee-K)*2);if(this.setOrbit(ne,se,ce),O!==0){const he=this.goalLogFov+O;this.setFieldOfView(Math.exp(he))}}jumpToGoal(){this.update(0,SETTLING_TIME)}update(w,D){if(this.isStationary())return!1;const{maximumPolarAngle:O,maximumRadius:U}=this._options,G=this.spherical.theta-this.goalSpherical.theta;return Math.abs(G)>Math.PI&&!isFinite(this._options.minimumAzimuthalAngle)&&!isFinite(this._options.maximumAzimuthalAngle)&&(this.spherical.theta-=Math.sign(G)*2*Math.PI),this.spherical.theta=this.thetaDamper.update(this.spherical.theta,this.goalSpherical.theta,D,Math.PI),this.spherical.phi=this.phiDamper.update(this.spherical.phi,this.goalSpherical.phi,D,O),this.spherical.radius=this.radiusDamper.update(this.spherical.radius,this.goalSpherical.radius,D,U),this.logFov=this.fovDamper.update(this.logFov,this.goalLogFov,D,1),this.moveCamera(),!0}updateTouchActionStyle(){const{style:w}=this.element;if(this._interactionEnabled){const{touchAction:D}=this._options;this._disableZoom&&D!=="none"?w.touchAction="manipulation":w.touchAction=D}else w.touchAction=""}isStationary(){return this.goalSpherical.theta===this.spherical.theta&&this.goalSpherical.phi===this.spherical.phi&&this.goalSpherical.radius===this.spherical.radius&&this.goalLogFov===this.logFov}moveCamera(){this.spherical.makeSafe(),this.camera.position.setFromSpherical(this.spherical),this.camera.setRotationFromEuler(new Euler(this.spherical.phi-Math.PI/2,this.spherical.theta,0,"YXZ")),this.camera.fov!==Math.exp(this.logFov)&&(this.camera.fov=Math.exp(this.logFov),this.camera.updateProjectionMatrix())}userAdjustOrbit(w,D,O){this.adjustOrbit(w*this.orbitSensitivity*this.inputSensitivity,D*this.orbitSensitivity*this.inputSensitivity,O*this.inputSensitivity)}wrapAngle(w){const D=(w+Math.PI)/(2*Math.PI);return(D-Math.floor(D))*2*Math.PI-Math.PI}pixelLengthToSphericalAngle(w){return 2*Math.PI*w/this.scene.height}twoTouchDistance(w,D){const{clientX:O,clientY:U}=w,{clientX:G,clientY:q}=D,K=G-O,ee=q-U;return Math.sqrt(K*K+ee*ee)}handleSinglePointerMove(w,D){const O=this.pixelLengthToSphericalAngle(w),U=this.pixelLengthToSphericalAngle(D);this.isUserPointing===!1&&(this.isUserPointing=!0,this.dispatchEvent({type:"pointer-change-start"})),this.userAdjustOrbit(O,U,0)}initializePan(){const{theta:w,phi:D}=this.spherical,O=w-this.scene.yaw;this.panPerPixel=PAN_SENSITIVITY*this.panSensitivity/this.scene.height,this.panProjection.set(-Math.cos(O),-Math.cos(D)*Math.sin(O),0,0,Math.sin(D),0,Math.sin(O),-Math.cos(D)*Math.cos(O),0)}movePan(w,D){const{scene:O}=this,U=vector3$2.set(w,D,0).multiplyScalar(this.inputSensitivity),G=this.spherical.radius*Math.exp(this.logFov)*this.panPerPixel;U.multiplyScalar(G);const q=O.getTarget();q.add(U.applyMatrix3(this.panProjection)),O.boundingSphere.clampPoint(q,q),O.setTarget(q.x,q.y,q.z)}recenter(w){if(performance.now()>this.startTime+TAP_MS||Math.abs(w.clientX-this.startPointerPosition.clientX)>TAP_DISTANCE||Math.abs(w.clientY-this.startPointerPosition.clientY)>TAP_DISTANCE)return;const{scene:D}=this,O=D.positionAndNormalFromPoint(D.getNDC(w.clientX,w.clientY));if(O==null){const{cameraTarget:U}=D.element;D.element.cameraTarget="",D.element.cameraTarget=U,this.userAdjustOrbit(0,0,1)}else D.target.worldToLocal(O.position),D.setTarget(O.position.x,O.position.y,O.position.z)}resetRadius(){const{scene:w}=this,D=w.positionAndNormalFromPoint(vector2.set(0,0));if(D==null)return;w.target.worldToLocal(D.position);const O=w.getTarget(),{theta:U,phi:G}=this.spherical,q=U-w.yaw,K=vector3$2.set(Math.sin(G)*Math.sin(q),Math.cos(G),Math.sin(G)*Math.cos(q)),ee=K.dot(D.position.sub(O));O.add(K.multiplyScalar(ee)),w.setTarget(O.x,O.y,O.z),this.setOrbit(void 0,void 0,this.goalSpherical.radius-ee)}onTouchChange(w){if(this.pointers.length===1)this.touchMode=this.touchModeRotate;else{if(this._disableZoom){this.touchMode=null,this.element.removeEventListener("touchmove",this.disableScroll);return}this.touchMode=this.touchDecided&&this.touchMode===null?null:this.touchModeZoom,this.touchDecided=!0,this.element.addEventListener("touchmove",this.disableScroll,{passive:!1}),this.lastSeparation=this.twoTouchDistance(this.pointers[0],this.pointers[1]),this.enablePan&&this.touchMode!=null&&(this.initializePan(),w.altKey||(this.scene.element[$panElement].style.opacity=1))}}onMouseDown(w){this.panPerPixel=0,this.enablePan&&(w.button===2||w.ctrlKey||w.metaKey||w.shiftKey)&&(this.initializePan(),this.scene.element[$panElement].style.opacity=1),this.element.style.cursor="grabbing"}orbitZoomKeyCodeHandler(w){let D=!0;switch(w.key){case"PageUp":this.userAdjustOrbit(0,0,ZOOM_SENSITIVITY*this.zoomSensitivity);break;case"PageDown":this.userAdjustOrbit(0,0,-1*ZOOM_SENSITIVITY*this.zoomSensitivity);break;case"ArrowUp":this.userAdjustOrbit(0,-KEYBOARD_ORBIT_INCREMENT,0);break;case"ArrowDown":this.userAdjustOrbit(0,KEYBOARD_ORBIT_INCREMENT,0);break;case"ArrowLeft":this.userAdjustOrbit(-KEYBOARD_ORBIT_INCREMENT,0,0);break;case"ArrowRight":this.userAdjustOrbit(KEYBOARD_ORBIT_INCREMENT,0,0);break;default:D=!1;break}return D}panKeyCodeHandler(w){this.initializePan();let D=!0;switch(w.key){case"ArrowUp":this.movePan(0,-1*PAN_KEY_INCREMENT);break;case"ArrowDown":this.movePan(0,PAN_KEY_INCREMENT);break;case"ArrowLeft":this.movePan(-1*PAN_KEY_INCREMENT,0);break;case"ArrowRight":this.movePan(PAN_KEY_INCREMENT,0);break;default:D=!1;break}return D}}/* @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */const INIT_FRAMES=30,AR_SHADOW_INTENSITY=.8,ROTATION_RATE=1.5,HIT_ANGLE_DEG=20,SCALE_SNAP=.2,MIN_VIEWPORT_SCALE=.25,MAX_DISTANCE=10,DECAY=150,MAX_LINE_LENGTH=5,BOX_SIZE=.1,ARStatus={NOT_PRESENTING:"not-presenting",SESSION_STARTED:"session-started",OBJECT_PLACED:"object-placed",FAILED:"failed"},ARTracking={TRACKING:"tracking",NOT_TRACKING:"not-tracking"},vector3$1=new Vector3,quaternion=new Quaternion,matrix4=new Matrix4,hitPosition=new Vector3,camera=new PerspectiveCamera(45,1,.1,100),lineGeometry=new BufferGeometry().setFromPoints([new Vector3(0,0,0),new Vector3(0,0,-1)]),boxGeometry=new BoxGeometry;class ARRenderer extends EventDispatcher{constructor(w){super(),this.renderer=w,this.currentSession=null,this.placeOnWall=!1,this.placementBox=null,this.lastTick=null,this.turntableRotation=null,this.oldShadowIntensity=null,this.frame=null,this.initialHitSource=null,this.transientHitTestSource=null,this.inputSource=null,this._presentedScene=null,this.resolveCleanup=null,this.exitWebXRButtonContainer=null,this.overlay=null,this.xrLight=null,this.xrMode=null,this.controller1=null,this.controller2=null,this.selectedController=null,this.tracking=!0,this.frames=0,this.initialized=!1,this.oldTarget=new Vector3,this.placementComplete=!1,this.isTranslating=!1,this.isRotating=!1,this.isTwoFingering=!1,this.lastDragPosition=new Vector3,this.relativeOrientation=new Quaternion,this.scaleLine=new Line(lineGeometry),this.firstRatio=0,this.lastAngle=0,this.goalPosition=new Vector3,this.goalYaw=0,this.goalScale=1,this.xDamper=new Damper,this.yDamper=new Damper,this.zDamper=new Damper,this.yawDamper=new Damper,this.pitchDamper=new Damper,this.rollDamper=new Damper,this.scaleDamper=new Damper,this.onExitWebXRButtonContainerClick=()=>this.stopPresenting(),this.onControllerSelectStart=D=>{const O=this.presentedScene,U=D.target;if(this.placementBox.controllerIntersection(O,U)!=null)this.selectedController!=null&&(this.selectedController.userData.line.visible=!1,O.canScale&&(this.isTwoFingering=!0,this.firstRatio=this.controllerSeparation()/O.pivot.scale.x,this.scaleLine.visible=!0)),U.attach(O.pivot),this.selectedController=U,O.setShadowIntensity(.01);else{const G=U===this.controller1?this.controller2:this.controller1;this.relativeOrientation.copy(U.quaternion).invert().multiply(O.pivot.getWorldQuaternion(quaternion)),G.userData.turning=!1,U.userData.turning=!0,U.userData.line.visible=!1}},this.onControllerSelectEnd=D=>{const O=D.target;if(O.userData.turning=!1,O.userData.line.visible=!0,this.isTwoFingering=!1,this.scaleLine.visible=!1,this.selectedController!=null&&this.selectedController!=O)return;const U=this.presentedScene;U.attach(U.pivot),this.selectedController=null,this.goalYaw=Math.atan2(U.pivot.matrix.elements[8],U.pivot.matrix.elements[10]),this.goalPosition.x=U.pivot.position.x,this.goalPosition.z=U.pivot.position.z},this.onUpdateScene=()=>{this.placementBox!=null&&this.isPresenting&&(this.placementBox.dispose(),this.placementBox=new PlacementBox(this.presentedScene,this.placeOnWall?"back":"bottom"))},this.onSelectStart=D=>{const O=this.transientHitTestSource;if(O==null)return;const U=this.frame.getHitTestResultsForTransientInput(O),G=this.presentedScene,q=this.placementBox;if(U.length===1){this.inputSource=D.inputSource;const{axes:K}=this.inputSource.gamepad,ee=q.getHit(this.presentedScene,K[0],K[1]);q.show=!0,ee!=null?(this.isTranslating=!0,this.lastDragPosition.copy(ee)):this.placeOnWall===!1&&(this.isRotating=!0,this.lastAngle=K[0]*ROTATION_RATE)}else if(U.length===2){q.show=!0,this.isTwoFingering=!0;const{separation:K}=this.fingerPolar(U);this.firstRatio=K/G.pivot.scale.x}},this.onSelectEnd=()=>{this.isTranslating=!1,this.isRotating=!1,this.isTwoFingering=!1,this.inputSource=null,this.goalPosition.y+=this.placementBox.offsetHeight*this.presentedScene.scale.x,this.placementBox.show=!1},this.threeRenderer=w.threeRenderer,this.threeRenderer.xr.enabled=!0}async resolveARSession(){assertIsArCandidate();const w=await navigator.xr.requestSession("immersive-ar",{requiredFeatures:[],optionalFeatures:["hit-test","dom-overlay","light-estimation"],domOverlay:this.overlay?{root:this.overlay}:void 0});return this.threeRenderer.xr.setReferenceSpaceType("local"),await this.threeRenderer.xr.setSession(w),this.threeRenderer.xr.cameraAutoUpdate=!1,w}get presentedScene(){return this._presentedScene}async supportsPresentation(){try{return assertIsArCandidate(),await navigator.xr.isSessionSupported("immersive-ar")}catch(w){return console.warn("Request to present in WebXR denied:"),console.warn(w),console.warn("Falling back to next ar-mode"),!1}}async present(w,D=!1){this.isPresenting&&console.warn("Cannot present while a model is already presenting");let O=new Promise((Z,ie)=>{requestAnimationFrame(()=>Z())});w.setHotspotsVisibility(!1),w.queueRender(),await O,this._presentedScene=w,this.overlay=w.element.shadowRoot.querySelector("div.default"),D===!0&&(this.xrLight=new XREstimatedLight(this.threeRenderer),this.xrLight.addEventListener("estimationstart",()=>{if(!this.isPresenting||this.xrLight==null)return;const Z=this.presentedScene;Z.add(this.xrLight),Z.environment=this.xrLight.environment}));const U=await this.resolveARSession();U.addEventListener("end",()=>{this.postSessionCleanup()},{once:!0});const G=w.element.shadowRoot.querySelector(".slot.exit-webxr-ar-button");G.classList.add("enabled"),G.addEventListener("click",this.onExitWebXRButtonContainerClick),this.exitWebXRButtonContainer=G;const q=await U.requestReferenceSpace("viewer");this.xrMode=U.interactionMode,this.tracking=!0,this.frames=0,this.initialized=!1,this.turntableRotation=w.yaw,this.goalYaw=w.yaw,this.goalScale=1,w.setBackground(null),this.oldShadowIntensity=w.shadowIntensity,w.setShadowIntensity(.01),this.oldTarget.copy(w.getTarget()),w.element.addEventListener("load",this.onUpdateScene);const K=HIT_ANGLE_DEG*Math.PI/180,ee=this.placeOnWall===!0?void 0:new XRRay(new DOMPoint(0,0,0),{x:0,y:-Math.sin(K),z:-Math.cos(K)});U.requestHitTestSource({space:q,offsetRay:ee}).then(Z=>{this.initialHitSource=Z}),this.xrMode!=="screen-space"&&(this.setupControllers(),this.xDamper.setDecayTime(DECAY),this.yDamper.setDecayTime(DECAY),this.zDamper.setDecayTime(DECAY),this.yawDamper.setDecayTime(DECAY),this.pitchDamper.setDecayTime(DECAY),this.rollDamper.setDecayTime(DECAY)),this.currentSession=U,this.placementBox=new PlacementBox(w,this.placeOnWall?"back":"bottom"),this.placementComplete=!1,this.lastTick=performance.now(),this.dispatchEvent({type:"status",status:ARStatus.SESSION_STARTED})}setupControllers(){this.controller1=this.threeRenderer.xr.getController(0),this.controller1.addEventListener("selectstart",this.onControllerSelectStart),this.controller1.addEventListener("selectend",this.onControllerSelectEnd),this.controller2=this.threeRenderer.xr.getController(1),this.controller2.addEventListener("selectstart",this.onControllerSelectStart),this.controller2.addEventListener("selectend",this.onControllerSelectEnd);const w=this.presentedScene;if(w.add(this.controller1),w.add(this.controller2),!this.controller1.userData.line){const D=new Line(lineGeometry);D.name="line",D.scale.z=MAX_LINE_LENGTH,this.controller1.userData.turning=!1,this.controller1.userData.line=D,this.controller1.add(D),this.controller2.userData.turning=!1;const O=D.clone();this.controller2.userData.line=O,this.controller2.add(O),this.scaleLine.name="scale line",this.scaleLine.visible=!1,this.controller1.add(this.scaleLine);const{size:U}=w,G=BOX_SIZE/Math.max(U.x,U.y,U.z),q=new Mesh(boxGeometry);q.name="box",q.scale.copy(U).multiplyScalar(G),q.visible=!1,this.controller1.userData.box=q,w.add(q);const K=q.clone();this.controller2.userData.box=K,w.add(K)}}hover(w){if(this.xrMode==="screen-space"||this.selectedController==w)return!1;const D=this.presentedScene,O=this.placementBox.controllerIntersection(D,w);return w.userData.box.visible=(O==null||w.userData.turning)&&!this.isTwoFingering,w.userData.line.scale.z=O==null?MAX_LINE_LENGTH:O.distance,O!=null}controllerSeparation(){return this.controller1.position.distanceTo(this.controller2.position)}async stopPresenting(){if(!this.isPresenting)return;const w=new Promise(D=>{this.resolveCleanup=D});try{await this.currentSession.end(),await w}catch(D){console.warn("Error while trying to end WebXR AR session"),console.warn(D),this.postSessionCleanup()}}get isPresenting(){return this.presentedScene!=null}get target(){return this.oldTarget}updateTarget(){const w=this.presentedScene;if(w!=null){const D=w.getTarget();this.oldTarget.copy(D),this.placeOnWall?D.z=w.boundingBox.min.z:D.y=w.boundingBox.min.y,w.setTarget(D.x,D.y,D.z)}}postSessionCleanup(){const w=this.currentSession;w!=null&&(w.removeEventListener("selectstart",this.onSelectStart),w.removeEventListener("selectend",this.onSelectEnd),this.currentSession=null);const D=this.presentedScene;if(this._presentedScene=null,D!=null){const{element:q}=D;this.xrLight!=null&&(D.remove(this.xrLight),this.xrLight.dispose(),this.xrLight=null),D.add(D.pivot),D.pivot.quaternion.set(0,0,0,1),D.pivot.position.set(0,0,0),D.pivot.scale.set(1,1,1),D.setShadowOffset(0);const K=this.turntableRotation;K!=null&&(D.yaw=K);const ee=this.oldShadowIntensity;ee!=null&&D.setShadowIntensity(ee),D.setEnvironmentAndSkybox(q[$currentEnvironmentMap],q[$currentBackground]);const Z=this.oldTarget;D.setTarget(Z.x,Z.y,Z.z),D.xrCamera=null,D.element.removeEventListener("load",this.onUpdateScene),D.orientHotspots(0);const{width:ie,height:Y}=q.getBoundingClientRect();D.setSize(ie,Y),requestAnimationFrame(()=>{D.element.dispatchEvent(new CustomEvent("camera-change",{detail:{source:ChangeSource.NONE}}))})}this.renderer.height=0;const O=this.exitWebXRButtonContainer;O!=null&&(O.classList.remove("enabled"),O.removeEventListener("click",this.onExitWebXRButtonContainerClick),this.exitWebXRButtonContainer=null);const U=this.transientHitTestSource;U!=null&&(U.cancel(),this.transientHitTestSource=null);const G=this.initialHitSource;G!=null&&(G.cancel(),this.initialHitSource=null),this.placementBox!=null&&(this.placementBox.dispose(),this.placementBox=null),this.xrMode!=="screen-space"&&(this.controller1!=null&&(this.controller1.userData.turning=!1,this.controller1.userData.box.visible=!1,this.controller1.userData.line.visible=!0,this.controller1.removeEventListener("selectstart",this.onControllerSelectStart),this.controller1.removeEventListener("selectend",this.onControllerSelectEnd),this.controller1.removeFromParent(),this.controller1=null),this.controller2!=null&&(this.controller2.userData.turning=!1,this.controller2.userData.box.visible=!1,this.controller2.userData.line.visible=!0,this.controller2.removeEventListener("selectstart",this.onControllerSelectStart),this.controller2.removeEventListener("selectend",this.onControllerSelectEnd),this.controller2.removeFromParent(),this.controller2=null),this.selectedController=null,this.scaleLine.visible=!1),this.isTranslating=!1,this.isRotating=!1,this.isTwoFingering=!1,this.lastTick=null,this.turntableRotation=null,this.oldShadowIntensity=null,this.frame=null,this.inputSource=null,this.overlay=null,this.resolveCleanup!=null&&this.resolveCleanup(),this.dispatchEvent({type:"status",status:ARStatus.NOT_PRESENTING})}updateView(w){const D=this.presentedScene,O=this.threeRenderer.xr;O.updateCamera(camera),D.xrCamera=O.getCamera();const{elements:U}=D.getCamera().matrixWorld;if(D.orientHotspots(Math.atan2(U[1],U[5])),this.initialized||(this.placeInitially(),this.initialized=!0),w.requestViewportScale&&w.recommendedViewportScale){const q=w.recommendedViewportScale;w.requestViewportScale(Math.max(q,MIN_VIEWPORT_SCALE))}const G=O.getBaseLayer();if(G!=null){const q=G instanceof XRWebGLLayer?G.getViewport(w):O.getBinding().getViewSubImage(G,w).viewport;this.threeRenderer.setViewport(q.x,q.y,q.width,q.height)}}placeInitially(){const w=this.presentedScene,{pivot:D,element:O}=w,{position:U}=D,G=w.getCamera(),{width:q,height:K}=this.overlay.getBoundingClientRect();w.setSize(q,K),G.projectionMatrixInverse.copy(G.projectionMatrix).invert();const{theta:ee}=O.getCameraOrbit(),Z=G.getWorldDirection(vector3$1);w.yaw=Math.atan2(-Z.x,-Z.z)-ee,this.goalYaw=w.yaw;const ie=Math.max(1,2*w.boundingSphere.radius);U.copy(G.position).add(Z.multiplyScalar(ie)),this.updateTarget();const Y=w.getTarget();if(U.add(Y).sub(this.oldTarget),this.goalPosition.copy(U),w.setHotspotsVisibility(!0),this.xrMode==="screen-space"){const{session:W}=this.frame;W.addEventListener("selectstart",this.onSelectStart),W.addEventListener("selectend",this.onSelectEnd),W.requestHitTestSourceForTransientInput({profile:"generic-touchscreen"}).then(ne=>{this.transientHitTestSource=ne})}}getTouchLocation(){const{axes:w}=this.inputSource.gamepad;let D=this.placementBox.getExpandedHit(this.presentedScene,w[0],w[1]);return D!=null&&(vector3$1.copy(D).sub(this.presentedScene.getCamera().position),vector3$1.length()>MAX_DISTANCE)?null:D}getHitPoint(w){const D=this.threeRenderer.xr.getReferenceSpace(),O=w.getPose(D);if(O==null)return null;const U=matrix4.fromArray(O.transform.matrix);return this.placeOnWall===!0&&(this.goalYaw=Math.atan2(U.elements[4],U.elements[6])),U.elements[5]>.75!==this.placeOnWall?hitPosition.setFromMatrixPosition(U):null}moveToFloor(w){const D=this.initialHitSource;if(D==null)return;const O=w.getHitTestResults(D);if(O.length==0)return;const U=O[0],G=this.getHitPoint(U);G!=null&&(this.placementBox.show=!0,this.isTranslating||(this.placeOnWall?this.goalPosition.copy(G):this.goalPosition.y=G.y),D.cancel(),this.initialHitSource=null,this.dispatchEvent({type:"status",status:ARStatus.OBJECT_PLACED}))}fingerPolar(w){const D=w[0].inputSource.gamepad.axes,O=w[1].inputSource.gamepad.axes,U=O[0]-D[0],G=O[1]-D[1],q=Math.atan2(G,U);let K=this.lastAngle-q;return K>Math.PI?K-=2*Math.PI:K<-Math.PI&&(K+=2*Math.PI),this.lastAngle=q,{separation:Math.sqrt(U*U+G*G),deltaYaw:K}}setScale(w){const D=w/this.firstRatio;this.goalScale=Math.abs(D-1)<SCALE_SNAP?1:D}processInput(w){const D=this.transientHitTestSource;if(D==null||!this.isTranslating&&!this.isTwoFingering&&!this.isRotating)return;const O=w.getHitTestResultsForTransientInput(D),U=this.presentedScene,G=U.pivot.scale.x;if(this.isTwoFingering){if(O.length<2)this.isTwoFingering=!1;else{const{separation:q,deltaYaw:K}=this.fingerPolar(O);this.placeOnWall===!1&&(this.goalYaw+=K),U.canScale&&this.setScale(q)}return}else if(O.length===2){this.isTranslating=!1,this.isRotating=!1,this.isTwoFingering=!0;const{separation:q}=this.fingerPolar(O);this.firstRatio=q/G;return}if(this.isRotating){const q=this.inputSource.gamepad.axes[0]*ROTATION_RATE;this.goalYaw+=q-this.lastAngle,this.lastAngle=q}else this.isTranslating&&O.forEach(q=>{if(q.inputSource!==this.inputSource)return;let K=null;if(q.results.length>0&&(K=this.getHitPoint(q.results[0])),K==null&&(K=this.getTouchLocation()),K!=null){if(this.goalPosition.sub(this.lastDragPosition),this.placeOnWall===!1){const ee=K.y-this.lastDragPosition.y;if(ee<0){this.placementBox.offsetHeight=ee/G,this.presentedScene.setShadowOffset(ee);const Z=vector3$1.copy(U.getCamera().position),ie=-ee/(Z.y-K.y);Z.multiplyScalar(ie),K.multiplyScalar(1-ie).add(Z)}}this.goalPosition.add(K),this.lastDragPosition.copy(K)}})}moveScene(w){const D=this.presentedScene,{pivot:O}=D,U=this.placementBox;if(U.updateOpacity(w),this.controller1&&(this.controller1.userData.turning&&(O.quaternion.copy(this.controller1.quaternion).multiply(this.relativeOrientation),this.selectedController&&this.selectedController===this.controller2&&O.quaternion.premultiply(quaternion.copy(this.controller2.quaternion).invert())),this.controller1.userData.box.position.copy(this.controller1.position),O.getWorldQuaternion(this.controller1.userData.box.quaternion)),this.controller2&&(this.controller2.userData.turning&&(O.quaternion.copy(this.controller2.quaternion).multiply(this.relativeOrientation),this.selectedController&&this.selectedController===this.controller1&&O.quaternion.premultiply(quaternion.copy(this.controller1.quaternion).invert())),this.controller2.userData.box.position.copy(this.controller2.position),O.getWorldQuaternion(this.controller2.userData.box.quaternion)),this.controller1&&this.controller2&&this.isTwoFingering){const W=this.controllerSeparation();this.setScale(W),this.scaleLine.scale.z=-W,this.scaleLine.lookAt(this.controller2.position)}const G=D.pivot.scale.x;if(this.goalScale!==G){const W=this.scaleDamper.update(G,this.goalScale,w,1);D.pivot.scale.set(W,W,W)}if(O.parent!==D)return;const{position:q}=O,K=D.boundingSphere.radius,ee=this.goalPosition;let Z=ChangeSource.NONE;if(!ee.equals(q)){Z=ChangeSource.USER_INTERACTION;let{x:W,y:ne,z:se}=q;if(W=this.xDamper.update(W,ee.x,w,K),ne=this.yDamper.update(ne,ee.y,w,K),se=this.zDamper.update(se,ee.z,w,K),q.set(W,ne,se),this.xrMode==="screen-space"&&!this.isTranslating){const le=ee.y-ne;this.placementComplete&&this.placeOnWall===!1?(U.offsetHeight=le/D.pivot.scale.x,D.setShadowOffset(le)):le===0&&(this.placementComplete=!0,U.show=!1,D.setShadowIntensity(AR_SHADOW_INTENSITY))}this.xrMode!=="screen-space"&&ee.equals(q)&&D.setShadowIntensity(AR_SHADOW_INTENSITY)}D.updateTarget(w),quaternion.setFromAxisAngle(vector3$1.set(0,1,0),this.goalYaw);const ie=D.pivot.quaternion.angleTo(quaternion),Y=ie-this.yawDamper.update(ie,0,w,Math.PI);D.pivot.quaternion.rotateTowards(quaternion,Y),D.element.dispatchEvent(new CustomEvent("camera-change",{detail:{source:Z}}))}onWebXRFrame(w,D){if(this.xrMode!=="screen-space"){const K=this.hover(this.controller1),ee=this.hover(this.controller2);this.placementBox.show=(K||ee)&&!this.isTwoFingering}this.frame=D,++this.frames;const O=this.threeRenderer.xr.getReferenceSpace(),U=D.getViewerPose(O);U==null&&this.tracking===!0&&this.frames>INIT_FRAMES&&(this.tracking=!1,this.dispatchEvent({type:"tracking",status:ARTracking.NOT_TRACKING}));const G=this.presentedScene;if(U==null||G==null||!G.element.loaded){this.threeRenderer.clear();return}this.tracking===!1&&(this.tracking=!0,this.dispatchEvent({type:"tracking",status:ARTracking.TRACKING}));let q=!0;for(const K of U.views){if(this.updateView(K),q){this.moveToFloor(D),this.processInput(D);const ee=w-this.lastTick;this.moveScene(ee),this.renderer.preRender(G,w,ee),this.lastTick=w,G.renderShadow(this.threeRenderer)}this.threeRenderer.render(G,G.getCamera()),q=!1}}}function clone(F){const w=new Map,D=new Map,O=F.clone();return parallelTraverse(F,O,function(U,G){w.set(G,U),D.set(U,G)}),O.traverse(function(U){if(!U.isSkinnedMesh)return;const G=U,q=w.get(U),K=q.skeleton.bones;G.skeleton=q.skeleton.clone(),G.bindMatrix.copy(q.bindMatrix),G.skeleton.bones=K.map(function(ee){return D.get(ee)}),G.bind(G.skeleton,G.bindMatrix)}),O}function parallelTraverse(F,w,D){D(F,w);for(let O=0;O<F.children.length;O++)parallelTraverse(F.children[O],w.children[O],D)}/* @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */const $prepared=Symbol("prepared"),$prepare=Symbol("prepare"),$preparedGLTF=Symbol("preparedGLTF"),$clone=Symbol("clone");class GLTFInstance{static prepare(w){if(w.scene==null)throw new Error("Model does not have a scene");if(w[$prepared])return w;const D=this[$prepare](w);return D[$prepared]=!0,D}static[$prepare](w){const{scene:D}=w,O=[D];return Object.assign(Object.assign({},w),{scene:D,scenes:O})}get parser(){return this[$preparedGLTF].parser}get animations(){return this[$preparedGLTF].animations}get scene(){return this[$preparedGLTF].scene}get scenes(){return this[$preparedGLTF].scenes}get cameras(){return this[$preparedGLTF].cameras}get asset(){return this[$preparedGLTF].asset}get userData(){return this[$preparedGLTF].userData}constructor(w){this[$preparedGLTF]=w}clone(){const w=this.constructor,D=this[$clone]();return new w(D)}dispose(){this.scenes.forEach(w=>{w.traverse(D=>{const O=D;if(!O.material)return;(Array.isArray(O.material)?O.material:[O.material]).forEach(G=>{for(const q in G){const K=G[q];if(K instanceof Texture$1){const ee=K.source.data;ee.close!=null&&ee.close(),K.dispose()}}G.dispose()}),O.geometry.dispose()})})}[$clone](){const w=this[$preparedGLTF],D=clone(this.scene);cloneVariantMaterials(D,this.scene);const O=[D],U=w.userData?Object.assign({},w.userData):{};return Object.assign(Object.assign({},w),{scene:D,scenes:O,userData:U})}}const cloneVariantMaterials=(F,w)=>{traversePair(F,w,(D,O)=>{O.userData.variantMaterials!==void 0&&(D.userData.variantMaterials=new Map(O.userData.variantMaterials)),O.userData.variantData!==void 0&&(D.userData.variantData=O.userData.variantData),O.userData.originalMaterial!==void 0&&(D.userData.originalMaterial=O.userData.originalMaterial)})},traversePair=(F,w,D)=>{D(F,w);for(let O=0;O<F.children.length;O++)traversePair(F.children[O],w.children[O],D)},$threeGLTF=Symbol("threeGLTF"),$gltf=Symbol("gltf"),$gltfElementMap=Symbol("gltfElementMap"),$threeObjectMap=Symbol("threeObjectMap"),$parallelTraverseThreeScene=Symbol("parallelTraverseThreeScene"),$correlateOriginalThreeGLTF=Symbol("correlateOriginalThreeGLTF"),$correlateCloneThreeGLTF=Symbol("correlateCloneThreeGLTF");class CorrelatedSceneGraph{static from(w,D){return D!=null?this[$correlateCloneThreeGLTF](w,D):this[$correlateOriginalThreeGLTF](w)}static[$correlateOriginalThreeGLTF](w){const D=w.parser.json,O=w.parser.associations,U=new Map,G={name:"Default"},q={index:-1};for(const K of O.keys())K instanceof Material$1&&O.get(K)==null&&(q.index<0&&(D.materials==null&&(D.materials=[]),q.index=D.materials.length,D.materials.push(G)),K.name=G.name,O.set(K,{materials:q.index}));for(const[K,ee]of O){ee&&(K.userData=K.userData||{},K.userData.associations=ee);for(const Z in ee)if(Z!=null&&Z!=="primitives"){const ie=Z,W=(D[ie]||[])[ee[ie]];if(W==null)continue;let ne=U.get(W);ne==null&&(ne=new Set,U.set(W,ne)),ne.add(K)}}return new CorrelatedSceneGraph(w,D,O,U)}static[$correlateCloneThreeGLTF](w,D){const O=D.threeGLTF,U=D.gltf,G=JSON.parse(JSON.stringify(U)),q=new Map,K=new Map;for(let ee=0;ee<O.scenes.length;ee++)this[$parallelTraverseThreeScene](O.scenes[ee],w.scenes[ee],(Z,ie)=>{const Y=D.threeObjectMap.get(Z);if(Y!=null){for(const W in Y)if(W!=null&&W!=="primitives"){const ne=W,se=Y[ne],le=G[ne][se],ce=q.get(ie)||{};ce[ne]=se,q.set(ie,ce);const he=K.get(le)||new Set;he.add(ie),K.set(le,he)}}});return new CorrelatedSceneGraph(w,G,q,K)}static[$parallelTraverseThreeScene](w,D,O){const U=(G,q)=>{if(O(G,q),G.isObject3D){const K=G,ee=q;if(K.material)if(Array.isArray(K.material))for(let Z=0;Z<K.material.length;++Z)O(K.material[Z],ee.material[Z]);else O(K.material,ee.material);for(let Z=0;Z<G.children.length;++Z)U(G.children[Z],q.children[Z])}};U(w,D)}get threeGLTF(){return this[$threeGLTF]}get gltf(){return this[$gltf]}get gltfElementMap(){return this[$gltfElementMap]}get threeObjectMap(){return this[$threeObjectMap]}constructor(w,D,O,U){this[$threeGLTF]=w,this[$gltf]=D,this[$gltfElementMap]=U,this[$threeObjectMap]=O}}/* @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */const $correlatedSceneGraph=Symbol("correlatedSceneGraph");class ModelViewerGLTFInstance extends GLTFInstance{static[$prepare](w){const D=super[$prepare](w);D[$correlatedSceneGraph]==null&&(D[$correlatedSceneGraph]=CorrelatedSceneGraph.from(D));const{scene:O}=D,U=new Sphere(void 0,1/0);return O.traverse(G=>{G.renderOrder=1e3,G.frustumCulled=!1,G.name||(G.name=G.uuid);const q=G;if(q.material){const{geometry:K}=q;q.castShadow=!0,q.isSkinnedMesh&&(K.boundingSphere=U,K.boundingBox=null);const ee=q.material;if(ee.isMeshBasicMaterial===!0&&(ee.toneMapped=!1),ee.shadowSide=FrontSide,ee.aoMap){const{gltf:Z,threeObjectMap:ie}=D[$correlatedSceneGraph],Y=ie.get(ee);if(Z.materials!=null&&Y!=null&&Y.materials!=null){const W=Z.materials[Y.materials];W.occlusionTexture&&W.occlusionTexture.texCoord===0&&K.attributes.uv!=null&&K.setAttribute("uv2",K.attributes.uv)}}}}),D}get correlatedSceneGraph(){return this[$preparedGLTF][$correlatedSceneGraph]}[$clone](){const w=super[$clone](),D=new Map;return w.scene.traverse(O=>{const U=O;if(U.material){const q=U.material;if(q!=null){if(D.has(q.uuid)){U.material=D.get(q.uuid);return}U.material=q.clone(),D.set(q.uuid,U.material)}}const G=O;G.target!==void 0&&G.add(G.target)}),w[$correlatedSceneGraph]=CorrelatedSceneGraph.from(w,this.correlatedSceneGraph),w}}const getBufferForType=(F,w,D)=>{let O;switch(F){case UnsignedByteType:O=new Uint8ClampedArray(w*D*4);break;case HalfFloatType:O=new Uint16Array(w*D*4);break;case UnsignedIntType:O=new Uint32Array(w*D*4);break;case ByteType:O=new Int8Array(w*D*4);break;case ShortType:O=new Int16Array(w*D*4);break;case IntType:O=new Int32Array(w*D*4);break;case FloatType:O=new Float32Array(w*D*4);break;default:throw new Error("Unsupported data type")}return O};let _canReadPixelsResult;const canReadPixels=(F,w,D,O)=>{if(_canReadPixelsResult!==void 0)return _canReadPixelsResult;const U=new WebGLRenderTarget(1,1,O);w.setRenderTarget(U);const G=new Mesh(new PlaneGeometry,new MeshBasicMaterial({color:16777215}));w.render(G,D),w.setRenderTarget(null);const q=getBufferForType(F,U.width,U.height);return w.readRenderTargetPixels(U,0,0,U.width,U.height,q),U.dispose(),G.geometry.dispose(),G.material.dispose(),_canReadPixelsResult=q[0]!==0,_canReadPixelsResult};class QuadRenderer{constructor(w){var D,O,U,G,q,K,ee,Z,ie,Y,W,ne,se,le,ce,he;this._rendererIsDisposable=!1,this._supportsReadPixels=!0,this.render=()=>{this._renderer.setRenderTarget(this._renderTarget);try{this._renderer.render(this._scene,this._camera)}catch(me){throw this._renderer.setRenderTarget(null),me}this._renderer.setRenderTarget(null)},this._width=w.width,this._height=w.height,this._type=w.type,this._colorSpace=w.colorSpace;const pe={format:RGBAFormat,depthBuffer:!1,stencilBuffer:!1,type:this._type,colorSpace:this._colorSpace,anisotropy:((D=w.renderTargetOptions)===null||D===void 0?void 0:D.anisotropy)!==void 0?(O=w.renderTargetOptions)===null||O===void 0?void 0:O.anisotropy:1,generateMipmaps:((U=w.renderTargetOptions)===null||U===void 0?void 0:U.generateMipmaps)!==void 0?(G=w.renderTargetOptions)===null||G===void 0?void 0:G.generateMipmaps:!1,magFilter:((q=w.renderTargetOptions)===null||q===void 0?void 0:q.magFilter)!==void 0?(K=w.renderTargetOptions)===null||K===void 0?void 0:K.magFilter:LinearFilter,minFilter:((ee=w.renderTargetOptions)===null||ee===void 0?void 0:ee.minFilter)!==void 0?(Z=w.renderTargetOptions)===null||Z===void 0?void 0:Z.minFilter:LinearFilter,samples:((ie=w.renderTargetOptions)===null||ie===void 0?void 0:ie.samples)!==void 0?(Y=w.renderTargetOptions)===null||Y===void 0?void 0:Y.samples:void 0,wrapS:((W=w.renderTargetOptions)===null||W===void 0?void 0:W.wrapS)!==void 0?(ne=w.renderTargetOptions)===null||ne===void 0?void 0:ne.wrapS:ClampToEdgeWrapping,wrapT:((se=w.renderTargetOptions)===null||se===void 0?void 0:se.wrapT)!==void 0?(le=w.renderTargetOptions)===null||le===void 0?void 0:le.wrapT:ClampToEdgeWrapping};if(this._material=w.material,w.renderer?this._renderer=w.renderer:(this._renderer=QuadRenderer.instantiateRenderer(),this._rendererIsDisposable=!0),this._scene=new Scene,this._camera=new OrthographicCamera,this._camera.position.set(0,0,10),this._camera.left=-.5,this._camera.right=.5,this._camera.top=.5,this._camera.bottom=-.5,this._camera.updateProjectionMatrix(),!canReadPixels(this._type,this._renderer,this._camera,pe)){let me;switch(this._type){case HalfFloatType:me=this._renderer.extensions.has("EXT_color_buffer_float")?FloatType:void 0;break}me!==void 0?(console.warn(`This browser does not support reading pixels from ${this._type} RenderTargets, switching to ${FloatType}`),this._type=me):(this._supportsReadPixels=!1,console.warn("This browser dos not support toArray or toDataTexture, calls to those methods will result in an error thrown"))}this._quad=new Mesh(new PlaneGeometry,this._material),this._quad.geometry.computeBoundingBox(),this._scene.add(this._quad),this._renderTarget=new WebGLRenderTarget(this.width,this.height,pe),this._renderTarget.texture.mapping=((ce=w.renderTargetOptions)===null||ce===void 0?void 0:ce.mapping)!==void 0?(he=w.renderTargetOptions)===null||he===void 0?void 0:he.mapping:UVMapping}static instantiateRenderer(){const w=new WebGLRenderer;return w.setSize(128,128),w}toArray(){if(!this._supportsReadPixels)throw new Error("Can't read pixels in this browser");const w=getBufferForType(this._type,this._width,this._height);return this._renderer.readRenderTargetPixels(this._renderTarget,0,0,this._width,this._height,w),w}toDataTexture(w){const D=new DataTexture(this.toArray(),this.width,this.height,RGBAFormat,this._type,w?.mapping||UVMapping,w?.wrapS||ClampToEdgeWrapping,w?.wrapT||ClampToEdgeWrapping,w?.magFilter||LinearFilter,w?.minFilter||LinearFilter,w?.anisotropy||1,LinearSRGBColorSpace);return D.generateMipmaps=w?.generateMipmaps!==void 0?w?.generateMipmaps:!1,D}disposeOnDemandRenderer(){this._renderer.setRenderTarget(null),this._rendererIsDisposable&&(this._renderer.dispose(),this._renderer.forceContextLoss())}dispose(w){this.disposeOnDemandRenderer(),w&&this.renderTarget.dispose(),this.material instanceof ShaderMaterial&&Object.values(this.material.uniforms).forEach(D=>{D.value instanceof Texture$1&&D.value.dispose()}),Object.values(this.material).forEach(D=>{D instanceof Texture$1&&D.dispose()}),this.material.dispose(),this._quad.geometry.dispose()}get width(){return this._width}set width(w){this._width=w,this._renderTarget.setSize(this._width,this._height)}get height(){return this._height}set height(w){this._height=w,this._renderTarget.setSize(this._width,this._height)}get renderer(){return this._renderer}get renderTarget(){return this._renderTarget}set renderTarget(w){this._renderTarget=w,this._width=w.width,this._height=w.height}get material(){return this._material}get type(){return this._type}get colorSpace(){return this._colorSpace}}const vertexShader=`
varying vec2 vUv;

void main() {
  vUv = uv;
  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
}
`,fragmentShader=`
// min half float value
#define HALF_FLOAT_MIN vec3( -65504, -65504, -65504 )
// max half float value
#define HALF_FLOAT_MAX vec3( 65504, 65504, 65504 )

uniform sampler2D sdr;
uniform sampler2D gainMap;
uniform vec3 gamma;
uniform vec3 offsetHdr;
uniform vec3 offsetSdr;
uniform vec3 gainMapMin;
uniform vec3 gainMapMax;
uniform float weightFactor;

varying vec2 vUv;

void main() {
  vec3 rgb = texture2D( sdr, vUv ).rgb;
  vec3 recovery = texture2D( gainMap, vUv ).rgb;
  vec3 logRecovery = pow( recovery, gamma );
  vec3 logBoost = gainMapMin * ( 1.0 - logRecovery ) + gainMapMax * logRecovery;
  vec3 hdrColor = (rgb + offsetSdr) * exp2( logBoost * weightFactor ) - offsetHdr;
  vec3 clampedHdrColor = max( HALF_FLOAT_MIN, min( HALF_FLOAT_MAX, hdrColor ));
  gl_FragColor = vec4( clampedHdrColor , 1.0 );
}
`;class GainMapDecoderMaterial extends ShaderMaterial{constructor({gamma:w,offsetHdr:D,offsetSdr:O,gainMapMin:U,gainMapMax:G,maxDisplayBoost:q,hdrCapacityMin:K,hdrCapacityMax:ee,sdr:Z,gainMap:ie}){super({name:"GainMapDecoderMaterial",vertexShader,fragmentShader,uniforms:{sdr:{value:Z},gainMap:{value:ie},gamma:{value:new Vector3(1/w[0],1/w[1],1/w[2])},offsetHdr:{value:new Vector3().fromArray(D)},offsetSdr:{value:new Vector3().fromArray(O)},gainMapMin:{value:new Vector3().fromArray(U)},gainMapMax:{value:new Vector3().fromArray(G)},weightFactor:{value:(Math.log2(q)-K)/(ee-K)}},blending:NoBlending,depthTest:!1,depthWrite:!1}),this._maxDisplayBoost=q,this._hdrCapacityMin=K,this._hdrCapacityMax=ee,this.needsUpdate=!0,this.uniformsNeedUpdate=!0}get sdr(){return this.uniforms.sdr.value}set sdr(w){this.uniforms.sdr.value=w}get gainMap(){return this.uniforms.gainMap.value}set gainMap(w){this.uniforms.gainMap.value=w}get offsetHdr(){return this.uniforms.offsetHdr.value.toArray()}set offsetHdr(w){this.uniforms.offsetHdr.value.fromArray(w)}get offsetSdr(){return this.uniforms.offsetSdr.value.toArray()}set offsetSdr(w){this.uniforms.offsetSdr.value.fromArray(w)}get gainMapMin(){return this.uniforms.gainMapMin.value.toArray()}set gainMapMin(w){this.uniforms.gainMapMin.value.fromArray(w)}get gainMapMax(){return this.uniforms.gainMapMax.value.toArray()}set gainMapMax(w){this.uniforms.gainMapMax.value.fromArray(w)}get gamma(){const w=this.uniforms.gamma.value;return[1/w.x,1/w.y,1/w.z]}set gamma(w){const D=this.uniforms.gamma.value;D.x=1/w[0],D.y=1/w[1],D.z=1/w[2]}get hdrCapacityMin(){return this._hdrCapacityMin}set hdrCapacityMin(w){this._hdrCapacityMin=w,this.calculateWeight()}get hdrCapacityMax(){return this._hdrCapacityMax}set hdrCapacityMax(w){this._hdrCapacityMax=w,this.calculateWeight()}get maxDisplayBoost(){return this._maxDisplayBoost}set maxDisplayBoost(w){this._maxDisplayBoost=Math.max(1,Math.min(65504,w)),this.calculateWeight()}calculateWeight(){const w=(Math.log2(this._maxDisplayBoost)-this._hdrCapacityMin)/(this._hdrCapacityMax-this._hdrCapacityMin);this.uniforms.weightFactor.value=Math.max(0,Math.min(1,w))}}class GainMapNotFoundError extends Error{}class XMPMetadataNotFoundError extends Error{}const getXMLValue=(F,w,D)=>{const O=new RegExp(`${w}="([^"]*)"`,"i").exec(F);if(O)return O[1];const U=new RegExp(`<${w}[^>]*>([\\s\\S]*?)</${w}>`,"i").exec(F);if(U){const G=U[1].match(/<rdf:li>([^<]*)<\/rdf:li>/g);return G&&G.length===3?G.map(q=>q.replace(/<\/?rdf:li>/g,"")):U[1].trim()}if(D!==void 0)return D;throw new Error(`Can't find ${w} in gainmap metadata`)},extractXMP=F=>{let w;typeof TextDecoder<"u"?w=new TextDecoder().decode(F):w=F.toString();let D=w.indexOf("<x:xmpmeta");for(;D!==-1;){const O=w.indexOf("x:xmpmeta>",D),U=w.slice(D,O+10);try{const G=getXMLValue(U,"hdrgm:GainMapMin","0"),q=getXMLValue(U,"hdrgm:GainMapMax"),K=getXMLValue(U,"hdrgm:Gamma","1"),ee=getXMLValue(U,"hdrgm:OffsetSDR","0.015625"),Z=getXMLValue(U,"hdrgm:OffsetHDR","0.015625"),ie=/hdrgm:HDRCapacityMin="([^"]*)"/.exec(U),Y=ie?ie[1]:"0",W=/hdrgm:HDRCapacityMax="([^"]*)"/.exec(U);if(!W)throw new Error("Incomplete gainmap metadata");const ne=W[1];return{gainMapMin:Array.isArray(G)?G.map(se=>parseFloat(se)):[parseFloat(G),parseFloat(G),parseFloat(G)],gainMapMax:Array.isArray(q)?q.map(se=>parseFloat(se)):[parseFloat(q),parseFloat(q),parseFloat(q)],gamma:Array.isArray(K)?K.map(se=>parseFloat(se)):[parseFloat(K),parseFloat(K),parseFloat(K)],offsetSdr:Array.isArray(ee)?ee.map(se=>parseFloat(se)):[parseFloat(ee),parseFloat(ee),parseFloat(ee)],offsetHdr:Array.isArray(Z)?Z.map(se=>parseFloat(se)):[parseFloat(Z),parseFloat(Z),parseFloat(Z)],hdrCapacityMin:parseFloat(Y),hdrCapacityMax:parseFloat(ne)}}catch{}D=w.indexOf("<x:xmpmeta",O)}};class MPFExtractor{constructor(w){this.options={debug:w&&w.debug!==void 0?w.debug:!1,extractFII:w&&w.extractFII!==void 0?w.extractFII:!0,extractNonFII:w&&w.extractNonFII!==void 0?w.extractNonFII:!0}}extract(w){return new Promise((D,O)=>{const U=this.options.debug,G=new DataView(w.buffer);if(G.getUint16(0)!==65496){O(new Error("Not a valid jpeg"));return}const q=G.byteLength;let K=2,ee=0,Z;for(;K<q;){if(++ee>250){O(new Error(`Found no marker after ${ee} loops `));return}if(G.getUint8(K)!==255){O(new Error(`Not a valid marker at offset 0x${K.toString(16)}, found: 0x${G.getUint8(K).toString(16)}`));return}if(Z=G.getUint8(K+1),U&&console.log(`Marker: ${Z.toString(16)}`),Z===226){U&&console.log("Found APP2 marker (0xffe2)");const ie=K+4;if(G.getUint32(ie)===1297106432){const Y=ie+4;let W;if(G.getUint16(Y)===18761)W=!1;else if(G.getUint16(Y)===19789)W=!0;else{O(new Error("No valid endianness marker found in TIFF header"));return}if(G.getUint16(Y+2,!W)!==42){O(new Error("Not valid TIFF data! (no 0x002A marker)"));return}const ne=G.getUint32(Y+4,!W);if(ne<8){O(new Error("Not valid TIFF data! (First offset less than 8)"));return}const se=Y+ne,le=G.getUint16(se,!W),ce=se+2;let he=0;for(let ge=ce;ge<ce+12*le;ge+=12)G.getUint16(ge,!W)===45057&&(he=G.getUint32(ge+8,!W));const me=se+2+le*12+4,be=[];for(let ge=me;ge<me+he*16;ge+=16){const ve={MPType:G.getUint32(ge,!W),size:G.getUint32(ge+4,!W),dataOffset:G.getUint32(ge+8,!W),dependantImages:G.getUint32(ge+12,!W),start:-1,end:-1,isFII:!1};ve.dataOffset?(ve.start=Y+ve.dataOffset,ve.isFII=!1):(ve.start=0,ve.isFII=!0),ve.end=ve.start+ve.size,be.push(ve)}if(this.options.extractNonFII&&be.length){const ge=new Blob([G]),ve=[];for(const Se of be){if(Se.isFII&&!this.options.extractFII)continue;const Me=ge.slice(Se.start,Se.end+1,"image/jpeg");ve.push(Me)}D(ve)}}}K+=2+G.getUint16(K+2)}})}}const extractGainmapFromJPEG=async F=>{const w=extractXMP(F);if(!w)throw new XMPMetadataNotFoundError("Gain map XMP metadata not found");const O=await new MPFExtractor({extractFII:!0,extractNonFII:!0}).extract(F);if(O.length!==2)throw new GainMapNotFoundError("Gain map recovery image not found");return{sdr:new Uint8Array(await O[0].arrayBuffer()),gainMap:new Uint8Array(await O[1].arrayBuffer()),metadata:w}},getHTMLImageFromBlob=F=>new Promise((w,D)=>{const O=document.createElement("img");O.onload=()=>{w(O)},O.onerror=U=>{D(U)},O.src=URL.createObjectURL(F)});class LoaderBase extends Loader{constructor(w,D){super(D),w&&(this._renderer=w),this._internalLoadingManager=new LoadingManager}setRenderer(w){return this._renderer=w,this}setRenderTargetOptions(w){return this._renderTargetOptions=w,this}prepareQuadRenderer(){this._renderer||console.warn("WARNING: An existing WebGL Renderer was not passed to this Loader constructor or in setRenderer, the result of this Loader will need to be converted to a Data Texture with toDataTexture() before you can use it in your renderer.");const w=new GainMapDecoderMaterial({gainMapMax:[1,1,1],gainMapMin:[0,0,0],gamma:[1,1,1],offsetHdr:[1,1,1],offsetSdr:[1,1,1],hdrCapacityMax:1,hdrCapacityMin:0,maxDisplayBoost:1,gainMap:new Texture$1,sdr:new Texture$1});return new QuadRenderer({width:16,height:16,type:HalfFloatType,colorSpace:LinearSRGBColorSpace,material:w,renderer:this._renderer,renderTargetOptions:this._renderTargetOptions})}async render(w,D,O,U){const G=U?new Blob([U],{type:"image/jpeg"}):void 0,q=new Blob([O],{type:"image/jpeg"});let K,ee,Z=!1;if(typeof createImageBitmap>"u"){const W=await Promise.all([G?getHTMLImageFromBlob(G):Promise.resolve(void 0),getHTMLImageFromBlob(q)]);ee=W[0],K=W[1],Z=!0}else{const W=await Promise.all([G?createImageBitmap(G,{imageOrientation:"flipY"}):Promise.resolve(void 0),createImageBitmap(q,{imageOrientation:"flipY"})]);ee=W[0],K=W[1]}const ie=new Texture$1(ee||new ImageData(2,2),UVMapping,ClampToEdgeWrapping,ClampToEdgeWrapping,LinearFilter,LinearMipMapLinearFilter,RGBAFormat,UnsignedByteType,1,LinearSRGBColorSpace);ie.flipY=Z,ie.needsUpdate=!0;const Y=new Texture$1(K,UVMapping,ClampToEdgeWrapping,ClampToEdgeWrapping,LinearFilter,LinearMipMapLinearFilter,RGBAFormat,UnsignedByteType,1,SRGBColorSpace);Y.flipY=Z,Y.needsUpdate=!0,w.width=K.width,w.height=K.height,w.material.gainMap=ie,w.material.sdr=Y,w.material.gainMapMin=D.gainMapMin,w.material.gainMapMax=D.gainMapMax,w.material.offsetHdr=D.offsetHdr,w.material.offsetSdr=D.offsetSdr,w.material.gamma=D.gamma,w.material.hdrCapacityMin=D.hdrCapacityMin,w.material.hdrCapacityMax=D.hdrCapacityMax,w.material.maxDisplayBoost=Math.pow(2,D.hdrCapacityMax),w.material.needsUpdate=!0,w.render()}}class HDRJPGLoader extends LoaderBase{load(w,D,O,U){const G=this.prepareQuadRenderer(),q=new FileLoader(this._internalLoadingManager);return q.setResponseType("arraybuffer"),q.setRequestHeader(this.requestHeader),q.setPath(this.path),q.setWithCredentials(this.withCredentials),this.manager.itemStart(w),q.load(w,async K=>{if(typeof K=="string")throw new Error("Invalid buffer, received [string], was expecting [ArrayBuffer]");const ee=new Uint8Array(K);let Z,ie,Y;try{const W=await extractGainmapFromJPEG(ee);Z=W.sdr,ie=W.gainMap,Y=W.metadata}catch(W){if(W instanceof XMPMetadataNotFoundError||W instanceof GainMapNotFoundError)console.warn(`Failure to reconstruct an HDR image from ${w}: Gain map metadata not found in the file, HDRJPGLoader will render the SDR jpeg`),Y={gainMapMin:[0,0,0],gainMapMax:[1,1,1],gamma:[1,1,1],hdrCapacityMin:0,hdrCapacityMax:1,offsetHdr:[0,0,0],offsetSdr:[0,0,0]},Z=ee;else throw W}try{await this.render(G,Y,Z,ie)}catch(W){this.manager.itemError(w),typeof U=="function"&&U(W),G.disposeOnDemandRenderer();return}typeof D=="function"&&D(G),this.manager.itemEnd(w),G.disposeOnDemandRenderer()},O,K=>{this.manager.itemError(w),typeof U=="function"&&U(K)}),G}}class HDRLoader extends DataTextureLoader{constructor(w){super(w),this.type=HalfFloatType}parse(w){const q=function(Me,Ee){switch(Me){case 1:throw new Error("THREE.HDRLoader: Read Error: "+(Ee||""));case 2:throw new Error("THREE.HDRLoader: Write Error: "+(Ee||""));case 3:throw new Error("THREE.HDRLoader: Bad File Format: "+(Ee||""));default:case 4:throw new Error("THREE.HDRLoader: Memory Error: "+(Ee||""))}},Y=function(Me,Ee,we){Ee=Ee||1024;let Le=Me.pos,Ne=-1,Oe=0,Pe="",Ce=String.fromCharCode.apply(null,new Uint16Array(Me.subarray(Le,Le+128)));for(;0>(Ne=Ce.indexOf(`
`))&&Oe<Ee&&Le<Me.byteLength;)Pe+=Ce,Oe+=Ce.length,Le+=128,Ce+=String.fromCharCode.apply(null,new Uint16Array(Me.subarray(Le,Le+128)));return-1<Ne?(Me.pos+=Oe+Ne+1,Pe+Ce.slice(0,Ne)):!1},W=function(Me){const Ee=/^#\?(\S+)/,we=/^\s*GAMMA\s*=\s*(\d+(\.\d+)?)\s*$/,Re=/^\s*EXPOSURE\s*=\s*(\d+(\.\d+)?)\s*$/,Le=/^\s*FORMAT=(\S+)\s*$/,Ne=/^\s*\-Y\s+(\d+)\s+\+X\s+(\d+)\s*$/,Oe={valid:0,string:"",comments:"",programtype:"RGBE",format:"",gamma:1,exposure:1,width:0,height:0};let Pe,Ce;for((Me.pos>=Me.byteLength||!(Pe=Y(Me)))&&q(1,"no header found"),(Ce=Pe.match(Ee))||q(3,"bad initial token"),Oe.valid|=1,Oe.programtype=Ce[1],Oe.string+=Pe+`
`;Pe=Y(Me),Pe!==!1;){if(Oe.string+=Pe+`
`,Pe.charAt(0)==="#"){Oe.comments+=Pe+`
`;continue}if((Ce=Pe.match(we))&&(Oe.gamma=parseFloat(Ce[1])),(Ce=Pe.match(Re))&&(Oe.exposure=parseFloat(Ce[1])),(Ce=Pe.match(Le))&&(Oe.valid|=2,Oe.format=Ce[1]),(Ce=Pe.match(Ne))&&(Oe.valid|=4,Oe.height=parseInt(Ce[1],10),Oe.width=parseInt(Ce[2],10)),Oe.valid&2&&Oe.valid&4)break}return Oe.valid&2||q(3,"missing format specifier"),Oe.valid&4||q(3,"missing image size specifier"),Oe},ne=function(Me,Ee,we){const Re=Ee;if(Re<8||Re>32767||Me[0]!==2||Me[1]!==2||Me[2]&128)return new Uint8Array(Me);Re!==(Me[2]<<8|Me[3])&&q(3,"wrong scanline width");const Le=new Uint8Array(4*Ee*we);Le.length||q(4,"unable to allocate buffer space");let Ne=0,Oe=0;const Pe=4*Re,Ce=new Uint8Array(4),Be=new Uint8Array(Pe);let ze=we;for(;ze>0&&Oe<Me.byteLength;){Oe+4>Me.byteLength&&q(1),Ce[0]=Me[Oe++],Ce[1]=Me[Oe++],Ce[2]=Me[Oe++],Ce[3]=Me[Oe++],(Ce[0]!=2||Ce[1]!=2||(Ce[2]<<8|Ce[3])!=Re)&&q(3,"bad rgbe scanline format");let Xe=0,lt;for(;Xe<Pe&&Oe<Me.byteLength;){lt=Me[Oe++];const rt=lt>128;if(rt&&(lt-=128),(lt===0||Xe+lt>Pe)&&q(3,"bad scanline data"),rt){const St=Me[Oe++];for(let Lt=0;Lt<lt;Lt++)Be[Xe++]=St}else Be.set(Me.subarray(Oe,Oe+lt),Xe),Xe+=lt,Oe+=lt}const ke=Re;for(let rt=0;rt<ke;rt++){let St=0;Le[Ne]=Be[rt+St],St+=Re,Le[Ne+1]=Be[rt+St],St+=Re,Le[Ne+2]=Be[rt+St],St+=Re,Le[Ne+3]=Be[rt+St],Ne+=4}ze--}return Le},se=function(Me,Ee,we,Re){const Le=Me[Ee+3],Ne=Math.pow(2,Le-128)/255;we[Re+0]=Me[Ee+0]*Ne,we[Re+1]=Me[Ee+1]*Ne,we[Re+2]=Me[Ee+2]*Ne,we[Re+3]=1},le=function(Me,Ee,we,Re){const Le=Me[Ee+3],Ne=Math.pow(2,Le-128)/255;we[Re+0]=DataUtils.toHalfFloat(Math.min(Me[Ee+0]*Ne,65504)),we[Re+1]=DataUtils.toHalfFloat(Math.min(Me[Ee+1]*Ne,65504)),we[Re+2]=DataUtils.toHalfFloat(Math.min(Me[Ee+2]*Ne,65504)),we[Re+3]=DataUtils.toHalfFloat(1)},ce=new Uint8Array(w);ce.pos=0;const he=W(ce),pe=he.width,me=he.height,be=ne(ce.subarray(ce.pos),pe,me);let ge,ve,Se;switch(this.type){case FloatType:Se=be.length/4;const Me=new Float32Array(Se*4);for(let we=0;we<Se;we++)se(be,we*4,Me,we*4);ge=Me,ve=FloatType;break;case HalfFloatType:Se=be.length/4;const Ee=new Uint16Array(Se*4);for(let we=0;we<Se;we++)le(be,we*4,Ee,we*4);ge=Ee,ve=HalfFloatType;break;default:throw new Error("THREE.HDRLoader: Unsupported type: "+this.type)}return{width:pe,height:me,data:ge,header:he.string,gamma:he.gamma,exposure:he.exposure,type:ve}}setDataType(w){return this.type=w,this}load(w,D,O,U){function G(q,K){switch(q.type){case FloatType:case HalfFloatType:q.colorSpace=LinearSRGBColorSpace,q.minFilter=LinearFilter,q.magFilter=LinearFilter,q.generateMipmaps=!1,q.flipY=!0;break}D&&D(q,K)}return super.load(w,G,O,U)}}class RGBELoader extends HDRLoader{constructor(w){console.warn("RGBELoader has been deprecated. Please use HDRLoader instead."),super(w)}}/* @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */const legacy={topLight:{intensity:500,position:[.418,16.199,.3]},room:{position:[-.757,13.219,.717],scale:[31.713,28.305,28.591]},boxes:[{position:[-10.906,2.009,1.846],rotation:-.195,scale:[2.328,7.905,4.651]},{position:[-5.607,-.754,-.758],rotation:.994,scale:[1.97,1.534,3.955]},{position:[6.167,.857,7.803],rotation:.561,scale:[3.927,6.285,3.687]},{position:[-2.017,.018,6.124],rotation:.333,scale:[2.002,4.566,2.064]},{position:[2.291,-.756,-2.621],rotation:-.286,scale:[1.546,1.552,1.496]},{position:[-2.193,-.369,-5.547],rotation:.516,scale:[3.875,3.487,2.986]}],lights:[{intensity:50,position:[-16.116,14.37,8.208],scale:[.1,2.428,2.739]},{intensity:50,position:[-16.109,18.021,-8.207],scale:[.1,2.425,2.751]},{intensity:17,position:[14.904,12.198,-1.832],scale:[.15,4.265,6.331]},{intensity:43,position:[-.462,8.89,14.52],scale:[4.38,5.441,.088]},{intensity:20,position:[3.235,11.486,-12.541],scale:[2.5,2,.1]},{intensity:100,position:[0,20,0],scale:[1,.1,1]}]},neutral={topLight:{intensity:400,position:[.5,14,.5]},room:{position:[0,13.2,0],scale:[31.5,28.5,31.5]},boxes:[{position:[-10.906,-1,1.846],rotation:-.195,scale:[2.328,7.905,4.651]},{position:[-5.607,-.754,-.758],rotation:.994,scale:[1.97,1.534,3.955]},{position:[6.167,-.16,7.803],rotation:.561,scale:[3.927,6.285,3.687]},{position:[-2.017,.018,6.124],rotation:.333,scale:[2.002,4.566,2.064]},{position:[2.291,-.756,-2.621],rotation:-.286,scale:[1.546,1.552,1.496]},{position:[-2.193,-.369,-5.547],rotation:.516,scale:[3.875,3.487,2.986]}],lights:[{intensity:80,position:[-14,10,8],scale:[.1,2.5,2.5]},{intensity:80,position:[-14,14,-4],scale:[.1,2.5,2.5]},{intensity:23,position:[14,12,0],scale:[.1,5,5]},{intensity:16,position:[0,9,14],scale:[5,5,.1]},{intensity:80,position:[7,8,-14],scale:[2.5,2.5,.1]},{intensity:80,position:[-7,16,-14],scale:[2.5,2.5,.1]},{intensity:1,position:[0,20,0],scale:[.1,.1,.1]}]};class EnvironmentScene extends Scene{constructor(w){super(),this.position.y=-3.5;const D=new BoxGeometry;D.deleteAttribute("uv");const O=new MeshStandardMaterial({metalness:0,side:BackSide}),U=new MeshStandardMaterial({metalness:0}),G=w=="legacy"?legacy:neutral,q=new PointLight(16777215,G.topLight.intensity,28,2);q.position.set(...G.topLight.position),this.add(q);const K=new Mesh(D,O);K.position.set(...G.room.position),K.scale.set(...G.room.scale),this.add(K);for(const ee of G.boxes){const Z=new Mesh(D,U);Z.position.set(...ee.position),Z.rotation.set(0,ee.rotation,0),Z.scale.set(...ee.scale),this.add(Z)}for(const ee of G.lights){const Z=new Mesh(D,this.createAreaLightMaterial(ee.intensity));Z.position.set(...ee.position),Z.scale.set(...ee.scale),this.add(Z)}}createAreaLightMaterial(w){const D=new MeshBasicMaterial;return D.color.setScalar(w),D}}/* @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */const GENERATED_SIGMA=.04,MAX_SAMPLES=20,HDR_FILE_RE=/\.hdr(\.js)?$/;class TextureUtils{constructor(w){this.threeRenderer=w,this.lottieLoaderUrl="",this._ldrLoader=null,this._imageLoader=null,this._hdrLoader=null,this._lottieLoader=null,this.generatedEnvironmentMap=null,this.generatedEnvironmentMapAlt=null,this.skyboxCache=new Map,this.blurMaterial=null,this.blurScene=null}ldrLoader(w){return this._ldrLoader==null&&(this._ldrLoader=new TextureLoader),this._ldrLoader.setWithCredentials(w),this._ldrLoader}imageLoader(w){return this._imageLoader==null&&(this._imageLoader=new HDRJPGLoader(this.threeRenderer)),this._imageLoader.setWithCredentials(w),this._imageLoader}hdrLoader(w){return this._hdrLoader==null&&(this._hdrLoader=new RGBELoader,this._hdrLoader.setDataType(HalfFloatType)),this._hdrLoader.setWithCredentials(w),this._hdrLoader}async getLottieLoader(w){if(this._lottieLoader==null){const{LottieLoader:D}=await import(this.lottieLoaderUrl);this._lottieLoader=new D}return this._lottieLoader.setWithCredentials(w),this._lottieLoader}async loadImage(w,D){const O=await new Promise((U,G)=>this.ldrLoader(D).load(w,U,()=>{},G));return O.name=w,O.flipY=!1,O}async loadLottie(w,D,O){const U=await this.getLottieLoader(O);U.setQuality(D);const G=await new Promise((q,K)=>U.load(w,q,()=>{},K));return G.name=w,G}async loadEquirect(w,D=!1,O=()=>{}){try{const U=HDR_FILE_RE.test(w),G=U?this.hdrLoader(D):this.imageLoader(D),q=await new Promise((K,ee)=>G.load(w,Z=>{const{renderTarget:ie}=Z;if(ie!=null){const{texture:Y}=ie;Z.dispose(!1),K(Y)}else K(Z)},Z=>{O(Z.loaded/Z.total*.9)},ee));return O(1),q.name=w,q.mapping=EquirectangularReflectionMapping,U||(q.colorSpace=SRGBColorSpace),q}finally{O&&O(1)}}async generateEnvironmentMapAndSkybox(w=null,D=null,O=()=>{},U=!1){const G=D!=="legacy";(D==="legacy"||D==="neutral")&&(D=null),D=deserializeUrl(D);let q=Promise.resolve(null),K;w&&(q=this.loadEquirectFromUrl(w,U,O)),D?K=this.loadEquirectFromUrl(D,U,O):w?K=this.loadEquirectFromUrl(w,U,O):K=G?this.loadGeneratedEnvironmentMapAlt():this.loadGeneratedEnvironmentMap();const[ee,Z]=await Promise.all([K,q]);if(ee==null)throw new Error("Failed to load environment map.");return{environmentMap:ee,skybox:Z}}async loadEquirectFromUrl(w,D,O){if(!this.skyboxCache.has(w)){const U=this.loadEquirect(w,D,O);this.skyboxCache.set(w,U)}return this.skyboxCache.get(w)}async GenerateEnvironmentMap(w,D){await timePasses();const O=this.threeRenderer,U=new WebGLCubeRenderTarget(256,{generateMipmaps:!1,type:HalfFloatType,format:RGBAFormat,colorSpace:LinearSRGBColorSpace,depthBuffer:!0}),G=new CubeCamera(.1,100,U),q=G.renderTarget.texture;q.name=D;const K=O.outputColorSpace,ee=O.toneMapping;return O.toneMapping=NoToneMapping,O.outputColorSpace=LinearSRGBColorSpace,G.update(O,w),this.blurCubemap(U,GENERATED_SIGMA),O.toneMapping=ee,O.outputColorSpace=K,q}async loadGeneratedEnvironmentMap(){return this.generatedEnvironmentMap==null&&(this.generatedEnvironmentMap=this.GenerateEnvironmentMap(new EnvironmentScene("legacy"),"legacy")),this.generatedEnvironmentMap}async loadGeneratedEnvironmentMapAlt(){return this.generatedEnvironmentMapAlt==null&&(this.generatedEnvironmentMapAlt=this.GenerateEnvironmentMap(new EnvironmentScene("neutral"),"neutral")),this.generatedEnvironmentMapAlt}blurCubemap(w,D){if(this.blurMaterial==null){this.blurMaterial=this.getBlurShader(MAX_SAMPLES);const U=new BoxGeometry,G=new Mesh(U,this.blurMaterial);this.blurScene=new Scene,this.blurScene.add(G)}const O=w.clone();this.halfblur(w,O,D,"latitudinal"),this.halfblur(O,w,D,"longitudinal")}halfblur(w,D,O,U){const q=w.width,K=isFinite(O)?Math.PI/(2*q):2*Math.PI/(2*MAX_SAMPLES-1),ee=O/K,Z=isFinite(O)?1+Math.floor(3*ee):MAX_SAMPLES;Z>MAX_SAMPLES&&console.warn(`sigmaRadians, ${O}, is too large and will clip, as it requested ${Z} samples when the maximum is set to ${MAX_SAMPLES}`);const ie=[];let Y=0;for(let se=0;se<MAX_SAMPLES;++se){const le=se/ee,ce=Math.exp(-le*le/2);ie.push(ce),se==0?Y+=ce:se<Z&&(Y+=2*ce)}for(let se=0;se<ie.length;se++)ie[se]=ie[se]/Y;const W=this.blurMaterial.uniforms;W.envMap.value=w.texture,W.samples.value=Z,W.weights.value=ie,W.latitudinal.value=U==="latitudinal",W.dTheta.value=K,new CubeCamera(.1,100,D).update(this.threeRenderer,this.blurScene)}getBlurShader(w){const D=new Float32Array(w),O=new Vector3(0,1,0);return new ShaderMaterial({name:"SphericalGaussianBlur",defines:{n:w},uniforms:{envMap:{value:null},samples:{value:1},weights:{value:D},latitudinal:{value:!1},dTheta:{value:0},poleAxis:{value:O}},vertexShader:`
      
      varying vec3 vOutputDirection;
  
      void main() {
  
        vOutputDirection = vec3( position );
        gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
  
      }
    `,fragmentShader:`
        varying vec3 vOutputDirection;
  
        uniform samplerCube envMap;
        uniform int samples;
        uniform float weights[ n ];
        uniform bool latitudinal;
        uniform float dTheta;
        uniform vec3 poleAxis;
  
        vec3 getSample( float theta, vec3 axis ) {
  
          float cosTheta = cos( theta );
          // Rodrigues' axis-angle rotation
          vec3 sampleDirection = vOutputDirection * cosTheta
            + cross( axis, vOutputDirection ) * sin( theta )
            + axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );
  
          return vec3( textureCube( envMap, sampleDirection ) );
  
        }
  
        void main() {
  
          vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );
  
          if ( all( equal( axis, vec3( 0.0 ) ) ) ) {
  
            axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );
  
          }
  
          axis = normalize( axis );
  
          gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
          gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );
  
          for ( int i = 1; i < n; i++ ) {
  
            if ( i >= samples ) {
  
              break;
  
            }
  
            float theta = dTheta * float( i );
            gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
            gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );
  
          }
        }
      `,blending:NoBlending,depthTest:!1,depthWrite:!1,side:BackSide})}async dispose(){for(const[,w]of this.skyboxCache)(await w).dispose();this.generatedEnvironmentMap!=null&&((await this.generatedEnvironmentMap).dispose(),this.generatedEnvironmentMap=null),this.generatedEnvironmentMapAlt!=null&&((await this.generatedEnvironmentMapAlt).dispose(),this.generatedEnvironmentMapAlt=null),this.blurMaterial!=null&&this.blurMaterial.dispose()}}/* @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */const DURATION_DECAY=.2,LOW_FRAME_DURATION_MS=40,HIGH_FRAME_DURATION_MS=60,MAX_AVG_CHANGE_MS=5,SCALE_STEPS=[1,.79,.62,.5,.4,.31,.25],DEFAULT_LAST_STEP=3,DEFAULT_POWER_PREFERENCE="high-performance",COMMERCE_EXPOSURE=1.3;class Renderer extends EventDispatcher{static get singleton(){return this._singleton||(this._singleton=new Renderer({powerPreference:(self.ModelViewerElement||{}).powerPreference||DEFAULT_POWER_PREFERENCE,debug:isDebugMode()})),this._singleton}static resetSingleton(){const w=this._singleton.dispose();for(const D of w)D.disconnectedCallback();this._singleton=new Renderer({powerPreference:(self.ModelViewerElement||{}).powerPreference||DEFAULT_POWER_PREFERENCE,debug:isDebugMode()});for(const D of w)D.connectedCallback()}get canRender(){return this.threeRenderer!=null}get scaleFactor(){return SCALE_STEPS[this.scaleStep]}set minScale(w){let D=1;for(;D<SCALE_STEPS.length&&!(SCALE_STEPS[D]<w);)++D;this.lastStep=D-1}constructor(w){super(),this.loader=new CachingGLTFLoader(ModelViewerGLTFInstance),this.width=0,this.height=0,this.dpr=1,this.scenes=new Set,this.multipleScenesVisible=!1,this.lastTick=performance.now(),this.renderedLastFrame=!1,this.scaleStep=0,this.lastStep=DEFAULT_LAST_STEP,this.avgFrameDuration=(HIGH_FRAME_DURATION_MS+LOW_FRAME_DURATION_MS)/2,this.onWebGLContextLost=D=>{this.dispatchEvent({type:"contextlost",sourceEvent:D})},this.onWebGLContextRestored=()=>{var D;(D=this.textureUtils)===null||D===void 0||D.dispose(),this.textureUtils=new TextureUtils(this.threeRenderer);for(const O of this.scenes)O.element[$updateEnvironment]()},this.dpr=window.devicePixelRatio,this.canvas3D=document.createElement("canvas"),this.canvas3D.id="webgl-canvas",this.canvas3D.classList.add("show");try{this.threeRenderer=new WebGLRenderer({canvas:this.canvas3D,alpha:!0,antialias:!0,powerPreference:w.powerPreference,preserveDrawingBuffer:!0}),this.threeRenderer.autoClear=!0,this.threeRenderer.setPixelRatio(1),this.threeRenderer.debug={checkShaderErrors:!!w.debug,onShaderError:null},this.threeRenderer.toneMapping=NeutralToneMapping}catch(D){console.warn(D)}this.arRenderer=new ARRenderer(this),this.textureUtils=this.canRender?new TextureUtils(this.threeRenderer):null,CachingGLTFLoader.initializeKTX2Loader(this.threeRenderer),this.canvas3D.addEventListener("webglcontextlost",this.onWebGLContextLost),this.canvas3D.addEventListener("webglcontextrestored",this.onWebGLContextRestored),this.updateRendererSize()}registerScene(w){this.scenes.add(w),w.forceRescale();const D=new Vector2;this.threeRenderer.getSize(D),w.canvas.width=D.x,w.canvas.height=D.y,this.canRender&&this.scenes.size>0&&this.threeRenderer.setAnimationLoop((O,U)=>this.render(O,U))}unregisterScene(w){this.scenes.delete(w),this.canvas3D.parentElement===w.canvas.parentElement&&w.canvas.parentElement.removeChild(this.canvas3D),this.canRender&&this.scenes.size===0&&this.threeRenderer.setAnimationLoop(null)}displayCanvas(w){return w.element.modelIsVisible&&!this.multipleScenesVisible?this.canvas3D:w.element[$canvas]}countVisibleScenes(){const{canvas3D:w}=this;let D=0,O=null;for(const G of this.scenes){const{element:q}=G;q.modelIsVisible&&G.externalRenderer==null&&++D,w.parentElement===G.canvas.parentElement&&(O=G)}const U=D>1;if(O!=null){const G=U&&!this.multipleScenesVisible,q=!O.element.modelIsVisible;if(G||q){const{width:K,height:ee}=this.sceneSize(O);this.copyPixels(O,K,ee),w.parentElement.removeChild(w)}}this.multipleScenesVisible=U}updateRendererSize(){var w;const D=window.devicePixelRatio;if(D!==this.dpr)for(const G of this.scenes){const{element:q}=G;q[$updateSize](q.getBoundingClientRect())}let O=0,U=0;for(const G of this.scenes)O=Math.max(O,G.width),U=Math.max(U,G.height);if(!(O===this.width&&U===this.height&&D===this.dpr)){this.width=O,this.height=U,this.dpr=D,O=Math.ceil(O*D),U=Math.ceil(U*D),this.canRender&&this.threeRenderer.setSize(O,U,!1);for(const G of this.scenes){const{canvas:q}=G;q.width=O,q.height=U,G.forceRescale(),(w=G.effectRenderer)===null||w===void 0||w.setSize(O,U)}}}updateRendererScale(w){const D=this.scaleStep;this.avgFrameDuration+=clamp$1(DURATION_DECAY*(w-this.avgFrameDuration),-MAX_AVG_CHANGE_MS,MAX_AVG_CHANGE_MS),this.avgFrameDuration>HIGH_FRAME_DURATION_MS?++this.scaleStep:this.avgFrameDuration<LOW_FRAME_DURATION_MS&&this.scaleStep>0&&--this.scaleStep,this.scaleStep=Math.min(this.scaleStep,this.lastStep),D!==this.scaleStep&&(this.avgFrameDuration=(HIGH_FRAME_DURATION_MS+LOW_FRAME_DURATION_MS)/2)}shouldRender(w){if(w.shouldRender())w.scaleStep!=this.scaleStep&&(w.scaleStep=this.scaleStep,this.rescaleCanvas(w));else if(w.scaleStep!=0)w.scaleStep=0,this.rescaleCanvas(w);else return!1;return!0}rescaleCanvas(w){const D=SCALE_STEPS[w.scaleStep],O=Math.ceil(this.width/D),U=Math.ceil(this.height/D),{style:G}=w.canvas;G.width=`${O}px`,G.height=`${U}px`,this.canvas3D.style.width=`${O}px`,this.canvas3D.style.height=`${U}px`;const q=this.dpr*D,K=D<1?"GPU throttling":this.dpr!==window.devicePixelRatio?"No meta viewport tag":"";w.element.dispatchEvent(new CustomEvent("render-scale",{detail:{reportedDpr:window.devicePixelRatio,renderedDpr:q,minimumDpr:this.dpr*SCALE_STEPS[this.lastStep],pixelWidth:Math.ceil(w.width*q),pixelHeight:Math.ceil(w.height*q),reason:K}}))}sceneSize(w){const{dpr:D}=this,O=SCALE_STEPS[w.scaleStep],U=Math.min(Math.ceil(w.width*O*D),this.canvas3D.width),G=Math.min(Math.ceil(w.height*O*D),this.canvas3D.height);return{width:U,height:G}}copyPixels(w,D,O){const U=w.context;if(U==null){console.log("could not acquire 2d context");return}U.clearRect(0,0,D,O),U.drawImage(this.canvas3D,0,0,D,O,0,0,D,O),w.canvas.classList.add("show")}orderedScenes(){const w=[];for(const D of[!1,!0])for(const O of this.scenes)O.element.modelIsVisible===D&&w.push(O);return w}get isPresenting(){return this.arRenderer.isPresenting}preRender(w,D,O){const{element:U,exposure:G,toneMapping:q}=w;U[$tick](D,O);const K=typeof G=="number"&&!Number.isNaN(G),ee=U.environmentImage,Z=U.skyboxImage,ie=q===NeutralToneMapping&&(ee==="neutral"||ee==="legacy"||!ee&&!Z);this.threeRenderer.toneMappingExposure=(K?G:1)*(ie?COMMERCE_EXPOSURE:1)}render(w,D){if(D!=null){this.arRenderer.onWebXRFrame(w,D);return}const O=w-this.lastTick;if(this.lastTick=w,!this.canRender||this.isPresenting)return;this.countVisibleScenes(),this.updateRendererSize(),this.renderedLastFrame&&(this.updateRendererScale(O),this.renderedLastFrame=!1);const{canvas3D:U}=this;for(const G of this.orderedScenes()){const{element:q}=G;if(!q.loaded||!q.modelIsVisible&&G.renderCount>0||(this.preRender(G,w,O),!this.shouldRender(G)))continue;if(G.externalRenderer!=null){const Z=G.getCamera();Z.updateMatrix();const{matrix:ie,projectionMatrix:Y}=Z,W=ie.elements.slice(),ne=G.getTarget();W[12]+=ne.x,W[13]+=ne.y,W[14]+=ne.z,G.externalRenderer.render({viewMatrix:W,projectionMatrix:Y.elements});continue}if(!q.modelIsVisible&&!this.multipleScenesVisible)for(const Z of this.scenes)Z.element.modelIsVisible&&Z.queueRender();const{width:K,height:ee}=this.sceneSize(G);G.renderShadow(this.threeRenderer),this.threeRenderer.setRenderTarget(null),this.threeRenderer.setViewport(0,Math.ceil(this.height*this.dpr)-ee,K,ee),G.effectRenderer!=null?G.effectRenderer.render(O):(this.threeRenderer.autoClear=!0,this.threeRenderer.toneMapping=G.toneMapping,this.threeRenderer.render(G,G.camera)),this.multipleScenesVisible||!G.element.modelIsVisible&&G.renderCount===0?this.copyPixels(G,K,ee):U.parentElement!==G.canvas.parentElement&&(G.canvas.parentElement.appendChild(U),G.canvas.classList.remove("show")),G.hasRendered(),++G.renderCount,this.renderedLastFrame=!0}}dispose(){this.textureUtils!=null&&this.textureUtils.dispose(),this.threeRenderer!=null&&this.threeRenderer.dispose(),this.textureUtils=null,this.threeRenderer=null;const w=[];for(const D of this.scenes)w.push(D.element);return this.canvas3D.removeEventListener("webglcontextlost",this.onWebGLContextLost),this.canvas3D.removeEventListener("webglcontextrestored",this.onWebGLContextRestored),w}}/* @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */const $correlatedObjects=Symbol("correlatedObjects"),$onUpdate$1=Symbol("onUpdate");class ThreeDOMElement{constructor(w,D){this[$onUpdate$1]=w,this[$correlatedObjects]=D}}/* @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */const quadMaterial=new MeshBasicMaterial,quad=new PlaneGeometry(2,2);let adhocNum=0;const $threeTexture$2=Symbol("threeTexture"),$threeTextures$1=Symbol("threeTextures");let Image$1=class extends ThreeDOMElement{get[$threeTexture$2](){var w;return(w=this[$correlatedObjects])===null||w===void 0?void 0:w.values().next().value}get[$threeTextures$1](){return this[$correlatedObjects]}constructor(w,D){super(w,new Set(D?[D]:[])),this[$threeTexture$2].image.src||(this[$threeTexture$2].image.src=D.name?D.name:"adhoc_image"+adhocNum++),this[$threeTexture$2].image.name||(this[$threeTexture$2].image.name=D&&D.image&&D.image.src?D.image.src.split("/").pop():"adhoc_image")}get name(){return this[$threeTexture$2].image.name||""}get uri(){return this[$threeTexture$2].image.src}get bufferView(){return this[$threeTexture$2].image.bufferView}get element(){const w=this[$threeTexture$2];if(w&&(w.isCanvasTexture||w.isVideoTexture))return w.image}get animation(){const w=this[$threeTexture$2];if(w&&w.isCanvasTexture&&w.animation)return w.animation}get type(){return this.uri!=null?"external":"embedded"}set name(w){for(const D of this[$threeTextures$1])D.image.name=w}update(){const w=this[$threeTexture$2];w&&w.isCanvasTexture&&!w.animation&&(this[$threeTexture$2].needsUpdate=!0,this[$onUpdate$1]())}async createThumbnail(w,D){const O=new Scene;quadMaterial.map=this[$threeTexture$2];const U=new Mesh(quad,quadMaterial);O.add(U);const G=new OrthographicCamera(-1,1,1,-1,0,1),{threeRenderer:q}=Renderer.singleton,K=new WebGLRenderTarget(w,D);q.setRenderTarget(K),q.render(O,G),q.setRenderTarget(null);const ee=new Uint8Array(w*D*4);q.readRenderTargetPixels(K,0,0,w,D,ee),blobCanvas.width=w,blobCanvas.height=D;const Z=blobCanvas.getContext("2d"),ie=Z.createImageData(w,D);return ie.data.set(ee),Z.putImageData(ie,0,0),new Promise(async(Y,W)=>{blobCanvas.toBlob(ne=>{if(!ne)return W("Failed to capture thumbnail.");Y(URL.createObjectURL(ne))},"image/png")})}};var Filter;(function(F){F[F.Nearest=9728]="Nearest",F[F.Linear=9729]="Linear",F[F.NearestMipmapNearest=9984]="NearestMipmapNearest",F[F.LinearMipmapNearest=9985]="LinearMipmapNearest",F[F.NearestMipmapLinear=9986]="NearestMipmapLinear",F[F.LinearMipmapLinear=9987]="LinearMipmapLinear"})(Filter||(Filter={}));var Wrap;(function(F){F[F.ClampToEdge=33071]="ClampToEdge",F[F.MirroredRepeat=33648]="MirroredRepeat",F[F.Repeat=10497]="Repeat"})(Wrap||(Wrap={}));/* @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */const wrapModeToWrapping=new Map([[Wrap.Repeat,RepeatWrapping],[Wrap.ClampToEdge,ClampToEdgeWrapping],[Wrap.MirroredRepeat,MirroredRepeatWrapping]]),wrappingToWrapMode=new Map([[RepeatWrapping,Wrap.Repeat],[ClampToEdgeWrapping,Wrap.ClampToEdge],[MirroredRepeatWrapping,Wrap.MirroredRepeat]]),minFilterToMinification=new Map([[Filter.Nearest,NearestFilter],[Filter.Linear,LinearFilter],[Filter.NearestMipmapNearest,NearestMipmapNearestFilter],[Filter.LinearMipmapNearest,LinearMipmapNearestFilter],[Filter.NearestMipmapLinear,NearestMipmapLinearFilter],[Filter.LinearMipmapLinear,LinearMipmapLinearFilter]]),minificationToMinFilter=new Map([[NearestFilter,Filter.Nearest],[LinearFilter,Filter.Linear],[NearestMipmapNearestFilter,Filter.NearestMipmapNearest],[LinearMipmapNearestFilter,Filter.LinearMipmapNearest],[NearestMipmapLinearFilter,Filter.NearestMipmapLinear],[LinearMipmapLinearFilter,Filter.LinearMipmapLinear]]),magFilterToMagnification=new Map([[Filter.Nearest,NearestFilter],[Filter.Linear,LinearFilter]]),magnificationToMagFilter=new Map([[NearestFilter,Filter.Nearest],[LinearFilter,Filter.Linear]]),isMinFilter=F=>minificationToMinFilter.has(F),isMagFilter=F=>magnificationToMagFilter.has(F),isWrapping=F=>wrappingToWrapMode.has(F),isValidSamplerValue=(F,w)=>{switch(F){case"minFilter":return isMinFilter(w);case"magFilter":return isMagFilter(w);case"wrapS":case"wrapT":return isWrapping(w);case"rotation":case"repeat":case"offset":return!0;default:throw new Error(`Cannot configure property "${F}" on Sampler`)}},$threeTexture$1=Symbol("threeTexture"),$threeTextures=Symbol("threeTextures"),$setProperty=Symbol("setProperty");let Sampler$1=class extends ThreeDOMElement{get[$threeTexture$1](){var w;return(w=this[$correlatedObjects])===null||w===void 0?void 0:w.values().next().value}get[$threeTextures](){return this[$correlatedObjects]}constructor(w,D){super(w,new Set(D?[D]:[]))}get name(){return this[$threeTexture$1].name||""}get minFilter(){return minificationToMinFilter.get(this[$threeTexture$1].minFilter)}get magFilter(){return magnificationToMagFilter.get(this[$threeTexture$1].magFilter)}get wrapS(){return wrappingToWrapMode.get(this[$threeTexture$1].wrapS)}get wrapT(){return wrappingToWrapMode.get(this[$threeTexture$1].wrapT)}get rotation(){return this[$threeTexture$1].rotation}get scale(){return toVector2D(this[$threeTexture$1].repeat)}get offset(){return toVector2D(this[$threeTexture$1].offset)}setMinFilter(w){this[$setProperty]("minFilter",minFilterToMinification.get(w))}setMagFilter(w){this[$setProperty]("magFilter",magFilterToMagnification.get(w))}setWrapS(w){this[$setProperty]("wrapS",wrapModeToWrapping.get(w))}setWrapT(w){this[$setProperty]("wrapT",wrapModeToWrapping.get(w))}setRotation(w){w==null&&(w=0),this[$setProperty]("rotation",w)}setScale(w){w==null&&(w={u:1,v:1}),this[$setProperty]("repeat",new Vector2(w.u,w.v))}setOffset(w){w==null&&(w={u:0,v:0}),this[$setProperty]("offset",new Vector2(w.u,w.v))}[$setProperty](w,D){if(isValidSamplerValue(w,D))for(const O of this[$threeTextures])O[w]=D,O.needsUpdate=!0;this[$onUpdate$1]()}};/* @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */const $image=Symbol("image"),$sampler=Symbol("sampler"),$threeTexture=Symbol("threeTexture");class Texture extends ThreeDOMElement{get[$threeTexture](){var w;return(w=this[$correlatedObjects])===null||w===void 0?void 0:w.values().next().value}constructor(w,D){super(w,new Set(D?[D]:[])),this[$sampler]=new Sampler$1(w,D),this[$image]=new Image$1(w,D)}get name(){return this[$threeTexture].name||""}set name(w){for(const D of this[$correlatedObjects])D.name=w}get sampler(){return this[$sampler]}get source(){return this[$image]}}/* @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */var _a$4,_b$4,_c$2;const $texture=Symbol("texture"),$transform=Symbol("transform"),$materials$1=Symbol("materials"),$usage=Symbol("usage"),$onUpdate=Symbol("onUpdate"),$activeVideo=Symbol("activeVideo");var TextureUsage;(function(F){F[F.Base=0]="Base",F[F.MetallicRoughness=1]="MetallicRoughness",F[F.Normal=2]="Normal",F[F.Occlusion=3]="Occlusion",F[F.Emissive=4]="Emissive",F[F.Clearcoat=5]="Clearcoat",F[F.ClearcoatRoughness=6]="ClearcoatRoughness",F[F.ClearcoatNormal=7]="ClearcoatNormal",F[F.SheenColor=8]="SheenColor",F[F.SheenRoughness=9]="SheenRoughness",F[F.Transmission=10]="Transmission",F[F.Thickness=11]="Thickness",F[F.Specular=12]="Specular",F[F.SpecularColor=13]="SpecularColor",F[F.Iridescence=14]="Iridescence",F[F.IridescenceThickness=15]="IridescenceThickness",F[F.Anisotropy=16]="Anisotropy"})(TextureUsage||(TextureUsage={}));class TextureInfo{constructor(w,D,O,U){this[_a$4]=null,this[_b$4]={rotation:0,scale:new Vector2(1,1),offset:new Vector2(0,0)},this[_c$2]=!1,O&&(this[$transform].rotation=O.rotation,this[$transform].scale.copy(O.repeat),this[$transform].offset.copy(O.offset),this[$texture]=new Texture(w,O)),this[$onUpdate]=w,this[$materials$1]=U,this[$usage]=D}get texture(){return this[$texture]}setTexture(w){var D,O;const U=w!=null?w.source[$threeTexture$2]:null,G=(D=this[$texture])===null||D===void 0?void 0:D.source[$threeTexture$2];if(G!=null&&G.isVideoTexture?this[$activeVideo]=!1:!((O=this[$texture])===null||O===void 0)&&O.source.animation&&this[$texture].source.animation.removeEventListener("enterFrame",this[$onUpdate]),this[$texture]=w,U!=null&&U.isVideoTexture){const K=U.image;if(this[$activeVideo]=!0,K.requestVideoFrameCallback!=null){const ee=()=>{this[$activeVideo]&&(this[$onUpdate](),K.requestVideoFrameCallback(ee))};K.requestVideoFrameCallback(ee)}else{const ee=()=>{this[$activeVideo]&&(this[$onUpdate](),requestAnimationFrame(ee))};requestAnimationFrame(ee)}}else w?.source.animation!=null&&w.source.animation.addEventListener("enterFrame",this[$onUpdate]);let q=SRGBColorSpace;if(this[$materials$1])for(const K of this[$materials$1]){switch(this[$usage]){case TextureUsage.Base:K.map=U;break;case TextureUsage.MetallicRoughness:q=LinearSRGBColorSpace,K.metalnessMap=U,K.roughnessMap=U;break;case TextureUsage.Normal:q=LinearSRGBColorSpace,K.normalMap=U;break;case TextureUsage.Occlusion:q=LinearSRGBColorSpace,K.aoMap=U;break;case TextureUsage.Emissive:K.emissiveMap=U;break;case TextureUsage.Clearcoat:K.clearcoatMap=U;break;case TextureUsage.ClearcoatRoughness:K.clearcoatRoughnessMap=U;break;case TextureUsage.ClearcoatNormal:K.clearcoatNormalMap=U;break;case TextureUsage.SheenColor:K.sheenColorMap=U;break;case TextureUsage.SheenRoughness:K.sheenRoughnessMap=U;break;case TextureUsage.Transmission:K.transmissionMap=U;break;case TextureUsage.Thickness:K.thicknessMap=U;break;case TextureUsage.Specular:K.specularIntensityMap=U;break;case TextureUsage.SpecularColor:K.specularColorMap=U;break;case TextureUsage.Iridescence:K.iridescenceMap=U;break;case TextureUsage.IridescenceThickness:K.iridescenceThicknessMap=U;break;case TextureUsage.Anisotropy:K.anisotropyMap=U;break}K.needsUpdate=!0}U&&(U.colorSpace=q,U.rotation=this[$transform].rotation,U.repeat=this[$transform].scale,U.offset=this[$transform].offset),this[$onUpdate]()}}_a$4=$texture,_b$4=$transform,_c$2=$activeVideo;/* @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */const $threeMaterial=Symbol("threeMaterial"),$threeMaterials=Symbol("threeMaterials"),$baseColorTexture=Symbol("baseColorTexture"),$metallicRoughnessTexture=Symbol("metallicRoughnessTexture");class PBRMetallicRoughness extends ThreeDOMElement{get[$threeMaterials](){return this[$correlatedObjects]}get[$threeMaterial](){var w;return(w=this[$correlatedObjects])===null||w===void 0?void 0:w.values().next().value}constructor(w,D){super(w,D);const{map:O,metalnessMap:U}=D.values().next().value;this[$baseColorTexture]=new TextureInfo(w,TextureUsage.Base,O,D),this[$metallicRoughnessTexture]=new TextureInfo(w,TextureUsage.MetallicRoughness,U,D)}get baseColorFactor(){const w=[0,0,0,this[$threeMaterial].opacity];return this[$threeMaterial].color.toArray(w),w}get metallicFactor(){return this[$threeMaterial].metalness}get roughnessFactor(){return this[$threeMaterial].roughness}get baseColorTexture(){return this[$baseColorTexture]}get metallicRoughnessTexture(){return this[$metallicRoughnessTexture]}setBaseColorFactor(w){const D=new Color;w instanceof Array?D.fromArray(w):D.set(w);for(const O of this[$threeMaterials])O.color.set(D),w instanceof Array&&w.length>3?O.opacity=w[3]:(w=[0,0,0,O.opacity],D.toArray(w));this[$onUpdate$1]()}setMetallicFactor(w){for(const D of this[$threeMaterials])D.metalness=w;this[$onUpdate$1]()}setRoughnessFactor(w){for(const D of this[$threeMaterials])D.roughness=w;this[$onUpdate$1]()}}/* @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */var _a$3,_b$3;const $pbrMetallicRoughness=Symbol("pbrMetallicRoughness"),$normalTexture=Symbol("normalTexture"),$occlusionTexture=Symbol("occlusionTexture"),$emissiveTexture=Symbol("emissiveTexture"),$backingThreeMaterial=Symbol("backingThreeMaterial"),$applyAlphaCutoff=Symbol("applyAlphaCutoff"),$getAlphaMode=Symbol("getAlphaMode"),$lazyLoadGLTFInfo=Symbol("lazyLoadGLTFInfo"),$initialize=Symbol("initialize"),$getLoadedMaterial=Symbol("getLoadedMaterial"),$ensureMaterialIsLoaded=Symbol("ensureMaterialIsLoaded"),$gltfIndex=Symbol("gltfIndex"),$setActive=Symbol("setActive"),$variantIndices=Symbol("variantIndices"),$isActive=Symbol("isActive"),$modelVariants=Symbol("modelVariants"),$name=Symbol("name"),$pbrTextures=Symbol("pbrTextures");class Material extends ThreeDOMElement{get[(_a$3=$variantIndices,_b$3=$pbrTextures,$backingThreeMaterial)](){return this[$correlatedObjects].values().next().value}constructor(w,D,O,U,G,q,K=void 0){super(w,G),this[_a$3]=new Set,this[_b$3]=new Map,this[$gltfIndex]=D,this[$isActive]=O,this[$modelVariants]=U,this[$name]=q,K==null?this[$initialize]():this[$lazyLoadGLTFInfo]=K}[$initialize](){const w=this[$onUpdate$1],D=this[$correlatedObjects];this[$pbrMetallicRoughness]=new PBRMetallicRoughness(w,D);const{normalMap:O,aoMap:U,emissiveMap:G}=D.values().next().value;this[$normalTexture]=new TextureInfo(w,TextureUsage.Normal,O,D),this[$occlusionTexture]=new TextureInfo(w,TextureUsage.Occlusion,U,D),this[$emissiveTexture]=new TextureInfo(w,TextureUsage.Emissive,G,D);const q=K=>{this[$pbrTextures].set(K,new TextureInfo(w,K,null,D))};q(TextureUsage.Clearcoat),q(TextureUsage.ClearcoatRoughness),q(TextureUsage.ClearcoatNormal),q(TextureUsage.SheenColor),q(TextureUsage.SheenRoughness),q(TextureUsage.Transmission),q(TextureUsage.Thickness),q(TextureUsage.Specular),q(TextureUsage.SpecularColor),q(TextureUsage.Iridescence),q(TextureUsage.IridescenceThickness),q(TextureUsage.Anisotropy)}async[$getLoadedMaterial](){if(this[$lazyLoadGLTFInfo]!=null){const w=await this[$lazyLoadGLTFInfo].doLazyLoad();return this[$initialize](),this[$lazyLoadGLTFInfo]=void 0,this.ensureLoaded=async()=>{},w}return null}colorFromRgb(w){const D=new Color;return w instanceof Array?D.fromArray(w):D.set(w),D}[$ensureMaterialIsLoaded](){if(this[$lazyLoadGLTFInfo]!=null)throw new Error(`Material "${this.name}" has not been loaded, call 'await
    myMaterial.ensureLoaded()' before using an unloaded material.`)}async ensureLoaded(){await this[$getLoadedMaterial]()}get isLoaded(){return this[$lazyLoadGLTFInfo]==null}get isActive(){return this[$isActive]}[$setActive](w){this[$isActive]=w}get name(){return this[$name]||""}set name(w){if(this[$name]=w,this[$correlatedObjects]!=null)for(const D of this[$correlatedObjects])D.name=w}get pbrMetallicRoughness(){return this[$ensureMaterialIsLoaded](),this[$pbrMetallicRoughness]}get normalTexture(){return this[$ensureMaterialIsLoaded](),this[$normalTexture]}get occlusionTexture(){return this[$ensureMaterialIsLoaded](),this[$occlusionTexture]}get emissiveTexture(){return this[$ensureMaterialIsLoaded](),this[$emissiveTexture]}get emissiveFactor(){return this[$ensureMaterialIsLoaded](),this[$backingThreeMaterial].emissive.toArray()}get index(){return this[$gltfIndex]}hasVariant(w){const D=this[$modelVariants].get(w);return D!=null&&this[$variantIndices].has(D.index)}setEmissiveFactor(w){this[$ensureMaterialIsLoaded]();const D=this.colorFromRgb(w);for(const O of this[$correlatedObjects])O.emissive.set(D);this[$onUpdate$1]()}[$getAlphaMode](){return this[$backingThreeMaterial].transparent?"BLEND":this[$backingThreeMaterial].alphaTest>0?"MASK":"OPAQUE"}[$applyAlphaCutoff](){this[$ensureMaterialIsLoaded]();for(const w of this[$correlatedObjects])this[$getAlphaMode]()==="MASK"?w.alphaTest==null&&(w.alphaTest=.5):w.alphaTest=void 0,w.needsUpdate=!0}setAlphaCutoff(w){this[$ensureMaterialIsLoaded]();for(const D of this[$correlatedObjects])D.alphaTest=w,D.needsUpdate=!0;this[$applyAlphaCutoff](),this[$onUpdate$1]()}getAlphaCutoff(){return this[$ensureMaterialIsLoaded](),this[$backingThreeMaterial].alphaTest}setDoubleSided(w){this[$ensureMaterialIsLoaded]();for(const D of this[$correlatedObjects])D.side=w?DoubleSide:FrontSide,D.needsUpdate=!0;this[$onUpdate$1]()}getDoubleSided(){return this[$ensureMaterialIsLoaded](),this[$backingThreeMaterial].side==DoubleSide}setAlphaMode(w){this[$ensureMaterialIsLoaded]();const D=(O,U)=>{O.transparent=U,O.depthWrite=!U};for(const O of this[$correlatedObjects])D(O,w==="BLEND"),w==="MASK"?O.alphaTest=.5:O.alphaTest=void 0,O.needsUpdate=!0;this[$onUpdate$1]()}getAlphaMode(){return this[$ensureMaterialIsLoaded](),this[$getAlphaMode]()}get emissiveStrength(){return this[$ensureMaterialIsLoaded](),this[$backingThreeMaterial].emissiveIntensity}setEmissiveStrength(w){this[$ensureMaterialIsLoaded]();for(const D of this[$correlatedObjects])D.emissiveIntensity=w;this[$onUpdate$1]()}get clearcoatFactor(){return this[$ensureMaterialIsLoaded](),this[$backingThreeMaterial].clearcoat}get clearcoatRoughnessFactor(){return this[$ensureMaterialIsLoaded](),this[$backingThreeMaterial].clearcoatRoughness}get clearcoatTexture(){return this[$ensureMaterialIsLoaded](),this[$pbrTextures].get(TextureUsage.Clearcoat)}get clearcoatRoughnessTexture(){return this[$ensureMaterialIsLoaded](),this[$pbrTextures].get(TextureUsage.ClearcoatRoughness)}get clearcoatNormalTexture(){return this[$ensureMaterialIsLoaded](),this[$pbrTextures].get(TextureUsage.ClearcoatNormal)}get clearcoatNormalScale(){return this[$ensureMaterialIsLoaded](),this[$backingThreeMaterial].clearcoatNormalScale.x}setClearcoatFactor(w){this[$ensureMaterialIsLoaded]();for(const D of this[$correlatedObjects])D.clearcoat=w;this[$onUpdate$1]()}setClearcoatRoughnessFactor(w){this[$ensureMaterialIsLoaded]();for(const D of this[$correlatedObjects])D.clearcoatRoughness=w;this[$onUpdate$1]()}setClearcoatNormalScale(w){this[$ensureMaterialIsLoaded]();for(const D of this[$correlatedObjects])D.clearcoatNormalScale=new Vector2(w,w);this[$onUpdate$1]()}get ior(){return this[$ensureMaterialIsLoaded](),this[$backingThreeMaterial].ior}setIor(w){this[$ensureMaterialIsLoaded]();for(const D of this[$correlatedObjects])D.ior=w;this[$onUpdate$1]()}get sheenColorFactor(){return this[$ensureMaterialIsLoaded](),this[$backingThreeMaterial].sheenColor.toArray()}get sheenColorTexture(){return this[$ensureMaterialIsLoaded](),this[$pbrTextures].get(TextureUsage.SheenColor)}get sheenRoughnessFactor(){return this[$ensureMaterialIsLoaded](),this[$backingThreeMaterial].sheenRoughness}get sheenRoughnessTexture(){return this[$ensureMaterialIsLoaded](),this[$pbrTextures].get(TextureUsage.SheenRoughness)}setSheenColorFactor(w){this[$ensureMaterialIsLoaded]();const D=this.colorFromRgb(w);for(const O of this[$correlatedObjects])O.sheenColor.set(D),O.sheen=1;this[$onUpdate$1]()}setSheenRoughnessFactor(w){this[$ensureMaterialIsLoaded]();for(const D of this[$correlatedObjects])D.sheenRoughness=w,D.sheen=1;this[$onUpdate$1]()}get transmissionFactor(){return this[$ensureMaterialIsLoaded](),this[$backingThreeMaterial].transmission}get transmissionTexture(){return this[$ensureMaterialIsLoaded](),this[$pbrTextures].get(TextureUsage.Transmission)}setTransmissionFactor(w){this[$ensureMaterialIsLoaded]();for(const D of this[$correlatedObjects])D.transmission=w;this[$onUpdate$1]()}get thicknessFactor(){return this[$ensureMaterialIsLoaded](),this[$backingThreeMaterial].thickness}get thicknessTexture(){return this[$ensureMaterialIsLoaded](),this[$pbrTextures].get(TextureUsage.Thickness)}get attenuationDistance(){return this[$ensureMaterialIsLoaded](),this[$backingThreeMaterial].attenuationDistance}get attenuationColor(){return this[$ensureMaterialIsLoaded](),this[$backingThreeMaterial].attenuationColor.toArray()}setThicknessFactor(w){this[$ensureMaterialIsLoaded]();for(const D of this[$correlatedObjects])D.thickness=w;this[$onUpdate$1]()}setAttenuationDistance(w){this[$ensureMaterialIsLoaded]();for(const D of this[$correlatedObjects])D.attenuationDistance=w;this[$onUpdate$1]()}setAttenuationColor(w){this[$ensureMaterialIsLoaded]();const D=this.colorFromRgb(w);for(const O of this[$correlatedObjects])O.attenuationColor.set(D);this[$onUpdate$1]()}get specularFactor(){return this[$ensureMaterialIsLoaded](),this[$backingThreeMaterial].specularIntensity}get specularTexture(){return this[$ensureMaterialIsLoaded](),this[$pbrTextures].get(TextureUsage.Specular)}get specularColorFactor(){return this[$ensureMaterialIsLoaded](),this[$backingThreeMaterial].specularColor.toArray()}get specularColorTexture(){return this[$ensureMaterialIsLoaded](),this[$pbrTextures].get(TextureUsage.SheenColor)}setSpecularFactor(w){this[$ensureMaterialIsLoaded]();for(const D of this[$correlatedObjects])D.specularIntensity=w;this[$onUpdate$1]()}setSpecularColorFactor(w){this[$ensureMaterialIsLoaded]();const D=this.colorFromRgb(w);for(const O of this[$correlatedObjects])O.specularColor.set(D);this[$onUpdate$1]()}get iridescenceFactor(){return this[$ensureMaterialIsLoaded](),this[$backingThreeMaterial].iridescence}get iridescenceTexture(){return this[$ensureMaterialIsLoaded](),this[$pbrTextures].get(TextureUsage.Iridescence)}get iridescenceIor(){return this[$ensureMaterialIsLoaded](),this[$backingThreeMaterial].iridescenceIOR}get iridescenceThicknessMinimum(){return this[$ensureMaterialIsLoaded](),this[$backingThreeMaterial].iridescenceThicknessRange[0]}get iridescenceThicknessMaximum(){return this[$ensureMaterialIsLoaded](),this[$backingThreeMaterial].iridescenceThicknessRange[1]}get iridescenceThicknessTexture(){return this[$ensureMaterialIsLoaded](),this[$pbrTextures].get(TextureUsage.IridescenceThickness)}setIridescenceFactor(w){this[$ensureMaterialIsLoaded]();for(const D of this[$correlatedObjects])D.iridescence=w;this[$onUpdate$1]()}setIridescenceIor(w){this[$ensureMaterialIsLoaded]();for(const D of this[$correlatedObjects])D.iridescenceIOR=w;this[$onUpdate$1]()}setIridescenceThicknessMinimum(w){this[$ensureMaterialIsLoaded]();for(const D of this[$correlatedObjects])D.iridescenceThicknessRange[0]=w;this[$onUpdate$1]()}setIridescenceThicknessMaximum(w){this[$ensureMaterialIsLoaded]();for(const D of this[$correlatedObjects])D.iridescenceThicknessRange[1]=w;this[$onUpdate$1]()}get anisotropyStrength(){return this[$ensureMaterialIsLoaded](),this[$backingThreeMaterial].anisotropy}get anisotropyRotation(){return this[$ensureMaterialIsLoaded](),this[$backingThreeMaterial].anisotropyRotation}get anisotropyTexture(){return this[$ensureMaterialIsLoaded](),this[$pbrTextures].get(TextureUsage.Anisotropy)}setAnisotropyStrength(w){this[$ensureMaterialIsLoaded]();for(const D of this[$correlatedObjects])D.anisotropy=w;this[$onUpdate$1]()}setAnisotropyRotation(w){this[$ensureMaterialIsLoaded]();for(const D of this[$correlatedObjects])D.anisotropyRotation=w;this[$onUpdate$1]()}}let Node$1=class{constructor(w){this.name="",this.children=new Array,this.name=w}};class PrimitiveNode extends Node$1{constructor(w,D,O,U){super(w.name),this.materials=new Map,this.variantToMaterialMap=new Map,this.initialMaterialIdx=0,this.activeMaterialIdx=0,this.mesh=w;const{gltf:G,threeGLTF:q,threeObjectMap:K}=U;this.parser=q.parser,this.modelVariants=O,this.mesh.userData.variantData=O;const ee=K.get(w.material);ee.materials!=null?this.initialMaterialIdx=this.activeMaterialIdx=ee.materials:console.error(`Primitive (${w.name}) missing initial material reference.`);const Z=w.userData.associations||{};if(Z.meshes==null){console.error("Mesh is missing primitive index association");return}const W=((G.meshes||[])[Z.meshes].primitives||[])[Z.primitives];if(W==null){console.error("Mesh primitive definition is missing.");return}if(W.material!=null)this.materials.set(W.material,D[W.material]);else{const ne=D.findIndex(se=>se.name==="Default");ne>=0?this.materials.set(ne,D[ne]):console.warn("gltfPrimitive has no material!")}if(W.extensions&&W.extensions.KHR_materials_variants){const ne=W.extensions.KHR_materials_variants,le=q.parser.json.extensions.KHR_materials_variants.variants;for(const ce of ne.mappings){const he=D[ce.material];this.materials.set(ce.material,he);for(const pe of ce.variants){const{name:me}=le[pe];this.variantToMaterialMap.set(pe,he),he[$variantIndices].add(pe),O.has(me)||O.set(me,{name:me,index:pe})}}}}async setActiveMaterial(w){const D=this.materials.get(w);if(w!==this.activeMaterialIdx){const O=D[$correlatedObjects],U=await D[$getLoadedMaterial]();U!=null?this.mesh.material=U:this.mesh.material=O.values().next().value,this.parser.assignFinalMaterial(this.mesh),O.add(this.mesh.material),this.activeMaterialIdx=w}return this.mesh.material}getActiveMaterial(){return this.materials.get(this.activeMaterialIdx)}getMaterial(w){return this.materials.get(w)}async enableVariant(w){if(w==null)return this.setActiveMaterial(this.initialMaterialIdx);if(this.variantToMaterialMap!=null&&this.modelVariants.has(w)){const D=this.modelVariants.get(w);return this.enableVariantHelper(D.index)}return null}async enableVariantHelper(w){if(this.variantToMaterialMap!=null&&w!=null){const D=this.variantToMaterialMap.get(w);if(D!=null)return this.setActiveMaterial(D.index)}return null}async instantiateVariants(){if(this.variantToMaterialMap!=null)for(const w of this.variantToMaterialMap.keys()){const D=this.mesh.userData.variantMaterials.get(w);if(D.material!=null)continue;const O=await this.enableVariantHelper(w);O!=null&&(D.material=O)}}get variantInfo(){return this.variantToMaterialMap}addVariant(w,D){if(!this.ensureVariantIsUnused(D))return!1;this.modelVariants.has(D)||this.modelVariants.set(D,{name:D,index:this.modelVariants.size});const U=this.modelVariants.get(D).index;return w[$variantIndices].add(U),this.variantToMaterialMap.set(U,w),this.materials.set(w.index,w),this.updateVariantUserData(U,w),!0}deleteVariant(w){if(this.variantInfo.has(w)){this.variantInfo.delete(w);const D=this.mesh.userData.variantMaterials;D?.delete(w)}}updateVariantUserData(w,D){D[$variantIndices].add(w),this.mesh.userData.variantData=this.modelVariants,this.mesh.userData.variantMaterials=this.mesh.userData.variantMaterials||new Map,this.mesh.userData.variantMaterials.set(w,{material:D[$correlatedObjects].values().next().value,gltfMaterialIndex:D.index})}ensureVariantIsUnused(w){const D=this.modelVariants.get(w);return D!=null&&this.variantInfo.has(D.index)?(console.warn(`Primitive cannot add variant '${w}' for this material, it already exists.`),!1):!0}}/* @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */var _a$2,_b$2,_c$1,_d$1,_e$1,_f$1;const $materials=Symbol("materials"),$hierarchy=Symbol("hierarchy"),$roots=Symbol("roots"),$primitivesList=Symbol("primitives"),$prepareVariantsForExport=Symbol("prepareVariantsForExport"),$switchVariant=Symbol("switchVariant"),$materialFromPoint=Symbol("materialFromPoint"),$nodeFromPoint=Symbol("nodeFromPoint"),$nodeFromIndex=Symbol("nodeFromIndex"),$variantData=Symbol("variantData"),$availableVariants=Symbol("availableVariants"),$modelOnUpdate=Symbol("modelOnUpdate"),$cloneMaterial=Symbol("cloneMaterial");class LazyLoader{constructor(w,D,O,U){this.gltf=w,this.gltfElementMap=D,this.mapKey=O,this.doLazyLoad=U}}class Model{constructor(w,D=()=>{}){this[_a$2]=new Array,this[_b$2]=new Array,this[_c$1]=new Array,this[_d$1]=new Array,this[_e$1]=()=>{},this[_f$1]=new Map,this[$modelOnUpdate]=D;const{gltf:O,threeGLTF:U,gltfElementMap:G}=w;for(const[ee,Z]of O.materials.entries()){const ie=G.get(Z);if(ie!=null)this[$materials].push(new Material(D,ee,!0,this[$variantData],ie,Z.name));else{const W=(O.materials||[])[ee],ne=new Set;G.set(W,ne);const se=async()=>{const le=await U.parser.getDependency("material",ee);return ne.add(le),le};this[$materials].push(new Material(D,ee,!1,this[$variantData],ne,Z.name,new LazyLoader(O,G,W,se)))}}const q=new Map,K=new Array;for(const ee of U.scene.children)K.push(ee);for(;K.length>0;){const ee=K.pop();let Z=null;ee instanceof Mesh?(Z=new PrimitiveNode(ee,this.materials,this[$variantData],w),this[$primitivesList].push(Z)):Z=new Node$1(ee.name);const ie=q.get(ee);ie!=null?ie.children.push(Z):this[$roots].push(Z),this[$hierarchy].push(Z);for(const Y of ee.children)K.push(Y),q.set(ee,Z)}}get materials(){return this[$materials]}[(_a$2=$materials,_b$2=$hierarchy,_c$1=$roots,_d$1=$primitivesList,_e$1=$modelOnUpdate,_f$1=$variantData,$availableVariants)](){const w=Array.from(this[$variantData].values());return w.sort((D,O)=>D.index-O.index),w.map(D=>D.name)}getMaterialByName(w){const D=this[$materials].filter(O=>O.name===w);return D.length>0?D[0]:null}[$nodeFromIndex](w,D){const O=this[$hierarchy].find(U=>{if(U instanceof PrimitiveNode){const{meshes:G,primitives:q}=U.mesh.userData.associations;if(G==w&&q==D)return!0}return!1});return O??null}[$nodeFromPoint](w){return this[$hierarchy].find(D=>D instanceof PrimitiveNode&&D.mesh===w.object)}[$materialFromPoint](w){return this[$nodeFromPoint](w).getActiveMaterial()}async[$switchVariant](w){for(const D of this[$primitivesList])await D.enableVariant(w);for(const D of this.materials)D[$setActive](!1);for(const D of this[$primitivesList])this.materials[D.getActiveMaterial().index][$setActive](!0)}async[$prepareVariantsForExport](){const w=new Array;for(const D of this[$primitivesList])w.push(D.instantiateVariants());await Promise.all(w)}[$cloneMaterial](w,D){const O=this.materials[w];O.isLoaded||console.error(`Cloning an unloaded material,
           call 'material.ensureLoaded() before cloning the material.`);const U=O[$correlatedObjects],G=new Set;for(const[K,ee]of U.entries()){const Z=ee.clone();Z.name=D+(U.size>1?"_inst"+K:""),G.add(Z)}const q=new Material(this[$modelOnUpdate],this[$materials].length,!1,this[$variantData],G,D);return this[$materials].push(q),q}createMaterialInstanceForVariant(w,D,O,U=!0){let G=null;for(const q of this[$primitivesList]){const K=this[$variantData].get(O);K!=null&&q.variantInfo.has(K.index)||q.getMaterial(w)!=null&&(this.hasVariant(O)||this.createVariant(O),G==null&&(G=this[$cloneMaterial](w,D)),q.addVariant(G,O))}if(U&&G!=null){G[$setActive](!0),this.materials[w][$setActive](!1);for(const q of this[$primitivesList])q.enableVariant(O)}return G}createVariant(w){this[$variantData].has(w)?console.warn(`Variant '${w}'' already exists`):this[$variantData].set(w,{name:w,index:this[$variantData].size})}hasVariant(w){return this[$variantData].has(w)}setMaterialToVariant(w,D){if(this[$availableVariants]().find(O=>O===D)==null){console.warn(`Can't add material to '${D}', the variant does not exist.'`);return}if(w<0||w>=this.materials.length){console.error("setMaterialToVariant(): materialIndex is out of bounds.");return}for(const O of this[$primitivesList]){const U=O.getMaterial(w);U!=null&&O.addVariant(U,D)}}updateVariantName(w,D){const O=this[$variantData].get(w);O!=null&&(O.name=D,this[$variantData].set(D,O),this[$variantData].delete(w))}deleteVariant(w){const D=this[$variantData].get(w);if(D!=null){for(const O of this.materials)O.hasVariant(w)&&O[$variantIndices].delete(D.index);for(const O of this[$primitivesList])O.deleteVariant(D.index);this[$variantData].delete(w)}}}/* @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */var __decorate$5=function(F,w,D,O){var U=arguments.length,G=U<3?w:O===null?O=Object.getOwnPropertyDescriptor(w,D):O,q;if(typeof Reflect=="object"&&typeof Reflect.decorate=="function")G=Reflect.decorate(F,w,D,O);else for(var K=F.length-1;K>=0;K--)(q=F[K])&&(G=(U<3?q(G):U>3?q(w,D,G):q(w,D))||G);return U>3&&G&&Object.defineProperty(w,D,G),G};const $currentGLTF=Symbol("currentGLTF"),$originalGltfJson=Symbol("originalGltfJson"),$model=Symbol("model"),$getOnUpdateMethod=Symbol("getOnUpdateMethod"),$buildTexture=Symbol("buildTexture"),SceneGraphMixin=F=>{var w,D,O;class U extends F{constructor(){super(...arguments),this[w]=void 0,this[D]=null,this[O]=null,this.variantName=null,this.orientation="0 0 0",this.scale="1 1 1"}get model(){return this[$model]}get availableVariants(){return this.model?this.model[$availableVariants]():[]}get originalGltfJson(){return this[$originalGltfJson]}[(w=$model,D=$currentGLTF,O=$originalGltfJson,$getOnUpdateMethod)](){return()=>{this[$needsRender]()}}[$buildTexture](q){return q.colorSpace=SRGBColorSpace,q.wrapS=RepeatWrapping,q.wrapT=RepeatWrapping,new Texture(this[$getOnUpdateMethod](),q)}async createTexture(q,K="image/png"){const{textureUtils:ee}=this[$renderer],Z=await ee.loadImage(q,this.withCredentials);return Z.userData.mimeType=K,this[$buildTexture](Z)}async createLottieTexture(q,K=1){const{textureUtils:ee}=this[$renderer],Z=await ee.loadLottie(q,K,this.withCredentials);return this[$buildTexture](Z)}createVideoTexture(q){const K=document.createElement("video");K.crossOrigin=this.withCredentials?"use-credentials":"anonymous",K.src=q,K.muted=!0,K.playsInline=!0,K.loop=!0,K.play();const ee=new VideoTexture(K);return this[$buildTexture](ee)}createCanvasTexture(){const q=document.createElement("canvas"),K=new CanvasTexture(q);return this[$buildTexture](K)}async updated(q){if(super.updated(q),q.has("variantName")){const K=this[$progressTracker].beginActivity("variant-update");K(.1);const ee=this[$model],{variantName:Z}=this;ee!=null&&(await ee[$switchVariant](Z),this[$needsRender](),this.dispatchEvent(new CustomEvent("variant-applied"))),K(1)}if(q.has("orientation")||q.has("scale")){if(!this.loaded)return;const K=this[$scene];K.applyTransform(),K.updateBoundingBox(),K.updateShadow(),this[$renderer].arRenderer.onUpdateScene(),this[$needsRender]()}}[$onModelLoad](){super[$onModelLoad]();const{currentGLTF:q}=this[$scene];if(q!=null){const{correlatedSceneGraph:K}=q;K!=null&&q!==this[$currentGLTF]&&(this[$model]=new Model(K,this[$getOnUpdateMethod]()),this[$originalGltfJson]=JSON.parse(JSON.stringify(K.gltf))),"variants"in q.userData&&this.requestUpdate("variantName")}this[$currentGLTF]=q}async exportScene(q){const K=this[$scene];return new Promise(async(ee,Z)=>{const ie={binary:!0,onlyVisible:!0,maxTextureSize:1/0,includeCustomExtensions:!1,forceIndices:!1};Object.assign(ie,q),ie.animations=K.animations,ie.truncateDrawRange=!0;const Y=K.shadow;let W=!1;Y!=null&&(W=Y.visible,Y.visible=!1),await this[$model][$prepareVariantsForExport](),new GLTFExporter().register(se=>new GLTFExporterMaterialsVariantsExtension(se)).parse(K.model,se=>ee(new Blob([ie.binary?se:JSON.stringify(se)],{type:ie.binary?"application/octet-stream":"application/json"})),()=>Z("glTF export failed"),ie),Y!=null&&(Y.visible=W)})}materialFromPoint(q,K){const ee=this[$model];if(ee==null)return null;const Z=this[$scene],ie=Z.getNDC(q,K),Y=Z.hitFromPoint(ie);return Y==null||Y.face==null?null:ee[$materialFromPoint](Y)}}return __decorate$5([n$2({type:String,attribute:"variant-name"})],U.prototype,"variantName",void 0),__decorate$5([n$2({type:String,attribute:"orientation"})],U.prototype,"orientation",void 0),__decorate$5([n$2({type:String,attribute:"scale"})],U.prototype,"scale",void 0),U};/* @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */class GroundedSkybox extends Mesh{constructor(){super(void 0,new MeshBasicMaterial({depthWrite:!1})),this.height=0,this.radius=0,this.resolution=0,this.userData.noHit=!0}get map(){return this.material.map}set map(w){this.material.map=w}isUsable(){return this.height>0&&this.radius>0&&this.geometry!=null&&this.map!=null}updateGeometry(w=this.height,D=this.radius,O=128){(w!=this.height||D!=this.radius||O!=this.resolution)&&(this.height=w,this.radius=D,this.resolution=O,w>0&&D>0&&(this.geometry.dispose(),this.geometry=makeGeometry(w,D,O)))}}function makeGeometry(F,w,D){const O=new SphereGeometry(w,2*D,D);O.scale(1,1,-1);const U=O.getAttribute("position"),G=new Vector3;for(let q=0;q<U.count;++q)if(G.fromBufferAttribute(U,q),G.y<0){const K=-F*3/2,ee=G.y<K?-F/G.y:1-G.y*G.y/(3*K*K);G.multiplyScalar(ee),G.toArray(U.array,3*q)}return U.needsUpdate=!0,O}/* @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */const a=new Vector3,b=new Vector3,c=new Vector3,mat=new Matrix3,triangle=new Triangle,quat=new Quaternion;class Hotspot extends CSS2DObject{constructor(w){super(document.createElement("div")),this.normal=new Vector3(0,1,0),this.initialized=!1,this.referenceCount=1,this.pivot=document.createElement("div"),this.slot=document.createElement("slot"),this.element.classList.add("annotation-wrapper"),this.slot.name=w.name,this.element.appendChild(this.pivot),this.pivot.appendChild(this.slot),this.updatePosition(w.position),this.updateNormal(w.normal),this.surface=w.surface}get facingCamera(){return!this.element.classList.contains("hide")}show(){(!this.facingCamera||!this.initialized)&&this.updateVisibility(!0)}hide(){(this.facingCamera||!this.initialized)&&this.updateVisibility(!1)}increment(){this.referenceCount++}decrement(){return this.referenceCount>0&&--this.referenceCount,this.referenceCount===0}updatePosition(w){if(w==null)return;const D=parseExpressions(w)[0].terms;for(let O=0;O<3;++O)this.position.setComponent(O,normalizeUnit(D[O]).number);this.updateMatrixWorld()}updateNormal(w){if(w==null)return;const D=parseExpressions(w)[0].terms;for(let O=0;O<3;++O)this.normal.setComponent(O,D[O].number)}updateSurface(){const{mesh:w,tri:D,bary:O}=this;if(w==null||D==null||O==null)return;w.getVertexPosition(D.x,a),w.getVertexPosition(D.y,b),w.getVertexPosition(D.z,c),a.toArray(mat.elements,0),b.toArray(mat.elements,3),c.toArray(mat.elements,6),this.position.copy(O).applyMatrix3(mat);const U=this.parent;U.worldToLocal(w.localToWorld(this.position)),triangle.set(a,b,c),triangle.getNormal(this.normal).transformDirection(w.matrixWorld);const G=U.parent;quat.setFromAxisAngle(a.set(0,1,0),-G.rotation.y),this.normal.applyQuaternion(quat)}orient(w){this.pivot.style.transform=`rotate(${w}rad)`}updateVisibility(w){this.element.classList.toggle("hide",!w),this.slot.assignedNodes().forEach(D=>{if(D.nodeType!==Node.ELEMENT_NODE)return;const O=D,U=O.dataset.visibilityAttribute;if(U!=null){const G=`data-${U}`;O.toggleAttribute(G,w)}O.dispatchEvent(new CustomEvent("hotspot-visibility",{detail:{visible:w}}))}),this.initialized=!0}}const HorizontalBlurShader={name:"HorizontalBlurShader",uniforms:{tDiffuse:{value:null},h:{value:1/512}},vertexShader:`

		varying vec2 vUv;

		void main() {

			vUv = uv;
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`,fragmentShader:`

		uniform sampler2D tDiffuse;
		uniform float h;

		varying vec2 vUv;

		void main() {

			vec4 sum = vec4( 0.0 );

			sum += texture2D( tDiffuse, vec2( vUv.x - 4.0 * h, vUv.y ) ) * 0.051;
			sum += texture2D( tDiffuse, vec2( vUv.x - 3.0 * h, vUv.y ) ) * 0.0918;
			sum += texture2D( tDiffuse, vec2( vUv.x - 2.0 * h, vUv.y ) ) * 0.12245;
			sum += texture2D( tDiffuse, vec2( vUv.x - 1.0 * h, vUv.y ) ) * 0.1531;
			sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y ) ) * 0.1633;
			sum += texture2D( tDiffuse, vec2( vUv.x + 1.0 * h, vUv.y ) ) * 0.1531;
			sum += texture2D( tDiffuse, vec2( vUv.x + 2.0 * h, vUv.y ) ) * 0.12245;
			sum += texture2D( tDiffuse, vec2( vUv.x + 3.0 * h, vUv.y ) ) * 0.0918;
			sum += texture2D( tDiffuse, vec2( vUv.x + 4.0 * h, vUv.y ) ) * 0.051;

			gl_FragColor = sum;

		}`},VerticalBlurShader={name:"VerticalBlurShader",uniforms:{tDiffuse:{value:null},v:{value:1/512}},vertexShader:`

		varying vec2 vUv;

		void main() {

			vUv = uv;
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`,fragmentShader:`

		uniform sampler2D tDiffuse;
		uniform float v;

		varying vec2 vUv;

		void main() {

			vec4 sum = vec4( 0.0 );

			sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 4.0 * v ) ) * 0.051;
			sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 3.0 * v ) ) * 0.0918;
			sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 2.0 * v ) ) * 0.12245;
			sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 1.0 * v ) ) * 0.1531;
			sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y ) ) * 0.1633;
			sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 1.0 * v ) ) * 0.1531;
			sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 2.0 * v ) ) * 0.12245;
			sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 3.0 * v ) ) * 0.0918;
			sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 4.0 * v ) ) * 0.051;

			gl_FragColor = sum;

		}`};function lerp(F,w,D){return(1-D)*F+D*w}/* @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */const LOG_MAX_RESOLUTION=9,LOG_MIN_RESOLUTION=6,ANIMATION_SCALING=2,DEFAULT_HARD_INTENSITY=.3;class Shadow extends Object3D{constructor(w,D,O){super(),this.camera=new OrthographicCamera,this.renderTarget=null,this.renderTargetBlur=null,this.depthMaterial=new MeshDepthMaterial,this.horizontalBlurMaterial=new ShaderMaterial(HorizontalBlurShader),this.verticalBlurMaterial=new ShaderMaterial(VerticalBlurShader),this.intensity=0,this.softness=1,this.boundingBox=new Box3,this.size=new Vector3,this.maxDimension=0,this.isAnimated=!1,this.needsUpdate=!1;const{camera:U}=this;U.rotation.x=Math.PI/2,U.left=-.5,U.right=.5,U.bottom=-.5,U.top=.5,this.add(U);const G=new PlaneGeometry,q=new MeshBasicMaterial({opacity:1,transparent:!0,side:BackSide});this.floor=new Mesh(G,q),this.floor.userData.noHit=!0,U.add(this.floor),this.blurPlane=new Mesh(G),this.blurPlane.visible=!1,U.add(this.blurPlane),w.target.add(this),this.depthMaterial.onBeforeCompile=function(K){K.fragmentShader=K.fragmentShader.replace("gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );","gl_FragColor = vec4( vec3( 0.0 ), ( 1.0 - fragCoordZ ) * opacity );")},this.depthMaterial.side=DoubleSide,this.horizontalBlurMaterial.depthTest=!1,this.verticalBlurMaterial.depthTest=!1,this.setScene(w,D,O)}setScene(w,D,O){const{boundingBox:U,size:G,rotation:q,position:K}=this;if(this.isAnimated=w.animationNames.length>0,this.boundingBox.copy(w.boundingBox),this.size.copy(w.size),this.maxDimension=Math.max(G.x,G.y,G.z)*(this.isAnimated?ANIMATION_SCALING:1),this.boundingBox.getCenter(K),O==="back"){const{min:ee,max:Z}=U;[ee.y,ee.z]=[ee.z,ee.y],[Z.y,Z.z]=[Z.z,Z.y],[G.y,G.z]=[G.z,G.y],q.x=Math.PI/2,q.y=Math.PI}else q.x=0,q.y=0;if(this.isAnimated){const ee=U.min.y,Z=U.max.y;G.y=this.maxDimension,U.expandByVector(G.subScalar(this.maxDimension).multiplyScalar(-.5)),U.min.y=ee,U.max.y=Z,G.set(this.maxDimension,Z-ee,this.maxDimension)}O==="bottom"?K.y=U.min.y:K.z=U.min.y,this.setSoftness(D)}setSoftness(w){this.softness=w;const{size:D,camera:O}=this,U=this.isAnimated?ANIMATION_SCALING:1,G=U*Math.pow(2,LOG_MAX_RESOLUTION-w*(LOG_MAX_RESOLUTION-LOG_MIN_RESOLUTION));this.setMapSize(G);const q=D.y/2,K=D.y*U;O.near=0,O.far=lerp(K,q,w),this.depthMaterial.opacity=1/w,O.updateProjectionMatrix(),this.setIntensity(this.intensity),this.setOffset(0)}setMapSize(w){const{size:D}=this;this.isAnimated&&(w*=ANIMATION_SCALING);const O=Math.floor(D.x>D.z?w:w*D.x/D.z),U=Math.floor(D.x>D.z?w*D.z/D.x:w),G=10,q=G+O,K=G+U;if(this.renderTarget!=null&&(this.renderTarget.width!==q||this.renderTarget.height!==K)&&(this.renderTarget.dispose(),this.renderTarget=null,this.renderTargetBlur.dispose(),this.renderTargetBlur=null),this.renderTarget==null){const ee={format:RGBAFormat};this.renderTarget=new WebGLRenderTarget(q,K,ee),this.renderTargetBlur=new WebGLRenderTarget(q,K,ee),this.floor.material.map=this.renderTarget.texture}this.camera.scale.set(D.x*(1+G/O),D.z*(1+G/U),1),this.needsUpdate=!0}setIntensity(w){this.intensity=w,w>0?(this.visible=!0,this.floor.visible=!0,this.floor.material.opacity=w*lerp(DEFAULT_HARD_INTENSITY,1,this.softness*this.softness)):(this.visible=!1,this.floor.visible=!1)}getIntensity(){return this.intensity}setOffset(w){this.floor.position.z=-w+this.gap()}gap(){return .001*this.maxDimension}render(w,D){D.overrideMaterial=this.depthMaterial;const O=w.getClearAlpha();w.setClearAlpha(0),this.floor.visible=!1;const U=w.xr.enabled;w.xr.enabled=!1;const G=w.getRenderTarget();w.setRenderTarget(this.renderTarget),w.render(D,this.camera),D.overrideMaterial=null,this.floor.visible=!0,this.blurShadow(w),w.xr.enabled=U,w.setRenderTarget(G),w.setClearAlpha(O)}blurShadow(w){const{camera:D,horizontalBlurMaterial:O,verticalBlurMaterial:U,renderTarget:G,renderTargetBlur:q,blurPlane:K}=this;K.visible=!0,K.material=O,O.uniforms.h.value=1/this.renderTarget.width,O.uniforms.tDiffuse.value=this.renderTarget.texture,w.setRenderTarget(q),w.render(K,D),K.material=U,U.uniforms.v.value=1/this.renderTarget.height,U.uniforms.tDiffuse.value=this.renderTargetBlur.texture,w.setRenderTarget(G),w.render(K,D),K.visible=!1}dispose(){this.renderTarget!=null&&this.renderTarget.dispose(),this.renderTargetBlur!=null&&this.renderTargetBlur.dispose(),this.depthMaterial.dispose(),this.horizontalBlurMaterial.dispose(),this.verticalBlurMaterial.dispose(),this.floor.material.dispose(),this.floor.geometry.dispose(),this.blurPlane.geometry.dispose(),this.removeFromParent()}}/* @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */const GROUNDED_SKYBOX_SIZE=10,MIN_SHADOW_RATIO=100,view=new Vector3,target=new Vector3,normalWorld=new Vector3,raycaster=new Raycaster,vector3=new Vector3,ndc=new Vector2;class ModelScene extends Scene{constructor({canvas:w,element:D,width:O,height:U}){super(),this.annotationRenderer=new CSS2DRenderer,this.effectRenderer=null,this.schemaElement=document.createElement("script"),this.width=1,this.height=1,this.aspect=1,this.scaleStep=0,this.renderCount=0,this.externalRenderer=null,this.appendedAnimations=[],this.markedAnimations=[],this.camera=new PerspectiveCamera(45,1,.1,100),this.xrCamera=null,this.url=null,this.pivot=new Object3D,this.target=new Object3D,this.animationNames=[],this.boundingBox=new Box3,this.boundingSphere=new Sphere,this.size=new Vector3,this.idealAspect=0,this.framedFoVDeg=0,this.shadow=null,this.shadowIntensity=0,this.shadowSoftness=1,this.bakedShadows=new Set,this.exposure=1,this.toneMapping=NeutralToneMapping,this.canScale=!0,this.isDirty=!1,this.goalTarget=new Vector3,this.targetDamperX=new Damper,this.targetDamperY=new Damper,this.targetDamperZ=new Damper,this._currentGLTF=null,this._model=null,this.cancelPendingSourceChange=null,this.animationsByName=new Map,this.currentAnimationAction=null,this.groundedSkybox=new GroundedSkybox,this.name="ModelScene",this.element=D,this.canvas=w,this.camera=new PerspectiveCamera(45,1,.1,100),this.camera.name="MainCamera",this.add(this.pivot),this.pivot.name="Pivot",this.pivot.add(this.target),this.setSize(O,U),this.target.name="Target",this.mixer=new AnimationMixer(this.target);const{domElement:G}=this.annotationRenderer,{style:q}=G;q.display="none",q.pointerEvents="none",q.position="absolute",q.top="0",this.element.shadowRoot.querySelector(".default").appendChild(G),this.schemaElement.setAttribute("type","application/ld+json")}get context(){return this.canvas.getContext("2d")}getCamera(){return this.xrCamera!=null?this.xrCamera:this.camera}queueRender(){this.isDirty=!0}shouldRender(){return this.isDirty}hasRendered(){this.isDirty=!1}forceRescale(){this.scaleStep=-1,this.queueRender()}async setObject(w){this.reset(),this._model=w,this.target.add(w),await this.setupScene()}async setSource(w,D=()=>{}){if(!w||w===this.url){D(1);return}if(this.reset(),this.url=w,this.externalRenderer!=null){const K=await this.externalRenderer.load(D);this.boundingSphere.radius=K.framedRadius,this.idealAspect=K.fieldOfViewAspect;return}this.cancelPendingSourceChange!=null&&(this.cancelPendingSourceChange(),this.cancelPendingSourceChange=null);let O;try{O=await new Promise(async(K,ee)=>{this.cancelPendingSourceChange=()=>ee();try{const Z=await this.element[$renderer].loader.load(w,this.element,D);K(Z)}catch(Z){ee(Z)}})}catch(K){if(K==null)return;throw K}this.cancelPendingSourceChange=null,this.reset(),this.url=w,this._currentGLTF=O,O!=null&&(this._model=O.scene,this.target.add(O.scene));const{animations:U}=O,G=new Map,q=[];for(const K of U)G.set(K.name,K),q.push(K.name);this.animations=U,this.animationsByName=G,this.animationNames=q,await this.setupScene()}async setupScene(){this.applyTransform(),this.updateBoundingBox(),await this.updateFraming(),this.updateShadow(),this.setShadowIntensity(this.shadowIntensity),this.setGroundedSkybox()}reset(){this.url=null,this.renderCount=0,this.queueRender(),this.shadow!=null&&this.shadow.setIntensity(0),this.bakedShadows.clear();const{_model:w}=this;w!=null&&(w.removeFromParent(),this._model=null);const D=this._currentGLTF;D!=null&&(D.dispose(),this._currentGLTF=null),this.currentAnimationAction!=null&&(this.currentAnimationAction.stop(),this.currentAnimationAction=null),this.mixer.stopAllAction(),this.mixer.uncacheRoot(this)}dispose(){this.reset(),this.shadow!=null&&(this.shadow.dispose(),this.shadow=null),this.element[$currentGLTF]=null,this.element[$originalGltfJson]=null,this.element[$model]=null}get currentGLTF(){return this._currentGLTF}setSize(w,D){if(!(this.width===w&&this.height===D)){if(this.width=Math.max(w,1),this.height=Math.max(D,1),this.annotationRenderer.setSize(w,D),this.aspect=this.width/this.height,this.externalRenderer!=null){const O=window.devicePixelRatio;this.externalRenderer.resize(w*O,D*O)}this.queueRender()}}markBakedShadow(w){w.userData.noHit=!0,this.bakedShadows.add(w)}unmarkBakedShadow(w){w.userData.noHit=!1,w.visible=!0,this.bakedShadows.delete(w),this.boundingBox.expandByObject(w)}findBakedShadows(w){const D=new Box3;w.traverse(O=>{const U=O;if(!U.material||!U.material.transparent)return;D.setFromObject(U);const q=D.getSize(vector3),K=Math.min(q.x,q.y,q.z);Math.max(q.x,q.y,q.z)<MIN_SHADOW_RATIO*K||this.markBakedShadow(U)})}checkBakedShadows(){const{min:w,max:D}=this.boundingBox,O=new Box3;this.boundingBox.getSize(this.size);for(const U of this.bakedShadows)O.setFromObject(U),!(O.min.y<w.y+this.size.y/MIN_SHADOW_RATIO&&O.min.x<=w.x&&O.max.x>=D.x&&O.min.z<=w.z&&O.max.z>=D.z)&&(O.min.z<w.z+this.size.z/MIN_SHADOW_RATIO&&O.min.x<=w.x&&O.max.x>=D.x&&O.min.y<=w.y&&O.max.y>=D.y||this.unmarkBakedShadow(U))}applyTransform(){const{model:w}=this;if(w==null)return;const D=parseExpressions(this.element.orientation)[0].terms,O=normalizeUnit(D[0]).number,U=normalizeUnit(D[1]).number,G=normalizeUnit(D[2]).number;w.quaternion.setFromEuler(new Euler(U,G,O,"YXZ"));const q=parseExpressions(this.element.scale)[0].terms;w.scale.set(q[0].number,q[1].number,q[2].number)}updateBoundingBox(){const{model:w}=this;if(w==null)return;this.target.remove(w),this.findBakedShadows(w);const D=(O,U)=>O.expandByPoint(U);this.setBakedShadowVisibility(!1),this.boundingBox=reduceVertices(w,D,new Box3),this.boundingBox.isEmpty()&&(this.setBakedShadowVisibility(!0),this.bakedShadows.forEach(O=>this.unmarkBakedShadow(O)),this.boundingBox=reduceVertices(w,D,new Box3)),this.checkBakedShadows(),this.setBakedShadowVisibility(),this.boundingBox.getSize(this.size),this.target.add(w)}async updateFraming(){const{model:w}=this;if(w==null)return;this.target.remove(w),this.setBakedShadowVisibility(!1);const{center:D}=this.boundingSphere;this.element.requestUpdate("cameraTarget"),await this.element.updateComplete,D.copy(this.getTarget());const O=(G,q)=>Math.max(G,D.distanceToSquared(q));this.boundingSphere.radius=Math.sqrt(reduceVertices(w,O,0));const U=(G,q)=>{q.sub(D);const K=Math.sqrt(q.x*q.x+q.z*q.z);return Math.max(G,K/(this.idealCameraDistance()-Math.abs(q.y)))};this.idealAspect=reduceVertices(w,U,0)/Math.tan(this.framedFoVDeg/2*Math.PI/180),this.setBakedShadowVisibility(),this.target.add(w)}setBakedShadowVisibility(w=this.shadowIntensity<=0){for(const D of this.bakedShadows)D.visible=w}idealCameraDistance(){const w=this.framedFoVDeg/2*Math.PI/180;return this.boundingSphere.radius/Math.sin(w)}adjustedFoV(w){const D=Math.tan(w/2*Math.PI/180)*Math.max(1,this.idealAspect/this.aspect);return 2*Math.atan(D)*180/Math.PI}getNDC(w,D){if(this.xrCamera!=null)ndc.set(w/window.screen.width,D/window.screen.height);else{const O=this.element.getBoundingClientRect();ndc.set((w-O.x)/this.width,(D-O.y)/this.height)}return ndc.multiplyScalar(2).subScalar(1),ndc.y*=-1,ndc}getSize(){return{width:this.width,height:this.height}}setEnvironmentAndSkybox(w,D){this.element[$renderer].arRenderer.presentedScene!==this&&(this.environment=w,this.setBackground(D),this.queueRender())}setBackground(w){this.groundedSkybox.map=w,this.groundedSkybox.isUsable()?(this.target.add(this.groundedSkybox),this.background=null):(this.target.remove(this.groundedSkybox),this.background=w)}farRadius(){return this.boundingSphere.radius*(this.groundedSkybox.parent!=null?GROUNDED_SKYBOX_SIZE:1)}setGroundedSkybox(){const w=parseExpressions(this.element.skyboxHeight)[0].terms[0],D=normalizeUnit(w).number,O=GROUNDED_SKYBOX_SIZE*this.boundingSphere.radius;this.groundedSkybox.updateGeometry(D,O),this.groundedSkybox.position.y=D-(this.shadow?2*this.shadow.gap():0),this.setBackground(this.groundedSkybox.map)}setTarget(w,D,O){this.goalTarget.set(-w,-D,-O)}setTargetDamperDecayTime(w){this.targetDamperX.setDecayTime(w),this.targetDamperY.setDecayTime(w),this.targetDamperZ.setDecayTime(w)}getTarget(){return this.goalTarget.clone().multiplyScalar(-1)}getDynamicTarget(){return this.target.position.clone().multiplyScalar(-1)}jumpToGoal(){this.updateTarget(SETTLING_TIME)}updateTarget(w){const D=this.goalTarget,O=this.target.position;if(D.equals(O))return!1;{const U=this.boundingSphere.radius/10;let{x:G,y:q,z:K}=O;return G=this.targetDamperX.update(G,D.x,w,U),q=this.targetDamperY.update(q,D.y,w,U),K=this.targetDamperZ.update(K,D.z,w,U),this.groundedSkybox.position.x=-G,this.groundedSkybox.position.z=-K,this.target.position.set(G,q,K),this.target.updateMatrixWorld(),this.queueRender(),!0}}pointTowards(w,D){const{x:O,z:U}=this.position;this.yaw=Math.atan2(w-O,D-U)}get model(){return this._model}set yaw(w){this.pivot.rotation.y=w,this.groundedSkybox.rotation.y=-w,this.queueRender()}get yaw(){return this.pivot.rotation.y}set animationTime(w){this.mixer.setTime(w),this.queueShadowRender()}get animationTime(){if(this.currentAnimationAction!=null){const w=Math.max(this.currentAnimationAction._loopCount,0);return this.currentAnimationAction.loop===LoopPingPong&&(w&1)===1?this.duration-this.currentAnimationAction.time:this.currentAnimationAction.time}return 0}set animationTimeScale(w){this.mixer.timeScale=w}get animationTimeScale(){return this.mixer.timeScale}get duration(){return this.currentAnimationAction!=null&&this.currentAnimationAction.getClip()?this.currentAnimationAction.getClip().duration:0}get hasActiveAnimation(){return this.currentAnimationAction!=null}playAnimation(w=null,D=0,O=LoopRepeat,U=1/0){if(this._currentGLTF==null)return;const{animations:G}=this;if(G==null||G.length===0)return;let q=null;if(w!=null&&(q=this.animationsByName.get(w),q==null)){const K=parseInt(w);!isNaN(K)&&K>=0&&K<G.length&&(q=G[K])}q==null&&(q=G[0]);try{const{currentAnimationAction:K}=this,ee=this.mixer.clipAction(q,this);ee.timeScale!=this.element.timeScale&&(ee.timeScale=this.element.timeScale),this.currentAnimationAction=ee,this.element.paused?this.mixer.stopAllAction():(ee.paused=!1,K!=null&&ee!==K?ee.crossFadeFrom(K,D,!1):this.animationTimeScale>0&&this.animationTime==this.duration&&(this.animationTime=0)),ee.setLoop(O,U),ee.enabled=!0,ee.clampWhenFinished=!0,ee.play()}catch(K){console.error(K)}}appendAnimation(w="",D=LoopRepeat,O=1/0,U=1,G=1,q=!1,K=!1,ee=!0,Z=null,ie=!1){if(this._currentGLTF==null||w===this.element.animationName)return;const{animations:Y}=this;if(Y==null||Y.length===0)return;let W=null;const ne=1.25;if(w&&(W=this.animationsByName.get(w)),W!=null){typeof O=="string"?isNaN(O)?(O=1/0,console.warn("Invalid repetitionCount value, repetitionCount is set to Infinity")):O=Math.max(parseInt(O),1):typeof O=="number"&&O<1&&(O=1),O===1&&D!==LoopOnce&&(D=LoopOnce),typeof U=="string"&&(isNaN(U)?(U=1,console.warn("Invalid weight value, weight is set to 1")):U=parseFloat(U)),typeof G=="string"&&(isNaN(G)?(G=1,console.warn("Invalid timeScale value, timeScale is set to 1")):G=parseFloat(G)),typeof q=="string"&&(q.toLowerCase().trim()==="true"?q=!0:q.toLowerCase().trim()==="false"?q=!1:isNaN(q)?(q=!1,console.warn("Invalid fade value, fade is set to false")):q=parseFloat(q)),typeof K=="string"&&(K.toLowerCase().trim()==="true"?K=!0:K.toLowerCase().trim()==="false"?K=!1:isNaN(K)?(K=!1,console.warn("Invalid warp value, warp is set to false")):K=parseFloat(K)),typeof Z=="string"&&(isNaN(Z)||(Z=parseFloat(Z)));try{const se=this.mixer.existingAction(W)||this.mixer.clipAction(W,this),le=se.timeScale;ie&&this.appendedAnimations.includes(w)&&(this.markedAnimations.map(ce=>ce.name).includes(w)||this.markedAnimations.push({name:w,loopMode:D,repetitionCount:O})),typeof Z=="number"&&(se.time=Math.min(Math.max(Z,0),W.duration)),typeof q=="boolean"&&q?se.fadeIn(ne):typeof q=="number"?se.fadeIn(Math.max(q,0)):U>=0&&(se.weight=Math.min(Math.max(U,0),1)),typeof K=="boolean"&&K?se.warp(ee?le:0,G,ne):typeof K=="number"?se.warp(ee?le:0,G,Math.max(K,0)):se.timeScale=G,se.isRunning()||(se.time==W.duration&&se.stop(),se.setLoop(D,O),se.paused=!1,se.enabled=!0,se.clampWhenFinished=!0,se.play()),this.appendedAnimations.includes(w)||this.element[$scene].appendedAnimations.push(w)}catch(se){console.error(se)}}}detachAnimation(w="",D=!0){if(this._currentGLTF==null||w===this.element.animationName)return;const{animations:O}=this;if(O==null||O.length===0)return;let U=null;const G=1.5;if(w&&(U=this.animationsByName.get(w)),U!=null){typeof D=="string"&&(D.toLowerCase().trim()==="true"?D=!0:D.toLowerCase().trim()==="false"?D=!1:isNaN(D)?(D=!0,console.warn("Invalid fade value, fade is set to true")):D=parseFloat(D));try{const q=this.mixer.existingAction(U)||this.mixer.clipAction(U,this);typeof D=="boolean"&&D?q.fadeOut(G):typeof D=="number"?q.fadeOut(Math.max(D,0)):q.stop();const K=this.element[$scene].appendedAnimations.filter(ee=>ee!==w);this.element[$scene].appendedAnimations=K}catch(q){console.error(q)}}}updateAnimationLoop(w="",D=LoopRepeat,O=1/0){if(this._currentGLTF==null||w===this.element.animationName)return;const{animations:U}=this;if(U==null||U.length===0)return;let G=null;if(w&&(G=this.animationsByName.get(w)),G!=null)try{const q=this.mixer.existingAction(G)||this.mixer.clipAction(G,this);q.stop(),q.setLoop(D,O),q.play()}catch(q){console.error(q)}}stopAnimation(){this.currentAnimationAction=null,this.mixer.stopAllAction()}updateAnimation(w){this.mixer.update(w),this.queueShadowRender()}subscribeMixerEvent(w,D){this.mixer.addEventListener(w,D)}updateShadow(){const w=this.shadow;if(w!=null){const D=this.element.arPlacement==="wall"?"back":"bottom";w.setScene(this,this.shadowSoftness,D),w.needsUpdate=!0}}renderShadow(w){const D=this.shadow;D!=null&&D.needsUpdate==!0&&(D.render(w,this),D.needsUpdate=!1)}queueShadowRender(){this.shadow!=null&&(this.shadow.needsUpdate=!0)}setShadowIntensity(w){if(this.shadowIntensity=w,this._currentGLTF!=null&&(this.setBakedShadowVisibility(),!(w<=0&&this.shadow==null))){if(this.shadow==null){const D=this.element.arPlacement==="wall"?"back":"bottom";this.shadow=new Shadow(this,this.shadowSoftness,D)}this.shadow.setIntensity(w)}}setShadowSoftness(w){this.shadowSoftness=w;const D=this.shadow;D?.setSoftness(w)}setShadowOffset(w){const D=this.shadow;D?.setOffset(w)}getHit(w=this){return raycaster.intersectObject(w,!0).find(O=>O.object.visible&&!O.object.userData.noHit)}hitFromController(w,D=this){return raycaster.setFromXRController(w),this.getHit(D)}hitFromPoint(w,D=this){return raycaster.setFromCamera(w,this.getCamera()),this.getHit(D)}positionAndNormalFromPoint(w,D=this){var O;const U=this.hitFromPoint(w,D);if(U==null)return null;const G=U.point,q=U.face!=null?U.face.normal.clone().applyNormalMatrix(new Matrix3().getNormalMatrix(U.object.matrixWorld)):raycaster.ray.direction.clone().multiplyScalar(-1),K=(O=U.uv)!==null&&O!==void 0?O:null;return{position:G,normal:q,uv:K}}surfaceFromPoint(w,D=this){const O=this.element.model;if(O==null)return null;const U=this.hitFromPoint(w,D);if(U==null||U.face==null)return null;const G=O[$nodeFromPoint](U),{meshes:q,primitives:K}=G.mesh.userData.associations,ee=new Vector3,Z=new Vector3,ie=new Vector3,{a:Y,b:W,c:ne}=U.face,se=U.object;se.getVertexPosition(Y,ee),se.getVertexPosition(W,Z),se.getVertexPosition(ne,ie);const le=new Triangle(ee,Z,ie),ce=new Vector3;return le.getBarycoord(se.worldToLocal(U.point),ce),`${q} ${K} ${Y} ${W} ${ne} ${ce.x.toFixed(3)} ${ce.y.toFixed(3)} ${ce.z.toFixed(3)}`}addHotspot(w){this.target.add(w),this.annotationRenderer.domElement.appendChild(w.element),this.updateSurfaceHotspot(w)}removeHotspot(w){this.target.remove(w)}forHotspots(w){const{children:D}=this.target;for(let O=0,U=D.length;O<U;O++){const G=D[O];G instanceof Hotspot&&w(G)}}updateSurfaceHotspot(w){if(w.surface==null||this.element.model==null)return;const D=parseExpressions(w.surface)[0].terms;if(D.length!=8){console.warn(w.surface+" does not have exactly 8 numbers.");return}const O=this.element.model[$nodeFromIndex](D[0].number,D[1].number);if(O==null){console.warn(w.surface+" does not match a node/primitive in this glTF! Skipping this hotspot.");return}const U=O.mesh.geometry.attributes.position.count,G=new Vector3(D[2].number,D[3].number,D[4].number);if(G.x>=U||G.y>=U||G.z>=U){console.warn(w.surface+" vertex indices out of range in this glTF! Skipping this hotspot.");return}const q=new Vector3(D[5].number,D[6].number,D[7].number);w.mesh=O.mesh,w.tri=G,w.bary=q,w.updateSurface()}animateSurfaceHotspots(){this.element.paused||this.forHotspots(w=>{w.updateSurface()})}updateHotspotsVisibility(w){this.forHotspots(D=>{view.copy(w),target.setFromMatrixPosition(D.matrixWorld),view.sub(target),normalWorld.copy(D.normal).transformDirection(this.target.matrixWorld),view.dot(normalWorld)<0?D.hide():D.show()})}orientHotspots(w){this.forHotspots(D=>{D.orient(w)})}setHotspotsVisibility(w){this.forHotspots(D=>{D.visible=w})}updateSchema(w){var D;const{schemaElement:O,element:U}=this,{alt:G,poster:q,iosSrc:K}=U;if(w!=null){const ee=[{"@type":"MediaObject",contentUrl:w,encodingFormat:((D=w.split(".").pop())===null||D===void 0?void 0:D.toLowerCase())==="gltf"?"model/gltf+json":"model/gltf-binary"}];K&&ee.push({"@type":"MediaObject",contentUrl:K,encodingFormat:"model/vnd.usdz+zip"});const Z={"@context":"http://schema.org/","@type":"3DModel",image:q??void 0,name:G??void 0,encoding:ee};O.textContent=JSON.stringify(Z),document.head.appendChild(O)}else O.parentElement!=null&&O.parentElement.removeChild(O)}}/* @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */class ProgressTracker extends EventTarget{constructor(){super(...arguments),this.ongoingActivities=new Set,this.totalProgress=0}get ongoingActivityCount(){return this.ongoingActivities.size}beginActivity(w){const D={progress:0,completed:!1};return this.ongoingActivities.add(D),this.ongoingActivityCount===1&&this.announceTotalProgress(D,0,w),O=>{let U;return U=Math.max(clamp$1(O,0,1),D.progress),U!==D.progress&&this.announceTotalProgress(D,U,w),D.progress}}announceTotalProgress(w,D,O){let U=0,G=0;D==1&&(w.completed=!0);for(const ee of this.ongoingActivities){const{progress:Z}=ee;U+=1-Z,ee.completed&&G++}const q=w.progress;w.progress=D,this.totalProgress+=(D-q)*(1-this.totalProgress)/U;const K=G===this.ongoingActivityCount?1:this.totalProgress;this.dispatchEvent(new CustomEvent("progress",{detail:{totalProgress:K,reason:O}})),G===this.ongoingActivityCount&&(this.totalProgress=0,this.ongoingActivities.clear())}}/* @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */var __decorate$4=function(F,w,D,O){var U=arguments.length,G=U<3?w:O===null?O=Object.getOwnPropertyDescriptor(w,D):O,q;if(typeof Reflect=="object"&&typeof Reflect.decorate=="function")G=Reflect.decorate(F,w,D,O);else for(var K=F.length-1;K>=0;K--)(q=F[K])&&(G=(U<3?q(G):U>3?q(w,D,G):q(w,D))||G);return U>3&&G&&Object.defineProperty(w,D,G),G},_a$1,_b$1,_c,_d,_e,_f,_g,_h,_j,_k,_l,_m,_o;const CLEAR_MODEL_TIMEOUT_MS=10,FALLBACK_SIZE_UPDATE_THRESHOLD_MS=50,ANNOUNCE_MODEL_VISIBILITY_DEBOUNCE_THRESHOLD=0,UNSIZED_MEDIA_WIDTH=300,UNSIZED_MEDIA_HEIGHT=150,blobCanvas=document.createElement("canvas"),$fallbackResizeHandler=Symbol("fallbackResizeHandler"),$defaultAriaLabel=Symbol("defaultAriaLabel"),$resizeObserver=Symbol("resizeObserver"),$clearModelTimeout=Symbol("clearModelTimeout"),$onContextLost=Symbol("onContextLost"),$loaded=Symbol("loaded"),$status=Symbol("status"),$onFocus=Symbol("onFocus"),$onBlur=Symbol("onBlur"),$updateSize=Symbol("updateSize"),$intersectionObserver=Symbol("intersectionObserver"),$isElementInViewport=Symbol("isElementInViewport"),$announceModelVisibility=Symbol("announceModelVisibility"),$ariaLabel=Symbol("ariaLabel"),$altDefaulted=Symbol("altDefaulted"),$statusElement=Symbol("statusElement"),$updateStatus=Symbol("updateStatus"),$loadedTime=Symbol("loadedTime"),$updateSource=Symbol("updateSource"),$markLoaded=Symbol("markLoaded"),$container=Symbol("container"),$userInputElement=Symbol("input"),$canvas=Symbol("canvas"),$scene=Symbol("scene"),$needsRender=Symbol("needsRender"),$tick=Symbol("tick"),$onModelLoad=Symbol("onModelLoad"),$onResize=Symbol("onResize"),$renderer=Symbol("renderer"),$progressTracker=Symbol("progressTracker"),$getLoaded=Symbol("getLoaded"),$getModelIsVisible=Symbol("getModelIsVisible"),$shouldAttemptPreload=Symbol("shouldAttemptPreload"),toVector3D=F=>({x:F.x,y:F.y,z:F.z,toString(){return`${this.x}m ${this.y}m ${this.z}m`}}),toVector2D=F=>({u:F.x,v:F.y,toString(){return`${this.u} ${this.v}`}});class ModelViewerElementBase extends y$2{static get is(){return"model-viewer"}static set modelCacheSize(w){CachingGLTFLoader[$evictionPolicy].evictionThreshold=w}static get modelCacheSize(){return CachingGLTFLoader[$evictionPolicy].evictionThreshold}static set minimumRenderScale(w){w>1&&console.warn("<model-viewer> minimumRenderScale has been clamped to a maximum value of 1."),w<=0&&console.warn("<model-viewer> minimumRenderScale has been clamped to a minimum value of 0.25."),Renderer.singleton.minScale=w}static get minimumRenderScale(){return Renderer.singleton.minScale}get loaded(){return this[$getLoaded]()}get[(_a$1=$isElementInViewport,_b$1=$loaded,_c=$loadedTime,_d=$status,_e=$clearModelTimeout,_f=$fallbackResizeHandler,_g=$announceModelVisibility,_h=$resizeObserver,_j=$intersectionObserver,_k=$progressTracker,$renderer)](){return Renderer.singleton}get modelIsVisible(){return this[$getModelIsVisible]()}constructor(){super(),this.alt=null,this.src=null,this.withCredentials=!1,this.generateSchema=!1,this[_a$1]=!1,this[_b$1]=!1,this[_c]=0,this[_d]="",this[_e]=null,this[_f]=debounce(()=>{const U=this.getBoundingClientRect();this[$updateSize](U)},FALLBACK_SIZE_UPDATE_THRESHOLD_MS),this[_g]=debounce(U=>{const G=this.modelIsVisible;G!==U&&this.dispatchEvent(new CustomEvent("model-visibility",{detail:{visible:G}}))},ANNOUNCE_MODEL_VISIBILITY_DEBOUNCE_THRESHOLD),this[_h]=null,this[_j]=null,this[_k]=new ProgressTracker,this[_l]=()=>{this[$statusElement].textContent=this[$status]},this[_m]=()=>{this[$statusElement].textContent=""},this[_o]=U=>{this.dispatchEvent(new CustomEvent("error",{detail:{type:"webglcontextlost",sourceError:U.sourceEvent}}))},this.attachShadow({mode:"open"});const w=this.shadowRoot;makeTemplate(w),this[$container]=w.querySelector(".container"),this[$userInputElement]=w.querySelector(".userInput"),this[$canvas]=w.querySelector("canvas"),this[$statusElement]=w.querySelector("#status"),this[$defaultAriaLabel]=this[$userInputElement].getAttribute("aria-label");let D,O;if(this.isConnected){const U=this.getBoundingClientRect();D=U.width,O=U.height}else D=UNSIZED_MEDIA_WIDTH,O=UNSIZED_MEDIA_HEIGHT;this[$scene]=new ModelScene({canvas:this[$canvas],element:this,width:D,height:O}),Promise.resolve().then(()=>{this[$updateSize](this.getBoundingClientRect())}),HAS_RESIZE_OBSERVER&&(this[$resizeObserver]=new ResizeObserver(U=>{if(!this[$renderer].isPresenting)for(let G of U)G.target===this&&this[$updateSize](G.contentRect)})),HAS_INTERSECTION_OBSERVER?this[$intersectionObserver]=new IntersectionObserver(U=>{for(let G of U)if(G.target===this){const q=this.modelIsVisible;this[$isElementInViewport]=G.isIntersecting,this[$announceModelVisibility](q),this[$isElementInViewport]&&!this.loaded&&this[$updateSource]()}},{root:null,rootMargin:"0px",threshold:1e-5}):this[$isElementInViewport]=!0}connectedCallback(){super.connectedCallback&&super.connectedCallback(),HAS_RESIZE_OBSERVER?this[$resizeObserver].observe(this):self.addEventListener("resize",this[$fallbackResizeHandler]),HAS_INTERSECTION_OBSERVER&&this[$intersectionObserver].observe(this),this.addEventListener("focus",this[$onFocus]),this.addEventListener("blur",this[$onBlur]);const w=this[$renderer];w.addEventListener("contextlost",this[$onContextLost]),w.registerScene(this[$scene]),this[$clearModelTimeout]!=null&&(self.clearTimeout(this[$clearModelTimeout]),this[$clearModelTimeout]=null,this.requestUpdate("src",null))}disconnectedCallback(){super.disconnectedCallback&&super.disconnectedCallback(),HAS_RESIZE_OBSERVER?this[$resizeObserver].unobserve(this):self.removeEventListener("resize",this[$fallbackResizeHandler]),HAS_INTERSECTION_OBSERVER&&this[$intersectionObserver].unobserve(this),this.removeEventListener("focus",this[$onFocus]),this.removeEventListener("blur",this[$onBlur]);const w=this[$renderer];w.removeEventListener("contextlost",this[$onContextLost]),w.unregisterScene(this[$scene]),this[$clearModelTimeout]=self.setTimeout(()=>{this[$scene].dispose(),this[$clearModelTimeout]=null},CLEAR_MODEL_TIMEOUT_MS)}updated(w){super.updated(w),w.has("src")&&(this.src==null?(this[$loaded]=!1,this[$loadedTime]=0,this[$scene].reset()):this.src!==this[$scene].url&&(this[$loaded]=!1,this[$loadedTime]=0,this[$updateSource]())),w.has("alt")&&this[$userInputElement].setAttribute("aria-label",this[$ariaLabel]),w.has("generateSchema")&&(this.generateSchema?this[$scene].updateSchema(this.src):this[$scene].updateSchema(null))}toDataURL(w,D){return this[$renderer].displayCanvas(this[$scene]).toDataURL(w,D)}async toBlob(w){const D=w?w.mimeType:void 0,O=w?w.qualityArgument:void 0,U=w?w.idealAspect:void 0,{width:G,height:q,idealAspect:K,aspect:ee}=this[$scene],{dpr:Z,scaleFactor:ie}=this[$renderer];let Y=G*ie*Z,W=q*ie*Z,ne=0,se=0;if(U===!0)if(K>ee){const le=W;W=Math.round(Y/K),se=(le-W)/2}else{const le=Y;Y=Math.round(W*K),ne=(le-Y)/2}blobCanvas.width=Y,blobCanvas.height=W;try{return new Promise(async(le,ce)=>{blobCanvas.getContext("2d").drawImage(this[$renderer].displayCanvas(this[$scene]),ne,se,Y,W,0,0,Y,W),blobCanvas.toBlob(he=>{if(!he)return ce(new Error("Unable to retrieve canvas blob"));le(he)},D,O)})}finally{this[$updateSize]({width:G,height:q})}}registerEffectComposer(w){w.setRenderer(this[$renderer].threeRenderer),w.setMainCamera(this[$scene].getCamera()),w.setMainScene(this[$scene]),this[$scene].effectRenderer=w}unregisterEffectComposer(){this[$scene].effectRenderer=null}registerRenderer(w){this[$scene].externalRenderer=w}unregisterRenderer(){this[$scene].externalRenderer=null}get[$ariaLabel](){return this[$altDefaulted]}get[$altDefaulted](){return this.alt==null||this.alt==="null"?this[$defaultAriaLabel]:this.alt}[$getLoaded](){return this[$loaded]}[$getModelIsVisible](){return this.loaded&&this[$isElementInViewport]}[$shouldAttemptPreload](){return!!this.src&&this[$isElementInViewport]}[$updateSize]({width:w,height:D}){w===0||D===0||(this[$container].style.width=`${w}px`,this[$container].style.height=`${D}px`,this[$onResize]({width:w,height:D}))}[$tick](w,D){var O;(O=this[$scene].effectRenderer)===null||O===void 0||O.beforeRender(w,D)}[$markLoaded](){this[$loaded]||(this[$loaded]=!0,this[$loadedTime]=performance.now())}[$needsRender](){this[$scene].queueRender()}[$onModelLoad](){}[$updateStatus](w){this[$status]=w;const D=this.getRootNode();D!=null&&D.activeElement===this&&this[$statusElement].textContent!=w&&(this[$statusElement].textContent=w)}[(_l=$onFocus,_m=$onBlur,$onResize)](w){this[$scene].setSize(w.width,w.height)}async[(_o=$onContextLost,$updateSource)](){const w=this[$scene];if(this.loaded||!this[$shouldAttemptPreload]()||this.src===w.url)return;this.generateSchema&&w.updateSchema(this.src),this[$updateStatus]("Loading"),w.stopAnimation();const D=this[$progressTracker].beginActivity("model-load"),O=this.src;try{const U=w.setSource(O,q=>D(clamp$1(q,0,1)*.95)),G=this[$updateEnvironment]();await Promise.all([U,G]),this[$markLoaded](),this[$onModelLoad](),this.updateComplete.then(()=>{this.dispatchEvent(new CustomEvent("before-render"))}),await new Promise(q=>{requestAnimationFrame(()=>{requestAnimationFrame(()=>{this.dispatchEvent(new CustomEvent("load",{detail:{url:O}})),q()})})})}catch(U){this.dispatchEvent(new CustomEvent("error",{detail:{type:"loadfailure",sourceError:U}}))}finally{D(1)}}}__decorate$4([n$2({type:String})],ModelViewerElementBase.prototype,"alt",void 0);__decorate$4([n$2({type:String})],ModelViewerElementBase.prototype,"src",void 0);__decorate$4([n$2({type:Boolean,attribute:"with-credentials"})],ModelViewerElementBase.prototype,"withCredentials",void 0);__decorate$4([n$2({type:Boolean,attribute:"generate-schema"})],ModelViewerElementBase.prototype,"generateSchema",void 0);/* @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */var __decorate$3=function(F,w,D,O){var U=arguments.length,G=U<3?w:O===null?O=Object.getOwnPropertyDescriptor(w,D):O,q;if(typeof Reflect=="object"&&typeof Reflect.decorate=="function")G=Reflect.decorate(F,w,D,O);else for(var K=F.length-1;K>=0;K--)(q=F[K])&&(G=(U<3?q(G):U>3?q(w,D,G):q(w,D))||G);return U>3&&G&&Object.defineProperty(w,D,G),G};const MILLISECONDS_PER_SECOND=1e3,$changeAnimation=Symbol("changeAnimation"),$appendAnimation=Symbol("appendAnimation"),$detachAnimation=Symbol("detachAnimation"),$paused=Symbol("paused"),DEFAULT_PLAY_OPTIONS={repetitions:1/0,pingpong:!1},DEFAULT_APPEND_OPTIONS={pingpong:!1,repetitions:null,weight:1,timeScale:1,fade:!1,warp:!1,relativeWarp:!0,time:null},DEFAULT_DETACH_OPTIONS={fade:!0},AnimationMixin=F=>{var w;class D extends F{constructor(...U){super(U),this.autoplay=!1,this.animationName=void 0,this.animationCrossfadeDuration=300,this[w]=!0,this[$scene].subscribeMixerEvent("loop",G=>{const q=G.action._loopCount,K=G.action._clip.name,ee=G.action._clip.uuid,Z=this[$scene].markedAnimations.find(ie=>ie.name===K);if(Z){this[$scene].updateAnimationLoop(Z.name,Z.loopMode,Z.repetitionCount);const ie=this[$scene].markedAnimations.filter(Y=>Y.name!==K);this[$scene].markedAnimations=ie}this.dispatchEvent(new CustomEvent("loop",{detail:{count:q,name:K,uuid:ee}}))}),this[$scene].subscribeMixerEvent("finished",G=>{if(!this[$scene].appendedAnimations.includes(G.action._clip.name))this[$paused]=!0;else{const q=this[$scene].appendedAnimations.filter(K=>K!==G.action._clip.name);this[$scene].appendedAnimations=q}this.dispatchEvent(new CustomEvent("finished"))})}get availableAnimations(){return this.loaded?this[$scene].animationNames:[]}get duration(){return this[$scene].duration}get paused(){return this[$paused]}get currentTime(){return this[$scene].animationTime}get appendedAnimations(){return this[$scene].appendedAnimations}set currentTime(U){this[$scene].animationTime=U,this[$needsRender]()}get timeScale(){return this[$scene].animationTimeScale}set timeScale(U){this[$scene].animationTimeScale=U}pause(){this[$paused]||(this[$paused]=!0,this.dispatchEvent(new CustomEvent("pause")))}play(U){this.availableAnimations.length>0&&(this[$paused]=!1,this[$changeAnimation](U),this.dispatchEvent(new CustomEvent("play")))}appendAnimation(U,G){this.availableAnimations.length>0&&(this[$paused]=!1,this[$appendAnimation](U,G),this.dispatchEvent(new CustomEvent("append-animation")))}detachAnimation(U,G){this.availableAnimations.length>0&&(this[$paused]=!1,this[$detachAnimation](U,G),this.dispatchEvent(new CustomEvent("detach-animation")))}[(w=$paused,$onModelLoad)](){super[$onModelLoad](),this[$paused]=!0,this.animationName!=null&&this[$changeAnimation](),this.autoplay&&this.play()}[$tick](U,G){super[$tick](U,G),!(this[$paused]||!this[$getModelIsVisible]()&&!this[$renderer].isPresenting)&&(this[$scene].updateAnimation(G/MILLISECONDS_PER_SECOND),this[$needsRender]())}updated(U){super.updated(U),U.has("autoplay")&&this.autoplay&&this.play(),U.has("animationName")&&this[$changeAnimation]()}[$changeAnimation](U=DEFAULT_PLAY_OPTIONS){var G;const q=(G=U.repetitions)!==null&&G!==void 0?G:1/0,K=U.pingpong?LoopPingPong:q===1?LoopOnce:LoopRepeat;this[$scene].playAnimation(this.animationName,this.animationCrossfadeDuration/MILLISECONDS_PER_SECOND,K,q),this[$paused]&&(this[$scene].updateAnimation(0),this[$needsRender]())}[$appendAnimation](U="",G=DEFAULT_APPEND_OPTIONS){var q;const K=(q=G.repetitions)!==null&&q!==void 0?q:1/0,ee=G.pingpong?LoopPingPong:K===1?LoopOnce:LoopRepeat,Z=!!G.repetitions||"pingpong"in G;this[$scene].appendAnimation(U||this.animationName,ee,K,G.weight,G.timeScale,G.fade,G.warp,G.relativeWarp,G.time,Z),this[$paused]&&(this[$scene].updateAnimation(0),this[$needsRender]())}[$detachAnimation](U="",G=DEFAULT_DETACH_OPTIONS){this[$scene].detachAnimation(U||this.animationName,G.fade),this[$paused]&&(this[$scene].updateAnimation(0),this[$needsRender]())}}return __decorate$3([n$2({type:Boolean})],D.prototype,"autoplay",void 0),__decorate$3([n$2({type:String,attribute:"animation-name"})],D.prototype,"animationName",void 0),__decorate$3([n$2({type:Number,attribute:"animation-crossfade-duration"})],D.prototype,"animationCrossfadeDuration",void 0),D};/* @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */const $hotspotMap=Symbol("hotspotMap"),$mutationCallback=Symbol("mutationCallback"),$observer=Symbol("observer"),$addHotspot=Symbol("addHotspot"),$removeHotspot=Symbol("removeHotspot"),worldToModel=new Matrix4,AnnotationMixin=F=>{var w,D,O;class U extends F{constructor(){super(...arguments),this[w]=new Map,this[D]=q=>{q.forEach(K=>{(!(K instanceof MutationRecord)||K.type==="childList")&&(K.addedNodes.forEach(ee=>{this[$addHotspot](ee)}),K.removedNodes.forEach(ee=>{this[$removeHotspot](ee)}),this[$needsRender]())})},this[O]=new MutationObserver(this[$mutationCallback])}connectedCallback(){super.connectedCallback();for(let K=0;K<this.children.length;++K)this[$addHotspot](this.children[K]);const{ShadyDOM:q}=self;q==null?this[$observer].observe(this,{childList:!0}):this[$observer]=q.observeChildren(this,this[$mutationCallback])}disconnectedCallback(){super.disconnectedCallback();const{ShadyDOM:q}=self;q==null?this[$observer].disconnect():q.unobserveChildren(this[$observer])}[(w=$hotspotMap,D=$mutationCallback,O=$observer,$onModelLoad)](){super[$onModelLoad]();const q=this[$scene];q.forHotspots(K=>{q.updateSurfaceHotspot(K)})}[$tick](q,K){super[$tick](q,K);const ee=this[$scene],{annotationRenderer:Z}=ee,ie=ee.getCamera();ee.shouldRender()&&(ee.animateSurfaceHotspots(),ee.updateHotspotsVisibility(ie.position),Z.domElement.style.display="",Z.render(ee,ie))}updateHotspot(q){const K=this[$hotspotMap].get(q.name);K!=null&&(K.updatePosition(q.position),K.updateNormal(q.normal),K.surface=q.surface,this[$scene].updateSurfaceHotspot(K),this[$needsRender]())}queryHotspot(q){const K=this[$hotspotMap].get(q);if(K==null)return null;const ee=toVector3D(K.position),Z=toVector3D(K.normal),ie=K.facingCamera,Y=this[$scene],W=Y.getCamera(),ne=new Vector3;ne.setFromMatrixPosition(K.matrixWorld),ne.project(W);const se=Y.width/2,le=Y.height/2;ne.x=ne.x*se+se,ne.y=-(ne.y*le)+le;const ce=toVector3D(new Vector3(ne.x,ne.y,ne.z));return!Number.isFinite(ce.x)||!Number.isFinite(ce.y)?null:{position:ee,normal:Z,canvasPosition:ce,facingCamera:ie}}positionAndNormalFromPoint(q,K){const ee=this[$scene],Z=ee.getNDC(q,K),ie=ee.positionAndNormalFromPoint(Z);if(ie==null)return null;worldToModel.copy(ee.target.matrixWorld).invert();const Y=toVector3D(ie.position.applyMatrix4(worldToModel)),W=toVector3D(ie.normal.transformDirection(worldToModel));let ne=null;return ie.uv!=null&&(ne=toVector2D(ie.uv)),{position:Y,normal:W,uv:ne}}surfaceFromPoint(q,K){const ee=this[$scene],Z=ee.getNDC(q,K);return ee.surfaceFromPoint(Z)}[$addHotspot](q){if(!(q instanceof HTMLElement&&q.slot.indexOf("hotspot")===0))return;let K=this[$hotspotMap].get(q.slot);K!=null?K.increment():(K=new Hotspot({name:q.slot,position:q.dataset.position,normal:q.dataset.normal,surface:q.dataset.surface}),this[$hotspotMap].set(q.slot,K),this[$scene].addHotspot(K)),this[$scene].queueRender()}[$removeHotspot](q){if(!(q instanceof HTMLElement))return;const K=this[$hotspotMap].get(q.slot);K&&(K.decrement()&&(this[$scene].removeHotspot(K),this[$hotspotMap].delete(q.slot)),this[$scene].queueRender())}}return U};/*!
fflate - fast JavaScript compression/decompression
<https://101arrowz.github.io/fflate>
Licensed under MIT. https://github.com/101arrowz/fflate/blob/master/LICENSE
version 0.8.2
*/var u8=Uint8Array,u16=Uint16Array,i32=Int32Array,fleb=new u8([0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0,0,0,0]),fdeb=new u8([0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,0,0]),clim=new u8([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]),freb=function(F,w){for(var D=new u16(31),O=0;O<31;++O)D[O]=w+=1<<F[O-1];for(var U=new i32(D[30]),O=1;O<30;++O)for(var G=D[O];G<D[O+1];++G)U[G]=G-D[O]<<5|O;return{b:D,r:U}},_a=freb(fleb,2),fl=_a.b,revfl=_a.r;fl[28]=258,revfl[258]=28;var _b=freb(fdeb,0),revfd=_b.r,rev=new u16(32768);for(var i=0;i<32768;++i){var x=(i&43690)>>1|(i&21845)<<1;x=(x&52428)>>2|(x&13107)<<2,x=(x&61680)>>4|(x&3855)<<4,rev[i]=((x&65280)>>8|(x&255)<<8)>>1}var hMap=(function(F,w,D){for(var O=F.length,U=0,G=new u16(w);U<O;++U)F[U]&&++G[F[U]-1];var q=new u16(w);for(U=1;U<w;++U)q[U]=q[U-1]+G[U-1]<<1;var K;if(D){K=new u16(1<<w);var ee=15-w;for(U=0;U<O;++U)if(F[U])for(var Z=U<<4|F[U],ie=w-F[U],Y=q[F[U]-1]++<<ie,W=Y|(1<<ie)-1;Y<=W;++Y)K[rev[Y]>>ee]=Z}else for(K=new u16(O),U=0;U<O;++U)F[U]&&(K[U]=rev[q[F[U]-1]++]>>15-F[U]);return K}),flt=new u8(288);for(var i=0;i<144;++i)flt[i]=8;for(var i=144;i<256;++i)flt[i]=9;for(var i=256;i<280;++i)flt[i]=7;for(var i=280;i<288;++i)flt[i]=8;var fdt=new u8(32);for(var i=0;i<32;++i)fdt[i]=5;var flm=hMap(flt,9,0),fdm=hMap(fdt,5,0),shft=function(F){return(F+7)/8|0},slc=function(F,w,D){return(D==null||D>F.length)&&(D=F.length),new u8(F.subarray(w,D))},ec=["unexpected EOF","invalid block type","invalid length/literal","invalid distance","stream finished","no stream handler",,"no callback","invalid UTF-8 data","extra field too long","date not in range 1980-2099","filename too long","stream finishing","invalid zip data"],err=function(F,w,D){var O=new Error(w||ec[F]);if(O.code=F,Error.captureStackTrace&&Error.captureStackTrace(O,err),!D)throw O;return O},wbits=function(F,w,D){D<<=w&7;var O=w/8|0;F[O]|=D,F[O+1]|=D>>8},wbits16=function(F,w,D){D<<=w&7;var O=w/8|0;F[O]|=D,F[O+1]|=D>>8,F[O+2]|=D>>16},hTree=function(F,w){for(var D=[],O=0;O<F.length;++O)F[O]&&D.push({s:O,f:F[O]});var U=D.length,G=D.slice();if(!U)return{t:et,l:0};if(U==1){var q=new u8(D[0].s+1);return q[D[0].s]=1,{t:q,l:1}}D.sort(function(ge,ve){return ge.f-ve.f}),D.push({s:-1,f:25001});var K=D[0],ee=D[1],Z=0,ie=1,Y=2;for(D[0]={s:-1,f:K.f+ee.f,l:K,r:ee};ie!=U-1;)K=D[D[Z].f<D[Y].f?Z++:Y++],ee=D[Z!=ie&&D[Z].f<D[Y].f?Z++:Y++],D[ie++]={s:-1,f:K.f+ee.f,l:K,r:ee};for(var W=G[0].s,O=1;O<U;++O)G[O].s>W&&(W=G[O].s);var ne=new u16(W+1),se=ln(D[ie-1],ne,0);if(se>w){var O=0,le=0,ce=se-w,he=1<<ce;for(G.sort(function(ve,Se){return ne[Se.s]-ne[ve.s]||ve.f-Se.f});O<U;++O){var pe=G[O].s;if(ne[pe]>w)le+=he-(1<<se-ne[pe]),ne[pe]=w;else break}for(le>>=ce;le>0;){var me=G[O].s;ne[me]<w?le-=1<<w-ne[me]++-1:++O}for(;O>=0&&le;--O){var be=G[O].s;ne[be]==w&&(--ne[be],++le)}se=w}return{t:new u8(ne),l:se}},ln=function(F,w,D){return F.s==-1?Math.max(ln(F.l,w,D+1),ln(F.r,w,D+1)):w[F.s]=D},lc=function(F){for(var w=F.length;w&&!F[--w];);for(var D=new u16(++w),O=0,U=F[0],G=1,q=function(ee){D[O++]=ee},K=1;K<=w;++K)if(F[K]==U&&K!=w)++G;else{if(!U&&G>2){for(;G>138;G-=138)q(32754);G>2&&(q(G>10?G-11<<5|28690:G-3<<5|12305),G=0)}else if(G>3){for(q(U),--G;G>6;G-=6)q(8304);G>2&&(q(G-3<<5|8208),G=0)}for(;G--;)q(U);G=1,U=F[K]}return{c:D.subarray(0,O),n:w}},clen=function(F,w){for(var D=0,O=0;O<w.length;++O)D+=F[O]*w[O];return D},wfblk=function(F,w,D){var O=D.length,U=shft(w+2);F[U]=O&255,F[U+1]=O>>8,F[U+2]=F[U]^255,F[U+3]=F[U+1]^255;for(var G=0;G<O;++G)F[U+G+4]=D[G];return(U+4+O)*8},wblk=function(F,w,D,O,U,G,q,K,ee,Z,ie){wbits(w,ie++,D),++U[256];for(var Y=hTree(U,15),W=Y.t,ne=Y.l,se=hTree(G,15),le=se.t,ce=se.l,he=lc(W),pe=he.c,me=he.n,be=lc(le),ge=be.c,ve=be.n,Se=new u16(19),Me=0;Me<pe.length;++Me)++Se[pe[Me]&31];for(var Me=0;Me<ge.length;++Me)++Se[ge[Me]&31];for(var Ee=hTree(Se,7),we=Ee.t,Re=Ee.l,Le=19;Le>4&&!we[clim[Le-1]];--Le);var Ne=Z+5<<3,Oe=clen(U,flt)+clen(G,fdt)+q,Pe=clen(U,W)+clen(G,le)+q+14+3*Le+clen(Se,we)+2*Se[16]+3*Se[17]+7*Se[18];if(ee>=0&&Ne<=Oe&&Ne<=Pe)return wfblk(w,ie,F.subarray(ee,ee+Z));var Ce,Be,ze,Xe;if(wbits(w,ie,1+(Pe<Oe)),ie+=2,Pe<Oe){Ce=hMap(W,ne,0),Be=W,ze=hMap(le,ce,0),Xe=le;var lt=hMap(we,Re,0);wbits(w,ie,me-257),wbits(w,ie+5,ve-1),wbits(w,ie+10,Le-4),ie+=14;for(var Me=0;Me<Le;++Me)wbits(w,ie+3*Me,we[clim[Me]]);ie+=3*Le;for(var ke=[pe,ge],rt=0;rt<2;++rt)for(var St=ke[rt],Me=0;Me<St.length;++Me){var Lt=St[Me]&31;wbits(w,ie,lt[Lt]),ie+=we[Lt],Lt>15&&(wbits(w,ie,St[Me]>>5&127),ie+=St[Me]>>12)}}else Ce=flm,Be=flt,ze=fdm,Xe=fdt;for(var Me=0;Me<K;++Me){var $t=O[Me];if($t>255){var Lt=$t>>18&31;wbits16(w,ie,Ce[Lt+257]),ie+=Be[Lt+257],Lt>7&&(wbits(w,ie,$t>>23&31),ie+=fleb[Lt]);var mt=$t&31;wbits16(w,ie,ze[mt]),ie+=Xe[mt],mt>3&&(wbits16(w,ie,$t>>5&8191),ie+=fdeb[mt])}else wbits16(w,ie,Ce[$t]),ie+=Be[$t]}return wbits16(w,ie,Ce[256]),ie+Be[256]},deo=new i32([65540,131080,131088,131104,262176,1048704,1048832,2114560,2117632]),et=new u8(0),dflt=function(F,w,D,O,U,G){var q=G.z||F.length,K=new u8(O+q+5*(1+Math.ceil(q/7e3))+U),ee=K.subarray(O,K.length-U),Z=G.l,ie=(G.r||0)&7;if(w){ie&&(ee[0]=G.r>>3);for(var Y=deo[w-1],W=Y>>13,ne=Y&8191,se=(1<<D)-1,le=G.p||new u16(32768),ce=G.h||new u16(se+1),he=Math.ceil(D/3),pe=2*he,me=function(In){return(F[In]^F[In+1]<<he^F[In+2]<<pe)&se},be=new i32(25e3),ge=new u16(288),ve=new u16(32),Se=0,Me=0,Ee=G.i||0,we=0,Re=G.w||0,Le=0;Ee+2<q;++Ee){var Ne=me(Ee),Oe=Ee&32767,Pe=ce[Ne];if(le[Oe]=Pe,ce[Ne]=Oe,Re<=Ee){var Ce=q-Ee;if((Se>7e3||we>24576)&&(Ce>423||!Z)){ie=wblk(F,ee,0,be,ge,ve,Me,we,Le,Ee-Le,ie),we=Se=Me=0,Le=Ee;for(var Be=0;Be<286;++Be)ge[Be]=0;for(var Be=0;Be<30;++Be)ve[Be]=0}var ze=2,Xe=0,lt=ne,ke=Oe-Pe&32767;if(Ce>2&&Ne==me(Ee-ke))for(var rt=Math.min(W,Ce)-1,St=Math.min(32767,Ee),Lt=Math.min(258,Ce);ke<=St&&--lt&&Oe!=Pe;){if(F[Ee+ze]==F[Ee+ze-ke]){for(var $t=0;$t<Lt&&F[Ee+$t]==F[Ee+$t-ke];++$t);if($t>ze){if(ze=$t,Xe=ke,$t>rt)break;for(var mt=Math.min(ke,$t-2),bt=0,Be=0;Be<mt;++Be){var Xt=Ee-ke+Be&32767,hn=le[Xt],Jt=Xt-hn&32767;Jt>bt&&(bt=Jt,Pe=Xt)}}}Oe=Pe,Pe=le[Oe],ke+=Oe-Pe&32767}if(Xe){be[we++]=268435456|revfl[ze]<<18|revfd[Xe];var Mn=revfl[ze]&31,Zn=revfd[Xe]&31;Me+=fleb[Mn]+fdeb[Zn],++ge[257+Mn],++ve[Zn],Re=Ee+ze,++Se}else be[we++]=F[Ee],++ge[F[Ee]]}}for(Ee=Math.max(Ee,Re);Ee<q;++Ee)be[we++]=F[Ee],++ge[F[Ee]];ie=wblk(F,ee,Z,be,ge,ve,Me,we,Le,Ee-Le,ie),Z||(G.r=ie&7|ee[ie/8|0]<<3,ie-=7,G.h=ce,G.p=le,G.i=Ee,G.w=Re)}else{for(var Ee=G.w||0;Ee<q+Z;Ee+=65535){var vn=Ee+65535;vn>=q&&(ee[ie/8|0]=Z,vn=q),ie=wfblk(ee,ie+1,F.subarray(Ee,vn))}G.i=q}return slc(K,0,O+shft(ie)+U)},crct=(function(){for(var F=new Int32Array(256),w=0;w<256;++w){for(var D=w,O=9;--O;)D=(D&1&&-306674912)^D>>>1;F[w]=D}return F})(),crc=function(){var F=-1;return{p:function(w){for(var D=F,O=0;O<w.length;++O)D=crct[D&255^w[O]]^D>>>8;F=D},d:function(){return~F}}},dopt=function(F,w,D,O,U){if(!U&&(U={l:1},w.dictionary)){var G=w.dictionary.subarray(-32768),q=new u8(G.length+F.length);q.set(G),q.set(F,G.length),F=q,U.w=G.length}return dflt(F,w.level==null?6:w.level,w.mem==null?U.l?Math.ceil(Math.max(8,Math.min(13,Math.log(F.length)))*1.5):20:12+w.mem,D,O,U)},mrg=function(F,w){var D={};for(var O in F)D[O]=F[O];for(var O in w)D[O]=w[O];return D},wbytes=function(F,w,D){for(;D;++w)F[w]=D,D>>>=8};function deflateSync(F,w){return dopt(F,w||{},0,0)}var fltn=function(F,w,D,O){for(var U in F){var G=F[U],q=w+U,K=O;Array.isArray(G)&&(K=mrg(O,G[1]),G=G[0]),G instanceof u8?D[q]=[G,K]:(D[q+="/"]=[new u8(0),K],fltn(G,q,D,O))}},te=typeof TextEncoder<"u"&&new TextEncoder,td=typeof TextDecoder<"u"&&new TextDecoder,tds=0;try{td.decode(et,{stream:!0}),tds=1}catch{}function strToU8(F,w){var D;if(te)return te.encode(F);for(var O=F.length,U=new u8(F.length+(F.length>>1)),G=0,q=function(Z){U[G++]=Z},D=0;D<O;++D){if(G+5>U.length){var K=new u8(G+8+(O-D<<1));K.set(U),U=K}var ee=F.charCodeAt(D);ee<128||w?q(ee):ee<2048?(q(192|ee>>6),q(128|ee&63)):ee>55295&&ee<57344?(ee=65536+(ee&1047552)|F.charCodeAt(++D)&1023,q(240|ee>>18),q(128|ee>>12&63),q(128|ee>>6&63),q(128|ee&63)):(q(224|ee>>12),q(128|ee>>6&63),q(128|ee&63))}return slc(U,0,G)}var exfl=function(F){var w=0;if(F)for(var D in F){var O=F[D].length;O>65535&&err(9),w+=O+4}return w},wzh=function(F,w,D,O,U,G,q,K){var ee=O.length,Z=D.extra,ie=K&&K.length,Y=exfl(Z);wbytes(F,w,q!=null?33639248:67324752),w+=4,q!=null&&(F[w++]=20,F[w++]=D.os),F[w]=20,w+=2,F[w++]=D.flag<<1|(G<0&&8),F[w++]=U&&8,F[w++]=D.compression&255,F[w++]=D.compression>>8;var W=new Date(D.mtime==null?Date.now():D.mtime),ne=W.getFullYear()-1980;if((ne<0||ne>119)&&err(10),wbytes(F,w,ne<<25|W.getMonth()+1<<21|W.getDate()<<16|W.getHours()<<11|W.getMinutes()<<5|W.getSeconds()>>1),w+=4,G!=-1&&(wbytes(F,w,D.crc),wbytes(F,w+4,G<0?-G-2:G),wbytes(F,w+8,D.size)),wbytes(F,w+12,ee),wbytes(F,w+14,Y),w+=16,q!=null&&(wbytes(F,w,ie),wbytes(F,w+6,D.attrs),wbytes(F,w+10,q),w+=14),F.set(O,w),w+=ee,Y)for(var se in Z){var le=Z[se],ce=le.length;wbytes(F,w,+se),wbytes(F,w+2,ce),F.set(le,w+4),w+=4+ce}return ie&&(F.set(K,w),w+=ie),w},wzf=function(F,w,D,O,U){wbytes(F,w,101010256),wbytes(F,w+8,D),wbytes(F,w+10,D),wbytes(F,w+12,O),wbytes(F,w+16,U)};function zipSync(F,w){w||(w={});var D={},O=[];fltn(F,"",D,w);var U=0,G=0;for(var q in D){var K=D[q],ee=K[0],Z=K[1],ie=Z.level==0?0:8,Y=strToU8(q),W=Y.length,ne=Z.comment,se=ne&&strToU8(ne),le=se&&se.length,ce=exfl(Z.extra);W>65535&&err(11);var he=ie?deflateSync(ee,Z):ee,pe=he.length,me=crc();me.p(ee),O.push(mrg(Z,{size:ee.length,crc:me.d(),c:he,f:Y,m:se,u:W!=q.length||se&&ne.length!=le,o:U,compression:ie})),U+=30+W+ce+pe,G+=76+2*(W+ce)+(le||0)+pe}for(var be=new u8(G+22),ge=U,ve=G-U,Se=0;Se<O.length;++Se){var Y=O[Se];wzh(be,Y.o,Y,Y.f,Y.u,Y.c.length);var Me=30+Y.f.length+exfl(Y.extra);be.set(Y.c,Y.o+Me),wzh(be,U,Y,Y.f,Y.u,Y.c.length,Y.o,Y.m),U+=16+Me+(Y.m?Y.m.length:0)}return wzf(be,U,O.length,ve,ge),be}class USDNode{constructor(w,D="",O=[],U=[]){this.name=w,this.type=D,this.metadata=O,this.properties=U,this.children=[]}addMetadata(w,D){this.metadata.push({key:w,value:D})}addProperty(w,D=[]){this.properties.push({property:w,metadata:D})}addChild(w){this.children.push(w)}toString(w=0){const D="	".repeat(w),O=this.metadata.map(ie=>{const Y=ie.key,W=ie.value;if(Array.isArray(W)){const ne=[];return ne.push(`${Y} = {`),W.forEach(se=>{ne.push(`${D}		${se}`)}),ne.push(`${D}	}`),ne.join(`
`)}else return`${Y} = ${W}`}),U=O.length?` (
${O.map(ie=>`${D}	${ie}`).join(`
`)}
${D})`:"",G=this.properties.map(ie=>{const Y=ie.property,W=ie.metadata.length?` (
${ie.metadata.map(ne=>`${D}		${ne}`).join(`
`)}
${D}	)`:"";return`${D}	${Y}${W}`}),q=this.children.map(ie=>ie.toString(w+1)),K=[];if(G.length>0&&K.push(...G),q.length>0){G.length>0&&K.push("");for(let ie=0;ie<q.length;ie++)K.push(q[ie]),ie<q.length-1&&K.push("")}const ee=K.join(`
`),Z=this.type?this.type+" ":"";return`${D}def ${Z}"${this.name}"${U}
${D}{
${ee}
${D}}`}}class USDZExporter{constructor(){this.textureUtils=null}setTextureUtils(w){this.textureUtils=w}parse(w,D,O,U){this.parseAsync(w,U).then(D).catch(O)}async parseAsync(w,D={}){D=Object.assign({ar:{anchoring:{type:"plane"},planeAnchoring:{alignment:"horizontal"}},includeAnchoringProperties:!0,onlyVisible:!0,quickLookCompatible:!1,maxTextureSize:1024},D);const O=new Set,U={},G="model.usda";U[G]=null;const q=new USDNode("Root","Xform"),K=new USDNode("Scenes","Scope");K.addMetadata("kind",'"sceneLibrary"'),q.addChild(K);const ee="Scene",Z=new USDNode(ee,"Xform");Z.addMetadata("customData",["bool preliminary_collidesWithEnvironment = 0",`string sceneName = "${ee}"`]),Z.addMetadata("sceneName",`"${ee}"`),D.includeAnchoringProperties&&(Z.addProperty(`token preliminary:anchoring:type = "${D.ar.anchoring.type}"`),Z.addProperty(`token preliminary:planeAnchoring:alignment = "${D.ar.planeAnchoring.alignment}"`)),K.addChild(Z);let ie;const Y={},W={};buildHierarchy(w,Z,Y,O,U,D);const ne=buildMaterials(Y,W,D.quickLookCompatible);ie=buildHeader()+`
`+q.toString()+`

`+ne.toString(),U[G]=strToU8(ie),ie=null;for(const le in W){let ce=W[le];if(ce.isCompressedTexture===!0){if(this.textureUtils===null)throw new Error("THREE.USDZExporter: setTextureUtils() must be called to process compressed textures.");ce=await this.textureUtils.decompress(ce)}const he=imageToCanvas(ce.image,ce.flipY,D.maxTextureSize),pe=await new Promise(me=>he.toBlob(me,"image/png",1));U[`textures/Texture_${le}.png`]=new Uint8Array(await pe.arrayBuffer())}let se=0;for(const le in U){const ce=U[le],he=34+le.length;se+=he;const pe=se&63;if(pe!==4){const me=64-pe,be=new Uint8Array(me);U[le]=[ce,{extra:{12345:be}}]}se=ce.length}return zipSync(U,{level:0})}}function getName(F,w){let D=F.name;return D=D.replace(/[^A-Za-z0-9_]/g,""),/^[0-9]/.test(D)&&(D="_"+D),D===""&&(F.isCamera?D="Camera":D="Object"),w.has(D)&&(D=D+"_"+F.id),w.add(D),D}function imageToCanvas(F,w,D){if(typeof HTMLImageElement<"u"&&F instanceof HTMLImageElement||typeof HTMLCanvasElement<"u"&&F instanceof HTMLCanvasElement||typeof OffscreenCanvas<"u"&&F instanceof OffscreenCanvas||typeof ImageBitmap<"u"&&F instanceof ImageBitmap){const O=D/Math.max(F.width,F.height),U=document.createElement("canvas");U.width=F.width*Math.min(1,O),U.height=F.height*Math.min(1,O);const G=U.getContext("2d");return w===!0&&(G.translate(0,U.height),G.scale(1,-1)),G.drawImage(F,0,0,U.width,U.height),U}else throw new Error("THREE.USDZExporter: No valid image data found. Unable to process texture.")}const PRECISION=7;function buildHeader(){return`#usda 1.0
(
	customLayerData = {
		string creator = "Three.js USDZExporter"
	}
	defaultPrim = "Root"
	metersPerUnit = 1
	upAxis = "Y"
)
`}function buildHierarchy(F,w,D,O,U,G){for(let q=0,K=F.children.length;q<K;q++){const ee=F.children[q];if(ee.visible===!1&&G.onlyVisible===!0)continue;let Z;if(ee.isMesh){const ie=ee.geometry,Y=ee.material;if(Y.isMeshStandardMaterial){const W="geometries/Geometry_"+ie.id+".usda";if(!(W in U)){const ne=buildMeshObject(ie);U[W]=strToU8(buildHeader()+`
`+ne.toString())}Y.uuid in D||(D[Y.uuid]=Y),Z=buildMesh(ee,ie,D[Y.uuid],O)}else console.warn("THREE.USDZExporter: Unsupported material type (USDZ only supports MeshStandardMaterial)",ee)}else ee.isCamera?Z=buildCamera(ee,O):Z=buildXform(ee,O);Z&&(w.addChild(Z),buildHierarchy(ee,Z,D,O,U,G))}}function buildXform(F,w){const D=getName(F,w),O=buildMatrix(F.matrix);F.matrix.determinant()<0&&console.warn("THREE.USDZExporter: USDZ does not support negative scales",F);const U=new USDNode(D,"Xform");return U.addProperty(`matrix4d xformOp:transform = ${O}`),U.addProperty('uniform token[] xformOpOrder = ["xformOp:transform"]'),U}function buildMesh(F,w,D,O){const U=buildXform(F,O);return U.addMetadata("prepend references",`@./geometries/Geometry_${w.id}.usda@</Geometry>`),U.addMetadata("prepend apiSchemas",'["MaterialBindingAPI"]'),U.addProperty(`rel material:binding = </Materials/Material_${D.id}>`),U}function buildMatrix(F){const w=F.elements;return`( ${buildMatrixRow(w,0)}, ${buildMatrixRow(w,4)}, ${buildMatrixRow(w,8)}, ${buildMatrixRow(w,12)} )`}function buildMatrixRow(F,w){return`(${F[w+0]}, ${F[w+1]}, ${F[w+2]}, ${F[w+3]})`}function buildMeshObject(F){const w=new USDNode("Geometry"),D=buildMeshNode(F);return w.addChild(D),w}function buildMeshNode(F){const w="Geometry",D=F.attributes,O=D.position.count,U=new USDNode(w,"Mesh");U.addProperty(`int[] faceVertexCounts = [${buildMeshVertexCount(F)}]`),U.addProperty(`int[] faceVertexIndices = [${buildMeshVertexIndices(F)}]`),U.addProperty(`normal3f[] normals = [${buildVector3Array(D.normal,O)}]`,['interpolation = "vertex"']),U.addProperty(`point3f[] points = [${buildVector3Array(D.position,O)}]`);for(let q=0;q<4;q++){const K=q>0?q:"",ee=D["uv"+K];ee!==void 0&&U.addProperty(`texCoord2f[] primvars:st${K} = [${buildVector2Array(ee)}]`,['interpolation = "vertex"'])}const G=D.color;return G!==void 0&&U.addProperty(`color3f[] primvars:displayColor = [${buildVector3Array(G,O)}]`,['interpolation = "vertex"']),U.addProperty('uniform token subdivisionScheme = "none"'),U}function buildMeshVertexCount(F){const w=F.index!==null?F.index.count:F.attributes.position.count;return Array(w/3).fill(3).join(", ")}function buildMeshVertexIndices(F){const w=F.index,D=[];if(w!==null)for(let O=0;O<w.count;O++)D.push(w.getX(O));else{const O=F.attributes.position.count;for(let U=0;U<O;U++)D.push(U)}return D.join(", ")}function buildVector3Array(F,w){if(F===void 0)return console.warn("USDZExporter: Normals missing."),Array(w).fill("(0, 0, 0)").join(", ");const D=[];for(let O=0;O<F.count;O++){const U=F.getX(O),G=F.getY(O),q=F.getZ(O);D.push(`(${U.toPrecision(PRECISION)}, ${G.toPrecision(PRECISION)}, ${q.toPrecision(PRECISION)})`)}return D.join(", ")}function buildVector2Array(F){const w=[];for(let D=0;D<F.count;D++){const O=F.getX(D),U=F.getY(D);w.push(`(${O.toPrecision(PRECISION)}, ${1-U.toPrecision(PRECISION)})`)}return w.join(", ")}function buildMaterials(F,w,D=!1){const O=new USDNode("Materials");for(const U in F){const G=F[U];O.addChild(buildMaterial(G,w,D))}return O}function buildMaterial(F,w,D=!1){const O=new USDNode(`Material_${F.id}`,"Material");function U(q,K,ee){const Z=q.source.id+"_"+q.flipY;w[Z]=q;const ie=q.channel>0?"st"+q.channel:"st",Y={1e3:"repeat",1001:"clamp",1002:"mirror"},W=q.repeat.clone(),ne=q.offset.clone(),se=q.rotation,le=Math.sin(se),ce=Math.cos(se);ne.y=1-ne.y-W.y,D?(ne.x=ne.x/W.x,ne.y=ne.y/W.y,ne.x+=le/W.x,ne.y+=ce-1):(ne.x+=le*W.x,ne.y+=(1-ce)*W.y);const he=new USDNode(`PrimvarReader_${K}`,"Shader");he.addProperty('uniform token info:id = "UsdPrimvarReader_float2"'),he.addProperty("float2 inputs:fallback = (0.0, 0.0)"),he.addProperty(`string inputs:varname = "${ie}"`),he.addProperty("float2 outputs:result");const pe=new USDNode(`Transform2d_${K}`,"Shader");pe.addProperty('uniform token info:id = "UsdTransform2d"'),pe.addProperty(`float2 inputs:in.connect = </Materials/Material_${F.id}/PrimvarReader_${K}.outputs:result>`),pe.addProperty(`float inputs:rotation = ${(se*(180/Math.PI)).toFixed(PRECISION)}`),pe.addProperty(`float2 inputs:scale = ${buildVector2(W)}`),pe.addProperty(`float2 inputs:translation = ${buildVector2(ne)}`),pe.addProperty("float2 outputs:result");const me=new USDNode(`Texture_${q.id}_${K}`,"Shader");return me.addProperty('uniform token info:id = "UsdUVTexture"'),me.addProperty(`asset inputs:file = @textures/Texture_${Z}.png@`),me.addProperty(`float2 inputs:st.connect = </Materials/Material_${F.id}/Transform2d_${K}.outputs:result>`),ee!==void 0&&me.addProperty(`float4 inputs:scale = ${buildColor4(ee)}`),K==="normal"&&(me.addProperty("float4 inputs:scale = (2, 2, 2, 1)"),me.addProperty("float4 inputs:bias = (-1, -1, -1, 0)")),me.addProperty(`token inputs:sourceColorSpace = "${q.colorSpace===NoColorSpace?"raw":"sRGB"}"`),me.addProperty(`token inputs:wrapS = "${Y[q.wrapS]}"`),me.addProperty(`token inputs:wrapT = "${Y[q.wrapT]}"`),me.addProperty("float outputs:r"),me.addProperty("float outputs:g"),me.addProperty("float outputs:b"),me.addProperty("float3 outputs:rgb"),(F.transparent||F.alphaTest>0)&&me.addProperty("float outputs:a"),[he,pe,me]}F.side===DoubleSide&&console.warn("THREE.USDZExporter: USDZ does not support double sided materials",F);const G=new USDNode("PreviewSurface","Shader");if(G.addProperty('uniform token info:id = "UsdPreviewSurface"'),F.map!==null?(G.addProperty(`color3f inputs:diffuseColor.connect = </Materials/Material_${F.id}/Texture_${F.map.id}_diffuse.outputs:rgb>`),F.transparent?G.addProperty(`float inputs:opacity.connect = </Materials/Material_${F.id}/Texture_${F.map.id}_diffuse.outputs:a>`):F.alphaTest>0&&(G.addProperty(`float inputs:opacity.connect = </Materials/Material_${F.id}/Texture_${F.map.id}_diffuse.outputs:a>`),G.addProperty(`float inputs:opacityThreshold = ${F.alphaTest}`)),U(F.map,"diffuse",F.color).forEach(K=>O.addChild(K))):G.addProperty(`color3f inputs:diffuseColor = ${buildColor(F.color)}`),F.emissiveMap!==null){G.addProperty(`color3f inputs:emissiveColor.connect = </Materials/Material_${F.id}/Texture_${F.emissiveMap.id}_emissive.outputs:rgb>`);const q=new Color(F.emissive.r*F.emissiveIntensity,F.emissive.g*F.emissiveIntensity,F.emissive.b*F.emissiveIntensity);U(F.emissiveMap,"emissive",q).forEach(ee=>O.addChild(ee))}else F.emissive.getHex()>0&&G.addProperty(`color3f inputs:emissiveColor = ${buildColor(F.emissive)}`);if(F.normalMap!==null&&(G.addProperty(`normal3f inputs:normal.connect = </Materials/Material_${F.id}/Texture_${F.normalMap.id}_normal.outputs:rgb>`),U(F.normalMap,"normal").forEach(K=>O.addChild(K))),F.aoMap!==null){G.addProperty(`float inputs:occlusion.connect = </Materials/Material_${F.id}/Texture_${F.aoMap.id}_occlusion.outputs:r>`);const q=new Color(F.aoMapIntensity,F.aoMapIntensity,F.aoMapIntensity);U(F.aoMap,"occlusion",q).forEach(ee=>O.addChild(ee))}if(F.roughnessMap!==null){G.addProperty(`float inputs:roughness.connect = </Materials/Material_${F.id}/Texture_${F.roughnessMap.id}_roughness.outputs:g>`);const q=new Color(F.roughness,F.roughness,F.roughness);U(F.roughnessMap,"roughness",q).forEach(ee=>O.addChild(ee))}else G.addProperty(`float inputs:roughness = ${F.roughness}`);if(F.metalnessMap!==null){G.addProperty(`float inputs:metallic.connect = </Materials/Material_${F.id}/Texture_${F.metalnessMap.id}_metallic.outputs:b>`);const q=new Color(F.metalness,F.metalness,F.metalness);U(F.metalnessMap,"metallic",q).forEach(ee=>O.addChild(ee))}else G.addProperty(`float inputs:metallic = ${F.metalness}`);if(F.alphaMap!==null?(G.addProperty(`float inputs:opacity.connect = </Materials/Material_${F.id}/Texture_${F.alphaMap.id}_opacity.outputs:r>`),G.addProperty("float inputs:opacityThreshold = 0.0001"),U(F.alphaMap,"opacity").forEach(K=>O.addChild(K))):G.addProperty(`float inputs:opacity = ${F.opacity}`),F.isMeshPhysicalMaterial){if(F.clearcoatMap!==null){G.addProperty(`float inputs:clearcoat.connect = </Materials/Material_${F.id}/Texture_${F.clearcoatMap.id}_clearcoat.outputs:r>`);const q=new Color(F.clearcoat,F.clearcoat,F.clearcoat);U(F.clearcoatMap,"clearcoat",q).forEach(ee=>O.addChild(ee))}else G.addProperty(`float inputs:clearcoat = ${F.clearcoat}`);if(F.clearcoatRoughnessMap!==null){G.addProperty(`float inputs:clearcoatRoughness.connect = </Materials/Material_${F.id}/Texture_${F.clearcoatRoughnessMap.id}_clearcoatRoughness.outputs:g>`);const q=new Color(F.clearcoatRoughness,F.clearcoatRoughness,F.clearcoatRoughness);U(F.clearcoatRoughnessMap,"clearcoatRoughness",q).forEach(ee=>O.addChild(ee))}else G.addProperty(`float inputs:clearcoatRoughness = ${F.clearcoatRoughness}`);G.addProperty(`float inputs:ior = ${F.ior}`)}return G.addProperty("int inputs:useSpecularWorkflow = 0"),G.addProperty("token outputs:surface"),O.addChild(G),O.addProperty(`token outputs:surface.connect = </Materials/Material_${F.id}/PreviewSurface.outputs:surface>`),O}function buildColor(F){return`(${F.r}, ${F.g}, ${F.b})`}function buildColor4(F){return`(${F.r}, ${F.g}, ${F.b}, 1.0)`}function buildVector2(F){return`(${F.x}, ${F.y})`}function buildCamera(F,w){const D=getName(F,w),O=buildMatrix(F.matrix);F.matrix.determinant()<0&&console.warn("THREE.USDZExporter: USDZ does not support negative scales",F);const U=new USDNode(D,"Camera");U.addProperty(`matrix4d xformOp:transform = ${O}`),U.addProperty('uniform token[] xformOpOrder = ["xformOp:transform"]');const G=F.isOrthographicCamera?"orthographic":"perspective";U.addProperty(`token projection = "${G}"`);const q=`(${F.near.toPrecision(PRECISION)}, ${F.far.toPrecision(PRECISION)})`;U.addProperty(`float2 clippingRange = ${q}`);let K;F.isOrthographicCamera?K=((Math.abs(F.left)+Math.abs(F.right))*10).toPrecision(PRECISION):K=F.getFilmWidth().toPrecision(PRECISION),U.addProperty(`float horizontalAperture = ${K}`);let ee;if(F.isOrthographicCamera?ee=((Math.abs(F.top)+Math.abs(F.bottom))*10).toPrecision(PRECISION):ee=F.getFilmHeight().toPrecision(PRECISION),U.addProperty(`float verticalAperture = ${ee}`),F.isPerspectiveCamera){const Z=F.getFocalLength().toPrecision(PRECISION);U.addProperty(`float focalLength = ${Z}`);const ie=F.focus.toPrecision(PRECISION);U.addProperty(`float focusDistance = ${ie}`)}return U}/* @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */const enumerationDeserializer=F=>w=>{try{const D=parseExpressions(w),O=(D.length?D[0].terms:[]).filter(U=>U&&U.type==="ident").map(U=>U.value).filter(U=>F.indexOf(U)>-1);return new Set(O)}catch{}return new Set};/* @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */var __decorate$2=function(F,w,D,O){var U=arguments.length,G=U<3?w:O===null?O=Object.getOwnPropertyDescriptor(w,D):O,q;if(typeof Reflect=="object"&&typeof Reflect.decorate=="function")G=Reflect.decorate(F,w,D,O);else for(var K=F.length-1;K>=0;K--)(q=F[K])&&(G=(U<3?q(G):U>3?q(w,D,G):q(w,D))||G);return U>3&&G&&Object.defineProperty(w,D,G),G};let isWebXRBlocked=!1,isSceneViewerBlocked=!1;const noArViewerSigil="#model-viewer-no-ar-fallback",deserializeARModes=enumerationDeserializer(["quick-look","scene-viewer","webxr","none"]),DEFAULT_AR_MODES="webxr scene-viewer quick-look",ARMode={QUICK_LOOK:"quick-look",SCENE_VIEWER:"scene-viewer",WEBXR:"webxr",NONE:"none"},$arButtonContainer=Symbol("arButtonContainer"),$enterARWithWebXR=Symbol("enterARWithWebXR"),$openSceneViewer=Symbol("openSceneViewer"),$openIOSARQuickLook=Symbol("openIOSARQuickLook"),$canActivateAR=Symbol("canActivateAR"),$arMode=Symbol("arMode"),$arModes=Symbol("arModes"),$arAnchor=Symbol("arAnchor"),$preload=Symbol("preload"),$onARButtonContainerClick=Symbol("onARButtonContainerClick"),$onARStatus=Symbol("onARStatus"),$onARTracking=Symbol("onARTracking"),$onARTap=Symbol("onARTap"),$selectARMode=Symbol("selectARMode"),$triggerLoad=Symbol("triggerLoad"),ARMixin=F=>{var w,D,O,U,G,q,K,ee,Z,ie;class Y extends F{constructor(){super(...arguments),this.ar=!1,this.arScale="auto",this.arUsdzMaxTextureSize="auto",this.arPlacement="floor",this.arModes=DEFAULT_AR_MODES,this.iosSrc=null,this.xrEnvironment=!1,this[w]=!1,this[D]=this.shadowRoot.querySelector(".ar-button"),this[O]=document.createElement("a"),this[U]=new Set,this[G]=ARMode.NONE,this[q]=!1,this[K]=ne=>{ne.preventDefault(),this.activateAR()},this[ee]=({status:ne})=>{(ne===ARStatus.NOT_PRESENTING||this[$renderer].arRenderer.presentedScene===this[$scene])&&(this.setAttribute("ar-status",ne),this.dispatchEvent(new CustomEvent("ar-status",{detail:{status:ne}})),ne===ARStatus.NOT_PRESENTING?this.removeAttribute("ar-tracking"):ne===ARStatus.SESSION_STARTED&&this.setAttribute("ar-tracking",ARTracking.TRACKING))},this[Z]=({status:ne})=>{this.setAttribute("ar-tracking",ne),this.dispatchEvent(new CustomEvent("ar-tracking",{detail:{status:ne}}))},this[ie]=ne=>{ne.data=="_apple_ar_quicklook_button_tapped"&&this.dispatchEvent(new CustomEvent("quick-look-button-tapped"))}}get canActivateAR(){return this[$arMode]!==ARMode.NONE}connectedCallback(){super.connectedCallback(),this[$renderer].arRenderer.addEventListener("status",this[$onARStatus]),this.setAttribute("ar-status",ARStatus.NOT_PRESENTING),this[$renderer].arRenderer.addEventListener("tracking",this[$onARTracking]),this[$arAnchor].addEventListener("message",this[$onARTap])}disconnectedCallback(){super.disconnectedCallback(),this[$renderer].arRenderer.removeEventListener("status",this[$onARStatus]),this[$renderer].arRenderer.removeEventListener("tracking",this[$onARTracking]),this[$arAnchor].removeEventListener("message",this[$onARTap])}update(ne){super.update(ne),ne.has("arScale")&&(this[$scene].canScale=this.arScale!=="fixed"),ne.has("arPlacement")&&(this[$scene].updateShadow(),this[$needsRender]()),ne.has("arModes")&&(this[$arModes]=deserializeARModes(this.arModes)),(ne.has("ar")||ne.has("arModes")||ne.has("src")||ne.has("iosSrc")||ne.has("arUsdzMaxTextureSize"))&&this[$selectARMode]()}async activateAR(){switch(this[$arMode]){case ARMode.QUICK_LOOK:await this[$openIOSARQuickLook]();break;case ARMode.WEBXR:await this[$enterARWithWebXR]();break;case ARMode.SCENE_VIEWER:this[$openSceneViewer]();break;default:console.warn("No AR Mode can be activated. This is probably due to missing configuration or device capabilities");break}}async[(w=$canActivateAR,D=$arButtonContainer,O=$arAnchor,U=$arModes,G=$arMode,q=$preload,K=$onARButtonContainerClick,ee=$onARStatus,Z=$onARTracking,ie=$onARTap,$selectARMode)](){var ne;let se=ARMode.NONE;if(this.ar){if(this.src!=null)for(const le of this[$arModes]){if(le==="webxr"&&IS_WEBXR_AR_CANDIDATE&&!isWebXRBlocked&&await this[$renderer].arRenderer.supportsPresentation()){se=ARMode.WEBXR;break}if(le==="scene-viewer"&&!isSceneViewerBlocked&&(IS_SCENEVIEWER_CANDIDATE||navigator.userAgentData&&navigator.userAgentData.getHighEntropyValues&&(!((ne=(await navigator.userAgentData.getHighEntropyValues(["formFactor"])).formFactor)===null||ne===void 0)&&ne.includes("XR")))){se=ARMode.SCENE_VIEWER;break}if(le==="quick-look"&&IS_AR_QUICKLOOK_CANDIDATE){se=ARMode.QUICK_LOOK;break}}se===ARMode.NONE&&this.iosSrc!=null&&IS_AR_QUICKLOOK_CANDIDATE&&(se=ARMode.QUICK_LOOK)}if(se!==ARMode.NONE)this[$arButtonContainer].classList.add("enabled"),this[$arButtonContainer].addEventListener("click",this[$onARButtonContainerClick]);else if(this[$arButtonContainer].classList.contains("enabled")){this[$arButtonContainer].removeEventListener("click",this[$onARButtonContainerClick]),this[$arButtonContainer].classList.remove("enabled");const le=ARStatus.FAILED;this.setAttribute("ar-status",le),this.dispatchEvent(new CustomEvent("ar-status",{detail:{status:le}}))}this[$arMode]=se}async[$enterARWithWebXR](){console.log("Attempting to present in AR with WebXR..."),await this[$triggerLoad]();try{this[$arButtonContainer].removeEventListener("click",this[$onARButtonContainerClick]);const{arRenderer:ne}=this[$renderer];ne.placeOnWall=this.arPlacement==="wall",await ne.present(this[$scene],this.xrEnvironment)}catch(ne){console.warn("Error while trying to present in AR with WebXR"),console.error(ne),await this[$renderer].arRenderer.stopPresenting(),isWebXRBlocked=!0,console.warn("Falling back to next ar-mode"),await this[$selectARMode](),this.activateAR()}finally{this[$selectARMode]()}}async[$triggerLoad](){this.loaded||(this[$preload]=!0,this[$updateSource](),await waitForEvent(this,"load"),this[$preload]=!1)}[$shouldAttemptPreload](){return super[$shouldAttemptPreload]()||this[$preload]}[$openSceneViewer](){const ne=self.location.toString(),se=new URL(ne),le=new URL(this.src,ne);le.hash&&(le.hash="");const ce=new URLSearchParams(le.search);if(se.hash=noArViewerSigil,ce.set("mode","ar_preferred"),ce.has("disable_occlusion")||ce.set("disable_occlusion","true"),this.arScale==="fixed"&&ce.set("resizable","false"),this.arPlacement==="wall"&&ce.set("enable_vertical_placement","true"),ce.has("sound")){const me=new URL(ce.get("sound"),ne);ce.set("sound",me.toString())}if(ce.has("link")){const me=new URL(ce.get("link"),ne);ce.set("link",me.toString())}const he=`intent://arvr.google.com/scene-viewer/1.2?${ce.toString()+"&file="+encodeURIComponent(le.toString())}#Intent;scheme=https;package=com.google.android.googlequicksearchbox;action=android.intent.action.VIEW;S.browser_fallback_url=${encodeURIComponent(se.toString())};end;`,pe=()=>{self.location.hash===noArViewerSigil&&(isSceneViewerBlocked=!0,self.history.back(),console.warn("Error while trying to present in AR with Scene Viewer"),console.warn("Falling back to next ar-mode"),this[$selectARMode]())};self.addEventListener("hashchange",pe,{once:!0}),this[$arAnchor].setAttribute("href",he),console.log("Attempting to present in AR with Scene Viewer..."),this[$arAnchor].click()}async[$openIOSARQuickLook](){const ne=!this.iosSrc;this[$arButtonContainer].classList.remove("enabled");const se=ne?await this.prepareUSDZ():this.iosSrc,le=new URL(se,self.location.toString());if(ne){const pe=self.location.toString(),me=new URL(pe),be=new URL(this.src,me);be.hash&&(le.hash=be.hash)}this.arScale==="fixed"&&(le.hash&&(le.hash+="&"),le.hash+="allowsContentScaling=0");const ce=this[$arAnchor];ce.setAttribute("rel","ar");const he=document.createElement("img");ce.appendChild(he),ce.setAttribute("href",le.toString()),ne&&ce.setAttribute("download","model.usdz"),ce.style.display="none",ce.isConnected||this.shadowRoot.appendChild(ce),console.log("Attempting to present in AR with Quick Look..."),ce.click(),ce.removeChild(he),ne&&URL.revokeObjectURL(se),this[$arButtonContainer].classList.add("enabled")}async prepareUSDZ(){const ne=this[$progressTracker].beginActivity("usdz-conversion");await this[$triggerLoad]();const{model:se,shadow:le,target:ce}=this[$scene];if(se==null)return"";let he=!1;le!=null&&(he=le.visible,le.visible=!1),ne(.2);const pe=new USDZExporter;ce.remove(se),se.position.copy(ce.position),se.updateWorldMatrix(!1,!0);const me=await pe.parseAsync(se,{maxTextureSize:isNaN(this.arUsdzMaxTextureSize)?1/0:Math.max(parseInt(this.arUsdzMaxTextureSize),16)});se.position.set(0,0,0),ce.add(se);const be=new Blob([me],{type:"model/vnd.usdz+zip"}),ge=URL.createObjectURL(be);return ne(1),le!=null&&(le.visible=he),ge}}return __decorate$2([n$2({type:Boolean,attribute:"ar"})],Y.prototype,"ar",void 0),__decorate$2([n$2({type:String,attribute:"ar-scale"})],Y.prototype,"arScale",void 0),__decorate$2([n$2({type:String,attribute:"ar-usdz-max-texture-size"})],Y.prototype,"arUsdzMaxTextureSize",void 0),__decorate$2([n$2({type:String,attribute:"ar-placement"})],Y.prototype,"arPlacement",void 0),__decorate$2([n$2({type:String,attribute:"ar-modes"})],Y.prototype,"arModes",void 0),__decorate$2([n$2({type:String,attribute:"ios-src"})],Y.prototype,"iosSrc",void 0),__decorate$2([n$2({type:Boolean,attribute:"xr-environment"})],Y.prototype,"xrEnvironment",void 0),Y};/* @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */var __decorate$1=function(F,w,D,O){var U=arguments.length,G=U<3?w:O===null?O=Object.getOwnPropertyDescriptor(w,D):O,q;if(typeof Reflect=="object"&&typeof Reflect.decorate=="function")G=Reflect.decorate(F,w,D,O);else for(var K=F.length-1;K>=0;K--)(q=F[K])&&(G=(U<3?q(G):U>3?q(w,D,G):q(w,D))||G);return U>3&&G&&Object.defineProperty(w,D,G),G};const PROGRESS_BAR_UPDATE_THRESHOLD=100,DEFAULT_DRACO_DECODER_LOCATION="https://www.gstatic.com/draco/versioned/decoders/1.5.6/",DEFAULT_KTX2_TRANSCODER_LOCATION="https://www.gstatic.com/basis-universal/versioned/2021-04-15-ba1c3e4/",DEFAULT_LOTTIE_LOADER_LOCATION="https://cdn.jsdelivr.net/npm/three@0.149.0/examples/jsm/loaders/LottieLoader.js",RevealStrategy={AUTO:"auto"},LoadingStrategy={AUTO:"auto",EAGER:"eager"},$defaultProgressBarElement=Symbol("defaultProgressBarElement"),$posterContainerElement=Symbol("posterContainerElement"),$defaultPosterElement=Symbol("defaultPosterElement"),$shouldDismissPoster=Symbol("shouldDismissPoster"),$hidePoster=Symbol("hidePoster"),$modelIsRevealed=Symbol("modelIsRevealed"),$updateProgressBar=Symbol("updateProgressBar"),$ariaLabelCallToAction=Symbol("ariaLabelCallToAction"),$onProgress=Symbol("onProgress"),LoadingMixin=F=>{var w,D,O,U,G,q,K,ee;class Z extends F{static set dracoDecoderLocation(Y){CachingGLTFLoader.setDRACODecoderLocation(Y)}static get dracoDecoderLocation(){return CachingGLTFLoader.getDRACODecoderLocation()}static set ktx2TranscoderLocation(Y){CachingGLTFLoader.setKTX2TranscoderLocation(Y)}static get ktx2TranscoderLocation(){return CachingGLTFLoader.getKTX2TranscoderLocation()}static set meshoptDecoderLocation(Y){CachingGLTFLoader.setMeshoptDecoderLocation(Y)}static get meshoptDecoderLocation(){return CachingGLTFLoader.getMeshoptDecoderLocation()}static set lottieLoaderLocation(Y){Renderer.singleton.textureUtils.lottieLoaderUrl=Y}static get lottieLoaderLocation(){return Renderer.singleton.textureUtils.lottieLoaderUrl}static mapURLs(Y){Renderer.singleton.loader[$loader].manager.setURLModifier(Y)}dismissPoster(){this.loaded?this[$hidePoster]():(this[$shouldDismissPoster]=!0,this[$updateSource]())}showPoster(){const Y=this[$posterContainerElement];if(Y.classList.contains("show"))return;Y.classList.add("show"),this[$userInputElement].classList.remove("show");const W=this[$defaultPosterElement];W.removeAttribute("tabindex"),W.removeAttribute("aria-hidden");const ne=this.modelIsVisible;this[$modelIsRevealed]=!1,this[$announceModelVisibility](ne)}getDimensions(){return toVector3D(this[$scene].size)}getBoundingBoxCenter(){return toVector3D(this[$scene].boundingBox.getCenter(new Vector3))}constructor(...Y){super(...Y),this.poster=null,this.reveal=RevealStrategy.AUTO,this.loading=LoadingStrategy.AUTO,this[w]=!1,this[D]=!1,this[O]=this.shadowRoot.querySelector(".slot.poster"),this[U]=this.shadowRoot.querySelector("#default-poster"),this[G]=this.shadowRoot.querySelector("#default-progress-bar > .bar"),this[q]=this[$defaultPosterElement].getAttribute("aria-label"),this[K]=throttle(ce=>{const he=this[$defaultProgressBarElement].parentNode;requestAnimationFrame(()=>{this[$defaultProgressBarElement].style.transform=`scaleX(${ce})`,ce===0&&(he.removeChild(this[$defaultProgressBarElement]),he.appendChild(this[$defaultProgressBarElement])),this[$defaultProgressBarElement].classList.toggle("hide",ce===1)})},PROGRESS_BAR_UPDATE_THRESHOLD),this[ee]=ce=>{const he=ce.detail.totalProgress,pe=ce.detail.reason;he===1&&(this[$updateProgressBar].flush(),this.loaded&&(this[$shouldDismissPoster]||this.reveal===RevealStrategy.AUTO)&&this[$hidePoster]()),this[$updateProgressBar](he),this.dispatchEvent(new CustomEvent("progress",{detail:{totalProgress:he,reason:pe}}))};const W=self.ModelViewerElement||{},ne=W.dracoDecoderLocation||DEFAULT_DRACO_DECODER_LOCATION;CachingGLTFLoader.setDRACODecoderLocation(ne);const se=W.ktx2TranscoderLocation||DEFAULT_KTX2_TRANSCODER_LOCATION;CachingGLTFLoader.setKTX2TranscoderLocation(se),W.meshoptDecoderLocation&&CachingGLTFLoader.setMeshoptDecoderLocation(W.meshoptDecoderLocation);const le=W.lottieLoaderLocation||DEFAULT_LOTTIE_LOADER_LOCATION;Renderer.singleton.textureUtils.lottieLoaderUrl=le}connectedCallback(){super.connectedCallback(),this.loaded||this.showPoster(),this[$progressTracker].addEventListener("progress",this[$onProgress])}disconnectedCallback(){super.disconnectedCallback(),this[$progressTracker].removeEventListener("progress",this[$onProgress])}async updated(Y){super.updated(Y),Y.has("poster")&&this.poster!=null&&(this[$defaultPosterElement].style.backgroundImage=`url(${this.poster})`),Y.has("alt")&&this[$defaultPosterElement].setAttribute("aria-label",this[$altDefaulted]),(Y.has("reveal")||Y.has("loading"))&&this[$updateSource]()}[(w=$modelIsRevealed,D=$shouldDismissPoster,O=$posterContainerElement,U=$defaultPosterElement,G=$defaultProgressBarElement,q=$ariaLabelCallToAction,K=$updateProgressBar,ee=$onProgress,$shouldAttemptPreload)](){return!!this.src&&(this[$shouldDismissPoster]||this.loading===LoadingStrategy.EAGER||this.reveal===RevealStrategy.AUTO&&this[$isElementInViewport])}[$hidePoster](){this[$shouldDismissPoster]=!1;const Y=this[$posterContainerElement];if(!Y.classList.contains("show"))return;Y.classList.remove("show"),this[$userInputElement].classList.add("show");const W=this.modelIsVisible;this[$modelIsRevealed]=!0,this[$announceModelVisibility](W);const ne=this.getRootNode();ne&&ne.activeElement===this&&this[$userInputElement].focus();const se=this[$defaultPosterElement];se.setAttribute("aria-hidden","true"),se.tabIndex=-1,this.dispatchEvent(new CustomEvent("poster-dismissed"))}[$getModelIsVisible](){return super[$getModelIsVisible]()&&this[$modelIsRevealed]}}return __decorate$1([n$2({type:String})],Z.prototype,"poster",void 0),__decorate$1([n$2({type:String})],Z.prototype,"reveal",void 0),__decorate$1([n$2({type:String})],Z.prototype,"loading",void 0),Z};/* @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */var __decorate=function(F,w,D,O){var U=arguments.length,G=U<3?w:O===null?O=Object.getOwnPropertyDescriptor(w,D):O,q;if(typeof Reflect=="object"&&typeof Reflect.decorate=="function")G=Reflect.decorate(F,w,D,O);else for(var K=F.length-1;K>=0;K--)(q=F[K])&&(G=(U<3?q(G):U>3?q(w,D,G):q(w,D))||G);return U>3&&G&&Object.defineProperty(w,D,G),G};const DEFAULT_ROTATION_SPEED=Math.PI/32,AUTO_ROTATE_DELAY_DEFAULT=3e3,rotationRateIntrinsics={basis:[degreesToRadians(numberNode(DEFAULT_ROTATION_SPEED,"rad"))],keywords:{auto:[null]}},$autoRotateStartTime=Symbol("autoRotateStartTime"),$radiansPerSecond=Symbol("radiansPerSecond"),$syncRotationRate=Symbol("syncRotationRate"),$onCameraChange=Symbol("onCameraChange"),StagingMixin=F=>{var w,D,O;class U extends F{constructor(){super(...arguments),this.autoRotate=!1,this.autoRotateDelay=AUTO_ROTATE_DELAY_DEFAULT,this.rotationPerSecond="auto",this[w]=performance.now(),this[D]=0,this[O]=q=>{this.autoRotate&&q.detail.source==="user-interaction"&&(this[$autoRotateStartTime]=performance.now())}}connectedCallback(){super.connectedCallback(),this.addEventListener("camera-change",this[$onCameraChange]),this[$autoRotateStartTime]=performance.now()}disconnectedCallback(){super.disconnectedCallback(),this.removeEventListener("camera-change",this[$onCameraChange]),this[$autoRotateStartTime]=performance.now()}updated(q){super.updated(q),q.has("autoRotate")&&(this[$autoRotateStartTime]=performance.now())}[(w=$autoRotateStartTime,D=$radiansPerSecond,$syncRotationRate)](q){this[$radiansPerSecond]=q[0]}[$tick](q,K){if(super[$tick](q,K),!this.autoRotate||!this[$getModelIsVisible]()||this[$renderer].isPresenting)return;const ee=Math.min(K,q-this[$autoRotateStartTime]-this.autoRotateDelay);ee>0&&(this[$scene].yaw=this.turntableRotation+this[$radiansPerSecond]*ee*.001)}get turntableRotation(){return this[$scene].yaw}resetTurntableRotation(q=0){this[$scene].yaw=q}}return O=$onCameraChange,__decorate([n$2({type:Boolean,attribute:"auto-rotate"})],U.prototype,"autoRotate",void 0),__decorate([n$2({type:Number,attribute:"auto-rotate-delay"})],U.prototype,"autoRotateDelay",void 0),__decorate([style({intrinsics:rotationRateIntrinsics,updateHandler:$syncRotationRate}),n$2({type:String,attribute:"rotation-per-second"})],U.prototype,"rotationPerSecond",void 0),U};/* @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */const ModelViewerElement=AnnotationMixin(SceneGraphMixin(StagingMixin(EnvironmentMixin(ControlsMixin(ARMixin(LoadingMixin(AnimationMixin(ModelViewerElementBase))))))));customElements.define("model-viewer",ModelViewerElement);const LayoutGroupContext=reactExports.createContext({});function useConstant(F){const w=reactExports.useRef(null);return w.current===null&&(w.current=F()),w.current}const isBrowser=typeof window<"u",useIsomorphicLayoutEffect=isBrowser?reactExports.useLayoutEffect:reactExports.useEffect,PresenceContext=reactExports.createContext(null);function addUniqueItem(F,w){F.indexOf(w)===-1&&F.push(w)}function removeItem(F,w){const D=F.indexOf(w);D>-1&&F.splice(D,1)}const clamp=(F,w,D)=>D>w?w:D<F?F:D;let invariant=()=>{};const MotionGlobalConfig={},isNumericalString=F=>/^-?(?:\d+(?:\.\d+)?|\.\d+)$/u.test(F);function isObject(F){return typeof F=="object"&&F!==null}const isZeroValueString=F=>/^0[^.\s]+$/u.test(F);function memo(F){let w;return()=>(w===void 0&&(w=F()),w)}const noop=F=>F,combineFunctions=(F,w)=>D=>w(F(D)),pipe=(...F)=>F.reduce(combineFunctions),progress=(F,w,D)=>{const O=w-F;return O===0?1:(D-F)/O};class SubscriptionManager{constructor(){this.subscriptions=[]}add(w){return addUniqueItem(this.subscriptions,w),()=>removeItem(this.subscriptions,w)}notify(w,D,O){const U=this.subscriptions.length;if(U)if(U===1)this.subscriptions[0](w,D,O);else for(let G=0;G<U;G++){const q=this.subscriptions[G];q&&q(w,D,O)}}getSize(){return this.subscriptions.length}clear(){this.subscriptions.length=0}}const secondsToMilliseconds=F=>F*1e3,millisecondsToSeconds=F=>F/1e3;function velocityPerSecond(F,w){return w?F*(1e3/w):0}const calcBezier=(F,w,D)=>(((1-3*D+3*w)*F+(3*D-6*w))*F+3*w)*F,subdivisionPrecision=1e-7,subdivisionMaxIterations=12;function binarySubdivide(F,w,D,O,U){let G,q,K=0;do q=w+(D-w)/2,G=calcBezier(q,O,U)-F,G>0?D=q:w=q;while(Math.abs(G)>subdivisionPrecision&&++K<subdivisionMaxIterations);return q}function cubicBezier(F,w,D,O){if(F===w&&D===O)return noop;const U=G=>binarySubdivide(G,0,1,F,D);return G=>G===0||G===1?G:calcBezier(U(G),w,O)}const mirrorEasing=F=>w=>w<=.5?F(2*w)/2:(2-F(2*(1-w)))/2,reverseEasing=F=>w=>1-F(1-w),backOut=cubicBezier(.33,1.53,.69,.99),backIn=reverseEasing(backOut),backInOut=mirrorEasing(backIn),anticipate=F=>(F*=2)<1?.5*backIn(F):.5*(2-Math.pow(2,-10*(F-1))),circIn=F=>1-Math.sin(Math.acos(F)),circOut=reverseEasing(circIn),circInOut=mirrorEasing(circIn),easeIn=cubicBezier(.42,0,1,1),easeOut=cubicBezier(0,0,.58,1),easeInOut=cubicBezier(.42,0,.58,1),isEasingArray=F=>Array.isArray(F)&&typeof F[0]!="number",isBezierDefinition=F=>Array.isArray(F)&&typeof F[0]=="number",easingLookup={linear:noop,easeIn,easeInOut,easeOut,circIn,circInOut,circOut,backIn,backInOut,backOut,anticipate},isValidEasing=F=>typeof F=="string",easingDefinitionToFunction=F=>{if(isBezierDefinition(F)){invariant(F.length===4);const[w,D,O,U]=F;return cubicBezier(w,D,O,U)}else if(isValidEasing(F))return easingLookup[F];return F},stepsOrder=["setup","read","resolveKeyframes","preUpdate","update","preRender","render","postRender"];function createRenderStep(F,w){let D=new Set,O=new Set,U=!1,G=!1;const q=new WeakSet;let K={delta:0,timestamp:0,isProcessing:!1};function ee(ie){q.has(ie)&&(Z.schedule(ie),F()),ie(K)}const Z={schedule:(ie,Y=!1,W=!1)=>{const se=W&&U?D:O;return Y&&q.add(ie),se.has(ie)||se.add(ie),ie},cancel:ie=>{O.delete(ie),q.delete(ie)},process:ie=>{if(K=ie,U){G=!0;return}U=!0,[D,O]=[O,D],D.forEach(ee),D.clear(),U=!1,G&&(G=!1,Z.process(ie))}};return Z}const maxElapsed=40;function createRenderBatcher(F,w){let D=!1,O=!0;const U={delta:0,timestamp:0,isProcessing:!1},G=()=>D=!0,q=stepsOrder.reduce((me,be)=>(me[be]=createRenderStep(G),me),{}),{setup:K,read:ee,resolveKeyframes:Z,preUpdate:ie,update:Y,preRender:W,render:ne,postRender:se}=q,le=()=>{const me=MotionGlobalConfig.useManualTiming?U.timestamp:performance.now();D=!1,MotionGlobalConfig.useManualTiming||(U.delta=O?1e3/60:Math.max(Math.min(me-U.timestamp,maxElapsed),1)),U.timestamp=me,U.isProcessing=!0,K.process(U),ee.process(U),Z.process(U),ie.process(U),Y.process(U),W.process(U),ne.process(U),se.process(U),U.isProcessing=!1,D&&w&&(O=!1,F(le))},ce=()=>{D=!0,O=!0,U.isProcessing||F(le)};return{schedule:stepsOrder.reduce((me,be)=>{const ge=q[be];return me[be]=(ve,Se=!1,Me=!1)=>(D||ce(),ge.schedule(ve,Se,Me)),me},{}),cancel:me=>{for(let be=0;be<stepsOrder.length;be++)q[stepsOrder[be]].cancel(me)},state:U,steps:q}}const{schedule:frame,cancel:cancelFrame,state:frameData,steps:frameSteps}=createRenderBatcher(typeof requestAnimationFrame<"u"?requestAnimationFrame:noop,!0);let now;function clearTime(){now=void 0}const time={now:()=>(now===void 0&&time.set(frameData.isProcessing||MotionGlobalConfig.useManualTiming?frameData.timestamp:performance.now()),now),set:F=>{now=F,queueMicrotask(clearTime)}},checkStringStartsWith=F=>w=>typeof w=="string"&&w.startsWith(F),isCSSVariableName=checkStringStartsWith("--"),startsAsVariableToken=checkStringStartsWith("var(--"),isCSSVariableToken=F=>startsAsVariableToken(F)?singleCssVariableRegex.test(F.split("/*")[0].trim()):!1,singleCssVariableRegex=/var\(--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)$/iu,number={test:F=>typeof F=="number",parse:parseFloat,transform:F=>F},alpha={...number,transform:F=>clamp(0,1,F)},scale={...number,default:1},sanitize=F=>Math.round(F*1e5)/1e5,floatRegex=/-?(?:\d+(?:\.\d+)?|\.\d+)/gu;function isNullish(F){return F==null}const singleColorRegex=/^(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))$/iu,isColorString=(F,w)=>D=>!!(typeof D=="string"&&singleColorRegex.test(D)&&D.startsWith(F)||w&&!isNullish(D)&&Object.prototype.hasOwnProperty.call(D,w)),splitColor=(F,w,D)=>O=>{if(typeof O!="string")return O;const[U,G,q,K]=O.match(floatRegex);return{[F]:parseFloat(U),[w]:parseFloat(G),[D]:parseFloat(q),alpha:K!==void 0?parseFloat(K):1}},clampRgbUnit=F=>clamp(0,255,F),rgbUnit={...number,transform:F=>Math.round(clampRgbUnit(F))},rgba={test:isColorString("rgb","red"),parse:splitColor("red","green","blue"),transform:({red:F,green:w,blue:D,alpha:O=1})=>"rgba("+rgbUnit.transform(F)+", "+rgbUnit.transform(w)+", "+rgbUnit.transform(D)+", "+sanitize(alpha.transform(O))+")"};function parseHex(F){let w="",D="",O="",U="";return F.length>5?(w=F.substring(1,3),D=F.substring(3,5),O=F.substring(5,7),U=F.substring(7,9)):(w=F.substring(1,2),D=F.substring(2,3),O=F.substring(3,4),U=F.substring(4,5),w+=w,D+=D,O+=O,U+=U),{red:parseInt(w,16),green:parseInt(D,16),blue:parseInt(O,16),alpha:U?parseInt(U,16)/255:1}}const hex={test:isColorString("#"),parse:parseHex,transform:rgba.transform},createUnitType=F=>({test:w=>typeof w=="string"&&w.endsWith(F)&&w.split(" ").length===1,parse:parseFloat,transform:w=>`${w}${F}`}),degrees=createUnitType("deg"),percent=createUnitType("%"),px=createUnitType("px"),vh=createUnitType("vh"),vw=createUnitType("vw"),progressPercentage={...percent,parse:F=>percent.parse(F)/100,transform:F=>percent.transform(F*100)},hsla={test:isColorString("hsl","hue"),parse:splitColor("hue","saturation","lightness"),transform:({hue:F,saturation:w,lightness:D,alpha:O=1})=>"hsla("+Math.round(F)+", "+percent.transform(sanitize(w))+", "+percent.transform(sanitize(D))+", "+sanitize(alpha.transform(O))+")"},color={test:F=>rgba.test(F)||hex.test(F)||hsla.test(F),parse:F=>rgba.test(F)?rgba.parse(F):hsla.test(F)?hsla.parse(F):hex.parse(F),transform:F=>typeof F=="string"?F:F.hasOwnProperty("red")?rgba.transform(F):hsla.transform(F),getAnimatableNone:F=>{const w=color.parse(F);return w.alpha=0,color.transform(w)}},colorRegex=/(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))/giu;function test(F){return isNaN(F)&&typeof F=="string"&&(F.match(floatRegex)?.length||0)+(F.match(colorRegex)?.length||0)>0}const NUMBER_TOKEN="number",COLOR_TOKEN="color",VAR_TOKEN="var",VAR_FUNCTION_TOKEN="var(",SPLIT_TOKEN="${}",complexRegex=/var\s*\(\s*--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)|#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\)|-?(?:\d+(?:\.\d+)?|\.\d+)/giu;function analyseComplexValue(F){const w=F.toString(),D=[],O={color:[],number:[],var:[]},U=[];let G=0;const K=w.replace(complexRegex,ee=>(color.test(ee)?(O.color.push(G),U.push(COLOR_TOKEN),D.push(color.parse(ee))):ee.startsWith(VAR_FUNCTION_TOKEN)?(O.var.push(G),U.push(VAR_TOKEN),D.push(ee)):(O.number.push(G),U.push(NUMBER_TOKEN),D.push(parseFloat(ee))),++G,SPLIT_TOKEN)).split(SPLIT_TOKEN);return{values:D,split:K,indexes:O,types:U}}function parseComplexValue(F){return analyseComplexValue(F).values}function createTransformer(F){const{split:w,types:D}=analyseComplexValue(F),O=w.length;return U=>{let G="";for(let q=0;q<O;q++)if(G+=w[q],U[q]!==void 0){const K=D[q];K===NUMBER_TOKEN?G+=sanitize(U[q]):K===COLOR_TOKEN?G+=color.transform(U[q]):G+=U[q]}return G}}const convertNumbersToZero=F=>typeof F=="number"?0:color.test(F)?color.getAnimatableNone(F):F;function getAnimatableNone$1(F){const w=parseComplexValue(F);return createTransformer(F)(w.map(convertNumbersToZero))}const complex={test,parse:parseComplexValue,createTransformer,getAnimatableNone:getAnimatableNone$1};function hueToRgb(F,w,D){return D<0&&(D+=1),D>1&&(D-=1),D<1/6?F+(w-F)*6*D:D<1/2?w:D<2/3?F+(w-F)*(2/3-D)*6:F}function hslaToRgba({hue:F,saturation:w,lightness:D,alpha:O}){F/=360,w/=100,D/=100;let U=0,G=0,q=0;if(!w)U=G=q=D;else{const K=D<.5?D*(1+w):D+w-D*w,ee=2*D-K;U=hueToRgb(ee,K,F+1/3),G=hueToRgb(ee,K,F),q=hueToRgb(ee,K,F-1/3)}return{red:Math.round(U*255),green:Math.round(G*255),blue:Math.round(q*255),alpha:O}}function mixImmediate(F,w){return D=>D>0?w:F}const mixNumber$1=(F,w,D)=>F+(w-F)*D,mixLinearColor=(F,w,D)=>{const O=F*F,U=D*(w*w-O)+O;return U<0?0:Math.sqrt(U)},colorTypes=[hex,rgba,hsla],getColorType=F=>colorTypes.find(w=>w.test(F));function asRGBA(F){const w=getColorType(F);if(!w)return!1;let D=w.parse(F);return w===hsla&&(D=hslaToRgba(D)),D}const mixColor=(F,w)=>{const D=asRGBA(F),O=asRGBA(w);if(!D||!O)return mixImmediate(F,w);const U={...D};return G=>(U.red=mixLinearColor(D.red,O.red,G),U.green=mixLinearColor(D.green,O.green,G),U.blue=mixLinearColor(D.blue,O.blue,G),U.alpha=mixNumber$1(D.alpha,O.alpha,G),rgba.transform(U))},invisibleValues=new Set(["none","hidden"]);function mixVisibility(F,w){return invisibleValues.has(F)?D=>D<=0?F:w:D=>D>=1?w:F}function mixNumber(F,w){return D=>mixNumber$1(F,w,D)}function getMixer(F){return typeof F=="number"?mixNumber:typeof F=="string"?isCSSVariableToken(F)?mixImmediate:color.test(F)?mixColor:mixComplex:Array.isArray(F)?mixArray:typeof F=="object"?color.test(F)?mixColor:mixObject:mixImmediate}function mixArray(F,w){const D=[...F],O=D.length,U=F.map((G,q)=>getMixer(G)(G,w[q]));return G=>{for(let q=0;q<O;q++)D[q]=U[q](G);return D}}function mixObject(F,w){const D={...F,...w},O={};for(const U in D)F[U]!==void 0&&w[U]!==void 0&&(O[U]=getMixer(F[U])(F[U],w[U]));return U=>{for(const G in O)D[G]=O[G](U);return D}}function matchOrder(F,w){const D=[],O={color:0,var:0,number:0};for(let U=0;U<w.values.length;U++){const G=w.types[U],q=F.indexes[G][O[G]],K=F.values[q]??0;D[U]=K,O[G]++}return D}const mixComplex=(F,w)=>{const D=complex.createTransformer(w),O=analyseComplexValue(F),U=analyseComplexValue(w);return O.indexes.var.length===U.indexes.var.length&&O.indexes.color.length===U.indexes.color.length&&O.indexes.number.length>=U.indexes.number.length?invisibleValues.has(F)&&!U.values.length||invisibleValues.has(w)&&!O.values.length?mixVisibility(F,w):pipe(mixArray(matchOrder(O,U),U.values),D):mixImmediate(F,w)};function mix(F,w,D){return typeof F=="number"&&typeof w=="number"&&typeof D=="number"?mixNumber$1(F,w,D):getMixer(F)(F,w)}const frameloopDriver=F=>{const w=({timestamp:D})=>F(D);return{start:(D=!0)=>frame.update(w,D),stop:()=>cancelFrame(w),now:()=>frameData.isProcessing?frameData.timestamp:time.now()}},generateLinearEasing=(F,w,D=10)=>{let O="";const U=Math.max(Math.round(w/D),2);for(let G=0;G<U;G++)O+=Math.round(F(G/(U-1))*1e4)/1e4+", ";return`linear(${O.substring(0,O.length-2)})`},maxGeneratorDuration=2e4;function calcGeneratorDuration(F){let w=0;const D=50;let O=F.next(w);for(;!O.done&&w<maxGeneratorDuration;)w+=D,O=F.next(w);return w>=maxGeneratorDuration?1/0:w}function createGeneratorEasing(F,w=100,D){const O=D({...F,keyframes:[0,w]}),U=Math.min(calcGeneratorDuration(O),maxGeneratorDuration);return{type:"keyframes",ease:G=>O.next(U*G).value/w,duration:millisecondsToSeconds(U)}}const velocitySampleDuration=5;function calcGeneratorVelocity(F,w,D){const O=Math.max(w-velocitySampleDuration,0);return velocityPerSecond(D-F(O),w-O)}const springDefaults={stiffness:100,damping:10,mass:1,velocity:0,duration:800,bounce:.3,visualDuration:.3,restSpeed:{granular:.01,default:2},restDelta:{granular:.005,default:.5},minDuration:.01,maxDuration:10,minDamping:.05,maxDamping:1},safeMin=.001;function findSpring({duration:F=springDefaults.duration,bounce:w=springDefaults.bounce,velocity:D=springDefaults.velocity,mass:O=springDefaults.mass}){let U,G,q=1-w;q=clamp(springDefaults.minDamping,springDefaults.maxDamping,q),F=clamp(springDefaults.minDuration,springDefaults.maxDuration,millisecondsToSeconds(F)),q<1?(U=Z=>{const ie=Z*q,Y=ie*F,W=ie-D,ne=calcAngularFreq(Z,q),se=Math.exp(-Y);return safeMin-W/ne*se},G=Z=>{const Y=Z*q*F,W=Y*D+D,ne=Math.pow(q,2)*Math.pow(Z,2)*F,se=Math.exp(-Y),le=calcAngularFreq(Math.pow(Z,2),q);return(-U(Z)+safeMin>0?-1:1)*((W-ne)*se)/le}):(U=Z=>{const ie=Math.exp(-Z*F),Y=(Z-D)*F+1;return-safeMin+ie*Y},G=Z=>{const ie=Math.exp(-Z*F),Y=(D-Z)*(F*F);return ie*Y});const K=5/F,ee=approximateRoot(U,G,K);if(F=secondsToMilliseconds(F),isNaN(ee))return{stiffness:springDefaults.stiffness,damping:springDefaults.damping,duration:F};{const Z=Math.pow(ee,2)*O;return{stiffness:Z,damping:q*2*Math.sqrt(O*Z),duration:F}}}const rootIterations=12;function approximateRoot(F,w,D){let O=D;for(let U=1;U<rootIterations;U++)O=O-F(O)/w(O);return O}function calcAngularFreq(F,w){return F*Math.sqrt(1-w*w)}const durationKeys=["duration","bounce"],physicsKeys=["stiffness","damping","mass"];function isSpringType(F,w){return w.some(D=>F[D]!==void 0)}function getSpringOptions(F){let w={velocity:springDefaults.velocity,stiffness:springDefaults.stiffness,damping:springDefaults.damping,mass:springDefaults.mass,isResolvedFromDuration:!1,...F};if(!isSpringType(F,physicsKeys)&&isSpringType(F,durationKeys))if(F.visualDuration){const D=F.visualDuration,O=2*Math.PI/(D*1.2),U=O*O,G=2*clamp(.05,1,1-(F.bounce||0))*Math.sqrt(U);w={...w,mass:springDefaults.mass,stiffness:U,damping:G}}else{const D=findSpring(F);w={...w,...D,mass:springDefaults.mass},w.isResolvedFromDuration=!0}return w}function spring(F=springDefaults.visualDuration,w=springDefaults.bounce){const D=typeof F!="object"?{visualDuration:F,keyframes:[0,1],bounce:w}:F;let{restSpeed:O,restDelta:U}=D;const G=D.keyframes[0],q=D.keyframes[D.keyframes.length-1],K={done:!1,value:G},{stiffness:ee,damping:Z,mass:ie,duration:Y,velocity:W,isResolvedFromDuration:ne}=getSpringOptions({...D,velocity:-millisecondsToSeconds(D.velocity||0)}),se=W||0,le=Z/(2*Math.sqrt(ee*ie)),ce=q-G,he=millisecondsToSeconds(Math.sqrt(ee/ie)),pe=Math.abs(ce)<5;O||(O=pe?springDefaults.restSpeed.granular:springDefaults.restSpeed.default),U||(U=pe?springDefaults.restDelta.granular:springDefaults.restDelta.default);let me;if(le<1){const ge=calcAngularFreq(he,le);me=ve=>{const Se=Math.exp(-le*he*ve);return q-Se*((se+le*he*ce)/ge*Math.sin(ge*ve)+ce*Math.cos(ge*ve))}}else if(le===1)me=ge=>q-Math.exp(-he*ge)*(ce+(se+he*ce)*ge);else{const ge=he*Math.sqrt(le*le-1);me=ve=>{const Se=Math.exp(-le*he*ve),Me=Math.min(ge*ve,300);return q-Se*((se+le*he*ce)*Math.sinh(Me)+ge*ce*Math.cosh(Me))/ge}}const be={calculatedDuration:ne&&Y||null,next:ge=>{const ve=me(ge);if(ne)K.done=ge>=Y;else{let Se=ge===0?se:0;le<1&&(Se=ge===0?secondsToMilliseconds(se):calcGeneratorVelocity(me,ge,ve));const Me=Math.abs(Se)<=O,Ee=Math.abs(q-ve)<=U;K.done=Me&&Ee}return K.value=K.done?q:ve,K},toString:()=>{const ge=Math.min(calcGeneratorDuration(be),maxGeneratorDuration),ve=generateLinearEasing(Se=>be.next(ge*Se).value,ge,30);return ge+"ms "+ve},toTransition:()=>{}};return be}spring.applyToOptions=F=>{const w=createGeneratorEasing(F,100,spring);return F.ease=w.ease,F.duration=secondsToMilliseconds(w.duration),F.type="keyframes",F};function inertia({keyframes:F,velocity:w=0,power:D=.8,timeConstant:O=325,bounceDamping:U=10,bounceStiffness:G=500,modifyTarget:q,min:K,max:ee,restDelta:Z=.5,restSpeed:ie}){const Y=F[0],W={done:!1,value:Y},ne=Me=>K!==void 0&&Me<K||ee!==void 0&&Me>ee,se=Me=>K===void 0?ee:ee===void 0||Math.abs(K-Me)<Math.abs(ee-Me)?K:ee;let le=D*w;const ce=Y+le,he=q===void 0?ce:q(ce);he!==ce&&(le=he-Y);const pe=Me=>-le*Math.exp(-Me/O),me=Me=>he+pe(Me),be=Me=>{const Ee=pe(Me),we=me(Me);W.done=Math.abs(Ee)<=Z,W.value=W.done?he:we};let ge,ve;const Se=Me=>{ne(W.value)&&(ge=Me,ve=spring({keyframes:[W.value,se(W.value)],velocity:calcGeneratorVelocity(me,Me,W.value),damping:U,stiffness:G,restDelta:Z,restSpeed:ie}))};return Se(0),{calculatedDuration:null,next:Me=>{let Ee=!1;return!ve&&ge===void 0&&(Ee=!0,be(Me),Se(Me)),ge!==void 0&&Me>=ge?ve.next(Me-ge):(!Ee&&be(Me),W)}}}function createMixers(F,w,D){const O=[],U=D||MotionGlobalConfig.mix||mix,G=F.length-1;for(let q=0;q<G;q++){let K=U(F[q],F[q+1]);if(w){const ee=Array.isArray(w)?w[q]||noop:w;K=pipe(ee,K)}O.push(K)}return O}function interpolate$1(F,w,{clamp:D=!0,ease:O,mixer:U}={}){const G=F.length;if(invariant(G===w.length),G===1)return()=>w[0];if(G===2&&w[0]===w[1])return()=>w[1];const q=F[0]===F[1];F[0]>F[G-1]&&(F=[...F].reverse(),w=[...w].reverse());const K=createMixers(w,O,U),ee=K.length,Z=ie=>{if(q&&ie<F[0])return w[0];let Y=0;if(ee>1)for(;Y<F.length-2&&!(ie<F[Y+1]);Y++);const W=progress(F[Y],F[Y+1],ie);return K[Y](W)};return D?ie=>Z(clamp(F[0],F[G-1],ie)):Z}function fillOffset(F,w){const D=F[F.length-1];for(let O=1;O<=w;O++){const U=progress(0,w,O);F.push(mixNumber$1(D,1,U))}}function defaultOffset(F){const w=[0];return fillOffset(w,F.length-1),w}function convertOffsetToTimes(F,w){return F.map(D=>D*w)}function defaultEasing(F,w){return F.map(()=>w||easeInOut).splice(0,F.length-1)}function keyframes({duration:F=300,keyframes:w,times:D,ease:O="easeInOut"}){const U=isEasingArray(O)?O.map(easingDefinitionToFunction):easingDefinitionToFunction(O),G={done:!1,value:w[0]},q=convertOffsetToTimes(D&&D.length===w.length?D:defaultOffset(w),F),K=interpolate$1(q,w,{ease:Array.isArray(U)?U:defaultEasing(w,U)});return{calculatedDuration:F,next:ee=>(G.value=K(ee),G.done=ee>=F,G)}}const isNotNull$1=F=>F!==null;function getFinalKeyframe$1(F,{repeat:w,repeatType:D="loop"},O,U=1){const G=F.filter(isNotNull$1),K=U<0||w&&D!=="loop"&&w%2===1?0:G.length-1;return!K||O===void 0?G[K]:O}const transitionTypeMap={decay:inertia,inertia,tween:keyframes,keyframes,spring};function replaceTransitionType(F){typeof F.type=="string"&&(F.type=transitionTypeMap[F.type])}class WithPromise{constructor(){this.updateFinished()}get finished(){return this._finished}updateFinished(){this._finished=new Promise(w=>{this.resolve=w})}notifyFinished(){this.resolve()}then(w,D){return this.finished.then(w,D)}}const percentToProgress=F=>F/100;class JSAnimation extends WithPromise{constructor(w){super(),this.state="idle",this.startTime=null,this.isStopped=!1,this.currentTime=0,this.holdTime=null,this.playbackSpeed=1,this.stop=()=>{const{motionValue:D}=this.options;D&&D.updatedAt!==time.now()&&this.tick(time.now()),this.isStopped=!0,this.state!=="idle"&&(this.teardown(),this.options.onStop?.())},this.options=w,this.initAnimation(),this.play(),w.autoplay===!1&&this.pause()}initAnimation(){const{options:w}=this;replaceTransitionType(w);const{type:D=keyframes,repeat:O=0,repeatDelay:U=0,repeatType:G,velocity:q=0}=w;let{keyframes:K}=w;const ee=D||keyframes;ee!==keyframes&&typeof K[0]!="number"&&(this.mixKeyframes=pipe(percentToProgress,mix(K[0],K[1])),K=[0,100]);const Z=ee({...w,keyframes:K});G==="mirror"&&(this.mirroredGenerator=ee({...w,keyframes:[...K].reverse(),velocity:-q})),Z.calculatedDuration===null&&(Z.calculatedDuration=calcGeneratorDuration(Z));const{calculatedDuration:ie}=Z;this.calculatedDuration=ie,this.resolvedDuration=ie+U,this.totalDuration=this.resolvedDuration*(O+1)-U,this.generator=Z}updateTime(w){const D=Math.round(w-this.startTime)*this.playbackSpeed;this.holdTime!==null?this.currentTime=this.holdTime:this.currentTime=D}tick(w,D=!1){const{generator:O,totalDuration:U,mixKeyframes:G,mirroredGenerator:q,resolvedDuration:K,calculatedDuration:ee}=this;if(this.startTime===null)return O.next(0);const{delay:Z=0,keyframes:ie,repeat:Y,repeatType:W,repeatDelay:ne,type:se,onUpdate:le,finalKeyframe:ce}=this.options;this.speed>0?this.startTime=Math.min(this.startTime,w):this.speed<0&&(this.startTime=Math.min(w-U/this.speed,this.startTime)),D?this.currentTime=w:this.updateTime(w);const he=this.currentTime-Z*(this.playbackSpeed>=0?1:-1),pe=this.playbackSpeed>=0?he<0:he>U;this.currentTime=Math.max(he,0),this.state==="finished"&&this.holdTime===null&&(this.currentTime=U);let me=this.currentTime,be=O;if(Y){const Me=Math.min(this.currentTime,U)/K;let Ee=Math.floor(Me),we=Me%1;!we&&Me>=1&&(we=1),we===1&&Ee--,Ee=Math.min(Ee,Y+1),!!(Ee%2)&&(W==="reverse"?(we=1-we,ne&&(we-=ne/K)):W==="mirror"&&(be=q)),me=clamp(0,1,we)*K}const ge=pe?{done:!1,value:ie[0]}:be.next(me);G&&(ge.value=G(ge.value));let{done:ve}=ge;!pe&&ee!==null&&(ve=this.playbackSpeed>=0?this.currentTime>=U:this.currentTime<=0);const Se=this.holdTime===null&&(this.state==="finished"||this.state==="running"&&ve);return Se&&se!==inertia&&(ge.value=getFinalKeyframe$1(ie,this.options,ce,this.speed)),le&&le(ge.value),Se&&this.finish(),ge}then(w,D){return this.finished.then(w,D)}get duration(){return millisecondsToSeconds(this.calculatedDuration)}get iterationDuration(){const{delay:w=0}=this.options||{};return this.duration+millisecondsToSeconds(w)}get time(){return millisecondsToSeconds(this.currentTime)}set time(w){w=secondsToMilliseconds(w),this.currentTime=w,this.startTime===null||this.holdTime!==null||this.playbackSpeed===0?this.holdTime=w:this.driver&&(this.startTime=this.driver.now()-w/this.playbackSpeed),this.driver?.start(!1)}get speed(){return this.playbackSpeed}set speed(w){this.updateTime(time.now());const D=this.playbackSpeed!==w;this.playbackSpeed=w,D&&(this.time=millisecondsToSeconds(this.currentTime))}play(){if(this.isStopped)return;const{driver:w=frameloopDriver,startTime:D}=this.options;this.driver||(this.driver=w(U=>this.tick(U))),this.options.onPlay?.();const O=this.driver.now();this.state==="finished"?(this.updateFinished(),this.startTime=O):this.holdTime!==null?this.startTime=O-this.holdTime:this.startTime||(this.startTime=D??O),this.state==="finished"&&this.speed<0&&(this.startTime+=this.calculatedDuration),this.holdTime=null,this.state="running",this.driver.start()}pause(){this.state="paused",this.updateTime(time.now()),this.holdTime=this.currentTime}complete(){this.state!=="running"&&this.play(),this.state="finished",this.holdTime=null}finish(){this.notifyFinished(),this.teardown(),this.state="finished",this.options.onComplete?.()}cancel(){this.holdTime=null,this.startTime=0,this.tick(0),this.teardown(),this.options.onCancel?.()}teardown(){this.state="idle",this.stopDriver(),this.startTime=this.holdTime=null}stopDriver(){this.driver&&(this.driver.stop(),this.driver=void 0)}sample(w){return this.startTime=0,this.tick(w,!0)}attachTimeline(w){return this.options.allowFlatten&&(this.options.type="keyframes",this.options.ease="linear",this.initAnimation()),this.driver?.stop(),w.observe(this)}}function fillWildcards(F){for(let w=1;w<F.length;w++)F[w]??(F[w]=F[w-1])}const radToDeg=F=>F*180/Math.PI,rotate=F=>{const w=radToDeg(Math.atan2(F[1],F[0]));return rebaseAngle(w)},matrix2dParsers={x:4,y:5,translateX:4,translateY:5,scaleX:0,scaleY:3,scale:F=>(Math.abs(F[0])+Math.abs(F[3]))/2,rotate,rotateZ:rotate,skewX:F=>radToDeg(Math.atan(F[1])),skewY:F=>radToDeg(Math.atan(F[2])),skew:F=>(Math.abs(F[1])+Math.abs(F[2]))/2},rebaseAngle=F=>(F=F%360,F<0&&(F+=360),F),rotateZ=rotate,scaleX=F=>Math.sqrt(F[0]*F[0]+F[1]*F[1]),scaleY=F=>Math.sqrt(F[4]*F[4]+F[5]*F[5]),matrix3dParsers={x:12,y:13,z:14,translateX:12,translateY:13,translateZ:14,scaleX,scaleY,scale:F=>(scaleX(F)+scaleY(F))/2,rotateX:F=>rebaseAngle(radToDeg(Math.atan2(F[6],F[5]))),rotateY:F=>rebaseAngle(radToDeg(Math.atan2(-F[2],F[0]))),rotateZ,rotate:rotateZ,skewX:F=>radToDeg(Math.atan(F[4])),skewY:F=>radToDeg(Math.atan(F[1])),skew:F=>(Math.abs(F[1])+Math.abs(F[4]))/2};function defaultTransformValue(F){return F.includes("scale")?1:0}function parseValueFromTransform(F,w){if(!F||F==="none")return defaultTransformValue(w);const D=F.match(/^matrix3d\(([-\d.e\s,]+)\)$/u);let O,U;if(D)O=matrix3dParsers,U=D;else{const K=F.match(/^matrix\(([-\d.e\s,]+)\)$/u);O=matrix2dParsers,U=K}if(!U)return defaultTransformValue(w);const G=O[w],q=U[1].split(",").map(convertTransformToNumber);return typeof G=="function"?G(q):q[G]}const readTransformValue=(F,w)=>{const{transform:D="none"}=getComputedStyle(F);return parseValueFromTransform(D,w)};function convertTransformToNumber(F){return parseFloat(F.trim())}const transformPropOrder=["transformPerspective","x","y","z","translateX","translateY","translateZ","scale","scaleX","scaleY","rotate","rotateX","rotateY","rotateZ","skew","skewX","skewY"],transformProps=new Set(transformPropOrder),isNumOrPxType=F=>F===number||F===px,transformKeys=new Set(["x","y","z"]),nonTranslationalTransformKeys=transformPropOrder.filter(F=>!transformKeys.has(F));function removeNonTranslationalTransform(F){const w=[];return nonTranslationalTransformKeys.forEach(D=>{const O=F.getValue(D);O!==void 0&&(w.push([D,O.get()]),O.set(D.startsWith("scale")?1:0))}),w}const positionalValues={width:({x:F},{paddingLeft:w="0",paddingRight:D="0"})=>F.max-F.min-parseFloat(w)-parseFloat(D),height:({y:F},{paddingTop:w="0",paddingBottom:D="0"})=>F.max-F.min-parseFloat(w)-parseFloat(D),top:(F,{top:w})=>parseFloat(w),left:(F,{left:w})=>parseFloat(w),bottom:({y:F},{top:w})=>parseFloat(w)+(F.max-F.min),right:({x:F},{left:w})=>parseFloat(w)+(F.max-F.min),x:(F,{transform:w})=>parseValueFromTransform(w,"x"),y:(F,{transform:w})=>parseValueFromTransform(w,"y")};positionalValues.translateX=positionalValues.x;positionalValues.translateY=positionalValues.y;const toResolve=new Set;let isScheduled=!1,anyNeedsMeasurement=!1,isForced=!1;function measureAllKeyframes(){if(anyNeedsMeasurement){const F=Array.from(toResolve).filter(O=>O.needsMeasurement),w=new Set(F.map(O=>O.element)),D=new Map;w.forEach(O=>{const U=removeNonTranslationalTransform(O);U.length&&(D.set(O,U),O.render())}),F.forEach(O=>O.measureInitialState()),w.forEach(O=>{O.render();const U=D.get(O);U&&U.forEach(([G,q])=>{O.getValue(G)?.set(q)})}),F.forEach(O=>O.measureEndState()),F.forEach(O=>{O.suspendedScrollY!==void 0&&window.scrollTo(0,O.suspendedScrollY)})}anyNeedsMeasurement=!1,isScheduled=!1,toResolve.forEach(F=>F.complete(isForced)),toResolve.clear()}function readAllKeyframes(){toResolve.forEach(F=>{F.readKeyframes(),F.needsMeasurement&&(anyNeedsMeasurement=!0)})}function flushKeyframeResolvers(){isForced=!0,readAllKeyframes(),measureAllKeyframes(),isForced=!1}class KeyframeResolver{constructor(w,D,O,U,G,q=!1){this.state="pending",this.isAsync=!1,this.needsMeasurement=!1,this.unresolvedKeyframes=[...w],this.onComplete=D,this.name=O,this.motionValue=U,this.element=G,this.isAsync=q}scheduleResolve(){this.state="scheduled",this.isAsync?(toResolve.add(this),isScheduled||(isScheduled=!0,frame.read(readAllKeyframes),frame.resolveKeyframes(measureAllKeyframes))):(this.readKeyframes(),this.complete())}readKeyframes(){const{unresolvedKeyframes:w,name:D,element:O,motionValue:U}=this;if(w[0]===null){const G=U?.get(),q=w[w.length-1];if(G!==void 0)w[0]=G;else if(O&&D){const K=O.readValue(D,q);K!=null&&(w[0]=K)}w[0]===void 0&&(w[0]=q),U&&G===void 0&&U.set(w[0])}fillWildcards(w)}setFinalKeyframe(){}measureInitialState(){}renderEndStyles(){}measureEndState(){}complete(w=!1){this.state="complete",this.onComplete(this.unresolvedKeyframes,this.finalKeyframe,w),toResolve.delete(this)}cancel(){this.state==="scheduled"&&(toResolve.delete(this),this.state="pending")}resume(){this.state==="pending"&&this.scheduleResolve()}}const isCSSVar=F=>F.startsWith("--");function setStyle(F,w,D){isCSSVar(w)?F.style.setProperty(w,D):F.style[w]=D}const supportsScrollTimeline=memo(()=>window.ScrollTimeline!==void 0),supportsFlags={};function memoSupports(F,w){const D=memo(F);return()=>supportsFlags[w]??D()}const supportsLinearEasing=memoSupports(()=>{try{document.createElement("div").animate({opacity:0},{easing:"linear(0, 1)"})}catch{return!1}return!0},"linearEasing"),cubicBezierAsString=([F,w,D,O])=>`cubic-bezier(${F}, ${w}, ${D}, ${O})`,supportedWaapiEasing={linear:"linear",ease:"ease",easeIn:"ease-in",easeOut:"ease-out",easeInOut:"ease-in-out",circIn:cubicBezierAsString([0,.65,.55,1]),circOut:cubicBezierAsString([.55,0,1,.45]),backIn:cubicBezierAsString([.31,.01,.66,-.59]),backOut:cubicBezierAsString([.33,1.53,.69,.99])};function mapEasingToNativeEasing(F,w){if(F)return typeof F=="function"?supportsLinearEasing()?generateLinearEasing(F,w):"ease-out":isBezierDefinition(F)?cubicBezierAsString(F):Array.isArray(F)?F.map(D=>mapEasingToNativeEasing(D,w)||supportedWaapiEasing.easeOut):supportedWaapiEasing[F]}function startWaapiAnimation(F,w,D,{delay:O=0,duration:U=300,repeat:G=0,repeatType:q="loop",ease:K="easeOut",times:ee}={},Z=void 0){const ie={[w]:D};ee&&(ie.offset=ee);const Y=mapEasingToNativeEasing(K,U);Array.isArray(Y)&&(ie.easing=Y);const W={delay:O,duration:U,easing:Array.isArray(Y)?"linear":Y,fill:"both",iterations:G+1,direction:q==="reverse"?"alternate":"normal"};return Z&&(W.pseudoElement=Z),F.animate(ie,W)}function isGenerator(F){return typeof F=="function"&&"applyToOptions"in F}function applyGeneratorOptions({type:F,...w}){return isGenerator(F)&&supportsLinearEasing()?F.applyToOptions(w):(w.duration??(w.duration=300),w.ease??(w.ease="easeOut"),w)}class NativeAnimation extends WithPromise{constructor(w){if(super(),this.finishedTime=null,this.isStopped=!1,!w)return;const{element:D,name:O,keyframes:U,pseudoElement:G,allowFlatten:q=!1,finalKeyframe:K,onComplete:ee}=w;this.isPseudoElement=!!G,this.allowFlatten=q,this.options=w,invariant(typeof w.type!="string");const Z=applyGeneratorOptions(w);this.animation=startWaapiAnimation(D,O,U,Z,G),Z.autoplay===!1&&this.animation.pause(),this.animation.onfinish=()=>{if(this.finishedTime=this.time,!G){const ie=getFinalKeyframe$1(U,this.options,K,this.speed);this.updateMotionValue?this.updateMotionValue(ie):setStyle(D,O,ie),this.animation.cancel()}ee?.(),this.notifyFinished()}}play(){this.isStopped||(this.animation.play(),this.state==="finished"&&this.updateFinished())}pause(){this.animation.pause()}complete(){this.animation.finish?.()}cancel(){try{this.animation.cancel()}catch{}}stop(){if(this.isStopped)return;this.isStopped=!0;const{state:w}=this;w==="idle"||w==="finished"||(this.updateMotionValue?this.updateMotionValue():this.commitStyles(),this.isPseudoElement||this.cancel())}commitStyles(){this.isPseudoElement||this.animation.commitStyles?.()}get duration(){const w=this.animation.effect?.getComputedTiming?.().duration||0;return millisecondsToSeconds(Number(w))}get iterationDuration(){const{delay:w=0}=this.options||{};return this.duration+millisecondsToSeconds(w)}get time(){return millisecondsToSeconds(Number(this.animation.currentTime)||0)}set time(w){this.finishedTime=null,this.animation.currentTime=secondsToMilliseconds(w)}get speed(){return this.animation.playbackRate}set speed(w){w<0&&(this.finishedTime=null),this.animation.playbackRate=w}get state(){return this.finishedTime!==null?"finished":this.animation.playState}get startTime(){return Number(this.animation.startTime)}set startTime(w){this.animation.startTime=w}attachTimeline({timeline:w,observe:D}){return this.allowFlatten&&this.animation.effect?.updateTiming({easing:"linear"}),this.animation.onfinish=null,w&&supportsScrollTimeline()?(this.animation.timeline=w,noop):D(this)}}const unsupportedEasingFunctions={anticipate,backInOut,circInOut};function isUnsupportedEase(F){return F in unsupportedEasingFunctions}function replaceStringEasing(F){typeof F.ease=="string"&&isUnsupportedEase(F.ease)&&(F.ease=unsupportedEasingFunctions[F.ease])}const sampleDelta=10;class NativeAnimationExtended extends NativeAnimation{constructor(w){replaceStringEasing(w),replaceTransitionType(w),super(w),w.startTime&&(this.startTime=w.startTime),this.options=w}updateMotionValue(w){const{motionValue:D,onUpdate:O,onComplete:U,element:G,...q}=this.options;if(!D)return;if(w!==void 0){D.set(w);return}const K=new JSAnimation({...q,autoplay:!1}),ee=secondsToMilliseconds(this.finishedTime??this.time);D.setWithVelocity(K.sample(ee-sampleDelta).value,K.sample(ee).value,sampleDelta),K.stop()}}const isAnimatable=(F,w)=>w==="zIndex"?!1:!!(typeof F=="number"||Array.isArray(F)||typeof F=="string"&&(complex.test(F)||F==="0")&&!F.startsWith("url("));function hasKeyframesChanged(F){const w=F[0];if(F.length===1)return!0;for(let D=0;D<F.length;D++)if(F[D]!==w)return!0}function canAnimate(F,w,D,O){const U=F[0];if(U===null)return!1;if(w==="display"||w==="visibility")return!0;const G=F[F.length-1],q=isAnimatable(U,w),K=isAnimatable(G,w);return!q||!K?!1:hasKeyframesChanged(F)||(D==="spring"||isGenerator(D))&&O}function makeAnimationInstant(F){F.duration=0,F.type="keyframes"}const acceleratedValues=new Set(["opacity","clipPath","filter","transform"]),supportsWaapi=memo(()=>Object.hasOwnProperty.call(Element.prototype,"animate"));function supportsBrowserAnimation(F){const{motionValue:w,name:D,repeatDelay:O,repeatType:U,damping:G,type:q}=F;if(!(w?.owner?.current instanceof HTMLElement))return!1;const{onUpdate:ee,transformTemplate:Z}=w.owner.getProps();return supportsWaapi()&&D&&acceleratedValues.has(D)&&(D!=="transform"||!Z)&&!ee&&!O&&U!=="mirror"&&G!==0&&q!=="inertia"}const MAX_RESOLVE_DELAY=40;class AsyncMotionValueAnimation extends WithPromise{constructor({autoplay:w=!0,delay:D=0,type:O="keyframes",repeat:U=0,repeatDelay:G=0,repeatType:q="loop",keyframes:K,name:ee,motionValue:Z,element:ie,...Y}){super(),this.stop=()=>{this._animation&&(this._animation.stop(),this.stopTimeline?.()),this.keyframeResolver?.cancel()},this.createdAt=time.now();const W={autoplay:w,delay:D,type:O,repeat:U,repeatDelay:G,repeatType:q,name:ee,motionValue:Z,element:ie,...Y},ne=ie?.KeyframeResolver||KeyframeResolver;this.keyframeResolver=new ne(K,(se,le,ce)=>this.onKeyframesResolved(se,le,W,!ce),ee,Z,ie),this.keyframeResolver?.scheduleResolve()}onKeyframesResolved(w,D,O,U){this.keyframeResolver=void 0;const{name:G,type:q,velocity:K,delay:ee,isHandoff:Z,onUpdate:ie}=O;this.resolvedAt=time.now(),canAnimate(w,G,q,K)||((MotionGlobalConfig.instantAnimations||!ee)&&ie?.(getFinalKeyframe$1(w,O,D)),w[0]=w[w.length-1],makeAnimationInstant(O),O.repeat=0);const W={startTime:U?this.resolvedAt?this.resolvedAt-this.createdAt>MAX_RESOLVE_DELAY?this.resolvedAt:this.createdAt:this.createdAt:void 0,finalKeyframe:D,...O,keyframes:w},ne=!Z&&supportsBrowserAnimation(W)?new NativeAnimationExtended({...W,element:W.motionValue.owner.current}):new JSAnimation(W);ne.finished.then(()=>this.notifyFinished()).catch(noop),this.pendingTimeline&&(this.stopTimeline=ne.attachTimeline(this.pendingTimeline),this.pendingTimeline=void 0),this._animation=ne}get finished(){return this._animation?this.animation.finished:this._finished}then(w,D){return this.finished.finally(w).then(()=>{})}get animation(){return this._animation||(this.keyframeResolver?.resume(),flushKeyframeResolvers()),this._animation}get duration(){return this.animation.duration}get iterationDuration(){return this.animation.iterationDuration}get time(){return this.animation.time}set time(w){this.animation.time=w}get speed(){return this.animation.speed}get state(){return this.animation.state}set speed(w){this.animation.speed=w}get startTime(){return this.animation.startTime}attachTimeline(w){return this._animation?this.stopTimeline=this.animation.attachTimeline(w):this.pendingTimeline=w,()=>this.stop()}play(){this.animation.play()}pause(){this.animation.pause()}complete(){this.animation.complete()}cancel(){this._animation&&this.animation.cancel(),this.keyframeResolver?.cancel()}}const splitCSSVariableRegex=/^var\(--(?:([\w-]+)|([\w-]+), ?([a-zA-Z\d ()%#.,-]+))\)/u;function parseCSSVariable(F){const w=splitCSSVariableRegex.exec(F);if(!w)return[,];const[,D,O,U]=w;return[`--${D??O}`,U]}function getVariableValue(F,w,D=1){const[O,U]=parseCSSVariable(F);if(!O)return;const G=window.getComputedStyle(w).getPropertyValue(O);if(G){const q=G.trim();return isNumericalString(q)?parseFloat(q):q}return isCSSVariableToken(U)?getVariableValue(U,w,D+1):U}function getValueTransition(F,w){return F?.[w]??F?.default??F}const positionalKeys=new Set(["width","height","top","left","right","bottom",...transformPropOrder]),auto={test:F=>F==="auto",parse:F=>F},testValueType=F=>w=>w.test(F),dimensionValueTypes=[number,px,percent,degrees,vw,vh,auto],findDimensionValueType=F=>dimensionValueTypes.find(testValueType(F));function isNone(F){return typeof F=="number"?F===0:F!==null?F==="none"||F==="0"||isZeroValueString(F):!0}const maxDefaults=new Set(["brightness","contrast","saturate","opacity"]);function applyDefaultFilter(F){const[w,D]=F.slice(0,-1).split("(");if(w==="drop-shadow")return F;const[O]=D.match(floatRegex)||[];if(!O)return F;const U=D.replace(O,"");let G=maxDefaults.has(w)?1:0;return O!==D&&(G*=100),w+"("+G+U+")"}const functionRegex=/\b([a-z-]*)\(.*?\)/gu,filter={...complex,getAnimatableNone:F=>{const w=F.match(functionRegex);return w?w.map(applyDefaultFilter).join(" "):F}},int={...number,transform:Math.round},transformValueTypes={rotate:degrees,rotateX:degrees,rotateY:degrees,rotateZ:degrees,scale,scaleX:scale,scaleY:scale,scaleZ:scale,skew:degrees,skewX:degrees,skewY:degrees,distance:px,translateX:px,translateY:px,translateZ:px,x:px,y:px,z:px,perspective:px,transformPerspective:px,opacity:alpha,originX:progressPercentage,originY:progressPercentage,originZ:px},numberValueTypes={borderWidth:px,borderTopWidth:px,borderRightWidth:px,borderBottomWidth:px,borderLeftWidth:px,borderRadius:px,radius:px,borderTopLeftRadius:px,borderTopRightRadius:px,borderBottomRightRadius:px,borderBottomLeftRadius:px,width:px,maxWidth:px,height:px,maxHeight:px,top:px,right:px,bottom:px,left:px,padding:px,paddingTop:px,paddingRight:px,paddingBottom:px,paddingLeft:px,margin:px,marginTop:px,marginRight:px,marginBottom:px,marginLeft:px,backgroundPositionX:px,backgroundPositionY:px,...transformValueTypes,zIndex:int,fillOpacity:alpha,strokeOpacity:alpha,numOctaves:int},defaultValueTypes={...numberValueTypes,color,backgroundColor:color,outlineColor:color,fill:color,stroke:color,borderColor:color,borderTopColor:color,borderRightColor:color,borderBottomColor:color,borderLeftColor:color,filter,WebkitFilter:filter},getDefaultValueType=F=>defaultValueTypes[F];function getAnimatableNone(F,w){let D=getDefaultValueType(F);return D!==filter&&(D=complex),D.getAnimatableNone?D.getAnimatableNone(w):void 0}const invalidTemplates=new Set(["auto","none","0"]);function makeNoneKeyframesAnimatable(F,w,D){let O=0,U;for(;O<F.length&&!U;){const G=F[O];typeof G=="string"&&!invalidTemplates.has(G)&&analyseComplexValue(G).values.length&&(U=F[O]),O++}if(U&&D)for(const G of w)F[G]=getAnimatableNone(D,U)}class DOMKeyframesResolver extends KeyframeResolver{constructor(w,D,O,U,G){super(w,D,O,U,G,!0)}readKeyframes(){const{unresolvedKeyframes:w,element:D,name:O}=this;if(!D||!D.current)return;super.readKeyframes();for(let ee=0;ee<w.length;ee++){let Z=w[ee];if(typeof Z=="string"&&(Z=Z.trim(),isCSSVariableToken(Z))){const ie=getVariableValue(Z,D.current);ie!==void 0&&(w[ee]=ie),ee===w.length-1&&(this.finalKeyframe=Z)}}if(this.resolveNoneKeyframes(),!positionalKeys.has(O)||w.length!==2)return;const[U,G]=w,q=findDimensionValueType(U),K=findDimensionValueType(G);if(q!==K)if(isNumOrPxType(q)&&isNumOrPxType(K))for(let ee=0;ee<w.length;ee++){const Z=w[ee];typeof Z=="string"&&(w[ee]=parseFloat(Z))}else positionalValues[O]&&(this.needsMeasurement=!0)}resolveNoneKeyframes(){const{unresolvedKeyframes:w,name:D}=this,O=[];for(let U=0;U<w.length;U++)(w[U]===null||isNone(w[U]))&&O.push(U);O.length&&makeNoneKeyframesAnimatable(w,O,D)}measureInitialState(){const{element:w,unresolvedKeyframes:D,name:O}=this;if(!w||!w.current)return;O==="height"&&(this.suspendedScrollY=window.pageYOffset),this.measuredOrigin=positionalValues[O](w.measureViewportBox(),window.getComputedStyle(w.current)),D[0]=this.measuredOrigin;const U=D[D.length-1];U!==void 0&&w.getValue(O,U).jump(U,!1)}measureEndState(){const{element:w,name:D,unresolvedKeyframes:O}=this;if(!w||!w.current)return;const U=w.getValue(D);U&&U.jump(this.measuredOrigin,!1);const G=O.length-1,q=O[G];O[G]=positionalValues[D](w.measureViewportBox(),window.getComputedStyle(w.current)),q!==null&&this.finalKeyframe===void 0&&(this.finalKeyframe=q),this.removedTransforms?.length&&this.removedTransforms.forEach(([K,ee])=>{w.getValue(K).set(ee)}),this.resolveNoneKeyframes()}}function resolveElements(F,w,D){if(F instanceof EventTarget)return[F];if(typeof F=="string"){let O=document;const U=D?.[F]??O.querySelectorAll(F);return U?Array.from(U):[]}return Array.from(F)}const getValueAsType=(F,w)=>w&&typeof F=="number"?w.transform(F):F;function isHTMLElement(F){return isObject(F)&&"offsetHeight"in F}const MAX_VELOCITY_DELTA=30,isFloat=F=>!isNaN(parseFloat(F));class MotionValue{constructor(w,D={}){this.canTrackVelocity=null,this.events={},this.updateAndNotify=O=>{const U=time.now();if(this.updatedAt!==U&&this.setPrevFrameValue(),this.prev=this.current,this.setCurrent(O),this.current!==this.prev&&(this.events.change?.notify(this.current),this.dependents))for(const G of this.dependents)G.dirty()},this.hasAnimated=!1,this.setCurrent(w),this.owner=D.owner}setCurrent(w){this.current=w,this.updatedAt=time.now(),this.canTrackVelocity===null&&w!==void 0&&(this.canTrackVelocity=isFloat(this.current))}setPrevFrameValue(w=this.current){this.prevFrameValue=w,this.prevUpdatedAt=this.updatedAt}onChange(w){return this.on("change",w)}on(w,D){this.events[w]||(this.events[w]=new SubscriptionManager);const O=this.events[w].add(D);return w==="change"?()=>{O(),frame.read(()=>{this.events.change.getSize()||this.stop()})}:O}clearListeners(){for(const w in this.events)this.events[w].clear()}attach(w,D){this.passiveEffect=w,this.stopPassiveEffect=D}set(w){this.passiveEffect?this.passiveEffect(w,this.updateAndNotify):this.updateAndNotify(w)}setWithVelocity(w,D,O){this.set(D),this.prev=void 0,this.prevFrameValue=w,this.prevUpdatedAt=this.updatedAt-O}jump(w,D=!0){this.updateAndNotify(w),this.prev=w,this.prevUpdatedAt=this.prevFrameValue=void 0,D&&this.stop(),this.stopPassiveEffect&&this.stopPassiveEffect()}dirty(){this.events.change?.notify(this.current)}addDependent(w){this.dependents||(this.dependents=new Set),this.dependents.add(w)}removeDependent(w){this.dependents&&this.dependents.delete(w)}get(){return this.current}getPrevious(){return this.prev}getVelocity(){const w=time.now();if(!this.canTrackVelocity||this.prevFrameValue===void 0||w-this.updatedAt>MAX_VELOCITY_DELTA)return 0;const D=Math.min(this.updatedAt-this.prevUpdatedAt,MAX_VELOCITY_DELTA);return velocityPerSecond(parseFloat(this.current)-parseFloat(this.prevFrameValue),D)}start(w){return this.stop(),new Promise(D=>{this.hasAnimated=!0,this.animation=w(D),this.events.animationStart&&this.events.animationStart.notify()}).then(()=>{this.events.animationComplete&&this.events.animationComplete.notify(),this.clearAnimation()})}stop(){this.animation&&(this.animation.stop(),this.events.animationCancel&&this.events.animationCancel.notify()),this.clearAnimation()}isAnimating(){return!!this.animation}clearAnimation(){delete this.animation}destroy(){this.dependents?.clear(),this.events.destroy?.notify(),this.clearListeners(),this.stop(),this.stopPassiveEffect&&this.stopPassiveEffect()}}function motionValue(F,w){return new MotionValue(F,w)}const{schedule:microtask}=createRenderBatcher(queueMicrotask,!1),isDragging={x:!1,y:!1};function isDragActive(){return isDragging.x||isDragging.y}function setDragLock(F){return F==="x"||F==="y"?isDragging[F]?null:(isDragging[F]=!0,()=>{isDragging[F]=!1}):isDragging.x||isDragging.y?null:(isDragging.x=isDragging.y=!0,()=>{isDragging.x=isDragging.y=!1})}function setupGesture(F,w){const D=resolveElements(F),O=new AbortController,U={passive:!0,...w,signal:O.signal};return[D,U,()=>O.abort()]}function isValidHover(F){return!(F.pointerType==="touch"||isDragActive())}function hover(F,w,D={}){const[O,U,G]=setupGesture(F,D),q=K=>{if(!isValidHover(K))return;const{target:ee}=K,Z=w(ee,K);if(typeof Z!="function"||!ee)return;const ie=Y=>{isValidHover(Y)&&(Z(Y),ee.removeEventListener("pointerleave",ie))};ee.addEventListener("pointerleave",ie,U)};return O.forEach(K=>{K.addEventListener("pointerenter",q,U)}),G}const isNodeOrChild=(F,w)=>w?F===w?!0:isNodeOrChild(F,w.parentElement):!1,isPrimaryPointer=F=>F.pointerType==="mouse"?typeof F.button!="number"||F.button<=0:F.isPrimary!==!1,focusableElements=new Set(["BUTTON","INPUT","SELECT","TEXTAREA","A"]);function isElementKeyboardAccessible(F){return focusableElements.has(F.tagName)||F.tabIndex!==-1}const isPressing=new WeakSet;function filterEvents(F){return w=>{w.key==="Enter"&&F(w)}}function firePointerEvent(F,w){F.dispatchEvent(new PointerEvent("pointer"+w,{isPrimary:!0,bubbles:!0}))}const enableKeyboardPress=(F,w)=>{const D=F.currentTarget;if(!D)return;const O=filterEvents(()=>{if(isPressing.has(D))return;firePointerEvent(D,"down");const U=filterEvents(()=>{firePointerEvent(D,"up")}),G=()=>firePointerEvent(D,"cancel");D.addEventListener("keyup",U,w),D.addEventListener("blur",G,w)});D.addEventListener("keydown",O,w),D.addEventListener("blur",()=>D.removeEventListener("keydown",O),w)};function isValidPressEvent(F){return isPrimaryPointer(F)&&!isDragActive()}function press(F,w,D={}){const[O,U,G]=setupGesture(F,D),q=K=>{const ee=K.currentTarget;if(!isValidPressEvent(K))return;isPressing.add(ee);const Z=w(ee,K),ie=(ne,se)=>{window.removeEventListener("pointerup",Y),window.removeEventListener("pointercancel",W),isPressing.has(ee)&&isPressing.delete(ee),isValidPressEvent(ne)&&typeof Z=="function"&&Z(ne,{success:se})},Y=ne=>{ie(ne,ee===window||ee===document||D.useGlobalTarget||isNodeOrChild(ee,ne.target))},W=ne=>{ie(ne,!1)};window.addEventListener("pointerup",Y,U),window.addEventListener("pointercancel",W,U)};return O.forEach(K=>{(D.useGlobalTarget?window:K).addEventListener("pointerdown",q,U),isHTMLElement(K)&&(K.addEventListener("focus",Z=>enableKeyboardPress(Z,U)),!isElementKeyboardAccessible(K)&&!K.hasAttribute("tabindex")&&(K.tabIndex=0))}),G}function isSVGElement(F){return isObject(F)&&"ownerSVGElement"in F}function isSVGSVGElement(F){return isSVGElement(F)&&F.tagName==="svg"}const isMotionValue=F=>!!(F&&F.getVelocity),valueTypes=[...dimensionValueTypes,color,complex],findValueType=F=>valueTypes.find(testValueType(F)),MotionConfigContext=reactExports.createContext({transformPagePoint:F=>F,isStatic:!1,reducedMotion:"never"});function setRef(F,w){if(typeof F=="function")return F(w);F!=null&&(F.current=w)}function composeRefs(...F){return w=>{let D=!1;const O=F.map(U=>{const G=setRef(U,w);return!D&&typeof G=="function"&&(D=!0),G});if(D)return()=>{for(let U=0;U<O.length;U++){const G=O[U];typeof G=="function"?G():setRef(F[U],null)}}}}function useComposedRefs(...F){return reactExports.useCallback(composeRefs(...F),F)}class PopChildMeasure extends reactExports.Component{getSnapshotBeforeUpdate(w){const D=this.props.childRef.current;if(D&&w.isPresent&&!this.props.isPresent){const O=D.offsetParent,U=isHTMLElement(O)&&O.offsetWidth||0,G=this.props.sizeRef.current;G.height=D.offsetHeight||0,G.width=D.offsetWidth||0,G.top=D.offsetTop,G.left=D.offsetLeft,G.right=U-G.width-G.left}return null}componentDidUpdate(){}render(){return this.props.children}}function PopChild({children:F,isPresent:w,anchorX:D,root:O}){const U=reactExports.useId(),G=reactExports.useRef(null),q=reactExports.useRef({width:0,height:0,top:0,left:0,right:0}),{nonce:K}=reactExports.useContext(MotionConfigContext),ee=useComposedRefs(G,F?.ref);return reactExports.useInsertionEffect(()=>{const{width:Z,height:ie,top:Y,left:W,right:ne}=q.current;if(w||!G.current||!Z||!ie)return;const se=D==="left"?`left: ${W}`:`right: ${ne}`;G.current.dataset.motionPopId=U;const le=document.createElement("style");K&&(le.nonce=K);const ce=O??document.head;return ce.appendChild(le),le.sheet&&le.sheet.insertRule(`
          [data-motion-pop-id="${U}"] {
            position: absolute !important;
            width: ${Z}px !important;
            height: ${ie}px !important;
            ${se}px !important;
            top: ${Y}px !important;
          }
        `),()=>{ce.contains(le)&&ce.removeChild(le)}},[w]),jsxRuntimeExports.jsx(PopChildMeasure,{isPresent:w,childRef:G,sizeRef:q,children:reactExports.cloneElement(F,{ref:ee})})}const PresenceChild=({children:F,initial:w,isPresent:D,onExitComplete:O,custom:U,presenceAffectsLayout:G,mode:q,anchorX:K,root:ee})=>{const Z=useConstant(newChildrenMap),ie=reactExports.useId();let Y=!0,W=reactExports.useMemo(()=>(Y=!1,{id:ie,initial:w,isPresent:D,custom:U,onExitComplete:ne=>{Z.set(ne,!0);for(const se of Z.values())if(!se)return;O&&O()},register:ne=>(Z.set(ne,!1),()=>Z.delete(ne))}),[D,Z,O]);return G&&Y&&(W={...W}),reactExports.useMemo(()=>{Z.forEach((ne,se)=>Z.set(se,!1))},[D]),reactExports.useEffect(()=>{!D&&!Z.size&&O&&O()},[D]),q==="popLayout"&&(F=jsxRuntimeExports.jsx(PopChild,{isPresent:D,anchorX:K,root:ee,children:F})),jsxRuntimeExports.jsx(PresenceContext.Provider,{value:W,children:F})};function newChildrenMap(){return new Map}function usePresence(F=!0){const w=reactExports.useContext(PresenceContext);if(w===null)return[!0,null];const{isPresent:D,onExitComplete:O,register:U}=w,G=reactExports.useId();reactExports.useEffect(()=>{if(F)return U(G)},[F]);const q=reactExports.useCallback(()=>F&&O&&O(G),[G,O,F]);return!D&&O?[!1,q]:[!0]}const getChildKey=F=>F.key||"";function onlyElements(F){const w=[];return reactExports.Children.forEach(F,D=>{reactExports.isValidElement(D)&&w.push(D)}),w}const AnimatePresence=({children:F,custom:w,initial:D=!0,onExitComplete:O,presenceAffectsLayout:U=!0,mode:G="sync",propagate:q=!1,anchorX:K="left",root:ee})=>{const[Z,ie]=usePresence(q),Y=reactExports.useMemo(()=>onlyElements(F),[F]),W=q&&!Z?[]:Y.map(getChildKey),ne=reactExports.useRef(!0),se=reactExports.useRef(Y),le=useConstant(()=>new Map),[ce,he]=reactExports.useState(Y),[pe,me]=reactExports.useState(Y);useIsomorphicLayoutEffect(()=>{ne.current=!1,se.current=Y;for(let ve=0;ve<pe.length;ve++){const Se=getChildKey(pe[ve]);W.includes(Se)?le.delete(Se):le.get(Se)!==!0&&le.set(Se,!1)}},[pe,W.length,W.join("-")]);const be=[];if(Y!==ce){let ve=[...Y];for(let Se=0;Se<pe.length;Se++){const Me=pe[Se],Ee=getChildKey(Me);W.includes(Ee)||(ve.splice(Se,0,Me),be.push(Me))}return G==="wait"&&be.length&&(ve=be),me(onlyElements(ve)),he(Y),null}const{forceRender:ge}=reactExports.useContext(LayoutGroupContext);return jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment,{children:pe.map(ve=>{const Se=getChildKey(ve),Me=q&&!Z?!1:Y===pe||W.includes(Se),Ee=()=>{if(le.has(Se))le.set(Se,!0);else return;let we=!0;le.forEach(Re=>{Re||(we=!1)}),we&&(ge?.(),me(se.current),q&&ie?.(),O&&O())};return jsxRuntimeExports.jsx(PresenceChild,{isPresent:Me,initial:!ne.current||D?void 0:!1,custom:w,presenceAffectsLayout:U,mode:G,root:ee,onExitComplete:Me?void 0:Ee,anchorX:K,children:ve},Se)})})},LazyContext=reactExports.createContext({strict:!1}),featureProps={animation:["animate","variants","whileHover","whileTap","exit","whileInView","whileFocus","whileDrag"],exit:["exit"],drag:["drag","dragControls"],focus:["whileFocus"],hover:["whileHover","onHoverStart","onHoverEnd"],tap:["whileTap","onTap","onTapStart","onTapCancel"],pan:["onPan","onPanStart","onPanSessionStart","onPanEnd"],inView:["whileInView","onViewportEnter","onViewportLeave"],layout:["layout","layoutId"]},featureDefinitions={};for(const F in featureProps)featureDefinitions[F]={isEnabled:w=>featureProps[F].some(D=>!!w[D])};function loadFeatures(F){for(const w in F)featureDefinitions[w]={...featureDefinitions[w],...F[w]}}const validMotionProps=new Set(["animate","exit","variants","initial","style","values","variants","transition","transformTemplate","custom","inherit","onBeforeLayoutMeasure","onAnimationStart","onAnimationComplete","onUpdate","onDragStart","onDrag","onDragEnd","onMeasureDragConstraints","onDirectionLock","onDragTransitionEnd","_dragX","_dragY","onHoverStart","onHoverEnd","onViewportEnter","onViewportLeave","globalTapTarget","ignoreStrict","viewport"]);function isValidMotionProp(F){return F.startsWith("while")||F.startsWith("drag")&&F!=="draggable"||F.startsWith("layout")||F.startsWith("onTap")||F.startsWith("onPan")||F.startsWith("onLayout")||validMotionProps.has(F)}let shouldForward=F=>!isValidMotionProp(F);function loadExternalIsValidProp(F){typeof F=="function"&&(shouldForward=w=>w.startsWith("on")?!isValidMotionProp(w):F(w))}try{loadExternalIsValidProp(require("@emotion/is-prop-valid").default)}catch{}function filterProps(F,w,D){const O={};for(const U in F)U==="values"&&typeof F.values=="object"||(shouldForward(U)||D===!0&&isValidMotionProp(U)||!w&&!isValidMotionProp(U)||F.draggable&&U.startsWith("onDrag"))&&(O[U]=F[U]);return O}const MotionContext=reactExports.createContext({});function isAnimationControls(F){return F!==null&&typeof F=="object"&&typeof F.start=="function"}function isVariantLabel(F){return typeof F=="string"||Array.isArray(F)}const variantPriorityOrder=["animate","whileInView","whileFocus","whileHover","whileTap","whileDrag","exit"],variantProps=["initial",...variantPriorityOrder];function isControllingVariants(F){return isAnimationControls(F.animate)||variantProps.some(w=>isVariantLabel(F[w]))}function isVariantNode(F){return!!(isControllingVariants(F)||F.variants)}function getCurrentTreeVariants(F,w){if(isControllingVariants(F)){const{initial:D,animate:O}=F;return{initial:D===!1||isVariantLabel(D)?D:void 0,animate:isVariantLabel(O)?O:void 0}}return F.inherit!==!1?w:{}}function useCreateMotionContext(F){const{initial:w,animate:D}=getCurrentTreeVariants(F,reactExports.useContext(MotionContext));return reactExports.useMemo(()=>({initial:w,animate:D}),[variantLabelsAsDependency(w),variantLabelsAsDependency(D)])}function variantLabelsAsDependency(F){return Array.isArray(F)?F.join(" "):F}const scaleCorrectors={};function addScaleCorrector(F){for(const w in F)scaleCorrectors[w]=F[w],isCSSVariableName(w)&&(scaleCorrectors[w].isCSSVariable=!0)}function isForcedMotionValue(F,{layout:w,layoutId:D}){return transformProps.has(F)||F.startsWith("origin")||(w||D!==void 0)&&(!!scaleCorrectors[F]||F==="opacity")}const translateAlias={x:"translateX",y:"translateY",z:"translateZ",transformPerspective:"perspective"},numTransforms=transformPropOrder.length;function buildTransform(F,w,D){let O="",U=!0;for(let G=0;G<numTransforms;G++){const q=transformPropOrder[G],K=F[q];if(K===void 0)continue;let ee=!0;if(typeof K=="number"?ee=K===(q.startsWith("scale")?1:0):ee=parseFloat(K)===0,!ee||D){const Z=getValueAsType(K,numberValueTypes[q]);if(!ee){U=!1;const ie=translateAlias[q]||q;O+=`${ie}(${Z}) `}D&&(w[q]=Z)}}return O=O.trim(),D?O=D(w,U?"":O):U&&(O="none"),O}function buildHTMLStyles(F,w,D){const{style:O,vars:U,transformOrigin:G}=F;let q=!1,K=!1;for(const ee in w){const Z=w[ee];if(transformProps.has(ee)){q=!0;continue}else if(isCSSVariableName(ee)){U[ee]=Z;continue}else{const ie=getValueAsType(Z,numberValueTypes[ee]);ee.startsWith("origin")?(K=!0,G[ee]=ie):O[ee]=ie}}if(w.transform||(q||D?O.transform=buildTransform(w,F.transform,D):O.transform&&(O.transform="none")),K){const{originX:ee="50%",originY:Z="50%",originZ:ie=0}=G;O.transformOrigin=`${ee} ${Z} ${ie}`}}const createHtmlRenderState=()=>({style:{},transform:{},transformOrigin:{},vars:{}});function copyRawValuesOnly(F,w,D){for(const O in w)!isMotionValue(w[O])&&!isForcedMotionValue(O,D)&&(F[O]=w[O])}function useInitialMotionValues({transformTemplate:F},w){return reactExports.useMemo(()=>{const D=createHtmlRenderState();return buildHTMLStyles(D,w,F),Object.assign({},D.vars,D.style)},[w])}function useStyle(F,w){const D=F.style||{},O={};return copyRawValuesOnly(O,D,F),Object.assign(O,useInitialMotionValues(F,w)),O}function useHTMLProps(F,w){const D={},O=useStyle(F,w);return F.drag&&F.dragListener!==!1&&(D.draggable=!1,O.userSelect=O.WebkitUserSelect=O.WebkitTouchCallout="none",O.touchAction=F.drag===!0?"none":`pan-${F.drag==="x"?"y":"x"}`),F.tabIndex===void 0&&(F.onTap||F.onTapStart||F.whileTap)&&(D.tabIndex=0),D.style=O,D}const dashKeys={offset:"stroke-dashoffset",array:"stroke-dasharray"},camelKeys={offset:"strokeDashoffset",array:"strokeDasharray"};function buildSVGPath(F,w,D=1,O=0,U=!0){F.pathLength=1;const G=U?dashKeys:camelKeys;F[G.offset]=px.transform(-O);const q=px.transform(w),K=px.transform(D);F[G.array]=`${q} ${K}`}function buildSVGAttrs(F,{attrX:w,attrY:D,attrScale:O,pathLength:U,pathSpacing:G=1,pathOffset:q=0,...K},ee,Z,ie){if(buildHTMLStyles(F,K,Z),ee){F.style.viewBox&&(F.attrs.viewBox=F.style.viewBox);return}F.attrs=F.style,F.style={};const{attrs:Y,style:W}=F;Y.transform&&(W.transform=Y.transform,delete Y.transform),(W.transform||Y.transformOrigin)&&(W.transformOrigin=Y.transformOrigin??"50% 50%",delete Y.transformOrigin),W.transform&&(W.transformBox=ie?.transformBox??"fill-box",delete Y.transformBox),w!==void 0&&(Y.x=w),D!==void 0&&(Y.y=D),O!==void 0&&(Y.scale=O),U!==void 0&&buildSVGPath(Y,U,G,q,!1)}const createSvgRenderState=()=>({...createHtmlRenderState(),attrs:{}}),isSVGTag=F=>typeof F=="string"&&F.toLowerCase()==="svg";function useSVGProps(F,w,D,O){const U=reactExports.useMemo(()=>{const G=createSvgRenderState();return buildSVGAttrs(G,w,isSVGTag(O),F.transformTemplate,F.style),{...G.attrs,style:{...G.style}}},[w]);if(F.style){const G={};copyRawValuesOnly(G,F.style,F),U.style={...G,...U.style}}return U}const lowercaseSVGElements=["animate","circle","defs","desc","ellipse","g","image","line","filter","marker","mask","metadata","path","pattern","polygon","polyline","rect","stop","switch","symbol","svg","text","tspan","use","view"];function isSVGComponent(F){return typeof F!="string"||F.includes("-")?!1:!!(lowercaseSVGElements.indexOf(F)>-1||/[A-Z]/u.test(F))}function useRender(F,w,D,{latestValues:O},U,G=!1){const K=(isSVGComponent(F)?useSVGProps:useHTMLProps)(w,O,U,F),ee=filterProps(w,typeof F=="string",G),Z=F!==reactExports.Fragment?{...ee,...K,ref:D}:{},{children:ie}=w,Y=reactExports.useMemo(()=>isMotionValue(ie)?ie.get():ie,[ie]);return reactExports.createElement(F,{...Z,children:Y})}function getValueState(F){const w=[{},{}];return F?.values.forEach((D,O)=>{w[0][O]=D.get(),w[1][O]=D.getVelocity()}),w}function resolveVariantFromProps(F,w,D,O){if(typeof w=="function"){const[U,G]=getValueState(O);w=w(D!==void 0?D:F.custom,U,G)}if(typeof w=="string"&&(w=F.variants&&F.variants[w]),typeof w=="function"){const[U,G]=getValueState(O);w=w(D!==void 0?D:F.custom,U,G)}return w}function resolveMotionValue(F){return isMotionValue(F)?F.get():F}function makeState({scrapeMotionValuesFromProps:F,createRenderState:w},D,O,U){return{latestValues:makeLatestValues(D,O,U,F),renderState:w()}}function makeLatestValues(F,w,D,O){const U={},G=O(F,{});for(const W in G)U[W]=resolveMotionValue(G[W]);let{initial:q,animate:K}=F;const ee=isControllingVariants(F),Z=isVariantNode(F);w&&Z&&!ee&&F.inherit!==!1&&(q===void 0&&(q=w.initial),K===void 0&&(K=w.animate));let ie=D?D.initial===!1:!1;ie=ie||q===!1;const Y=ie?K:q;if(Y&&typeof Y!="boolean"&&!isAnimationControls(Y)){const W=Array.isArray(Y)?Y:[Y];for(let ne=0;ne<W.length;ne++){const se=resolveVariantFromProps(F,W[ne]);if(se){const{transitionEnd:le,transition:ce,...he}=se;for(const pe in he){let me=he[pe];if(Array.isArray(me)){const be=ie?me.length-1:0;me=me[be]}me!==null&&(U[pe]=me)}for(const pe in le)U[pe]=le[pe]}}}return U}const makeUseVisualState=F=>(w,D)=>{const O=reactExports.useContext(MotionContext),U=reactExports.useContext(PresenceContext),G=()=>makeState(F,w,O,U);return D?G():useConstant(G)};function scrapeMotionValuesFromProps$1(F,w,D){const{style:O}=F,U={};for(const G in O)(isMotionValue(O[G])||w.style&&isMotionValue(w.style[G])||isForcedMotionValue(G,F)||D?.getValue(G)?.liveStyle!==void 0)&&(U[G]=O[G]);return U}const useHTMLVisualState=makeUseVisualState({scrapeMotionValuesFromProps:scrapeMotionValuesFromProps$1,createRenderState:createHtmlRenderState});function scrapeMotionValuesFromProps(F,w,D){const O=scrapeMotionValuesFromProps$1(F,w,D);for(const U in F)if(isMotionValue(F[U])||isMotionValue(w[U])){const G=transformPropOrder.indexOf(U)!==-1?"attr"+U.charAt(0).toUpperCase()+U.substring(1):U;O[G]=F[U]}return O}const useSVGVisualState=makeUseVisualState({scrapeMotionValuesFromProps,createRenderState:createSvgRenderState}),motionComponentSymbol=Symbol.for("motionComponentSymbol");function isRefObject(F){return F&&typeof F=="object"&&Object.prototype.hasOwnProperty.call(F,"current")}function useMotionRef(F,w,D){return reactExports.useCallback(O=>{O&&F.onMount&&F.onMount(O),w&&(O?w.mount(O):w.unmount()),D&&(typeof D=="function"?D(O):isRefObject(D)&&(D.current=O))},[w])}const camelToDash=F=>F.replace(/([a-z])([A-Z])/gu,"$1-$2").toLowerCase(),optimizedAppearDataId="framerAppearId",optimizedAppearDataAttribute="data-"+camelToDash(optimizedAppearDataId),SwitchLayoutGroupContext=reactExports.createContext({});function useVisualElement(F,w,D,O,U){const{visualElement:G}=reactExports.useContext(MotionContext),q=reactExports.useContext(LazyContext),K=reactExports.useContext(PresenceContext),ee=reactExports.useContext(MotionConfigContext).reducedMotion,Z=reactExports.useRef(null);O=O||q.renderer,!Z.current&&O&&(Z.current=O(F,{visualState:w,parent:G,props:D,presenceContext:K,blockInitialAnimation:K?K.initial===!1:!1,reducedMotionConfig:ee}));const ie=Z.current,Y=reactExports.useContext(SwitchLayoutGroupContext);ie&&!ie.projection&&U&&(ie.type==="html"||ie.type==="svg")&&createProjectionNode$1(Z.current,D,U,Y);const W=reactExports.useRef(!1);reactExports.useInsertionEffect(()=>{ie&&W.current&&ie.update(D,K)});const ne=D[optimizedAppearDataAttribute],se=reactExports.useRef(!!ne&&!window.MotionHandoffIsComplete?.(ne)&&window.MotionHasOptimisedAnimation?.(ne));return useIsomorphicLayoutEffect(()=>{ie&&(W.current=!0,window.MotionIsMounted=!0,ie.updateFeatures(),ie.scheduleRenderMicrotask(),se.current&&ie.animationState&&ie.animationState.animateChanges())}),reactExports.useEffect(()=>{ie&&(!se.current&&ie.animationState&&ie.animationState.animateChanges(),se.current&&(queueMicrotask(()=>{window.MotionHandoffMarkAsComplete?.(ne)}),se.current=!1),ie.enteringChildren=void 0)}),ie}function createProjectionNode$1(F,w,D,O){const{layoutId:U,layout:G,drag:q,dragConstraints:K,layoutScroll:ee,layoutRoot:Z,layoutCrossfade:ie}=w;F.projection=new D(F.latestValues,w["data-framer-portal-id"]?void 0:getClosestProjectingNode(F.parent)),F.projection.setOptions({layoutId:U,layout:G,alwaysMeasureLayout:!!q||K&&isRefObject(K),visualElement:F,animationType:typeof G=="string"?G:"both",initialPromotionConfig:O,crossfade:ie,layoutScroll:ee,layoutRoot:Z})}function getClosestProjectingNode(F){if(F)return F.options.allowProjection!==!1?F.projection:getClosestProjectingNode(F.parent)}function createMotionComponent(F,{forwardMotionProps:w=!1}={},D,O){D&&loadFeatures(D);const U=isSVGComponent(F)?useSVGVisualState:useHTMLVisualState;function G(K,ee){let Z;const ie={...reactExports.useContext(MotionConfigContext),...K,layoutId:useLayoutId(K)},{isStatic:Y}=ie,W=useCreateMotionContext(K),ne=U(K,Y);if(!Y&&isBrowser){useStrictMode();const se=getProjectionFunctionality(ie);Z=se.MeasureLayout,W.visualElement=useVisualElement(F,ne,ie,O,se.ProjectionNode)}return jsxRuntimeExports.jsxs(MotionContext.Provider,{value:W,children:[Z&&W.visualElement?jsxRuntimeExports.jsx(Z,{visualElement:W.visualElement,...ie}):null,useRender(F,K,useMotionRef(ne,W.visualElement,ee),ne,Y,w)]})}G.displayName=`motion.${typeof F=="string"?F:`create(${F.displayName??F.name??""})`}`;const q=reactExports.forwardRef(G);return q[motionComponentSymbol]=F,q}function useLayoutId({layoutId:F}){const w=reactExports.useContext(LayoutGroupContext).id;return w&&F!==void 0?w+"-"+F:F}function useStrictMode(F,w){reactExports.useContext(LazyContext).strict}function getProjectionFunctionality(F){const{drag:w,layout:D}=featureDefinitions;if(!w&&!D)return{};const O={...w,...D};return{MeasureLayout:w?.isEnabled(F)||D?.isEnabled(F)?O.MeasureLayout:void 0,ProjectionNode:O.ProjectionNode}}function createMotionProxy(F,w){if(typeof Proxy>"u")return createMotionComponent;const D=new Map,O=(G,q)=>createMotionComponent(G,q,F,w),U=(G,q)=>O(G,q);return new Proxy(U,{get:(G,q)=>q==="create"?O:(D.has(q)||D.set(q,createMotionComponent(q,void 0,F,w)),D.get(q))})}function convertBoundingBoxToBox({top:F,left:w,right:D,bottom:O}){return{x:{min:w,max:D},y:{min:F,max:O}}}function convertBoxToBoundingBox({x:F,y:w}){return{top:w.min,right:F.max,bottom:w.max,left:F.min}}function transformBoxPoints(F,w){if(!w)return F;const D=w({x:F.left,y:F.top}),O=w({x:F.right,y:F.bottom});return{top:D.y,left:D.x,bottom:O.y,right:O.x}}function isIdentityScale(F){return F===void 0||F===1}function hasScale({scale:F,scaleX:w,scaleY:D}){return!isIdentityScale(F)||!isIdentityScale(w)||!isIdentityScale(D)}function hasTransform(F){return hasScale(F)||has2DTranslate(F)||F.z||F.rotate||F.rotateX||F.rotateY||F.skewX||F.skewY}function has2DTranslate(F){return is2DTranslate(F.x)||is2DTranslate(F.y)}function is2DTranslate(F){return F&&F!=="0%"}function scalePoint(F,w,D){const O=F-D,U=w*O;return D+U}function applyPointDelta(F,w,D,O,U){return U!==void 0&&(F=scalePoint(F,U,O)),scalePoint(F,D,O)+w}function applyAxisDelta(F,w=0,D=1,O,U){F.min=applyPointDelta(F.min,w,D,O,U),F.max=applyPointDelta(F.max,w,D,O,U)}function applyBoxDelta(F,{x:w,y:D}){applyAxisDelta(F.x,w.translate,w.scale,w.originPoint),applyAxisDelta(F.y,D.translate,D.scale,D.originPoint)}const TREE_SCALE_SNAP_MIN=.999999999999,TREE_SCALE_SNAP_MAX=1.0000000000001;function applyTreeDeltas(F,w,D,O=!1){const U=D.length;if(!U)return;w.x=w.y=1;let G,q;for(let K=0;K<U;K++){G=D[K],q=G.projectionDelta;const{visualElement:ee}=G.options;ee&&ee.props.style&&ee.props.style.display==="contents"||(O&&G.options.layoutScroll&&G.scroll&&G!==G.root&&transformBox(F,{x:-G.scroll.offset.x,y:-G.scroll.offset.y}),q&&(w.x*=q.x.scale,w.y*=q.y.scale,applyBoxDelta(F,q)),O&&hasTransform(G.latestValues)&&transformBox(F,G.latestValues))}w.x<TREE_SCALE_SNAP_MAX&&w.x>TREE_SCALE_SNAP_MIN&&(w.x=1),w.y<TREE_SCALE_SNAP_MAX&&w.y>TREE_SCALE_SNAP_MIN&&(w.y=1)}function translateAxis(F,w){F.min=F.min+w,F.max=F.max+w}function transformAxis(F,w,D,O,U=.5){const G=mixNumber$1(F.min,F.max,U);applyAxisDelta(F,w,D,G,O)}function transformBox(F,w){transformAxis(F.x,w.x,w.scaleX,w.scale,w.originX),transformAxis(F.y,w.y,w.scaleY,w.scale,w.originY)}function measureViewportBox(F,w){return convertBoundingBoxToBox(transformBoxPoints(F.getBoundingClientRect(),w))}function measurePageBox(F,w,D){const O=measureViewportBox(F,D),{scroll:U}=w;return U&&(translateAxis(O.x,U.offset.x),translateAxis(O.y,U.offset.y)),O}const createAxisDelta=()=>({translate:0,scale:1,origin:0,originPoint:0}),createDelta=()=>({x:createAxisDelta(),y:createAxisDelta()}),createAxis=()=>({min:0,max:0}),createBox=()=>({x:createAxis(),y:createAxis()}),prefersReducedMotion={current:null},hasReducedMotionListener={current:!1};function initPrefersReducedMotion(){if(hasReducedMotionListener.current=!0,!!isBrowser)if(window.matchMedia){const F=window.matchMedia("(prefers-reduced-motion)"),w=()=>prefersReducedMotion.current=F.matches;F.addEventListener("change",w),w()}else prefersReducedMotion.current=!1}const visualElementStore=new WeakMap;function updateMotionValuesFromProps(F,w,D){for(const O in w){const U=w[O],G=D[O];if(isMotionValue(U))F.addValue(O,U);else if(isMotionValue(G))F.addValue(O,motionValue(U,{owner:F}));else if(G!==U)if(F.hasValue(O)){const q=F.getValue(O);q.liveStyle===!0?q.jump(U):q.hasAnimated||q.set(U)}else{const q=F.getStaticValue(O);F.addValue(O,motionValue(q!==void 0?q:U,{owner:F}))}}for(const O in D)w[O]===void 0&&F.removeValue(O);return w}const propEventHandlers=["AnimationStart","AnimationComplete","Update","BeforeLayoutMeasure","LayoutMeasure","LayoutAnimationStart","LayoutAnimationComplete"];class VisualElement{scrapeMotionValuesFromProps(w,D,O){return{}}constructor({parent:w,props:D,presenceContext:O,reducedMotionConfig:U,blockInitialAnimation:G,visualState:q},K={}){this.current=null,this.children=new Set,this.isVariantNode=!1,this.isControllingVariants=!1,this.shouldReduceMotion=null,this.values=new Map,this.KeyframeResolver=KeyframeResolver,this.features={},this.valueSubscriptions=new Map,this.prevMotionValues={},this.events={},this.propEventSubscriptions={},this.notifyUpdate=()=>this.notify("Update",this.latestValues),this.render=()=>{this.current&&(this.triggerBuild(),this.renderInstance(this.current,this.renderState,this.props.style,this.projection))},this.renderScheduledAt=0,this.scheduleRender=()=>{const W=time.now();this.renderScheduledAt<W&&(this.renderScheduledAt=W,frame.render(this.render,!1,!0))};const{latestValues:ee,renderState:Z}=q;this.latestValues=ee,this.baseTarget={...ee},this.initialValues=D.initial?{...ee}:{},this.renderState=Z,this.parent=w,this.props=D,this.presenceContext=O,this.depth=w?w.depth+1:0,this.reducedMotionConfig=U,this.options=K,this.blockInitialAnimation=!!G,this.isControllingVariants=isControllingVariants(D),this.isVariantNode=isVariantNode(D),this.isVariantNode&&(this.variantChildren=new Set),this.manuallyAnimateOnMount=!!(w&&w.current);const{willChange:ie,...Y}=this.scrapeMotionValuesFromProps(D,{},this);for(const W in Y){const ne=Y[W];ee[W]!==void 0&&isMotionValue(ne)&&ne.set(ee[W])}}mount(w){this.current=w,visualElementStore.set(w,this),this.projection&&!this.projection.instance&&this.projection.mount(w),this.parent&&this.isVariantNode&&!this.isControllingVariants&&(this.removeFromVariantTree=this.parent.addVariantChild(this)),this.values.forEach((D,O)=>this.bindToMotionValue(O,D)),hasReducedMotionListener.current||initPrefersReducedMotion(),this.shouldReduceMotion=this.reducedMotionConfig==="never"?!1:this.reducedMotionConfig==="always"?!0:prefersReducedMotion.current,this.parent?.addChild(this),this.update(this.props,this.presenceContext)}unmount(){this.projection&&this.projection.unmount(),cancelFrame(this.notifyUpdate),cancelFrame(this.render),this.valueSubscriptions.forEach(w=>w()),this.valueSubscriptions.clear(),this.removeFromVariantTree&&this.removeFromVariantTree(),this.parent?.removeChild(this);for(const w in this.events)this.events[w].clear();for(const w in this.features){const D=this.features[w];D&&(D.unmount(),D.isMounted=!1)}this.current=null}addChild(w){this.children.add(w),this.enteringChildren??(this.enteringChildren=new Set),this.enteringChildren.add(w)}removeChild(w){this.children.delete(w),this.enteringChildren&&this.enteringChildren.delete(w)}bindToMotionValue(w,D){this.valueSubscriptions.has(w)&&this.valueSubscriptions.get(w)();const O=transformProps.has(w);O&&this.onBindTransform&&this.onBindTransform();const U=D.on("change",q=>{this.latestValues[w]=q,this.props.onUpdate&&frame.preRender(this.notifyUpdate),O&&this.projection&&(this.projection.isTransformDirty=!0),this.scheduleRender()});let G;window.MotionCheckAppearSync&&(G=window.MotionCheckAppearSync(this,w,D)),this.valueSubscriptions.set(w,()=>{U(),G&&G(),D.owner&&D.stop()})}sortNodePosition(w){return!this.current||!this.sortInstanceNodePosition||this.type!==w.type?0:this.sortInstanceNodePosition(this.current,w.current)}updateFeatures(){let w="animation";for(w in featureDefinitions){const D=featureDefinitions[w];if(!D)continue;const{isEnabled:O,Feature:U}=D;if(!this.features[w]&&U&&O(this.props)&&(this.features[w]=new U(this)),this.features[w]){const G=this.features[w];G.isMounted?G.update():(G.mount(),G.isMounted=!0)}}}triggerBuild(){this.build(this.renderState,this.latestValues,this.props)}measureViewportBox(){return this.current?this.measureInstanceViewportBox(this.current,this.props):createBox()}getStaticValue(w){return this.latestValues[w]}setStaticValue(w,D){this.latestValues[w]=D}update(w,D){(w.transformTemplate||this.props.transformTemplate)&&this.scheduleRender(),this.prevProps=this.props,this.props=w,this.prevPresenceContext=this.presenceContext,this.presenceContext=D;for(let O=0;O<propEventHandlers.length;O++){const U=propEventHandlers[O];this.propEventSubscriptions[U]&&(this.propEventSubscriptions[U](),delete this.propEventSubscriptions[U]);const G="on"+U,q=w[G];q&&(this.propEventSubscriptions[U]=this.on(U,q))}this.prevMotionValues=updateMotionValuesFromProps(this,this.scrapeMotionValuesFromProps(w,this.prevProps,this),this.prevMotionValues),this.handleChildMotionValue&&this.handleChildMotionValue()}getProps(){return this.props}getVariant(w){return this.props.variants?this.props.variants[w]:void 0}getDefaultTransition(){return this.props.transition}getTransformPagePoint(){return this.props.transformPagePoint}getClosestVariantNode(){return this.isVariantNode?this:this.parent?this.parent.getClosestVariantNode():void 0}addVariantChild(w){const D=this.getClosestVariantNode();if(D)return D.variantChildren&&D.variantChildren.add(w),()=>D.variantChildren.delete(w)}addValue(w,D){const O=this.values.get(w);D!==O&&(O&&this.removeValue(w),this.bindToMotionValue(w,D),this.values.set(w,D),this.latestValues[w]=D.get())}removeValue(w){this.values.delete(w);const D=this.valueSubscriptions.get(w);D&&(D(),this.valueSubscriptions.delete(w)),delete this.latestValues[w],this.removeValueFromRenderState(w,this.renderState)}hasValue(w){return this.values.has(w)}getValue(w,D){if(this.props.values&&this.props.values[w])return this.props.values[w];let O=this.values.get(w);return O===void 0&&D!==void 0&&(O=motionValue(D===null?void 0:D,{owner:this}),this.addValue(w,O)),O}readValue(w,D){let O=this.latestValues[w]!==void 0||!this.current?this.latestValues[w]:this.getBaseTargetFromProps(this.props,w)??this.readValueFromInstance(this.current,w,this.options);return O!=null&&(typeof O=="string"&&(isNumericalString(O)||isZeroValueString(O))?O=parseFloat(O):!findValueType(O)&&complex.test(D)&&(O=getAnimatableNone(w,D)),this.setBaseTarget(w,isMotionValue(O)?O.get():O)),isMotionValue(O)?O.get():O}setBaseTarget(w,D){this.baseTarget[w]=D}getBaseTarget(w){const{initial:D}=this.props;let O;if(typeof D=="string"||typeof D=="object"){const G=resolveVariantFromProps(this.props,D,this.presenceContext?.custom);G&&(O=G[w])}if(D&&O!==void 0)return O;const U=this.getBaseTargetFromProps(this.props,w);return U!==void 0&&!isMotionValue(U)?U:this.initialValues[w]!==void 0&&O===void 0?void 0:this.baseTarget[w]}on(w,D){return this.events[w]||(this.events[w]=new SubscriptionManager),this.events[w].add(D)}notify(w,...D){this.events[w]&&this.events[w].notify(...D)}scheduleRenderMicrotask(){microtask.render(this.render)}}class DOMVisualElement extends VisualElement{constructor(){super(...arguments),this.KeyframeResolver=DOMKeyframesResolver}sortInstanceNodePosition(w,D){return w.compareDocumentPosition(D)&2?1:-1}getBaseTargetFromProps(w,D){return w.style?w.style[D]:void 0}removeValueFromRenderState(w,{vars:D,style:O}){delete D[w],delete O[w]}handleChildMotionValue(){this.childSubscription&&(this.childSubscription(),delete this.childSubscription);const{children:w}=this.props;isMotionValue(w)&&(this.childSubscription=w.on("change",D=>{this.current&&(this.current.textContent=`${D}`)}))}}function renderHTML(F,{style:w,vars:D},O,U){const G=F.style;let q;for(q in w)G[q]=w[q];U?.applyProjectionStyles(G,O);for(q in D)G.setProperty(q,D[q])}function getComputedStyle$1(F){return window.getComputedStyle(F)}class HTMLVisualElement extends DOMVisualElement{constructor(){super(...arguments),this.type="html",this.renderInstance=renderHTML}readValueFromInstance(w,D){if(transformProps.has(D))return this.projection?.isProjecting?defaultTransformValue(D):readTransformValue(w,D);{const O=getComputedStyle$1(w),U=(isCSSVariableName(D)?O.getPropertyValue(D):O[D])||0;return typeof U=="string"?U.trim():U}}measureInstanceViewportBox(w,{transformPagePoint:D}){return measureViewportBox(w,D)}build(w,D,O){buildHTMLStyles(w,D,O.transformTemplate)}scrapeMotionValuesFromProps(w,D,O){return scrapeMotionValuesFromProps$1(w,D,O)}}const camelCaseAttributes=new Set(["baseFrequency","diffuseConstant","kernelMatrix","kernelUnitLength","keySplines","keyTimes","limitingConeAngle","markerHeight","markerWidth","numOctaves","targetX","targetY","surfaceScale","specularConstant","specularExponent","stdDeviation","tableValues","viewBox","gradientTransform","pathLength","startOffset","textLength","lengthAdjust"]);function renderSVG(F,w,D,O){renderHTML(F,w,void 0,O);for(const U in w.attrs)F.setAttribute(camelCaseAttributes.has(U)?U:camelToDash(U),w.attrs[U])}class SVGVisualElement extends DOMVisualElement{constructor(){super(...arguments),this.type="svg",this.isSVGTag=!1,this.measureInstanceViewportBox=createBox}getBaseTargetFromProps(w,D){return w[D]}readValueFromInstance(w,D){if(transformProps.has(D)){const O=getDefaultValueType(D);return O&&O.default||0}return D=camelCaseAttributes.has(D)?D:camelToDash(D),w.getAttribute(D)}scrapeMotionValuesFromProps(w,D,O){return scrapeMotionValuesFromProps(w,D,O)}build(w,D,O){buildSVGAttrs(w,D,this.isSVGTag,O.transformTemplate,O.style)}renderInstance(w,D,O,U){renderSVG(w,D,O,U)}mount(w){this.isSVGTag=isSVGTag(w.tagName),super.mount(w)}}const createDomVisualElement=(F,w)=>isSVGComponent(F)?new SVGVisualElement(w):new HTMLVisualElement(w,{allowProjection:F!==reactExports.Fragment});function resolveVariant(F,w,D){const O=F.getProps();return resolveVariantFromProps(O,w,D!==void 0?D:O.custom,F)}const isKeyframesTarget=F=>Array.isArray(F);function setMotionValue(F,w,D){F.hasValue(w)?F.getValue(w).set(D):F.addValue(w,motionValue(D))}function resolveFinalValueInKeyframes(F){return isKeyframesTarget(F)?F[F.length-1]||0:F}function setTarget(F,w){const D=resolveVariant(F,w);let{transitionEnd:O={},transition:U={},...G}=D||{};G={...G,...O};for(const q in G){const K=resolveFinalValueInKeyframes(G[q]);setMotionValue(F,q,K)}}function isWillChangeMotionValue(F){return!!(isMotionValue(F)&&F.add)}function addValueToWillChange(F,w){const D=F.getValue("willChange");if(isWillChangeMotionValue(D))return D.add(w);if(!D&&MotionGlobalConfig.WillChange){const O=new MotionGlobalConfig.WillChange("auto");F.addValue("willChange",O),O.add(w)}}function getOptimisedAppearId(F){return F.props[optimizedAppearDataAttribute]}const isNotNull=F=>F!==null;function getFinalKeyframe(F,{repeat:w,repeatType:D="loop"},O){const U=F.filter(isNotNull),G=w&&D!=="loop"&&w%2===1?0:U.length-1;return U[G]}const underDampedSpring={type:"spring",stiffness:500,damping:25,restSpeed:10},criticallyDampedSpring=F=>({type:"spring",stiffness:550,damping:F===0?2*Math.sqrt(550):30,restSpeed:10}),keyframesTransition={type:"keyframes",duration:.8},ease={type:"keyframes",ease:[.25,.1,.35,1],duration:.3},getDefaultTransition=(F,{keyframes:w})=>w.length>2?keyframesTransition:transformProps.has(F)?F.startsWith("scale")?criticallyDampedSpring(w[1]):underDampedSpring:ease;function isTransitionDefined({when:F,delay:w,delayChildren:D,staggerChildren:O,staggerDirection:U,repeat:G,repeatType:q,repeatDelay:K,from:ee,elapsed:Z,...ie}){return!!Object.keys(ie).length}const animateMotionValue=(F,w,D,O={},U,G)=>q=>{const K=getValueTransition(O,F)||{},ee=K.delay||O.delay||0;let{elapsed:Z=0}=O;Z=Z-secondsToMilliseconds(ee);const ie={keyframes:Array.isArray(D)?D:[null,D],ease:"easeOut",velocity:w.getVelocity(),...K,delay:-Z,onUpdate:W=>{w.set(W),K.onUpdate&&K.onUpdate(W)},onComplete:()=>{q(),K.onComplete&&K.onComplete()},name:F,motionValue:w,element:G?void 0:U};isTransitionDefined(K)||Object.assign(ie,getDefaultTransition(F,ie)),ie.duration&&(ie.duration=secondsToMilliseconds(ie.duration)),ie.repeatDelay&&(ie.repeatDelay=secondsToMilliseconds(ie.repeatDelay)),ie.from!==void 0&&(ie.keyframes[0]=ie.from);let Y=!1;if((ie.type===!1||ie.duration===0&&!ie.repeatDelay)&&(makeAnimationInstant(ie),ie.delay===0&&(Y=!0)),(MotionGlobalConfig.instantAnimations||MotionGlobalConfig.skipAnimations)&&(Y=!0,makeAnimationInstant(ie),ie.delay=0),ie.allowFlatten=!K.type&&!K.ease,Y&&!G&&w.get()!==void 0){const W=getFinalKeyframe(ie.keyframes,K);if(W!==void 0){frame.update(()=>{ie.onUpdate(W),ie.onComplete()});return}}return K.isSync?new JSAnimation(ie):new AsyncMotionValueAnimation(ie)};function shouldBlockAnimation({protectedKeys:F,needsAnimating:w},D){const O=F.hasOwnProperty(D)&&w[D]!==!0;return w[D]=!1,O}function animateTarget(F,w,{delay:D=0,transitionOverride:O,type:U}={}){let{transition:G=F.getDefaultTransition(),transitionEnd:q,...K}=w;O&&(G=O);const ee=[],Z=U&&F.animationState&&F.animationState.getState()[U];for(const ie in K){const Y=F.getValue(ie,F.latestValues[ie]??null),W=K[ie];if(W===void 0||Z&&shouldBlockAnimation(Z,ie))continue;const ne={delay:D,...getValueTransition(G||{},ie)},se=Y.get();if(se!==void 0&&!Y.isAnimating&&!Array.isArray(W)&&W===se&&!ne.velocity)continue;let le=!1;if(window.MotionHandoffAnimation){const he=getOptimisedAppearId(F);if(he){const pe=window.MotionHandoffAnimation(he,ie,frame);pe!==null&&(ne.startTime=pe,le=!0)}}addValueToWillChange(F,ie),Y.start(animateMotionValue(ie,Y,W,F.shouldReduceMotion&&positionalKeys.has(ie)?{type:!1}:ne,F,le));const ce=Y.animation;ce&&ee.push(ce)}return q&&Promise.all(ee).then(()=>{frame.update(()=>{q&&setTarget(F,q)})}),ee}function calcChildStagger(F,w,D,O=0,U=1){const G=Array.from(F).sort((Z,ie)=>Z.sortNodePosition(ie)).indexOf(w),q=F.size,K=(q-1)*O;return typeof D=="function"?D(G,q):U===1?G*O:K-G*O}function animateVariant(F,w,D={}){const O=resolveVariant(F,w,D.type==="exit"?F.presenceContext?.custom:void 0);let{transition:U=F.getDefaultTransition()||{}}=O||{};D.transitionOverride&&(U=D.transitionOverride);const G=O?()=>Promise.all(animateTarget(F,O,D)):()=>Promise.resolve(),q=F.variantChildren&&F.variantChildren.size?(ee=0)=>{const{delayChildren:Z=0,staggerChildren:ie,staggerDirection:Y}=U;return animateChildren(F,w,ee,Z,ie,Y,D)}:()=>Promise.resolve(),{when:K}=U;if(K){const[ee,Z]=K==="beforeChildren"?[G,q]:[q,G];return ee().then(()=>Z())}else return Promise.all([G(),q(D.delay)])}function animateChildren(F,w,D=0,O=0,U=0,G=1,q){const K=[];for(const ee of F.variantChildren)ee.notify("AnimationStart",w),K.push(animateVariant(ee,w,{...q,delay:D+(typeof O=="function"?0:O)+calcChildStagger(F.variantChildren,ee,O,U,G)}).then(()=>ee.notify("AnimationComplete",w)));return Promise.all(K)}function animateVisualElement(F,w,D={}){F.notify("AnimationStart",w);let O;if(Array.isArray(w)){const U=w.map(G=>animateVariant(F,G,D));O=Promise.all(U)}else if(typeof w=="string")O=animateVariant(F,w,D);else{const U=typeof w=="function"?resolveVariant(F,w,D.custom):w;O=Promise.all(animateTarget(F,U,D))}return O.then(()=>{F.notify("AnimationComplete",w)})}function shallowCompare(F,w){if(!Array.isArray(w))return!1;const D=w.length;if(D!==F.length)return!1;for(let O=0;O<D;O++)if(w[O]!==F[O])return!1;return!0}const numVariantProps=variantProps.length;function getVariantContext(F){if(!F)return;if(!F.isControllingVariants){const D=F.parent?getVariantContext(F.parent)||{}:{};return F.props.initial!==void 0&&(D.initial=F.props.initial),D}const w={};for(let D=0;D<numVariantProps;D++){const O=variantProps[D],U=F.props[O];(isVariantLabel(U)||U===!1)&&(w[O]=U)}return w}const reversePriorityOrder=[...variantPriorityOrder].reverse(),numAnimationTypes=variantPriorityOrder.length;function animateList(F){return w=>Promise.all(w.map(({animation:D,options:O})=>animateVisualElement(F,D,O)))}function createAnimationState(F){let w=animateList(F),D=createState(),O=!0;const U=ee=>(Z,ie)=>{const Y=resolveVariant(F,ie,ee==="exit"?F.presenceContext?.custom:void 0);if(Y){const{transition:W,transitionEnd:ne,...se}=Y;Z={...Z,...se,...ne}}return Z};function G(ee){w=ee(F)}function q(ee){const{props:Z}=F,ie=getVariantContext(F.parent)||{},Y=[],W=new Set;let ne={},se=1/0;for(let ce=0;ce<numAnimationTypes;ce++){const he=reversePriorityOrder[ce],pe=D[he],me=Z[he]!==void 0?Z[he]:ie[he],be=isVariantLabel(me),ge=he===ee?pe.isActive:null;ge===!1&&(se=ce);let ve=me===ie[he]&&me!==Z[he]&&be;if(ve&&O&&F.manuallyAnimateOnMount&&(ve=!1),pe.protectedKeys={...ne},!pe.isActive&&ge===null||!me&&!pe.prevProp||isAnimationControls(me)||typeof me=="boolean")continue;const Se=checkVariantsDidChange(pe.prevProp,me);let Me=Se||he===ee&&pe.isActive&&!ve&&be||ce>se&&be,Ee=!1;const we=Array.isArray(me)?me:[me];let Re=we.reduce(U(he),{});ge===!1&&(Re={});const{prevResolvedValues:Le={}}=pe,Ne={...Le,...Re},Oe=Be=>{Me=!0,W.has(Be)&&(Ee=!0,W.delete(Be)),pe.needsAnimating[Be]=!0;const ze=F.getValue(Be);ze&&(ze.liveStyle=!1)};for(const Be in Ne){const ze=Re[Be],Xe=Le[Be];if(ne.hasOwnProperty(Be))continue;let lt=!1;isKeyframesTarget(ze)&&isKeyframesTarget(Xe)?lt=!shallowCompare(ze,Xe):lt=ze!==Xe,lt?ze!=null?Oe(Be):W.add(Be):ze!==void 0&&W.has(Be)?Oe(Be):pe.protectedKeys[Be]=!0}pe.prevProp=me,pe.prevResolvedValues=Re,pe.isActive&&(ne={...ne,...Re}),O&&F.blockInitialAnimation&&(Me=!1);const Pe=ve&&Se;Me&&(!Pe||Ee)&&Y.push(...we.map(Be=>{const ze={type:he};if(typeof Be=="string"&&O&&!Pe&&F.manuallyAnimateOnMount&&F.parent){const{parent:Xe}=F,lt=resolveVariant(Xe,Be);if(Xe.enteringChildren&&lt){const{delayChildren:ke}=lt.transition||{};ze.delay=calcChildStagger(Xe.enteringChildren,F,ke)}}return{animation:Be,options:ze}}))}if(W.size){const ce={};if(typeof Z.initial!="boolean"){const he=resolveVariant(F,Array.isArray(Z.initial)?Z.initial[0]:Z.initial);he&&he.transition&&(ce.transition=he.transition)}W.forEach(he=>{const pe=F.getBaseTarget(he),me=F.getValue(he);me&&(me.liveStyle=!0),ce[he]=pe??null}),Y.push({animation:ce})}let le=!!Y.length;return O&&(Z.initial===!1||Z.initial===Z.animate)&&!F.manuallyAnimateOnMount&&(le=!1),O=!1,le?w(Y):Promise.resolve()}function K(ee,Z){if(D[ee].isActive===Z)return Promise.resolve();F.variantChildren?.forEach(Y=>Y.animationState?.setActive(ee,Z)),D[ee].isActive=Z;const ie=q(ee);for(const Y in D)D[Y].protectedKeys={};return ie}return{animateChanges:q,setActive:K,setAnimateFunction:G,getState:()=>D,reset:()=>{D=createState()}}}function checkVariantsDidChange(F,w){return typeof w=="string"?w!==F:Array.isArray(w)?!shallowCompare(w,F):!1}function createTypeState(F=!1){return{isActive:F,protectedKeys:{},needsAnimating:{},prevResolvedValues:{}}}function createState(){return{animate:createTypeState(!0),whileInView:createTypeState(),whileHover:createTypeState(),whileTap:createTypeState(),whileDrag:createTypeState(),whileFocus:createTypeState(),exit:createTypeState()}}class Feature{constructor(w){this.isMounted=!1,this.node=w}update(){}}class AnimationFeature extends Feature{constructor(w){super(w),w.animationState||(w.animationState=createAnimationState(w))}updateAnimationControlsSubscription(){const{animate:w}=this.node.getProps();isAnimationControls(w)&&(this.unmountControls=w.subscribe(this.node))}mount(){this.updateAnimationControlsSubscription()}update(){const{animate:w}=this.node.getProps(),{animate:D}=this.node.prevProps||{};w!==D&&this.updateAnimationControlsSubscription()}unmount(){this.node.animationState.reset(),this.unmountControls?.()}}let id$1=0;class ExitAnimationFeature extends Feature{constructor(){super(...arguments),this.id=id$1++}update(){if(!this.node.presenceContext)return;const{isPresent:w,onExitComplete:D}=this.node.presenceContext,{isPresent:O}=this.node.prevPresenceContext||{};if(!this.node.animationState||w===O)return;const U=this.node.animationState.setActive("exit",!w);D&&!w&&U.then(()=>{D(this.id)})}mount(){const{register:w,onExitComplete:D}=this.node.presenceContext||{};D&&D(this.id),w&&(this.unmount=w(this.id))}unmount(){}}const animations={animation:{Feature:AnimationFeature},exit:{Feature:ExitAnimationFeature}};function addDomEvent(F,w,D,O={passive:!0}){return F.addEventListener(w,D,O),()=>F.removeEventListener(w,D)}function extractEventInfo(F){return{point:{x:F.pageX,y:F.pageY}}}const addPointerInfo=F=>w=>isPrimaryPointer(w)&&F(w,extractEventInfo(w));function addPointerEvent(F,w,D,O){return addDomEvent(F,w,addPointerInfo(D),O)}const SCALE_PRECISION=1e-4,SCALE_MIN=1-SCALE_PRECISION,SCALE_MAX=1+SCALE_PRECISION,TRANSLATE_PRECISION=.01,TRANSLATE_MIN=0-TRANSLATE_PRECISION,TRANSLATE_MAX=0+TRANSLATE_PRECISION;function calcLength(F){return F.max-F.min}function isNear(F,w,D){return Math.abs(F-w)<=D}function calcAxisDelta(F,w,D,O=.5){F.origin=O,F.originPoint=mixNumber$1(w.min,w.max,F.origin),F.scale=calcLength(D)/calcLength(w),F.translate=mixNumber$1(D.min,D.max,F.origin)-F.originPoint,(F.scale>=SCALE_MIN&&F.scale<=SCALE_MAX||isNaN(F.scale))&&(F.scale=1),(F.translate>=TRANSLATE_MIN&&F.translate<=TRANSLATE_MAX||isNaN(F.translate))&&(F.translate=0)}function calcBoxDelta(F,w,D,O){calcAxisDelta(F.x,w.x,D.x,O?O.originX:void 0),calcAxisDelta(F.y,w.y,D.y,O?O.originY:void 0)}function calcRelativeAxis(F,w,D){F.min=D.min+w.min,F.max=F.min+calcLength(w)}function calcRelativeBox(F,w,D){calcRelativeAxis(F.x,w.x,D.x),calcRelativeAxis(F.y,w.y,D.y)}function calcRelativeAxisPosition(F,w,D){F.min=w.min-D.min,F.max=F.min+calcLength(w)}function calcRelativePosition(F,w,D){calcRelativeAxisPosition(F.x,w.x,D.x),calcRelativeAxisPosition(F.y,w.y,D.y)}function eachAxis(F){return[F("x"),F("y")]}const getContextWindow=({current:F})=>F?F.ownerDocument.defaultView:null,distance=(F,w)=>Math.abs(F-w);function distance2D(F,w){const D=distance(F.x,w.x),O=distance(F.y,w.y);return Math.sqrt(D**2+O**2)}class PanSession{constructor(w,D,{transformPagePoint:O,contextWindow:U=window,dragSnapToOrigin:G=!1,distanceThreshold:q=3}={}){if(this.startEvent=null,this.lastMoveEvent=null,this.lastMoveEventInfo=null,this.handlers={},this.contextWindow=window,this.updatePoint=()=>{if(!(this.lastMoveEvent&&this.lastMoveEventInfo))return;const W=getPanInfo(this.lastMoveEventInfo,this.history),ne=this.startEvent!==null,se=distance2D(W.offset,{x:0,y:0})>=this.distanceThreshold;if(!ne&&!se)return;const{point:le}=W,{timestamp:ce}=frameData;this.history.push({...le,timestamp:ce});const{onStart:he,onMove:pe}=this.handlers;ne||(he&&he(this.lastMoveEvent,W),this.startEvent=this.lastMoveEvent),pe&&pe(this.lastMoveEvent,W)},this.handlePointerMove=(W,ne)=>{this.lastMoveEvent=W,this.lastMoveEventInfo=transformPoint(ne,this.transformPagePoint),frame.update(this.updatePoint,!0)},this.handlePointerUp=(W,ne)=>{this.end();const{onEnd:se,onSessionEnd:le,resumeAnimation:ce}=this.handlers;if(this.dragSnapToOrigin&&ce&&ce(),!(this.lastMoveEvent&&this.lastMoveEventInfo))return;const he=getPanInfo(W.type==="pointercancel"?this.lastMoveEventInfo:transformPoint(ne,this.transformPagePoint),this.history);this.startEvent&&se&&se(W,he),le&&le(W,he)},!isPrimaryPointer(w))return;this.dragSnapToOrigin=G,this.handlers=D,this.transformPagePoint=O,this.distanceThreshold=q,this.contextWindow=U||window;const K=extractEventInfo(w),ee=transformPoint(K,this.transformPagePoint),{point:Z}=ee,{timestamp:ie}=frameData;this.history=[{...Z,timestamp:ie}];const{onSessionStart:Y}=D;Y&&Y(w,getPanInfo(ee,this.history)),this.removeListeners=pipe(addPointerEvent(this.contextWindow,"pointermove",this.handlePointerMove),addPointerEvent(this.contextWindow,"pointerup",this.handlePointerUp),addPointerEvent(this.contextWindow,"pointercancel",this.handlePointerUp))}updateHandlers(w){this.handlers=w}end(){this.removeListeners&&this.removeListeners(),cancelFrame(this.updatePoint)}}function transformPoint(F,w){return w?{point:w(F.point)}:F}function subtractPoint(F,w){return{x:F.x-w.x,y:F.y-w.y}}function getPanInfo({point:F},w){return{point:F,delta:subtractPoint(F,lastDevicePoint(w)),offset:subtractPoint(F,startDevicePoint(w)),velocity:getVelocity(w,.1)}}function startDevicePoint(F){return F[0]}function lastDevicePoint(F){return F[F.length-1]}function getVelocity(F,w){if(F.length<2)return{x:0,y:0};let D=F.length-1,O=null;const U=lastDevicePoint(F);for(;D>=0&&(O=F[D],!(U.timestamp-O.timestamp>secondsToMilliseconds(w)));)D--;if(!O)return{x:0,y:0};const G=millisecondsToSeconds(U.timestamp-O.timestamp);if(G===0)return{x:0,y:0};const q={x:(U.x-O.x)/G,y:(U.y-O.y)/G};return q.x===1/0&&(q.x=0),q.y===1/0&&(q.y=0),q}function applyConstraints(F,{min:w,max:D},O){return w!==void 0&&F<w?F=O?mixNumber$1(w,F,O.min):Math.max(F,w):D!==void 0&&F>D&&(F=O?mixNumber$1(D,F,O.max):Math.min(F,D)),F}function calcRelativeAxisConstraints(F,w,D){return{min:w!==void 0?F.min+w:void 0,max:D!==void 0?F.max+D-(F.max-F.min):void 0}}function calcRelativeConstraints(F,{top:w,left:D,bottom:O,right:U}){return{x:calcRelativeAxisConstraints(F.x,D,U),y:calcRelativeAxisConstraints(F.y,w,O)}}function calcViewportAxisConstraints(F,w){let D=w.min-F.min,O=w.max-F.max;return w.max-w.min<F.max-F.min&&([D,O]=[O,D]),{min:D,max:O}}function calcViewportConstraints(F,w){return{x:calcViewportAxisConstraints(F.x,w.x),y:calcViewportAxisConstraints(F.y,w.y)}}function calcOrigin(F,w){let D=.5;const O=calcLength(F),U=calcLength(w);return U>O?D=progress(w.min,w.max-O,F.min):O>U&&(D=progress(F.min,F.max-U,w.min)),clamp(0,1,D)}function rebaseAxisConstraints(F,w){const D={};return w.min!==void 0&&(D.min=w.min-F.min),w.max!==void 0&&(D.max=w.max-F.min),D}const defaultElastic=.35;function resolveDragElastic(F=defaultElastic){return F===!1?F=0:F===!0&&(F=defaultElastic),{x:resolveAxisElastic(F,"left","right"),y:resolveAxisElastic(F,"top","bottom")}}function resolveAxisElastic(F,w,D){return{min:resolvePointElastic(F,w),max:resolvePointElastic(F,D)}}function resolvePointElastic(F,w){return typeof F=="number"?F:F[w]||0}const elementDragControls=new WeakMap;class VisualElementDragControls{constructor(w){this.openDragLock=null,this.isDragging=!1,this.currentDirection=null,this.originPoint={x:0,y:0},this.constraints=!1,this.hasMutatedConstraints=!1,this.elastic=createBox(),this.latestPointerEvent=null,this.latestPanInfo=null,this.visualElement=w}start(w,{snapToCursor:D=!1,distanceThreshold:O}={}){const{presenceContext:U}=this.visualElement;if(U&&U.isPresent===!1)return;const G=Y=>{const{dragSnapToOrigin:W}=this.getProps();W?this.pauseAnimation():this.stopAnimation(),D&&this.snapToCursor(extractEventInfo(Y).point)},q=(Y,W)=>{const{drag:ne,dragPropagation:se,onDragStart:le}=this.getProps();if(ne&&!se&&(this.openDragLock&&this.openDragLock(),this.openDragLock=setDragLock(ne),!this.openDragLock))return;this.latestPointerEvent=Y,this.latestPanInfo=W,this.isDragging=!0,this.currentDirection=null,this.resolveConstraints(),this.visualElement.projection&&(this.visualElement.projection.isAnimationBlocked=!0,this.visualElement.projection.target=void 0),eachAxis(he=>{let pe=this.getAxisMotionValue(he).get()||0;if(percent.test(pe)){const{projection:me}=this.visualElement;if(me&&me.layout){const be=me.layout.layoutBox[he];be&&(pe=calcLength(be)*(parseFloat(pe)/100))}}this.originPoint[he]=pe}),le&&frame.postRender(()=>le(Y,W)),addValueToWillChange(this.visualElement,"transform");const{animationState:ce}=this.visualElement;ce&&ce.setActive("whileDrag",!0)},K=(Y,W)=>{this.latestPointerEvent=Y,this.latestPanInfo=W;const{dragPropagation:ne,dragDirectionLock:se,onDirectionLock:le,onDrag:ce}=this.getProps();if(!ne&&!this.openDragLock)return;const{offset:he}=W;if(se&&this.currentDirection===null){this.currentDirection=getCurrentDirection(he),this.currentDirection!==null&&le&&le(this.currentDirection);return}this.updateAxis("x",W.point,he),this.updateAxis("y",W.point,he),this.visualElement.render(),ce&&ce(Y,W)},ee=(Y,W)=>{this.latestPointerEvent=Y,this.latestPanInfo=W,this.stop(Y,W),this.latestPointerEvent=null,this.latestPanInfo=null},Z=()=>eachAxis(Y=>this.getAnimationState(Y)==="paused"&&this.getAxisMotionValue(Y).animation?.play()),{dragSnapToOrigin:ie}=this.getProps();this.panSession=new PanSession(w,{onSessionStart:G,onStart:q,onMove:K,onSessionEnd:ee,resumeAnimation:Z},{transformPagePoint:this.visualElement.getTransformPagePoint(),dragSnapToOrigin:ie,distanceThreshold:O,contextWindow:getContextWindow(this.visualElement)})}stop(w,D){const O=w||this.latestPointerEvent,U=D||this.latestPanInfo,G=this.isDragging;if(this.cancel(),!G||!U||!O)return;const{velocity:q}=U;this.startAnimation(q);const{onDragEnd:K}=this.getProps();K&&frame.postRender(()=>K(O,U))}cancel(){this.isDragging=!1;const{projection:w,animationState:D}=this.visualElement;w&&(w.isAnimationBlocked=!1),this.panSession&&this.panSession.end(),this.panSession=void 0;const{dragPropagation:O}=this.getProps();!O&&this.openDragLock&&(this.openDragLock(),this.openDragLock=null),D&&D.setActive("whileDrag",!1)}updateAxis(w,D,O){const{drag:U}=this.getProps();if(!O||!shouldDrag(w,U,this.currentDirection))return;const G=this.getAxisMotionValue(w);let q=this.originPoint[w]+O[w];this.constraints&&this.constraints[w]&&(q=applyConstraints(q,this.constraints[w],this.elastic[w])),G.set(q)}resolveConstraints(){const{dragConstraints:w,dragElastic:D}=this.getProps(),O=this.visualElement.projection&&!this.visualElement.projection.layout?this.visualElement.projection.measure(!1):this.visualElement.projection?.layout,U=this.constraints;w&&isRefObject(w)?this.constraints||(this.constraints=this.resolveRefConstraints()):w&&O?this.constraints=calcRelativeConstraints(O.layoutBox,w):this.constraints=!1,this.elastic=resolveDragElastic(D),U!==this.constraints&&O&&this.constraints&&!this.hasMutatedConstraints&&eachAxis(G=>{this.constraints!==!1&&this.getAxisMotionValue(G)&&(this.constraints[G]=rebaseAxisConstraints(O.layoutBox[G],this.constraints[G]))})}resolveRefConstraints(){const{dragConstraints:w,onMeasureDragConstraints:D}=this.getProps();if(!w||!isRefObject(w))return!1;const O=w.current,{projection:U}=this.visualElement;if(!U||!U.layout)return!1;const G=measurePageBox(O,U.root,this.visualElement.getTransformPagePoint());let q=calcViewportConstraints(U.layout.layoutBox,G);if(D){const K=D(convertBoxToBoundingBox(q));this.hasMutatedConstraints=!!K,K&&(q=convertBoundingBoxToBox(K))}return q}startAnimation(w){const{drag:D,dragMomentum:O,dragElastic:U,dragTransition:G,dragSnapToOrigin:q,onDragTransitionEnd:K}=this.getProps(),ee=this.constraints||{},Z=eachAxis(ie=>{if(!shouldDrag(ie,D,this.currentDirection))return;let Y=ee&&ee[ie]||{};q&&(Y={min:0,max:0});const W=U?200:1e6,ne=U?40:1e7,se={type:"inertia",velocity:O?w[ie]:0,bounceStiffness:W,bounceDamping:ne,timeConstant:750,restDelta:1,restSpeed:10,...G,...Y};return this.startAxisValueAnimation(ie,se)});return Promise.all(Z).then(K)}startAxisValueAnimation(w,D){const O=this.getAxisMotionValue(w);return addValueToWillChange(this.visualElement,w),O.start(animateMotionValue(w,O,0,D,this.visualElement,!1))}stopAnimation(){eachAxis(w=>this.getAxisMotionValue(w).stop())}pauseAnimation(){eachAxis(w=>this.getAxisMotionValue(w).animation?.pause())}getAnimationState(w){return this.getAxisMotionValue(w).animation?.state}getAxisMotionValue(w){const D=`_drag${w.toUpperCase()}`,O=this.visualElement.getProps(),U=O[D];return U||this.visualElement.getValue(w,(O.initial?O.initial[w]:void 0)||0)}snapToCursor(w){eachAxis(D=>{const{drag:O}=this.getProps();if(!shouldDrag(D,O,this.currentDirection))return;const{projection:U}=this.visualElement,G=this.getAxisMotionValue(D);if(U&&U.layout){const{min:q,max:K}=U.layout.layoutBox[D];G.set(w[D]-mixNumber$1(q,K,.5))}})}scalePositionWithinConstraints(){if(!this.visualElement.current)return;const{drag:w,dragConstraints:D}=this.getProps(),{projection:O}=this.visualElement;if(!isRefObject(D)||!O||!this.constraints)return;this.stopAnimation();const U={x:0,y:0};eachAxis(q=>{const K=this.getAxisMotionValue(q);if(K&&this.constraints!==!1){const ee=K.get();U[q]=calcOrigin({min:ee,max:ee},this.constraints[q])}});const{transformTemplate:G}=this.visualElement.getProps();this.visualElement.current.style.transform=G?G({},""):"none",O.root&&O.root.updateScroll(),O.updateLayout(),this.resolveConstraints(),eachAxis(q=>{if(!shouldDrag(q,w,null))return;const K=this.getAxisMotionValue(q),{min:ee,max:Z}=this.constraints[q];K.set(mixNumber$1(ee,Z,U[q]))})}addListeners(){if(!this.visualElement.current)return;elementDragControls.set(this.visualElement,this);const w=this.visualElement.current,D=addPointerEvent(w,"pointerdown",ee=>{const{drag:Z,dragListener:ie=!0}=this.getProps();Z&&ie&&this.start(ee)}),O=()=>{const{dragConstraints:ee}=this.getProps();isRefObject(ee)&&ee.current&&(this.constraints=this.resolveRefConstraints())},{projection:U}=this.visualElement,G=U.addEventListener("measure",O);U&&!U.layout&&(U.root&&U.root.updateScroll(),U.updateLayout()),frame.read(O);const q=addDomEvent(window,"resize",()=>this.scalePositionWithinConstraints()),K=U.addEventListener("didUpdate",(({delta:ee,hasLayoutChanged:Z})=>{this.isDragging&&Z&&(eachAxis(ie=>{const Y=this.getAxisMotionValue(ie);Y&&(this.originPoint[ie]+=ee[ie].translate,Y.set(Y.get()+ee[ie].translate))}),this.visualElement.render())}));return()=>{q(),D(),G(),K&&K()}}getProps(){const w=this.visualElement.getProps(),{drag:D=!1,dragDirectionLock:O=!1,dragPropagation:U=!1,dragConstraints:G=!1,dragElastic:q=defaultElastic,dragMomentum:K=!0}=w;return{...w,drag:D,dragDirectionLock:O,dragPropagation:U,dragConstraints:G,dragElastic:q,dragMomentum:K}}}function shouldDrag(F,w,D){return(w===!0||w===F)&&(D===null||D===F)}function getCurrentDirection(F,w=10){let D=null;return Math.abs(F.y)>w?D="y":Math.abs(F.x)>w&&(D="x"),D}class DragGesture extends Feature{constructor(w){super(w),this.removeGroupControls=noop,this.removeListeners=noop,this.controls=new VisualElementDragControls(w)}mount(){const{dragControls:w}=this.node.getProps();w&&(this.removeGroupControls=w.subscribe(this.controls)),this.removeListeners=this.controls.addListeners()||noop}unmount(){this.removeGroupControls(),this.removeListeners()}}const asyncHandler=F=>(w,D)=>{F&&frame.postRender(()=>F(w,D))};class PanGesture extends Feature{constructor(){super(...arguments),this.removePointerDownListener=noop}onPointerDown(w){this.session=new PanSession(w,this.createPanHandlers(),{transformPagePoint:this.node.getTransformPagePoint(),contextWindow:getContextWindow(this.node)})}createPanHandlers(){const{onPanSessionStart:w,onPanStart:D,onPan:O,onPanEnd:U}=this.node.getProps();return{onSessionStart:asyncHandler(w),onStart:asyncHandler(D),onMove:O,onEnd:(G,q)=>{delete this.session,U&&frame.postRender(()=>U(G,q))}}}mount(){this.removePointerDownListener=addPointerEvent(this.node.current,"pointerdown",w=>this.onPointerDown(w))}update(){this.session&&this.session.updateHandlers(this.createPanHandlers())}unmount(){this.removePointerDownListener(),this.session&&this.session.end()}}const globalProjectionState={hasAnimatedSinceResize:!0,hasEverUpdated:!1};function pixelsToPercent(F,w){return w.max===w.min?0:F/(w.max-w.min)*100}const correctBorderRadius={correct:(F,w)=>{if(!w.target)return F;if(typeof F=="string")if(px.test(F))F=parseFloat(F);else return F;const D=pixelsToPercent(F,w.target.x),O=pixelsToPercent(F,w.target.y);return`${D}% ${O}%`}},correctBoxShadow={correct:(F,{treeScale:w,projectionDelta:D})=>{const O=F,U=complex.parse(F);if(U.length>5)return O;const G=complex.createTransformer(F),q=typeof U[0]!="number"?1:0,K=D.x.scale*w.x,ee=D.y.scale*w.y;U[0+q]/=K,U[1+q]/=ee;const Z=mixNumber$1(K,ee,.5);return typeof U[2+q]=="number"&&(U[2+q]/=Z),typeof U[3+q]=="number"&&(U[3+q]/=Z),G(U)}};let hasTakenAnySnapshot=!1;class MeasureLayoutWithContext extends reactExports.Component{componentDidMount(){const{visualElement:w,layoutGroup:D,switchLayoutGroup:O,layoutId:U}=this.props,{projection:G}=w;addScaleCorrector(defaultScaleCorrectors),G&&(D.group&&D.group.add(G),O&&O.register&&U&&O.register(G),hasTakenAnySnapshot&&G.root.didUpdate(),G.addEventListener("animationComplete",()=>{this.safeToRemove()}),G.setOptions({...G.options,onExitComplete:()=>this.safeToRemove()})),globalProjectionState.hasEverUpdated=!0}getSnapshotBeforeUpdate(w){const{layoutDependency:D,visualElement:O,drag:U,isPresent:G}=this.props,{projection:q}=O;return q&&(q.isPresent=G,hasTakenAnySnapshot=!0,U||w.layoutDependency!==D||D===void 0||w.isPresent!==G?q.willUpdate():this.safeToRemove(),w.isPresent!==G&&(G?q.promote():q.relegate()||frame.postRender(()=>{const K=q.getStack();(!K||!K.members.length)&&this.safeToRemove()}))),null}componentDidUpdate(){const{projection:w}=this.props.visualElement;w&&(w.root.didUpdate(),microtask.postRender(()=>{!w.currentAnimation&&w.isLead()&&this.safeToRemove()}))}componentWillUnmount(){const{visualElement:w,layoutGroup:D,switchLayoutGroup:O}=this.props,{projection:U}=w;hasTakenAnySnapshot=!0,U&&(U.scheduleCheckAfterUnmount(),D&&D.group&&D.group.remove(U),O&&O.deregister&&O.deregister(U))}safeToRemove(){const{safeToRemove:w}=this.props;w&&w()}render(){return null}}function MeasureLayout(F){const[w,D]=usePresence(),O=reactExports.useContext(LayoutGroupContext);return jsxRuntimeExports.jsx(MeasureLayoutWithContext,{...F,layoutGroup:O,switchLayoutGroup:reactExports.useContext(SwitchLayoutGroupContext),isPresent:w,safeToRemove:D})}const defaultScaleCorrectors={borderRadius:{...correctBorderRadius,applyTo:["borderTopLeftRadius","borderTopRightRadius","borderBottomLeftRadius","borderBottomRightRadius"]},borderTopLeftRadius:correctBorderRadius,borderTopRightRadius:correctBorderRadius,borderBottomLeftRadius:correctBorderRadius,borderBottomRightRadius:correctBorderRadius,boxShadow:correctBoxShadow};function animateSingleValue(F,w,D){const O=isMotionValue(F)?F:motionValue(F);return O.start(animateMotionValue("",O,w,D)),O.animation}const compareByDepth=(F,w)=>F.depth-w.depth;class FlatTree{constructor(){this.children=[],this.isDirty=!1}add(w){addUniqueItem(this.children,w),this.isDirty=!0}remove(w){removeItem(this.children,w),this.isDirty=!0}forEach(w){this.isDirty&&this.children.sort(compareByDepth),this.isDirty=!1,this.children.forEach(w)}}function delay(F,w){const D=time.now(),O=({timestamp:U})=>{const G=U-D;G>=w&&(cancelFrame(O),F(G-w))};return frame.setup(O,!0),()=>cancelFrame(O)}const borders=["TopLeft","TopRight","BottomLeft","BottomRight"],numBorders=borders.length,asNumber=F=>typeof F=="string"?parseFloat(F):F,isPx=F=>typeof F=="number"||px.test(F);function mixValues(F,w,D,O,U,G){U?(F.opacity=mixNumber$1(0,D.opacity??1,easeCrossfadeIn(O)),F.opacityExit=mixNumber$1(w.opacity??1,0,easeCrossfadeOut(O))):G&&(F.opacity=mixNumber$1(w.opacity??1,D.opacity??1,O));for(let q=0;q<numBorders;q++){const K=`border${borders[q]}Radius`;let ee=getRadius(w,K),Z=getRadius(D,K);if(ee===void 0&&Z===void 0)continue;ee||(ee=0),Z||(Z=0),ee===0||Z===0||isPx(ee)===isPx(Z)?(F[K]=Math.max(mixNumber$1(asNumber(ee),asNumber(Z),O),0),(percent.test(Z)||percent.test(ee))&&(F[K]+="%")):F[K]=Z}(w.rotate||D.rotate)&&(F.rotate=mixNumber$1(w.rotate||0,D.rotate||0,O))}function getRadius(F,w){return F[w]!==void 0?F[w]:F.borderRadius}const easeCrossfadeIn=compress(0,.5,circOut),easeCrossfadeOut=compress(.5,.95,noop);function compress(F,w,D){return O=>O<F?0:O>w?1:D(progress(F,w,O))}function copyAxisInto(F,w){F.min=w.min,F.max=w.max}function copyBoxInto(F,w){copyAxisInto(F.x,w.x),copyAxisInto(F.y,w.y)}function copyAxisDeltaInto(F,w){F.translate=w.translate,F.scale=w.scale,F.originPoint=w.originPoint,F.origin=w.origin}function removePointDelta(F,w,D,O,U){return F-=w,F=scalePoint(F,1/D,O),U!==void 0&&(F=scalePoint(F,1/U,O)),F}function removeAxisDelta(F,w=0,D=1,O=.5,U,G=F,q=F){if(percent.test(w)&&(w=parseFloat(w),w=mixNumber$1(q.min,q.max,w/100)-q.min),typeof w!="number")return;let K=mixNumber$1(G.min,G.max,O);F===G&&(K-=w),F.min=removePointDelta(F.min,w,D,K,U),F.max=removePointDelta(F.max,w,D,K,U)}function removeAxisTransforms(F,w,[D,O,U],G,q){removeAxisDelta(F,w[D],w[O],w[U],w.scale,G,q)}const xKeys=["x","scaleX","originX"],yKeys=["y","scaleY","originY"];function removeBoxTransforms(F,w,D,O){removeAxisTransforms(F.x,w,xKeys,D?D.x:void 0,O?O.x:void 0),removeAxisTransforms(F.y,w,yKeys,D?D.y:void 0,O?O.y:void 0)}function isAxisDeltaZero(F){return F.translate===0&&F.scale===1}function isDeltaZero(F){return isAxisDeltaZero(F.x)&&isAxisDeltaZero(F.y)}function axisEquals(F,w){return F.min===w.min&&F.max===w.max}function boxEquals(F,w){return axisEquals(F.x,w.x)&&axisEquals(F.y,w.y)}function axisEqualsRounded(F,w){return Math.round(F.min)===Math.round(w.min)&&Math.round(F.max)===Math.round(w.max)}function boxEqualsRounded(F,w){return axisEqualsRounded(F.x,w.x)&&axisEqualsRounded(F.y,w.y)}function aspectRatio(F){return calcLength(F.x)/calcLength(F.y)}function axisDeltaEquals(F,w){return F.translate===w.translate&&F.scale===w.scale&&F.originPoint===w.originPoint}class NodeStack{constructor(){this.members=[]}add(w){addUniqueItem(this.members,w),w.scheduleRender()}remove(w){if(removeItem(this.members,w),w===this.prevLead&&(this.prevLead=void 0),w===this.lead){const D=this.members[this.members.length-1];D&&this.promote(D)}}relegate(w){const D=this.members.findIndex(U=>w===U);if(D===0)return!1;let O;for(let U=D;U>=0;U--){const G=this.members[U];if(G.isPresent!==!1){O=G;break}}return O?(this.promote(O),!0):!1}promote(w,D){const O=this.lead;if(w!==O&&(this.prevLead=O,this.lead=w,w.show(),O)){O.instance&&O.scheduleRender(),w.scheduleRender(),w.resumeFrom=O,D&&(w.resumeFrom.preserveOpacity=!0),O.snapshot&&(w.snapshot=O.snapshot,w.snapshot.latestValues=O.animationValues||O.latestValues),w.root&&w.root.isUpdating&&(w.isLayoutDirty=!0);const{crossfade:U}=w.options;U===!1&&O.hide()}}exitAnimationComplete(){this.members.forEach(w=>{const{options:D,resumingFrom:O}=w;D.onExitComplete&&D.onExitComplete(),O&&O.options.onExitComplete&&O.options.onExitComplete()})}scheduleRender(){this.members.forEach(w=>{w.instance&&w.scheduleRender(!1)})}removeLeadSnapshot(){this.lead&&this.lead.snapshot&&(this.lead.snapshot=void 0)}}function buildProjectionTransform(F,w,D){let O="";const U=F.x.translate/w.x,G=F.y.translate/w.y,q=D?.z||0;if((U||G||q)&&(O=`translate3d(${U}px, ${G}px, ${q}px) `),(w.x!==1||w.y!==1)&&(O+=`scale(${1/w.x}, ${1/w.y}) `),D){const{transformPerspective:Z,rotate:ie,rotateX:Y,rotateY:W,skewX:ne,skewY:se}=D;Z&&(O=`perspective(${Z}px) ${O}`),ie&&(O+=`rotate(${ie}deg) `),Y&&(O+=`rotateX(${Y}deg) `),W&&(O+=`rotateY(${W}deg) `),ne&&(O+=`skewX(${ne}deg) `),se&&(O+=`skewY(${se}deg) `)}const K=F.x.scale*w.x,ee=F.y.scale*w.y;return(K!==1||ee!==1)&&(O+=`scale(${K}, ${ee})`),O||"none"}const transformAxes=["","X","Y","Z"],animationTarget=1e3;let id=0;function resetDistortingTransform(F,w,D,O){const{latestValues:U}=w;U[F]&&(D[F]=U[F],w.setStaticValue(F,0),O&&(O[F]=0))}function cancelTreeOptimisedTransformAnimations(F){if(F.hasCheckedOptimisedAppear=!0,F.root===F)return;const{visualElement:w}=F.options;if(!w)return;const D=getOptimisedAppearId(w);if(window.MotionHasOptimisedAnimation(D,"transform")){const{layout:U,layoutId:G}=F.options;window.MotionCancelOptimisedAnimation(D,"transform",frame,!(U||G))}const{parent:O}=F;O&&!O.hasCheckedOptimisedAppear&&cancelTreeOptimisedTransformAnimations(O)}function createProjectionNode({attachResizeListener:F,defaultParent:w,measureScroll:D,checkIsScrollRoot:O,resetTransform:U}){return class{constructor(q={},K=w?.()){this.id=id++,this.animationId=0,this.animationCommitId=0,this.children=new Set,this.options={},this.isTreeAnimating=!1,this.isAnimationBlocked=!1,this.isLayoutDirty=!1,this.isProjectionDirty=!1,this.isSharedProjectionDirty=!1,this.isTransformDirty=!1,this.updateManuallyBlocked=!1,this.updateBlockedByResize=!1,this.isUpdating=!1,this.isSVG=!1,this.needsReset=!1,this.shouldResetTransform=!1,this.hasCheckedOptimisedAppear=!1,this.treeScale={x:1,y:1},this.eventHandlers=new Map,this.hasTreeAnimated=!1,this.updateScheduled=!1,this.scheduleUpdate=()=>this.update(),this.projectionUpdateScheduled=!1,this.checkUpdateFailed=()=>{this.isUpdating&&(this.isUpdating=!1,this.clearAllSnapshots())},this.updateProjection=()=>{this.projectionUpdateScheduled=!1,this.nodes.forEach(propagateDirtyNodes),this.nodes.forEach(resolveTargetDelta),this.nodes.forEach(calcProjection),this.nodes.forEach(cleanDirtyNodes)},this.resolvedRelativeTargetAt=0,this.hasProjected=!1,this.isVisible=!0,this.animationProgress=0,this.sharedNodes=new Map,this.latestValues=q,this.root=K?K.root||K:this,this.path=K?[...K.path,K]:[],this.parent=K,this.depth=K?K.depth+1:0;for(let ee=0;ee<this.path.length;ee++)this.path[ee].shouldResetTransform=!0;this.root===this&&(this.nodes=new FlatTree)}addEventListener(q,K){return this.eventHandlers.has(q)||this.eventHandlers.set(q,new SubscriptionManager),this.eventHandlers.get(q).add(K)}notifyListeners(q,...K){const ee=this.eventHandlers.get(q);ee&&ee.notify(...K)}hasListeners(q){return this.eventHandlers.has(q)}mount(q){if(this.instance)return;this.isSVG=isSVGElement(q)&&!isSVGSVGElement(q),this.instance=q;const{layoutId:K,layout:ee,visualElement:Z}=this.options;if(Z&&!Z.current&&Z.mount(q),this.root.nodes.add(this),this.parent&&this.parent.children.add(this),this.root.hasTreeAnimated&&(ee||K)&&(this.isLayoutDirty=!0),F){let ie,Y=0;const W=()=>this.root.updateBlockedByResize=!1;frame.read(()=>{Y=window.innerWidth}),F(q,()=>{const ne=window.innerWidth;ne!==Y&&(Y=ne,this.root.updateBlockedByResize=!0,ie&&ie(),ie=delay(W,250),globalProjectionState.hasAnimatedSinceResize&&(globalProjectionState.hasAnimatedSinceResize=!1,this.nodes.forEach(finishAnimation)))})}K&&this.root.registerSharedNode(K,this),this.options.animate!==!1&&Z&&(K||ee)&&this.addEventListener("didUpdate",({delta:ie,hasLayoutChanged:Y,hasRelativeLayoutChanged:W,layout:ne})=>{if(this.isTreeAnimationBlocked()){this.target=void 0,this.relativeTarget=void 0;return}const se=this.options.transition||Z.getDefaultTransition()||defaultLayoutTransition,{onLayoutAnimationStart:le,onLayoutAnimationComplete:ce}=Z.getProps(),he=!this.targetLayout||!boxEqualsRounded(this.targetLayout,ne),pe=!Y&&W;if(this.options.layoutRoot||this.resumeFrom||pe||Y&&(he||!this.currentAnimation)){this.resumeFrom&&(this.resumingFrom=this.resumeFrom,this.resumingFrom.resumingFrom=void 0);const me={...getValueTransition(se,"layout"),onPlay:le,onComplete:ce};(Z.shouldReduceMotion||this.options.layoutRoot)&&(me.delay=0,me.type=!1),this.startAnimation(me),this.setAnimationOrigin(ie,pe)}else Y||finishAnimation(this),this.isLead()&&this.options.onExitComplete&&this.options.onExitComplete();this.targetLayout=ne})}unmount(){this.options.layoutId&&this.willUpdate(),this.root.nodes.remove(this);const q=this.getStack();q&&q.remove(this),this.parent&&this.parent.children.delete(this),this.instance=void 0,this.eventHandlers.clear(),cancelFrame(this.updateProjection)}blockUpdate(){this.updateManuallyBlocked=!0}unblockUpdate(){this.updateManuallyBlocked=!1}isUpdateBlocked(){return this.updateManuallyBlocked||this.updateBlockedByResize}isTreeAnimationBlocked(){return this.isAnimationBlocked||this.parent&&this.parent.isTreeAnimationBlocked()||!1}startUpdate(){this.isUpdateBlocked()||(this.isUpdating=!0,this.nodes&&this.nodes.forEach(resetSkewAndRotation),this.animationId++)}getTransformTemplate(){const{visualElement:q}=this.options;return q&&q.getProps().transformTemplate}willUpdate(q=!0){if(this.root.hasTreeAnimated=!0,this.root.isUpdateBlocked()){this.options.onExitComplete&&this.options.onExitComplete();return}if(window.MotionCancelOptimisedAnimation&&!this.hasCheckedOptimisedAppear&&cancelTreeOptimisedTransformAnimations(this),!this.root.isUpdating&&this.root.startUpdate(),this.isLayoutDirty)return;this.isLayoutDirty=!0;for(let ie=0;ie<this.path.length;ie++){const Y=this.path[ie];Y.shouldResetTransform=!0,Y.updateScroll("snapshot"),Y.options.layoutRoot&&Y.willUpdate(!1)}const{layoutId:K,layout:ee}=this.options;if(K===void 0&&!ee)return;const Z=this.getTransformTemplate();this.prevTransformTemplateValue=Z?Z(this.latestValues,""):void 0,this.updateSnapshot(),q&&this.notifyListeners("willUpdate")}update(){if(this.updateScheduled=!1,this.isUpdateBlocked()){this.unblockUpdate(),this.clearAllSnapshots(),this.nodes.forEach(clearMeasurements);return}if(this.animationId<=this.animationCommitId){this.nodes.forEach(clearIsLayoutDirty);return}this.animationCommitId=this.animationId,this.isUpdating?(this.isUpdating=!1,this.nodes.forEach(resetTransformStyle),this.nodes.forEach(updateLayout),this.nodes.forEach(notifyLayoutUpdate)):this.nodes.forEach(clearIsLayoutDirty),this.clearAllSnapshots();const K=time.now();frameData.delta=clamp(0,1e3/60,K-frameData.timestamp),frameData.timestamp=K,frameData.isProcessing=!0,frameSteps.update.process(frameData),frameSteps.preRender.process(frameData),frameSteps.render.process(frameData),frameData.isProcessing=!1}didUpdate(){this.updateScheduled||(this.updateScheduled=!0,microtask.read(this.scheduleUpdate))}clearAllSnapshots(){this.nodes.forEach(clearSnapshot),this.sharedNodes.forEach(removeLeadSnapshots)}scheduleUpdateProjection(){this.projectionUpdateScheduled||(this.projectionUpdateScheduled=!0,frame.preRender(this.updateProjection,!1,!0))}scheduleCheckAfterUnmount(){frame.postRender(()=>{this.isLayoutDirty?this.root.didUpdate():this.root.checkUpdateFailed()})}updateSnapshot(){this.snapshot||!this.instance||(this.snapshot=this.measure(),this.snapshot&&!calcLength(this.snapshot.measuredBox.x)&&!calcLength(this.snapshot.measuredBox.y)&&(this.snapshot=void 0))}updateLayout(){if(!this.instance||(this.updateScroll(),!(this.options.alwaysMeasureLayout&&this.isLead())&&!this.isLayoutDirty))return;if(this.resumeFrom&&!this.resumeFrom.instance)for(let ee=0;ee<this.path.length;ee++)this.path[ee].updateScroll();const q=this.layout;this.layout=this.measure(!1),this.layoutCorrected=createBox(),this.isLayoutDirty=!1,this.projectionDelta=void 0,this.notifyListeners("measure",this.layout.layoutBox);const{visualElement:K}=this.options;K&&K.notify("LayoutMeasure",this.layout.layoutBox,q?q.layoutBox:void 0)}updateScroll(q="measure"){let K=!!(this.options.layoutScroll&&this.instance);if(this.scroll&&this.scroll.animationId===this.root.animationId&&this.scroll.phase===q&&(K=!1),K&&this.instance){const ee=O(this.instance);this.scroll={animationId:this.root.animationId,phase:q,isRoot:ee,offset:D(this.instance),wasRoot:this.scroll?this.scroll.isRoot:ee}}}resetTransform(){if(!U)return;const q=this.isLayoutDirty||this.shouldResetTransform||this.options.alwaysMeasureLayout,K=this.projectionDelta&&!isDeltaZero(this.projectionDelta),ee=this.getTransformTemplate(),Z=ee?ee(this.latestValues,""):void 0,ie=Z!==this.prevTransformTemplateValue;q&&this.instance&&(K||hasTransform(this.latestValues)||ie)&&(U(this.instance,Z),this.shouldResetTransform=!1,this.scheduleRender())}measure(q=!0){const K=this.measurePageBox();let ee=this.removeElementScroll(K);return q&&(ee=this.removeTransform(ee)),roundBox(ee),{animationId:this.root.animationId,measuredBox:K,layoutBox:ee,latestValues:{},source:this.id}}measurePageBox(){const{visualElement:q}=this.options;if(!q)return createBox();const K=q.measureViewportBox();if(!(this.scroll?.wasRoot||this.path.some(checkNodeWasScrollRoot))){const{scroll:Z}=this.root;Z&&(translateAxis(K.x,Z.offset.x),translateAxis(K.y,Z.offset.y))}return K}removeElementScroll(q){const K=createBox();if(copyBoxInto(K,q),this.scroll?.wasRoot)return K;for(let ee=0;ee<this.path.length;ee++){const Z=this.path[ee],{scroll:ie,options:Y}=Z;Z!==this.root&&ie&&Y.layoutScroll&&(ie.wasRoot&&copyBoxInto(K,q),translateAxis(K.x,ie.offset.x),translateAxis(K.y,ie.offset.y))}return K}applyTransform(q,K=!1){const ee=createBox();copyBoxInto(ee,q);for(let Z=0;Z<this.path.length;Z++){const ie=this.path[Z];!K&&ie.options.layoutScroll&&ie.scroll&&ie!==ie.root&&transformBox(ee,{x:-ie.scroll.offset.x,y:-ie.scroll.offset.y}),hasTransform(ie.latestValues)&&transformBox(ee,ie.latestValues)}return hasTransform(this.latestValues)&&transformBox(ee,this.latestValues),ee}removeTransform(q){const K=createBox();copyBoxInto(K,q);for(let ee=0;ee<this.path.length;ee++){const Z=this.path[ee];if(!Z.instance||!hasTransform(Z.latestValues))continue;hasScale(Z.latestValues)&&Z.updateSnapshot();const ie=createBox(),Y=Z.measurePageBox();copyBoxInto(ie,Y),removeBoxTransforms(K,Z.latestValues,Z.snapshot?Z.snapshot.layoutBox:void 0,ie)}return hasTransform(this.latestValues)&&removeBoxTransforms(K,this.latestValues),K}setTargetDelta(q){this.targetDelta=q,this.root.scheduleUpdateProjection(),this.isProjectionDirty=!0}setOptions(q){this.options={...this.options,...q,crossfade:q.crossfade!==void 0?q.crossfade:!0}}clearMeasurements(){this.scroll=void 0,this.layout=void 0,this.snapshot=void 0,this.prevTransformTemplateValue=void 0,this.targetDelta=void 0,this.target=void 0,this.isLayoutDirty=!1}forceRelativeParentToResolveTarget(){this.relativeParent&&this.relativeParent.resolvedRelativeTargetAt!==frameData.timestamp&&this.relativeParent.resolveTargetDelta(!0)}resolveTargetDelta(q=!1){const K=this.getLead();this.isProjectionDirty||(this.isProjectionDirty=K.isProjectionDirty),this.isTransformDirty||(this.isTransformDirty=K.isTransformDirty),this.isSharedProjectionDirty||(this.isSharedProjectionDirty=K.isSharedProjectionDirty);const ee=!!this.resumingFrom||this!==K;if(!(q||ee&&this.isSharedProjectionDirty||this.isProjectionDirty||this.parent?.isProjectionDirty||this.attemptToResolveRelativeTarget||this.root.updateBlockedByResize))return;const{layout:ie,layoutId:Y}=this.options;if(!(!this.layout||!(ie||Y))){if(this.resolvedRelativeTargetAt=frameData.timestamp,!this.targetDelta&&!this.relativeTarget){const W=this.getClosestProjectingParent();W&&W.layout&&this.animationProgress!==1?(this.relativeParent=W,this.forceRelativeParentToResolveTarget(),this.relativeTarget=createBox(),this.relativeTargetOrigin=createBox(),calcRelativePosition(this.relativeTargetOrigin,this.layout.layoutBox,W.layout.layoutBox),copyBoxInto(this.relativeTarget,this.relativeTargetOrigin)):this.relativeParent=this.relativeTarget=void 0}if(!(!this.relativeTarget&&!this.targetDelta)&&(this.target||(this.target=createBox(),this.targetWithTransforms=createBox()),this.relativeTarget&&this.relativeTargetOrigin&&this.relativeParent&&this.relativeParent.target?(this.forceRelativeParentToResolveTarget(),calcRelativeBox(this.target,this.relativeTarget,this.relativeParent.target)):this.targetDelta?(this.resumingFrom?this.target=this.applyTransform(this.layout.layoutBox):copyBoxInto(this.target,this.layout.layoutBox),applyBoxDelta(this.target,this.targetDelta)):copyBoxInto(this.target,this.layout.layoutBox),this.attemptToResolveRelativeTarget)){this.attemptToResolveRelativeTarget=!1;const W=this.getClosestProjectingParent();W&&!!W.resumingFrom==!!this.resumingFrom&&!W.options.layoutScroll&&W.target&&this.animationProgress!==1?(this.relativeParent=W,this.forceRelativeParentToResolveTarget(),this.relativeTarget=createBox(),this.relativeTargetOrigin=createBox(),calcRelativePosition(this.relativeTargetOrigin,this.target,W.target),copyBoxInto(this.relativeTarget,this.relativeTargetOrigin)):this.relativeParent=this.relativeTarget=void 0}}}getClosestProjectingParent(){if(!(!this.parent||hasScale(this.parent.latestValues)||has2DTranslate(this.parent.latestValues)))return this.parent.isProjecting()?this.parent:this.parent.getClosestProjectingParent()}isProjecting(){return!!((this.relativeTarget||this.targetDelta||this.options.layoutRoot)&&this.layout)}calcProjection(){const q=this.getLead(),K=!!this.resumingFrom||this!==q;let ee=!0;if((this.isProjectionDirty||this.parent?.isProjectionDirty)&&(ee=!1),K&&(this.isSharedProjectionDirty||this.isTransformDirty)&&(ee=!1),this.resolvedRelativeTargetAt===frameData.timestamp&&(ee=!1),ee)return;const{layout:Z,layoutId:ie}=this.options;if(this.isTreeAnimating=!!(this.parent&&this.parent.isTreeAnimating||this.currentAnimation||this.pendingAnimation),this.isTreeAnimating||(this.targetDelta=this.relativeTarget=void 0),!this.layout||!(Z||ie))return;copyBoxInto(this.layoutCorrected,this.layout.layoutBox);const Y=this.treeScale.x,W=this.treeScale.y;applyTreeDeltas(this.layoutCorrected,this.treeScale,this.path,K),q.layout&&!q.target&&(this.treeScale.x!==1||this.treeScale.y!==1)&&(q.target=q.layout.layoutBox,q.targetWithTransforms=createBox());const{target:ne}=q;if(!ne){this.prevProjectionDelta&&(this.createProjectionDeltas(),this.scheduleRender());return}!this.projectionDelta||!this.prevProjectionDelta?this.createProjectionDeltas():(copyAxisDeltaInto(this.prevProjectionDelta.x,this.projectionDelta.x),copyAxisDeltaInto(this.prevProjectionDelta.y,this.projectionDelta.y)),calcBoxDelta(this.projectionDelta,this.layoutCorrected,ne,this.latestValues),(this.treeScale.x!==Y||this.treeScale.y!==W||!axisDeltaEquals(this.projectionDelta.x,this.prevProjectionDelta.x)||!axisDeltaEquals(this.projectionDelta.y,this.prevProjectionDelta.y))&&(this.hasProjected=!0,this.scheduleRender(),this.notifyListeners("projectionUpdate",ne))}hide(){this.isVisible=!1}show(){this.isVisible=!0}scheduleRender(q=!0){if(this.options.visualElement?.scheduleRender(),q){const K=this.getStack();K&&K.scheduleRender()}this.resumingFrom&&!this.resumingFrom.instance&&(this.resumingFrom=void 0)}createProjectionDeltas(){this.prevProjectionDelta=createDelta(),this.projectionDelta=createDelta(),this.projectionDeltaWithTransform=createDelta()}setAnimationOrigin(q,K=!1){const ee=this.snapshot,Z=ee?ee.latestValues:{},ie={...this.latestValues},Y=createDelta();(!this.relativeParent||!this.relativeParent.options.layoutRoot)&&(this.relativeTarget=this.relativeTargetOrigin=void 0),this.attemptToResolveRelativeTarget=!K;const W=createBox(),ne=ee?ee.source:void 0,se=this.layout?this.layout.source:void 0,le=ne!==se,ce=this.getStack(),he=!ce||ce.members.length<=1,pe=!!(le&&!he&&this.options.crossfade===!0&&!this.path.some(hasOpacityCrossfade));this.animationProgress=0;let me;this.mixTargetDelta=be=>{const ge=be/1e3;mixAxisDelta(Y.x,q.x,ge),mixAxisDelta(Y.y,q.y,ge),this.setTargetDelta(Y),this.relativeTarget&&this.relativeTargetOrigin&&this.layout&&this.relativeParent&&this.relativeParent.layout&&(calcRelativePosition(W,this.layout.layoutBox,this.relativeParent.layout.layoutBox),mixBox(this.relativeTarget,this.relativeTargetOrigin,W,ge),me&&boxEquals(this.relativeTarget,me)&&(this.isProjectionDirty=!1),me||(me=createBox()),copyBoxInto(me,this.relativeTarget)),le&&(this.animationValues=ie,mixValues(ie,Z,this.latestValues,ge,pe,he)),this.root.scheduleUpdateProjection(),this.scheduleRender(),this.animationProgress=ge},this.mixTargetDelta(this.options.layoutRoot?1e3:0)}startAnimation(q){this.notifyListeners("animationStart"),this.currentAnimation?.stop(),this.resumingFrom?.currentAnimation?.stop(),this.pendingAnimation&&(cancelFrame(this.pendingAnimation),this.pendingAnimation=void 0),this.pendingAnimation=frame.update(()=>{globalProjectionState.hasAnimatedSinceResize=!0,this.motionValue||(this.motionValue=motionValue(0)),this.currentAnimation=animateSingleValue(this.motionValue,[0,1e3],{...q,velocity:0,isSync:!0,onUpdate:K=>{this.mixTargetDelta(K),q.onUpdate&&q.onUpdate(K)},onStop:()=>{},onComplete:()=>{q.onComplete&&q.onComplete(),this.completeAnimation()}}),this.resumingFrom&&(this.resumingFrom.currentAnimation=this.currentAnimation),this.pendingAnimation=void 0})}completeAnimation(){this.resumingFrom&&(this.resumingFrom.currentAnimation=void 0,this.resumingFrom.preserveOpacity=void 0);const q=this.getStack();q&&q.exitAnimationComplete(),this.resumingFrom=this.currentAnimation=this.animationValues=void 0,this.notifyListeners("animationComplete")}finishAnimation(){this.currentAnimation&&(this.mixTargetDelta&&this.mixTargetDelta(animationTarget),this.currentAnimation.stop()),this.completeAnimation()}applyTransformsToTarget(){const q=this.getLead();let{targetWithTransforms:K,target:ee,layout:Z,latestValues:ie}=q;if(!(!K||!ee||!Z)){if(this!==q&&this.layout&&Z&&shouldAnimatePositionOnly(this.options.animationType,this.layout.layoutBox,Z.layoutBox)){ee=this.target||createBox();const Y=calcLength(this.layout.layoutBox.x);ee.x.min=q.target.x.min,ee.x.max=ee.x.min+Y;const W=calcLength(this.layout.layoutBox.y);ee.y.min=q.target.y.min,ee.y.max=ee.y.min+W}copyBoxInto(K,ee),transformBox(K,ie),calcBoxDelta(this.projectionDeltaWithTransform,this.layoutCorrected,K,ie)}}registerSharedNode(q,K){this.sharedNodes.has(q)||this.sharedNodes.set(q,new NodeStack),this.sharedNodes.get(q).add(K);const Z=K.options.initialPromotionConfig;K.promote({transition:Z?Z.transition:void 0,preserveFollowOpacity:Z&&Z.shouldPreserveFollowOpacity?Z.shouldPreserveFollowOpacity(K):void 0})}isLead(){const q=this.getStack();return q?q.lead===this:!0}getLead(){const{layoutId:q}=this.options;return q?this.getStack()?.lead||this:this}getPrevLead(){const{layoutId:q}=this.options;return q?this.getStack()?.prevLead:void 0}getStack(){const{layoutId:q}=this.options;if(q)return this.root.sharedNodes.get(q)}promote({needsReset:q,transition:K,preserveFollowOpacity:ee}={}){const Z=this.getStack();Z&&Z.promote(this,ee),q&&(this.projectionDelta=void 0,this.needsReset=!0),K&&this.setOptions({transition:K})}relegate(){const q=this.getStack();return q?q.relegate(this):!1}resetSkewAndRotation(){const{visualElement:q}=this.options;if(!q)return;let K=!1;const{latestValues:ee}=q;if((ee.z||ee.rotate||ee.rotateX||ee.rotateY||ee.rotateZ||ee.skewX||ee.skewY)&&(K=!0),!K)return;const Z={};ee.z&&resetDistortingTransform("z",q,Z,this.animationValues);for(let ie=0;ie<transformAxes.length;ie++)resetDistortingTransform(`rotate${transformAxes[ie]}`,q,Z,this.animationValues),resetDistortingTransform(`skew${transformAxes[ie]}`,q,Z,this.animationValues);q.render();for(const ie in Z)q.setStaticValue(ie,Z[ie]),this.animationValues&&(this.animationValues[ie]=Z[ie]);q.scheduleRender()}applyProjectionStyles(q,K){if(!this.instance||this.isSVG)return;if(!this.isVisible){q.visibility="hidden";return}const ee=this.getTransformTemplate();if(this.needsReset){this.needsReset=!1,q.visibility="",q.opacity="",q.pointerEvents=resolveMotionValue(K?.pointerEvents)||"",q.transform=ee?ee(this.latestValues,""):"none";return}const Z=this.getLead();if(!this.projectionDelta||!this.layout||!Z.target){this.options.layoutId&&(q.opacity=this.latestValues.opacity!==void 0?this.latestValues.opacity:1,q.pointerEvents=resolveMotionValue(K?.pointerEvents)||""),this.hasProjected&&!hasTransform(this.latestValues)&&(q.transform=ee?ee({},""):"none",this.hasProjected=!1);return}q.visibility="";const ie=Z.animationValues||Z.latestValues;this.applyTransformsToTarget();let Y=buildProjectionTransform(this.projectionDeltaWithTransform,this.treeScale,ie);ee&&(Y=ee(ie,Y)),q.transform=Y;const{x:W,y:ne}=this.projectionDelta;q.transformOrigin=`${W.origin*100}% ${ne.origin*100}% 0`,Z.animationValues?q.opacity=Z===this?ie.opacity??this.latestValues.opacity??1:this.preserveOpacity?this.latestValues.opacity:ie.opacityExit:q.opacity=Z===this?ie.opacity!==void 0?ie.opacity:"":ie.opacityExit!==void 0?ie.opacityExit:0;for(const se in scaleCorrectors){if(ie[se]===void 0)continue;const{correct:le,applyTo:ce,isCSSVariable:he}=scaleCorrectors[se],pe=Y==="none"?ie[se]:le(ie[se],Z);if(ce){const me=ce.length;for(let be=0;be<me;be++)q[ce[be]]=pe}else he?this.options.visualElement.renderState.vars[se]=pe:q[se]=pe}this.options.layoutId&&(q.pointerEvents=Z===this?resolveMotionValue(K?.pointerEvents)||"":"none")}clearSnapshot(){this.resumeFrom=this.snapshot=void 0}resetTree(){this.root.nodes.forEach(q=>q.currentAnimation?.stop()),this.root.nodes.forEach(clearMeasurements),this.root.sharedNodes.clear()}}}function updateLayout(F){F.updateLayout()}function notifyLayoutUpdate(F){const w=F.resumeFrom?.snapshot||F.snapshot;if(F.isLead()&&F.layout&&w&&F.hasListeners("didUpdate")){const{layoutBox:D,measuredBox:O}=F.layout,{animationType:U}=F.options,G=w.source!==F.layout.source;U==="size"?eachAxis(ie=>{const Y=G?w.measuredBox[ie]:w.layoutBox[ie],W=calcLength(Y);Y.min=D[ie].min,Y.max=Y.min+W}):shouldAnimatePositionOnly(U,w.layoutBox,D)&&eachAxis(ie=>{const Y=G?w.measuredBox[ie]:w.layoutBox[ie],W=calcLength(D[ie]);Y.max=Y.min+W,F.relativeTarget&&!F.currentAnimation&&(F.isProjectionDirty=!0,F.relativeTarget[ie].max=F.relativeTarget[ie].min+W)});const q=createDelta();calcBoxDelta(q,D,w.layoutBox);const K=createDelta();G?calcBoxDelta(K,F.applyTransform(O,!0),w.measuredBox):calcBoxDelta(K,D,w.layoutBox);const ee=!isDeltaZero(q);let Z=!1;if(!F.resumeFrom){const ie=F.getClosestProjectingParent();if(ie&&!ie.resumeFrom){const{snapshot:Y,layout:W}=ie;if(Y&&W){const ne=createBox();calcRelativePosition(ne,w.layoutBox,Y.layoutBox);const se=createBox();calcRelativePosition(se,D,W.layoutBox),boxEqualsRounded(ne,se)||(Z=!0),ie.options.layoutRoot&&(F.relativeTarget=se,F.relativeTargetOrigin=ne,F.relativeParent=ie)}}}F.notifyListeners("didUpdate",{layout:D,snapshot:w,delta:K,layoutDelta:q,hasLayoutChanged:ee,hasRelativeLayoutChanged:Z})}else if(F.isLead()){const{onExitComplete:D}=F.options;D&&D()}F.options.transition=void 0}function propagateDirtyNodes(F){F.parent&&(F.isProjecting()||(F.isProjectionDirty=F.parent.isProjectionDirty),F.isSharedProjectionDirty||(F.isSharedProjectionDirty=!!(F.isProjectionDirty||F.parent.isProjectionDirty||F.parent.isSharedProjectionDirty)),F.isTransformDirty||(F.isTransformDirty=F.parent.isTransformDirty))}function cleanDirtyNodes(F){F.isProjectionDirty=F.isSharedProjectionDirty=F.isTransformDirty=!1}function clearSnapshot(F){F.clearSnapshot()}function clearMeasurements(F){F.clearMeasurements()}function clearIsLayoutDirty(F){F.isLayoutDirty=!1}function resetTransformStyle(F){const{visualElement:w}=F.options;w&&w.getProps().onBeforeLayoutMeasure&&w.notify("BeforeLayoutMeasure"),F.resetTransform()}function finishAnimation(F){F.finishAnimation(),F.targetDelta=F.relativeTarget=F.target=void 0,F.isProjectionDirty=!0}function resolveTargetDelta(F){F.resolveTargetDelta()}function calcProjection(F){F.calcProjection()}function resetSkewAndRotation(F){F.resetSkewAndRotation()}function removeLeadSnapshots(F){F.removeLeadSnapshot()}function mixAxisDelta(F,w,D){F.translate=mixNumber$1(w.translate,0,D),F.scale=mixNumber$1(w.scale,1,D),F.origin=w.origin,F.originPoint=w.originPoint}function mixAxis(F,w,D,O){F.min=mixNumber$1(w.min,D.min,O),F.max=mixNumber$1(w.max,D.max,O)}function mixBox(F,w,D,O){mixAxis(F.x,w.x,D.x,O),mixAxis(F.y,w.y,D.y,O)}function hasOpacityCrossfade(F){return F.animationValues&&F.animationValues.opacityExit!==void 0}const defaultLayoutTransition={duration:.45,ease:[.4,0,.1,1]},userAgentContains=F=>typeof navigator<"u"&&navigator.userAgent&&navigator.userAgent.toLowerCase().includes(F),roundPoint=userAgentContains("applewebkit/")&&!userAgentContains("chrome/")?Math.round:noop;function roundAxis(F){F.min=roundPoint(F.min),F.max=roundPoint(F.max)}function roundBox(F){roundAxis(F.x),roundAxis(F.y)}function shouldAnimatePositionOnly(F,w,D){return F==="position"||F==="preserve-aspect"&&!isNear(aspectRatio(w),aspectRatio(D),.2)}function checkNodeWasScrollRoot(F){return F!==F.root&&F.scroll?.wasRoot}const DocumentProjectionNode=createProjectionNode({attachResizeListener:(F,w)=>addDomEvent(F,"resize",w),measureScroll:()=>({x:document.documentElement.scrollLeft||document.body.scrollLeft,y:document.documentElement.scrollTop||document.body.scrollTop}),checkIsScrollRoot:()=>!0}),rootProjectionNode={current:void 0},HTMLProjectionNode=createProjectionNode({measureScroll:F=>({x:F.scrollLeft,y:F.scrollTop}),defaultParent:()=>{if(!rootProjectionNode.current){const F=new DocumentProjectionNode({});F.mount(window),F.setOptions({layoutScroll:!0}),rootProjectionNode.current=F}return rootProjectionNode.current},resetTransform:(F,w)=>{F.style.transform=w!==void 0?w:"none"},checkIsScrollRoot:F=>window.getComputedStyle(F).position==="fixed"}),drag={pan:{Feature:PanGesture},drag:{Feature:DragGesture,ProjectionNode:HTMLProjectionNode,MeasureLayout}};function handleHoverEvent(F,w,D){const{props:O}=F;F.animationState&&O.whileHover&&F.animationState.setActive("whileHover",D==="Start");const U="onHover"+D,G=O[U];G&&frame.postRender(()=>G(w,extractEventInfo(w)))}class HoverGesture extends Feature{mount(){const{current:w}=this.node;w&&(this.unmount=hover(w,(D,O)=>(handleHoverEvent(this.node,O,"Start"),U=>handleHoverEvent(this.node,U,"End"))))}unmount(){}}class FocusGesture extends Feature{constructor(){super(...arguments),this.isActive=!1}onFocus(){let w=!1;try{w=this.node.current.matches(":focus-visible")}catch{w=!0}!w||!this.node.animationState||(this.node.animationState.setActive("whileFocus",!0),this.isActive=!0)}onBlur(){!this.isActive||!this.node.animationState||(this.node.animationState.setActive("whileFocus",!1),this.isActive=!1)}mount(){this.unmount=pipe(addDomEvent(this.node.current,"focus",()=>this.onFocus()),addDomEvent(this.node.current,"blur",()=>this.onBlur()))}unmount(){}}function handlePressEvent(F,w,D){const{props:O}=F;if(F.current instanceof HTMLButtonElement&&F.current.disabled)return;F.animationState&&O.whileTap&&F.animationState.setActive("whileTap",D==="Start");const U="onTap"+(D==="End"?"":D),G=O[U];G&&frame.postRender(()=>G(w,extractEventInfo(w)))}class PressGesture extends Feature{mount(){const{current:w}=this.node;w&&(this.unmount=press(w,(D,O)=>(handlePressEvent(this.node,O,"Start"),(U,{success:G})=>handlePressEvent(this.node,U,G?"End":"Cancel")),{useGlobalTarget:this.node.props.globalTapTarget}))}unmount(){}}const observerCallbacks=new WeakMap,observers=new WeakMap,fireObserverCallback=F=>{const w=observerCallbacks.get(F.target);w&&w(F)},fireAllObserverCallbacks=F=>{F.forEach(fireObserverCallback)};function initIntersectionObserver({root:F,...w}){const D=F||document;observers.has(D)||observers.set(D,{});const O=observers.get(D),U=JSON.stringify(w);return O[U]||(O[U]=new IntersectionObserver(fireAllObserverCallbacks,{root:F,...w})),O[U]}function observeIntersection(F,w,D){const O=initIntersectionObserver(w);return observerCallbacks.set(F,D),O.observe(F),()=>{observerCallbacks.delete(F),O.unobserve(F)}}const thresholdNames={some:0,all:1};class InViewFeature extends Feature{constructor(){super(...arguments),this.hasEnteredView=!1,this.isInView=!1}startObserver(){this.unmount();const{viewport:w={}}=this.node.getProps(),{root:D,margin:O,amount:U="some",once:G}=w,q={root:D?D.current:void 0,rootMargin:O,threshold:typeof U=="number"?U:thresholdNames[U]},K=ee=>{const{isIntersecting:Z}=ee;if(this.isInView===Z||(this.isInView=Z,G&&!Z&&this.hasEnteredView))return;Z&&(this.hasEnteredView=!0),this.node.animationState&&this.node.animationState.setActive("whileInView",Z);const{onViewportEnter:ie,onViewportLeave:Y}=this.node.getProps(),W=Z?ie:Y;W&&W(ee)};return observeIntersection(this.node.current,q,K)}mount(){this.startObserver()}update(){if(typeof IntersectionObserver>"u")return;const{props:w,prevProps:D}=this.node;["amount","margin","root"].some(hasViewportOptionChanged(w,D))&&this.startObserver()}unmount(){}}function hasViewportOptionChanged({viewport:F={}},{viewport:w={}}={}){return D=>F[D]!==w[D]}const gestureAnimations={inView:{Feature:InViewFeature},tap:{Feature:PressGesture},focus:{Feature:FocusGesture},hover:{Feature:HoverGesture}},layout={layout:{ProjectionNode:HTMLProjectionNode,MeasureLayout}},featureBundle={...animations,...gestureAnimations,...drag,...layout},motion=createMotionProxy(featureBundle,createDomVisualElement);/**
 * @license lucide-react v0.552.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const toKebabCase=F=>F.replace(/([a-z0-9])([A-Z])/g,"$1-$2").toLowerCase(),toCamelCase=F=>F.replace(/^([A-Z])|[\s-_]+(\w)/g,(w,D,O)=>O?O.toUpperCase():D.toLowerCase()),toPascalCase=F=>{const w=toCamelCase(F);return w.charAt(0).toUpperCase()+w.slice(1)},mergeClasses=(...F)=>F.filter((w,D,O)=>!!w&&w.trim()!==""&&O.indexOf(w)===D).join(" ").trim(),hasA11yProp=F=>{for(const w in F)if(w.startsWith("aria-")||w==="role"||w==="title")return!0};/**
 * @license lucide-react v0.552.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */var defaultAttributes={xmlns:"http://www.w3.org/2000/svg",width:24,height:24,viewBox:"0 0 24 24",fill:"none",stroke:"currentColor",strokeWidth:2,strokeLinecap:"round",strokeLinejoin:"round"};/**
 * @license lucide-react v0.552.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const Icon=reactExports.forwardRef(({color:F="currentColor",size:w=24,strokeWidth:D=2,absoluteStrokeWidth:O,className:U="",children:G,iconNode:q,...K},ee)=>reactExports.createElement("svg",{ref:ee,...defaultAttributes,width:w,height:w,stroke:F,strokeWidth:O?Number(D)*24/Number(w):D,className:mergeClasses("lucide",U),...!G&&!hasA11yProp(K)&&{"aria-hidden":"true"},...K},[...q.map(([Z,ie])=>reactExports.createElement(Z,ie)),...Array.isArray(G)?G:[G]]));/**
 * @license lucide-react v0.552.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const createLucideIcon=(F,w)=>{const D=reactExports.forwardRef(({className:O,...U},G)=>reactExports.createElement(Icon,{ref:G,iconNode:w,className:mergeClasses(`lucide-${toKebabCase(toPascalCase(F))}`,`lucide-${F}`,O),...U}));return D.displayName=toPascalCase(F),D};/**
 * @license lucide-react v0.552.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const __iconNode$g=[["path",{d:"m12 19-7-7 7-7",key:"1l729n"}],["path",{d:"M19 12H5",key:"x3x0zl"}]],ArrowLeft=createLucideIcon("arrow-left",__iconNode$g);/**
 * @license lucide-react v0.552.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const __iconNode$f=[["path",{d:"M21 8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73l7 4a2 2 0 0 0 2 0l7-4A2 2 0 0 0 21 16Z",key:"hh9hay"}],["path",{d:"m3.3 7 8.7 5 8.7-5",key:"g66t2b"}],["path",{d:"M12 22V12",key:"d0xqtd"}]],Box=createLucideIcon("box",__iconNode$f);/**
 * @license lucide-react v0.552.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const __iconNode$e=[["path",{d:"M13.997 4a2 2 0 0 1 1.76 1.05l.486.9A2 2 0 0 0 18.003 7H20a2 2 0 0 1 2 2v9a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V9a2 2 0 0 1 2-2h1.997a2 2 0 0 0 1.759-1.048l.489-.904A2 2 0 0 1 10.004 4z",key:"18u6gg"}],["circle",{cx:"12",cy:"13",r:"3",key:"1vg3eu"}]],Camera=createLucideIcon("camera",__iconNode$e);/**
 * @license lucide-react v0.552.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const __iconNode$d=[["path",{d:"M20 6 9 17l-5-5",key:"1gmf2c"}]],Check=createLucideIcon("check",__iconNode$d);/**
 * @license lucide-react v0.552.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const __iconNode$c=[["circle",{cx:"12",cy:"12",r:"10",key:"1mglay"}],["line",{x1:"12",x2:"12",y1:"8",y2:"12",key:"1pkeuh"}],["line",{x1:"12",x2:"12.01",y1:"16",y2:"16",key:"4dfq90"}]],CircleAlert=createLucideIcon("circle-alert",__iconNode$c);/**
 * @license lucide-react v0.552.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const __iconNode$b=[["path",{d:"M12 15V3",key:"m9g1x1"}],["path",{d:"M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4",key:"ih7n3h"}],["path",{d:"m7 10 5 5 5-5",key:"brsn70"}]],Download=createLucideIcon("download",__iconNode$b);/**
 * @license lucide-react v0.552.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const __iconNode$a=[["path",{d:"M15 21v-8a1 1 0 0 0-1-1h-4a1 1 0 0 0-1 1v8",key:"5wwlr5"}],["path",{d:"M3 10a2 2 0 0 1 .709-1.528l7-6a2 2 0 0 1 2.582 0l7 6A2 2 0 0 1 21 10v9a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z",key:"r6nss1"}]],House=createLucideIcon("house",__iconNode$a);/**
 * @license lucide-react v0.552.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const __iconNode$9=[["circle",{cx:"12",cy:"12",r:"10",key:"1mglay"}],["path",{d:"M12 16v-4",key:"1dtifu"}],["path",{d:"M12 8h.01",key:"e9boi3"}]],Info=createLucideIcon("info",__iconNode$9);/**
 * @license lucide-react v0.552.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const __iconNode$8=[["path",{d:"M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71",key:"1cjeqo"}],["path",{d:"M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71",key:"19qd67"}]],Link=createLucideIcon("link",__iconNode$8);/**
 * @license lucide-react v0.552.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const __iconNode$7=[["path",{d:"M2.992 16.342a2 2 0 0 1 .094 1.167l-1.065 3.29a1 1 0 0 0 1.236 1.168l3.413-.998a2 2 0 0 1 1.099.092 10 10 0 1 0-4.777-4.719",key:"1sd12s"}]],MessageCircle=createLucideIcon("message-circle",__iconNode$7);/**
 * @license lucide-react v0.552.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const __iconNode$6=[["path",{d:"M12 19v3",key:"npa21l"}],["path",{d:"M15 9.34V5a3 3 0 0 0-5.68-1.33",key:"1gzdoj"}],["path",{d:"M16.95 16.95A7 7 0 0 1 5 12v-2",key:"cqa7eg"}],["path",{d:"M18.89 13.23A7 7 0 0 0 19 12v-2",key:"16hl24"}],["path",{d:"m2 2 20 20",key:"1ooewy"}],["path",{d:"M9 9v3a3 3 0 0 0 5.12 2.12",key:"r2i35w"}]],MicOff=createLucideIcon("mic-off",__iconNode$6);/**
 * @license lucide-react v0.552.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const __iconNode$5=[["path",{d:"M12 19v3",key:"npa21l"}],["path",{d:"M19 10v2a7 7 0 0 1-14 0v-2",key:"1vc78b"}],["rect",{x:"9",y:"2",width:"6",height:"13",rx:"3",key:"s6n7sd"}]],Mic=createLucideIcon("mic",__iconNode$5);/**
 * @license lucide-react v0.552.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const __iconNode$4=[["path",{d:"M14.536 21.686a.5.5 0 0 0 .937-.024l6.5-19a.496.496 0 0 0-.635-.635l-19 6.5a.5.5 0 0 0-.024.937l7.93 3.18a2 2 0 0 1 1.112 1.11z",key:"1ffxy3"}],["path",{d:"m21.854 2.147-10.94 10.939",key:"12cjpa"}]],Send=createLucideIcon("send",__iconNode$4);/**
 * @license lucide-react v0.552.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const __iconNode$3=[["circle",{cx:"18",cy:"5",r:"3",key:"gq8acd"}],["circle",{cx:"6",cy:"12",r:"3",key:"w7nqdw"}],["circle",{cx:"18",cy:"19",r:"3",key:"1xt0gg"}],["line",{x1:"8.59",x2:"15.42",y1:"13.51",y2:"17.49",key:"47mynk"}],["line",{x1:"15.41",x2:"8.59",y1:"6.51",y2:"10.49",key:"1n3mei"}]],Share2=createLucideIcon("share-2",__iconNode$3);/**
 * @license lucide-react v0.552.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const __iconNode$2=[["path",{d:"M11.017 2.814a1 1 0 0 1 1.966 0l1.051 5.558a2 2 0 0 0 1.594 1.594l5.558 1.051a1 1 0 0 1 0 1.966l-5.558 1.051a2 2 0 0 0-1.594 1.594l-1.051 5.558a1 1 0 0 1-1.966 0l-1.051-5.558a2 2 0 0 0-1.594-1.594l-5.558-1.051a1 1 0 0 1 0-1.966l5.558-1.051a2 2 0 0 0 1.594-1.594z",key:"1s2grr"}],["path",{d:"M20 2v4",key:"1rf3ol"}],["path",{d:"M22 4h-4",key:"gwowj6"}],["circle",{cx:"4",cy:"20",r:"2",key:"6kqj1y"}]],Sparkles=createLucideIcon("sparkles",__iconNode$2);/**
 * @license lucide-react v0.552.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const __iconNode$1=[["path",{d:"M18 6 6 18",key:"1bl5f8"}],["path",{d:"m6 6 12 12",key:"d8bk6v"}]],X=createLucideIcon("x",__iconNode$1);/**
 * @license lucide-react v0.552.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const __iconNode=[["path",{d:"M4 14a1 1 0 0 1-.78-1.63l9.9-10.2a.5.5 0 0 1 .86.46l-1.92 6.02A1 1 0 0 0 13 10h7a1 1 0 0 1 .78 1.63l-9.9 10.2a.5.5 0 0 1-.86-.46l1.92-6.02A1 1 0 0 0 11 14z",key:"1xq2db"}]],Zap=createLucideIcon("zap",__iconNode);function ARViewer({modelUrl:F,model:w,onBack:D}){const O=reactExports.useRef(null),[U,G]=reactExports.useState(""),[q,K]=reactExports.useState(!0),[ee,Z]=reactExports.useState(null),[ie,Y]=reactExports.useState(!1),[W,ne]=reactExports.useState(""),[se,le]=reactExports.useState(!1),[ce,he]=reactExports.useState(2),pe=.5,me=10,be=Le=>Le?Le.replace(/-/g," ").replace(/_/g," ").replace(/\b\w/g,Ne=>Ne.toUpperCase()):"",ge={},ve={};w?.desc_left,w?.desc_right,reactExports.useEffect(()=>{F?F.startsWith("http")||(Z("URL model tidak valid (harus dimulai dengan http/https)."),K(!1)):(Z("URL model tidak diberikan."),K(!1))},[F]),reactExports.useEffect(()=>{const Le=O.current;if(!Le||ee)return;const Ne=()=>{K(!1),Z(null)},Oe=Ce=>{G(Ce.detail.status)},Pe=Ce=>{const Be=Ce.detail?.sourceError?.message||"Gagal memuat model";Z(Be),K(!1),G("failed")};return Le.addEventListener("load",Ne),Le.addEventListener("ar-status",Oe),Le.addEventListener("error",Pe),()=>{Le.removeEventListener("load",Ne),Le.removeEventListener("ar-status",Oe),Le.removeEventListener("error",Pe)}},[ee]),reactExports.useEffect(()=>{const Le=O.current;Le&&!q&&!ee&&(Le.cameraOrbit=`0deg 75deg ${ce}m`,Le.fieldOfView="30deg")},[ce,q,ee]),reactExports.useEffect(()=>{const Le=O.current;if(!Le||q||ee)return;let Ne=0,Oe=!1;const Pe=Xe=>{const[lt,ke]=Xe;return Math.hypot(lt.pageX-ke.pageX,lt.pageY-ke.pageY)},Ce=Xe=>{Xe.touches.length===2&&(Xe.preventDefault(),Oe=!0,Ne=Pe(Xe.touches))},Be=Xe=>{if(Oe&&Xe.touches.length===2){Xe.preventDefault();const lt=Pe(Xe.touches),ke=Ne-lt,St=ce+ke*.001;he(Lt=>Math.max(pe,Math.min(me,St))),Ne=lt}},ze=()=>{Oe=!1};return Le.addEventListener("touchstart",Ce,{passive:!1}),Le.addEventListener("touchmove",Be,{passive:!1}),Le.addEventListener("touchend",ze),()=>{Le.removeEventListener("touchstart",Ce),Le.removeEventListener("touchmove",Be),Le.removeEventListener("touchend",ze)}},[ce,q,ee]);const Se=()=>{O.current&&O.current.activateAR()},Me=async()=>{if(F){Y(!0);try{const Le=await fetch(F,{mode:"cors"});if(!Le.ok)throw new Error(`HTTP ${Le.status}`);const Ne=await Le.blob();if(!Ne.type.includes("model/gltf-binary")&&!Ne.type.includes("octet-stream"))throw new Error("File bukan format .glb");const Oe=URL.createObjectURL(Ne),Pe=F.split("/").pop()?.split("?")[0]??"model.glb",Ce=document.createElement("a");Ce.href=Oe,Ce.download=Pe,document.body.appendChild(Ce),Ce.click(),document.body.removeChild(Ce),URL.revokeObjectURL(Oe)}catch(Le){alert("Gagal mengunduh: "+Le.message)}finally{Y(!1)}}},Ee=async()=>{try{await navigator.clipboard.writeText(F),ne("copied"),setTimeout(()=>{ne(""),le(!1)},2e3)}catch{alert("Gagal menyalin link.")}},we=()=>{const Le=`Lihat model 3D ini: ${F}`,Ne=`https://wa.me/?text=${encodeURIComponent(Le)}`;window.open(Ne,"_blank"),ne("whatsapp"),setTimeout(()=>{ne(""),le(!1)},1e3)},Re=U==="session-started";return!F||!F.startsWith("https")?jsxRuntimeExports.jsxs("div",{className:"flex flex-col items-center justify-center h-screen text-white space-y-6 px-4",children:[jsxRuntimeExports.jsx(Info,{className:"w-12 h-12 text-red-400"}),jsxRuntimeExports.jsxs("div",{className:"text-center max-w-md",children:[jsxRuntimeExports.jsx("h3",{className:"text-xl font-bold mb-2",children:"Model Tidak Tersedia"}),jsxRuntimeExports.jsx("p",{className:"text-sm text-white/70",children:"URL model tidak valid."})]}),jsxRuntimeExports.jsxs("button",{onClick:D,className:"px-6 py-3 bg-cyan-600 rounded-full font-medium hover:scale-105 transition-all flex items-center gap-2",children:[jsxRuntimeExports.jsx(House,{className:"w-5 h-5"})," Kembali"]})]}):ee?jsxRuntimeExports.jsxs("div",{className:"flex flex-col items-center justify-center h-screen text-white space-y-6 px-4",children:[jsxRuntimeExports.jsx(Info,{className:"w-12 h-12 text-yellow-400"}),jsxRuntimeExports.jsxs("div",{className:"text-center max-w-md",children:[jsxRuntimeExports.jsx("h3",{className:"text-xl font-bold mb-2",children:"Gagal Memuat Model"}),jsxRuntimeExports.jsx("p",{className:"text-sm break-words",children:ee}),jsxRuntimeExports.jsx("p",{className:"text-xs mt-2",children:"Cek URL, CORS, atau format file (.glb)"})]}),jsxRuntimeExports.jsxs("div",{className:"flex gap-3",children:[jsxRuntimeExports.jsxs("button",{onClick:Me,className:"px-5 py-2 bg-emerald-600 rounded-full text-sm flex items-center gap-2",children:[jsxRuntimeExports.jsx(Download,{className:"w-4 h-4"})," Coba Download"]}),jsxRuntimeExports.jsxs("button",{onClick:D,className:"px-5 py-2 bg-cyan-600 rounded-full text-sm flex items-center gap-2",children:[jsxRuntimeExports.jsx(House,{className:"w-4 h-4"})," Kembali"]})]})]}):jsxRuntimeExports.jsxs("div",{className:"relative w-full h-screen overflow-hidden bg-gradient-to-b from-black via-cyan-950 to-black",children:[jsxRuntimeExports.jsx("div",{className:"absolute inset-0 pointer-events-none overflow-hidden",children:jsxRuntimeExports.jsx("div",{className:"absolute inset-0 opacity-50",style:{backgroundImage:`
              linear-gradient(to right, rgba(0, 255, 255, 0.5) 1px, transparent 1px),
              linear-gradient(to bottom, rgba(0, 255, 255, 0.5) 1px, transparent 1px)
            `,backgroundSize:"60px 60px",backgroundPosition:"center bottom",transform:"perspective(300px) rotateX(45deg) scale(3.2) translateY(0%)",transformOrigin:"center bottom",animation:"gridMove 18s linear infinite",filter:"brightness(1.3)"}})}),jsxRuntimeExports.jsx("div",{className:"absolute inset-0 flex items-center justify-center pointer-events-none",children:jsxRuntimeExports.jsx("div",{className:"w-96 h-96 bg-cyan-500 rounded-full filter blur-3xl opacity-10 animate-pulse"})}),jsxRuntimeExports.jsx("model-viewer",{ref:O,src:F,alt:"3D Model AR",ar:!0,"ar-modes":"webxr scene-viewer quick-look","ar-scale":"auto","ar-placement":"floor","camera-controls":!0,"shadow-intensity":"1.5",exposure:"1.0","field-of-view":"30deg","max-camera-orbit":"auto auto","interaction-prompt":"none",crossorigin:"anonymous",loading:"eager","touch-action":"none",style:{width:"100%",height:"100%"},className:"touch-none select-none",children:jsxRuntimeExports.jsx("div",{slot:"poster",className:"flex items-center justify-center w-full h-full bg-gradient-to-br from-blue-900 to-brand-800",children:jsxRuntimeExports.jsxs("div",{className:"text-center",children:[jsxRuntimeExports.jsx("div",{className:"w-16 h-16 border-4 border-white/30 border-t-white rounded-full animate-spin mx-auto mb-4"}),jsxRuntimeExports.jsx("p",{className:"text-white font-medium",children:"Memuat Model 3D..."})]})})}),jsxRuntimeExports.jsx("div",{className:"w-[94vw] mx-auto absolute inset-0 hidden md:flex items-center justify-center px-6 md:px-12 pointer-events-none z-40",children:jsxRuntimeExports.jsxs("div",{className:"relative w-full flex justify-between items-center perspective-1000",children:[jsxRuntimeExports.jsx(motion.div,{initial:{opacity:0,x:-80,scale:.9},animate:{opacity:1,x:0,scale:1},transition:{duration:.7,delay:.3,ease:[.22,1,.36,1]},className:"flex flex-col items-start pointer-events-auto",children:jsxRuntimeExports.jsxs("div",{className:"relative preserve-3d transition-transform duration-300 ease-out",style:{top:"50%",willChange:"transform"},onMouseMove:Le=>{const Oe=Le.currentTarget.getBoundingClientRect();Le.clientX-Oe.left,Le.clientY-Oe.top,Oe.width/2,Oe.height/2},children:[jsxRuntimeExports.jsxs(motion.div,{initial:{width:0},animate:{width:64},transition:{duration:.6,delay:.6},className:"ml-auto relative left-[20%] flex items-center mb-2 overflow-hidden",children:[jsxRuntimeExports.jsx("div",{className:"w-0 h-0 border-t-8 border-t-transparent border-b-8 border-b-transparent border-l-8 border-l-blue-500"}),jsxRuntimeExports.jsx("div",{className:"w-16 h-0.5 bg-blue-500"})]}),jsxRuntimeExports.jsx(motion.div,{initial:{height:0},animate:{height:96},transition:{duration:.5,delay:.8},className:"ml-auto w-0.5 bg-red-500"}),jsxRuntimeExports.jsxs(motion.div,{layout:!0,initial:{opacity:0,y:20},animate:{opacity:1,y:0},transition:{duration:.5,delay:1},className:"mt-3 w-[400px] bg-white/10 backdrop-blur-md border border-white/20 rounded-xl p-4 text-white shadow-xl max-w-xs",children:[jsxRuntimeExports.jsx("p",{className:"text-xs font-medium text-cyan-300 mb-2",children:"Sistem & Manfaat"}),jsxRuntimeExports.jsx("p",{className:"text-xs text-cyan-100 mb-2",children:w.system}),jsxRuntimeExports.jsx("ul",{className:"text-xs space-y-1",children:(w.benefits||[]).map((Le,Ne)=>jsxRuntimeExports.jsxs("li",{className:"flex items-center gap-2",children:[jsxRuntimeExports.jsx("span",{className:"text-cyan-400",children:""}),jsxRuntimeExports.jsx("span",{children:Le})]},Ne))})]}),jsxRuntimeExports.jsx("div",{className:"absolute -inset-6 bg-cyan-500/20 rounded-full blur-3xl opacity-50",style:{zIndex:-1,transform:"translateZ(-10px)"}})]})}),jsxRuntimeExports.jsx(motion.div,{initial:{opacity:0,x:80,scale:.9},animate:{opacity:1,x:0,scale:1},transition:{duration:.7,delay:.3,ease:[.22,1,.36,1]},className:"flex flex-col items-end pointer-events-auto",children:jsxRuntimeExports.jsxs("div",{className:"relative preserve-3d transition-transform duration-300 ease-out",style:{top:"50%",willChange:"transform"},onMouseMove:Le=>{const Oe=Le.currentTarget.getBoundingClientRect();Le.clientX-Oe.left,Le.clientY-Oe.top,Oe.width/2,Oe.height/2},children:[jsxRuntimeExports.jsxs(motion.div,{initial:{width:0},animate:{width:64},transition:{duration:.6,delay:.6},className:"relative left-[-22%] flex items-center mb-2 overflow-hidden justify-start",children:[jsxRuntimeExports.jsx("div",{className:"w-16 h-0.5 bg-blue-500"}),jsxRuntimeExports.jsx("div",{className:"w-0 h-0 border-t-8 border-t-transparent border-b-8 border-b-transparent border-r-8 border-r-blue-500"})]}),jsxRuntimeExports.jsx(motion.div,{initial:{height:0},animate:{height:96},transition:{duration:.5,delay:.8},className:"w-0.5 bg-red-500"}),jsxRuntimeExports.jsxs(motion.div,{layout:!0,initial:{opacity:0,y:20},animate:{opacity:1,y:0},transition:{duration:.5,delay:1},className:"mt-3 w-[300px] bg-white/10 backdrop-blur-md border border-white/20 rounded-xl p-4 text-white shadow-xl max-w-md",children:[jsxRuntimeExports.jsx("p",{className:"text-xs font-medium text-cyan-300 mb-2",children:"Kegunaan & Sertifikasi"}),jsxRuntimeExports.jsx("ul",{className:"text-xs space-y-1 mb-2",children:(w.usage||[]).map((Le,Ne)=>jsxRuntimeExports.jsxs("li",{className:"flex items-center gap-2",children:[jsxRuntimeExports.jsx("span",{className:"text-pink-400",children:""}),jsxRuntimeExports.jsx("span",{children:Le})]},Ne))}),jsxRuntimeExports.jsx("div",{className:"flex flex-wrap gap-1",children:(w.certifications||[]).map((Le,Ne)=>jsxRuntimeExports.jsx("span",{className:"text-[10px] px-2 py-0.5 bg-cyan-500/20 rounded-full text-cyan-100",children:Le},Ne))})]}),jsxRuntimeExports.jsx("div",{className:"absolute -inset-6 bg-cyan-500/20 rounded-full blur-3xl opacity-50",style:{zIndex:-1,transform:"translateZ(-10px)"}})]})})]})}),jsxRuntimeExports.jsx("div",{className:"w-full absolute top-4 px-4 z-50",children:jsxRuntimeExports.jsx("div",{className:"max-w-[94vw] mx-auto backdrop-blur-xl bg-white/10 border border-white/20 rounded-2xl p-2 shadow-2xl pointer-events-auto",children:jsxRuntimeExports.jsxs("div",{className:"flex items-center justify-between gap-3",children:[jsxRuntimeExports.jsxs("div",{className:"flex items-center gap-2 bg-white/10 backdrop-blur-xl border border-white/20 rounded-md py-1.5 px-3",children:[jsxRuntimeExports.jsx(Zap,{className:"w-4 h-4 text-cyan-400 animate-pulse"}),jsxRuntimeExports.jsx("span",{className:"md:flex hidden text-white font-medium text-xs md:text-sm",children:Re?"AR Mode Aktif":"Preview 3D"}),jsxRuntimeExports.jsx("span",{className:"flex md:hidden text-white font-medium text-xs md:text-sm",children:Re?"AR Mode Aktif":"Preview"}),jsxRuntimeExports.jsx("span",{className:"md:flex hidden text-white font-medium text-xs md:text-sm truncate max-w-[140px]",children:w?.name?be(w.name):"Model 3D"})]}),jsxRuntimeExports.jsxs("div",{className:"flex items-center gap-3",children:[jsxRuntimeExports.jsx(AnimatePresence,{mode:"wait",children:q?jsxRuntimeExports.jsx(motion.div,{initial:{scale:.9},animate:{scale:1},className:"cursor-pointer hover:scale-103 hover:brightness-95 bg-gradient-to-r from-cyan-500 to-blue-600 text-white py-2 px-4 rounded-full text-xs md:text-sm flex items-center gap-1.5",children:jsxRuntimeExports.jsx("div",{className:"w-3.5 h-3.5 border-2 border-white/30 border-t-white rounded-full animate-spin"})},"loading"):U==="failed"?jsxRuntimeExports.jsxs(motion.div,{initial:{y:10},animate:{y:0},className:"bg-red-600 text-white py-2 px-4 rounded-full text-xs md:text-sm flex items-center gap-1.5",children:[jsxRuntimeExports.jsx(Info,{className:"w-3.5 h-3.5"})," AR Gagal"]},"error"):Re?jsxRuntimeExports.jsxs(motion.button,{initial:{y:10},animate:{y:0},onClick:()=>window.history.back(),className:"cursor-pointer hover:scale-103 hover:brightness-95 bg-gradient-to-r from-red-500 to-pink-600 text-white py-2 px-4 rounded-full text-xs md:text-sm flex items-center gap-1.5",children:[jsxRuntimeExports.jsx(Camera,{className:"w-3.5 h-3.5"})," ",jsxRuntimeExports.jsx("span",{className:"hidden md:inline",children:"Keluar AR"})]},"exit"):jsxRuntimeExports.jsxs(motion.button,{initial:{y:10},animate:{y:0},onClick:Se,className:"h-[40px] w-[40px] md:w-max cursor-pointer hover:scale-103 hover:brightness-95 bg-gradient-to-r from-cyan-500 to-blue-600 text-white md:py-2 md:px-4 justify-center rounded-full text-xs md:text-sm flex items-center gap-1.5",children:[jsxRuntimeExports.jsx(Box,{className:"w-4 md:w-3.5 h-4 md:h-3.5"})," ",jsxRuntimeExports.jsx("span",{className:"hidden md:inline",children:"Masuk AR"})]},"start")}),jsxRuntimeExports.jsx(motion.button,{initial:{scale:0},animate:{scale:1},transition:{delay:.1},onClick:D,className:"cursor-pointer hover:scale-103 hover:brightness-95 p-2.5 bg-white/10 backdrop-blur-md border border-white/30 text-white rounded-full",children:jsxRuntimeExports.jsx(House,{className:"w-4 h-4"})}),jsxRuntimeExports.jsx(motion.button,{initial:{scale:0},animate:{scale:1},transition:{delay:.2},onClick:Me,disabled:ie,className:"cursor-pointer hover:scale-103 hover:brightness-95 p-2.5 bg-gradient-to-r from-emerald-500 to-teal-600 text-white rounded-full disabled:opacity-50",children:ie?jsxRuntimeExports.jsx("div",{className:"w-4 h-4 border-2 border-white/30 border-t-white rounded-full animate-spin"}):jsxRuntimeExports.jsx(Download,{className:"w-4 h-4"})}),jsxRuntimeExports.jsxs("div",{className:"relative",children:[jsxRuntimeExports.jsx(motion.button,{initial:{scale:0},animate:{scale:1},transition:{delay:.3},onClick:()=>le(!se),className:"cursor-pointer hover:scale-103 hover:brightness-95 p-2.5 bg-gradient-to-r from-purple-500 to-pink-600 text-white rounded-full",children:jsxRuntimeExports.jsx(Share2,{className:"w-4 h-4"})}),jsxRuntimeExports.jsx(AnimatePresence,{children:se&&jsxRuntimeExports.jsxs(motion.div,{initial:{opacity:0,y:-8},animate:{opacity:1,y:0},exit:{opacity:0,y:-8},className:"absolute top-[150%] right-0 w-40 bg-white/20 backdrop-blur-xl border border-white/30 rounded-xl shadow-xl z-50 text-xs",children:[jsxRuntimeExports.jsxs("button",{onClick:Ee,className:"w-full px-3 py-2.5 flex items-center gap-2 text-white hover:bg-white/20",children:[W==="copied"?jsxRuntimeExports.jsx(Check,{className:"w-3.5 h-3.5 text-green-400"}):jsxRuntimeExports.jsx(Link,{className:"w-3.5 h-3.5"}),W==="copied"?"Tersalin!":"Salin Link"]}),jsxRuntimeExports.jsxs("button",{onClick:we,className:"w-full px-3 py-2.5 flex items-center gap-2 text-white hover:bg-white/20 border-t border-white/20",children:[jsxRuntimeExports.jsx("svg",{className:"w-3.5 h-3.5",viewBox:"0 0 24 24",fill:"currentColor",children:jsxRuntimeExports.jsx("path",{d:"M17.472 14.382c-.297-.149-1.758-.867-2.03-.967-.273-.099-.471-.148-.67.15-.197.297-.767.966-.94 1.164-.173.199-.347.223-.644.075-.297-.15-1.255-.463-2.39-1.475-.883-.788-1.48-1.761-1.653-2.059-.173-.297-.018-.458.13-.606.134-.133.298-.347.446-.52.149-.174.198-.298.298-.497.099-.198.05-.371-.025-.52-.075-.149-.669-1.612-.916-2.207-.242-.579-.487-.5-.669-.51-.173-.008-.371-.01-.57-.01-.198 0-.52.074-.792.372-.272.297-1.04 1.016-1.04 2.479 0 1.462 1.065 2.875 1.213 3.074.149.198 2.096 3.2 5.077 4.487.709.306 1.262.489 1.694.626.712.227 1.36.195 1.871.118.571-.085 1.758-.719 2.006-1.413.248-.694.248-1.289.173-1.413-.074-.124-.272-.198-.57-.347m-5.421 7.403h-.004a9.87 9.87 0 01-5.031-1.378l-.361-.214-3.741.982.998-3.648-.235-.374a9.86 9.86 0 01-1.51-5.26c.001-5.45 4.436-9.884 9.888-9.884 2.64 0 5.122 1.03 6.988 2.898a9.825 9.825 0 012.893 6.994c-.003 5.45-4.437 9.884-9.885 9.884m8.413-18.297A11.815 11.815 0 0012.05 0C5.495 0 .16 5.335.157 11.892c0 2.096.547 4.142 1.588 5.945L.057 24l6.305-1.654a11.882 11.882 0 005.683 1.448h.005c6.554 0 11.89-5.335 11.893-11.893A11.821 11.821 0 0020.884 3.488"})}),"WhatsApp"]})]})})]})]})]})})})]})}const API_DATA=[{filename:"toilet.glb",name:"toilet",size:6602832,sizeFormatted:"6.3 MB",fullUrl:"https://vr.kiraproject.id/models/toilet.glb",description:"Model 3D toilet modern dengan detail keramik dan fitting premium.",desc_left:{title:"Fungsi Utama",list:["Sistem flush otomatis dengan sensor inframerah","Desain anti-splash untuk kebersihan maksimal","Pemanas dudukan otomatis untuk kenyamanan","Mode hemat air (dual flush 3L/6L)"]},desc_right:{title:"Tujuan Penggunaan",value:`Toilet pintar untuk higienis & nyaman.
Tanpa sentuhan, bebas kuman.
Hemat air hingga 50%.
Cocok untuk rumah mewah & hotel bintang 5.`},system:"Smart Flush System v3.0",benefits:["Hemat air 50%","Bebas sentuhan","Pemanas dudukan","Bidet otomatis","Anti-bakteri UV"],usage:["Rumah mewah","Hotel bintang 5","Rumah sakit","Apartemen premium"],certifications:["SNI","WaterSense","ISO 9001","Green Product"],tags:["higienis","hemat","premium","smart home","luxury"]},{filename:"shoe.glb",name:"shoe",size:8947140,sizeFormatted:"8.53 MB",fullUrl:"https://vr.kiraproject.id/models/shoe.glb",description:"Sepatu sneaker high-res dengan tekstur kulit dan sol karet.",desc_left:{title:"Fitur Unggulan",list:["Upper berbahan kulit premium tahan air & gores","Sol karet anti-slip dengan pola grip 3D","Insole memory foam dengan ventilasi udara","Tali elastis anti-kendor + quick-lace system"]},desc_right:{title:"Dirancang Untuk",value:`Gaya hidup aktif di kota.
Stylish tapi tetap nyaman.
Tahan air, anti-slip.
Ideal untuk daily commute & jogging.`},system:"FlexGrip Technology",benefits:["Tahan air 100%","Anti-slip","Memory foam","Quick-lace","Breathable mesh"],usage:["Jogging","Daily commute","Outdoor adventure","Gym"],certifications:["ISO 20345","EcoTex 100","Vegan Certified"],tags:["daily","portable","premium","sport","outdoor"]},{filename:"TissueCosmo.glb",name:"TissueCosmo",size:70817700,sizeFormatted:"67.54 MB",fullUrl:"https://vr.kiraproject.id/models/TissueCosmo.glb",description:"Tisu wajah premium dalam kemasan Cosmo dengan efek emboss dan foil.",desc_left:{title:"Keunggulan Produk",list:["3 ply ultra-soft dengan teknologi lotion aloe vera","Tekstur emboss 3D untuk pembersihan lebih efektif","Kemasan premium dengan foil metalik & hot stamp","Aroma therapy alami (lavender & green tea)"]},desc_right:{title:"Untuk Siapa?",value:`Konsumen yang peduli kelembutan.
Kemasan elegan & premium.
Hypoallergenic, ramah kulit.
Cocok untuk hotel, spa, & rumah modern.`},system:"UltraSoft 3-Ply Technology",benefits:["Hypoallergenic","Lotion aloe vera","Emboss 3D","Aroma therapy","Biodegradable"],usage:["Hotel bintang 5","Spa & salon","Rumah modern","Hadiah perusahaan"],certifications:["FSC","Dermatest Excellent","Halal MUI","EU Ecolabel"],tags:["higienis","premium","gift","eco","luxury"]},{filename:"product-sample.glb",name:"product-sample",size:6540,sizeFormatted:"6.39 KB",fullUrl:"https://vr.kiraproject.id/models/product-sample.glb",description:"Contoh produk sederhana untuk demo AR dan rendering cepat.",desc_left:{title:"Fitur Demo",list:["Ukuran file ringan untuk loading cepat","Optimasi LOD untuk performa AR","Material PBR siap render real-time","UV mapping bersih & non-overlapping"]},desc_right:{title:"Tujuan Demo",value:`Template cepat untuk pengujian AR.
File ringan, load instan.
Cocok untuk developer & desainer.
Siap pakai di WebXR.`},system:"Demo Template v1",benefits:["File ringan","Loading cepat","PBR ready","WebXR optimized"],usage:["Testing","Demo","Developer","Portfolio"],certifications:[],tags:["demo","lightweight","developer","template"]},{filename:"box-sample.glb",name:"box-sample",size:1664,sizeFormatted:"1.63 KB",fullUrl:"https://vr.kiraproject.id/models/box-sample.glb",description:"Kotak kemasan minimalis dengan tekstur karton dan logo timbul.",desc_left:{title:"Spesifikasi Kemasan",list:["Material karton kraft 350 GSM","Teknik emboss logo 3D dengan foil gold","Lapisan anti-minyak food-grade","Desain lipat otomatis (auto-lock bottom)"]},desc_right:{title:"Aplikasi Ideal",value:`Kemasan premium untuk kosmetik & gift.
Desain mewah, ramah lingkungan.
Mudah dirakit tanpa lem.
Tingkatkan pengalaman unboxing.`},system:"Premium Folding Box",benefits:["Emboss 3D","Foil gold","Food-safe","Eco-friendly","Easy assembly"],usage:["Kosmetik","Gift box","Makanan premium","Brand luxury"],certifications:["FSC","Food Grade","ISO 22000"],tags:["packaging","premium","gift","eco","branding"]},{filename:"astronaut.glb",name:"astronaut",size:2869044,sizeFormatted:"2.74 MB",fullUrl:"https://vr.kiraproject.id/models/astronaut.glb",description:"Astronaut dengan spacesuit detail, cocok untuk visualisasi luar angkasa.",desc_left:{title:"Detail Teknis",list:["Spacesuit berbasis NASA EMU (Extravehicular Mobility Unit)","Visor anti-reflektif dengan lapisan emas","Life support backpack dengan detail pipa oksigen","Articulated joints untuk animasi realistis"]},desc_right:{title:"Konteks Penggunaan",value:`Visualisasi edukasi luar angkasa.
Simulasi spacewalk & misi Mars.
Cocok untuk museum & VR training.
Detail akurat berbasis NASA.`},system:"NASA EMU Spacesuit Replica",benefits:["Detail NASA-accurate","PBR materials","Rigged joints","4K textures","AR/VR ready"],usage:["Edukasi","Museum","VR training","Space simulation"],certifications:["NASA Reference","PBR Standard"],tags:["space","nasa","education","vr","science"]}],orbitingModels=API_DATA,formatName=F=>F.replace(/-/g," ").replace(/_/g," ").replace(/\b\w/g,w=>w.toUpperCase());function ModelSelector({onModelSelect:F}){const[w,D]=reactExports.useState(null),[O,U]=reactExports.useState(!1),[G,q]=reactExports.useState({x:0,y:0});return reactExports.useEffect(()=>{const K=()=>U(window.innerWidth<640);K(),window.addEventListener("resize",K);const ee=Z=>{q({x:(Z.clientX/window.innerWidth-.5)*20,y:(Z.clientY/window.innerHeight-.5)*20})};return window.addEventListener("mousemove",ee),()=>{window.removeEventListener("resize",K),window.removeEventListener("mousemove",ee)}},[]),jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment,{children:[jsxRuntimeExports.jsx("div",{className:"md:min-h-screen flex items-center justify-center md:mt-20 px-4 md:p-8",children:jsxRuntimeExports.jsx("div",{className:"w-full md:w-7xl mx-auto",style:{perspective:"1600px"},children:jsxRuntimeExports.jsxs("div",{className:"h-max",style:{transformStyle:"preserve-3d"},children:[jsxRuntimeExports.jsx("div",{className:"md:flex hidden absolute bg-gradient-to-br from-slate-900 via-blue-900 to-slate-900 backdrop-blur-2xl border-2 border-cyan-700/70 rounded-full top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 z-30 pointer-events-none",style:{transform:`translateZ(160px) rotateX(${G.y*.6}deg) rotateY(${G.x*.6}deg)`,transition:"transform 0.3s ease-out"},children:jsxRuntimeExports.jsxs("div",{className:"relative w-80 h-80 sm:w-96 sm:h-96 md:w-[420px] md:h-[420px] flex items-center justify-center",children:[jsxRuntimeExports.jsx("div",{className:`absolute inset-0 rounded-full bg-gradient-to-br from-white/5 via-cyan-500/10 to-blue-600/5 \r
                                backdrop-blur-2xl border border-white/10 animate-float-subtle`,style:{boxShadow:`
                         0 8px 40px rgba(0, 0, 0, 0.4),
                         0 0 100px rgba(0, 255, 255, 0.2),
                         inset 0 0 80px rgba(255, 255, 255, 0.05)
                       `,transform:"translateZ(10px)"},children:jsxRuntimeExports.jsx("div",{className:"absolute inset-0 rounded-full opacity-0 transition-opacity duration-500",style:{background:"radial-gradient(circle at center, rgba(0, 255, 255, 0.3), transparent 70%)",opacity:w?.6:.2,filter:"blur(30px)"}})}),jsxRuntimeExports.jsx("div",{className:"absolute inset-0 flex items-center justify-center animate-spin-3d-dynamic",children:jsxRuntimeExports.jsx("div",{className:"relative w-40 h-40 sm:w-48 sm:h-48 md:w-56 md:h-56",children:jsxRuntimeExports.jsxs("svg",{viewBox:"0 0 120 120",className:"w-full h-full drop-shadow-2xl",style:{filter:"drop-shadow(0 0 20px rgba(34, 211, 238, 0.5))"},children:[jsxRuntimeExports.jsxs("defs",{children:[jsxRuntimeExports.jsxs("linearGradient",{id:"polyGradient",x1:"0%",y1:"0%",x2:"100%",y2:"100%",children:[jsxRuntimeExports.jsx("stop",{offset:"0%",stopColor:"#67e8f9"}),jsxRuntimeExports.jsx("stop",{offset:"50%",stopColor:"#22d3ee"}),jsxRuntimeExports.jsx("stop",{offset:"100%",stopColor:"#0284c7"})]}),jsxRuntimeExports.jsxs("filter",{id:"polyGlow",children:[jsxRuntimeExports.jsx("feGaussianBlur",{stdDeviation:"8",result:"blur"}),jsxRuntimeExports.jsx("feFlood",{floodColor:"#22d3ee",floodOpacity:"0.8"}),jsxRuntimeExports.jsx("feComposite",{in2:"blur",operator:"in"}),jsxRuntimeExports.jsxs("feMerge",{children:[jsxRuntimeExports.jsx("feMergeNode",{}),jsxRuntimeExports.jsx("feMergeNode",{in:"SourceGraphic"})]})]})]}),jsxRuntimeExports.jsxs("g",{transform:"translate(60, 52)",filter:"url(#polyGlow)",className:"animate-micro-pulse",children:[jsxRuntimeExports.jsx("path",{d:"M0,-28 L24,14 L-24,14 Z",fill:"url(#polyGradient)",opacity:"0.95"}),jsxRuntimeExports.jsx("path",{d:"M0,-28 L24,14 L0,28 Z",fill:"#22d3ee",opacity:"0.75"}),jsxRuntimeExports.jsx("path",{d:"M0,-28 L-24,14 L0,28 Z",fill:"#06b6d4",opacity:"0.7"}),jsxRuntimeExports.jsx("path",{d:"M-24,14 L24,14 L0,28 Z",fill:"url(#polyGradient)",opacity:"0.85"})]})]})})}),jsxRuntimeExports.jsxs("div",{className:"absolute top-[65%] left-1/2 -translate-x-1/2 text-center animate-text-float",children:[jsxRuntimeExports.jsx("h1",{className:"text-white font-600 text-3xl sm:text-4xl md:text-3xl tracking-[0.3em]",style:{textShadow:"0 2px 12px rgba(0,0,0,0.4)"},children:"COSMO"}),jsxRuntimeExports.jsx("p",{className:"text-white/80 font-light text-sm sm:text-base tracking-widest mt-2",children:"3D/AR MODELS"})]}),jsxRuntimeExports.jsx("div",{className:"absolute inset-0 rounded-full overflow-hidden opacity-15",children:jsxRuntimeExports.jsx("div",{className:`h-full w-full bg-gradient-to-b from-transparent via-white/10 to-transparent \r
                                  animate-subtle-scan`,style:{backgroundSize:"100% 200%"}})})]})}),O?jsxRuntimeExports.jsx("div",{className:"grid grid-cols-2 gap-4 sm:gap-6 max-w-md mx-auto mt-12 sm:mt-40",children:orbitingModels.map(K=>{const ee=w===K.filename;return jsxRuntimeExports.jsx("button",{onClick:()=>F(K),onTouchStart:()=>D(K.filename),onTouchEnd:()=>D(null),className:"w-full aspect-square group touch-manipulation",children:jsxRuntimeExports.jsxs("div",{className:"relative cursor-pointer w-full h-full bg-gradient-to-br from-slate-900 via-blue-900 to-slate-900 backdrop-blur-2xl rounded-3xl border border-cyan-400/50 overflow-hidden",style:{boxShadow:ee?"0 0 70px rgba(0, 255, 255, 0.3), 0 20px 40px rgba(0, 0, 0, 0.3)":"0 0 30px rgba(0, 255, 255, 0.2), 0 10px 20px rgba(0, 0, 0, 0.4)",transform:"translateZ(40px)"},children:[jsxRuntimeExports.jsx("div",{className:"absolute inset-0 opacity-30",children:jsxRuntimeExports.jsx("div",{className:"h-full w-full bg-gradient-to-b from-transparent via-cyan-300/20 to-transparent animate-card-scan-slow",style:{backgroundSize:"100% 300%"}})}),jsxRuntimeExports.jsx("div",{className:"relative top-[-26px] md:top-0 flex items-center justify-center h-full",children:jsxRuntimeExports.jsx(Box,{size:40,className:`text-cyan-300 ${ee?"text-cyan-100":""} drop-shadow-2xl`})}),jsxRuntimeExports.jsxs("div",{className:"absolute bottom-0 left-0 right-0 py-4 p-3 bg-gradient-to-t from-black/90 via-black/60 to-transparent backdrop-blur-sm",children:[jsxRuntimeExports.jsx("p",{className:"text-cyan-100 font-bold text-xs sm:text-sm tracking-wider text-center",children:formatName(K.name)}),jsxRuntimeExports.jsx("p",{className:"text-cyan-300 text-xs text-center mt-1 opacity-80",children:K.sizeFormatted})]}),jsxRuntimeExports.jsx("div",{className:`absolute inset-0 rounded-3xl opacity-0 ${ee?"opacity-100":""} transition-opacity pointer-events-none`,style:{background:"radial-gradient(circle at 50% 30%, rgba(0, 255, 255, 0.6), transparent 60%)",filter:"blur(25px)",animation:ee?"pulse-glow 2s infinite":"none"}})]})},K.filename)})}):orbitingModels.map((K,ee)=>{const Z=orbitingModels.length,ie=ee*360/Z,Y=window.innerWidth<768?260:380,W=Math.cos(ie*Math.PI/180)*Y,ne=Math.sin(ie*Math.PI/180)*Y,se=w===K.filename;return jsxRuntimeExports.jsx("button",{onClick:()=>F(K),onMouseEnter:()=>D(K.filename),onMouseLeave:()=>D(null),className:"absolute cursor-pointer top-1/2 left-1/2 w-50 h-50 group",style:{transform:`
                        translate(-50%, -50%) 
                        translateX(${W}px) 
                        translateY(${ne}px) 
                        translateZ(${se?50:30}px) 
                        rotateY(${se?5:0}deg) 
                        rotateX(${se?-10:0}deg)
                      `,transformStyle:"preserve-3d",transition:"all 0.8s cubic-bezier(0.175, 0.885, 0.32, 1.2)"},children:jsxRuntimeExports.jsxs("div",{className:"relative w-full h-full bg-gradient-to-br from-slate-900 via-blue-900 to-slate-900 backdrop-blur-2xl rounded-3xl border border-cyan-400/50 overflow-hidden",style:{boxShadow:se?"0 0 90px rgba(0, 255, 255, 0.3), 0 35px 70px rgba(0, 0, 0, 0.2)":"0 0 35px rgba(0, 255, 255, 0.3), 0 15px 35px rgba(0, 0, 0, 0.5)",transform:"translateZ(60px)"},children:[jsxRuntimeExports.jsx("div",{className:"absolute inset-0 opacity-30",children:jsxRuntimeExports.jsx("div",{className:"h-full w-full bg-gradient-to-b from-transparent via-cyan-300/20 to-transparent animate-card-scan-slow",style:{backgroundSize:"100% 300%"}})}),jsxRuntimeExports.jsx("div",{className:"relative top-[-30px] flex items-center justify-center h-full z-10",children:jsxRuntimeExports.jsx(motion.div,{animate:{rotate:360},transition:{duration:20,repeat:1/0,ease:"linear"},children:jsxRuntimeExports.jsx(Box,{size:80,className:"text-cyan-400 drop-shadow-glow"})})}),jsxRuntimeExports.jsxs("div",{className:"absolute bottom-0 left-0 right-0 p-5 bg-gradient-to-t from-black/90 via-black/60 to-transparent backdrop-blur-sm",children:[jsxRuntimeExports.jsx("p",{className:"text-cyan-100 font-bold text-md mx-auto text-center tracking-widest drop-shadow-lg",children:formatName(K.name)}),jsxRuntimeExports.jsx("p",{className:"text-cyan-300 text-sm text-center mt-1 opacity-80",children:K.sizeFormatted})]}),jsxRuntimeExports.jsx("div",{className:`absolute inset-0 rounded-3xl opacity-0 ${se?"opacity-100":""} transition-opacity pointer-events-none`,style:{background:"radial-gradient(circle at 50% 30%, rgba(0, 255, 255, 0.7), transparent 60%)",filter:"blur(35px)",animation:se?"pulse-glow 2s infinite":"none"}})]})},K.filename)})]})})}),jsxRuntimeExports.jsx("style",{dangerouslySetInnerHTML:{__html:`
            @keyframes card-scan-slow {
              0%, 100% { background-position: 0% 0%; }
              50% { background-position: 0% 100%; }
            }
            @keyframes pulse-glow {
              0%, 100% { opacity: 0.6; }
              50% { opacity: 1; }
            }
            .animate-card-scan-slow { animation: card-scan-slow 6s infinite linear; }
            .animate-pulse-glow { animation: pulse-glow 2s infinite; }
          `}})]})}function UnityARViewer({onBack:F}){const w=reactExports.useRef(null),[D,O]=reactExports.useState(!1);return reactExports.useEffect(()=>{const U=G=>{G.data.type==="UNITY_LOADED"&&O(!0)};return window.addEventListener("message",U),()=>window.removeEventListener("message",U)},[]),jsxRuntimeExports.jsxs(motion.div,{initial:{opacity:0},animate:{opacity:1},exit:{opacity:0},className:"fixed inset-0 z-50 bg-black",children:[jsxRuntimeExports.jsxs("div",{className:"absolute top-0 left-0 right-0 z-10 p-4 flex justify-between items-center bg-gradient-to-b from-black/80 to-transparent",children:[jsxRuntimeExports.jsx("button",{onClick:F,className:"p-2.5 rounded-full bg-white/10 hover:bg-white/20 backdrop-blur-md transition-all",children:jsxRuntimeExports.jsx(ArrowLeft,{className:"w-6 h-6 text-cyan-400"})}),jsxRuntimeExports.jsx("h2",{className:"text-lg font-bold text-cyan-300",children:"AR Unity Mode"}),jsxRuntimeExports.jsx("div",{className:"w-10"})]}),!D&&jsxRuntimeExports.jsxs("div",{className:"absolute inset-0 flex flex-col items-center justify-center gap-6 bg-gradient-to-br from-slate-950 to-cyan-950",children:[jsxRuntimeExports.jsx("div",{className:"w-32 h-32 border-4 border-cyan-500/30 border-t-cyan-400 rounded-full animate-spin"}),jsxRuntimeExports.jsx("p",{className:"text-cyan-300 font-medium",children:"Memuat AR..."}),jsxRuntimeExports.jsx("p",{className:"text-sm text-cyan-400/70",children:"Izinkan kamera"})]}),jsxRuntimeExports.jsx("iframe",{ref:w,src:"/ar.html",className:"absolute inset-0 w-full h-full border-0",allow:"camera; gyroscope; accelerometer; magnetometer; xr-spatial-tracking",style:{display:D?"block":"none"}})]})}function dispatchCallback(F,w){F&&F(w)}function reverseDictionary(F){return Object.fromEntries(Object.entries(F).map(([w,D])=>[D,w]))}function escapeRegExp(F){return F.replace(/[.*+?^${}()|[\]\\]/g,"\\$&")}const Callable=class{constructor(){let F=function(...w){return F._call(...w)};return Object.setPrototypeOf(F,new.target.prototype)}_call(...F){throw Error("Must implement _call method in subclass")}};function isTypedArray(F){return F?.prototype?.__proto__?.constructor?.name==="TypedArray"}function isIntegralNumber(F){return Number.isInteger(F)||typeof F=="bigint"}function exists(F){return F!=null}function calculateDimensions(F){const w=[];let D=F;for(;Array.isArray(D);)w.push(D.length),D=D[0];return w}function pop(F,w,D=void 0){const O=F[w];if(O!==void 0)return delete F[w],O;if(D===void 0)throw Error(`Key ${w} does not exist in object.`);return D}function mergeArrays(...F){return Array.prototype.concat.apply([],F)}function product(...F){return F.reduce((w,D)=>w.flatMap(O=>D.map(U=>[O,U])))}function calculateReflectOffset(F,w){return Math.abs((F+w)%(2*w)-w)}const sharp={},ONNX_NODE=Object.freeze(Object.defineProperty({__proto__:null,default:sharp},Symbol.toStringTag,{value:"Module"}));var ortWeb_min$1={exports:{}};const backends={},backendsSortedByPriority=[],registerBackend=(F,w,D)=>{if(w&&typeof w.init=="function"&&typeof w.createSessionHandler=="function"){const O=backends[F];if(O===void 0)backends[F]={backend:w,priority:D};else{if(O.priority>D)return;if(O.priority===D&&O.backend!==w)throw new Error(`cannot register backend "${F}" using priority ${D}`)}if(D>=0){const U=backendsSortedByPriority.indexOf(F);U!==-1&&backendsSortedByPriority.splice(U,1);for(let G=0;G<backendsSortedByPriority.length;G++)if(backends[backendsSortedByPriority[G]].priority<=D){backendsSortedByPriority.splice(G,0,F);return}backendsSortedByPriority.push(F)}return}throw new TypeError("not a valid backend")},resolveBackend=async F=>{const w=F.length===0?backendsSortedByPriority:F,D=[];for(const O of w){const U=backends[O];if(U){if(U.initialized)return U.backend;if(U.aborted)continue;const G=!!U.initPromise;try{return G||(U.initPromise=U.backend.init()),await U.initPromise,U.initialized=!0,U.backend}catch(q){G||D.push({name:O,err:q}),U.aborted=!0}finally{delete U.initPromise}}}throw new Error(`no available backend found. ERR: ${D.map(O=>`[${O.name}] ${O.err}`).join(", ")}`)};class EnvImpl{constructor(){this.wasm={},this.webgl={},this.logLevelInternal="warning"}set logLevel(w){if(w!==void 0){if(typeof w!="string"||["verbose","info","warning","error","fatal"].indexOf(w)===-1)throw new Error(`Unsupported logging level: ${w}`);this.logLevelInternal=w}}get logLevel(){return this.logLevelInternal}}const env$2=new EnvImpl,isBigInt64ArrayAvailable=typeof BigInt64Array<"u"&&typeof BigInt64Array.from=="function",isBigUint64ArrayAvailable=typeof BigUint64Array<"u"&&typeof BigUint64Array.from=="function",NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP=new Map([["float32",Float32Array],["uint8",Uint8Array],["int8",Int8Array],["uint16",Uint16Array],["int16",Int16Array],["int32",Int32Array],["bool",Uint8Array],["float64",Float64Array],["uint32",Uint32Array]]),NUMERIC_TENSOR_TYPEDARRAY_TO_TYPE_MAP=new Map([[Float32Array,"float32"],[Uint8Array,"uint8"],[Int8Array,"int8"],[Uint16Array,"uint16"],[Int16Array,"int16"],[Int32Array,"int32"],[Float64Array,"float64"],[Uint32Array,"uint32"]]);isBigInt64ArrayAvailable&&(NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP.set("int64",BigInt64Array),NUMERIC_TENSOR_TYPEDARRAY_TO_TYPE_MAP.set(BigInt64Array,"int64"));isBigUint64ArrayAvailable&&(NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP.set("uint64",BigUint64Array),NUMERIC_TENSOR_TYPEDARRAY_TO_TYPE_MAP.set(BigUint64Array,"uint64"));const calculateSize=F=>{let w=1;for(let D=0;D<F.length;D++){const O=F[D];if(typeof O!="number"||!Number.isSafeInteger(O))throw new TypeError(`dims[${D}] must be an integer, got: ${O}`);if(O<0)throw new RangeError(`dims[${D}] must be a non-negative integer, got: ${O}`);w*=O}return w};let Tensor$2=class la{constructor(w,D,O){let U,G,q;if(typeof w=="string")if(U=w,q=O,w==="string"){if(!Array.isArray(D))throw new TypeError("A string tensor's data must be a string array.");G=D}else{const ee=NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP.get(w);if(ee===void 0)throw new TypeError(`Unsupported tensor type: ${w}.`);if(Array.isArray(D))G=ee.from(D);else if(D instanceof ee)G=D;else throw new TypeError(`A ${U} tensor's data must be type of ${ee}`)}else if(q=D,Array.isArray(w)){if(w.length===0)throw new TypeError("Tensor type cannot be inferred from an empty array.");const ee=typeof w[0];if(ee==="string")U="string",G=w;else if(ee==="boolean")U="bool",G=Uint8Array.from(w);else throw new TypeError(`Invalid element type of data array: ${ee}.`)}else{const ee=NUMERIC_TENSOR_TYPEDARRAY_TO_TYPE_MAP.get(w.constructor);if(ee===void 0)throw new TypeError(`Unsupported type for tensor data: ${w.constructor}.`);U=ee,G=w}if(q===void 0)q=[G.length];else if(!Array.isArray(q))throw new TypeError("A tensor's dims must be a number array");const K=calculateSize(q);if(K!==G.length)throw new Error(`Tensor's size(${K}) does not match data length(${G.length}).`);this.dims=q,this.type=U,this.data=G,this.size=K}static bufferToTensor(w,D){if(w===void 0)throw new Error("Image buffer must be defined");if(D.height===void 0||D.width===void 0)throw new Error("Image height and width must be defined");const{height:O,width:U}=D,G=D.norm;let q,K;G===void 0||G.mean===void 0?q=255:q=G.mean,G===void 0||G.bias===void 0?K=0:K=G.bias;const ee=D.bitmapFormat!==void 0?D.bitmapFormat:"RGBA",Z=D.tensorFormat!==void 0&&D.tensorFormat!==void 0?D.tensorFormat:"RGB",ie=O*U,Y=Z==="RGBA"?new Float32Array(ie*4):new Float32Array(ie*3);let W=4,ne=0,se=1,le=2,ce=3,he=0,pe=ie,me=ie*2,be=-1;ee==="RGB"&&(W=3,ne=0,se=1,le=2,ce=-1),Z==="RGBA"?be=ie*3:Z==="RBG"?(he=0,me=ie,pe=ie*2):Z==="BGR"&&(me=0,pe=ie,he=ie*2);for(let ve=0;ve<ie;ve++,ne+=W,le+=W,se+=W,ce+=W)Y[he++]=(w[ne]+K)/q,Y[pe++]=(w[se]+K)/q,Y[me++]=(w[le]+K)/q,be!==-1&&ce!==-1&&(Y[be++]=(w[ce]+K)/q);return Z==="RGBA"?new la("float32",Y,[1,4,O,U]):new la("float32",Y,[1,3,O,U])}static async fromImage(w,D){const O=typeof HTMLImageElement<"u"&&w instanceof HTMLImageElement,U=typeof ImageData<"u"&&w instanceof ImageData,G=typeof ImageBitmap<"u"&&w instanceof ImageBitmap,q=typeof String<"u"&&(w instanceof String||typeof w=="string");let K,ee={};if(O){const Z=document.createElement("canvas"),ie=Z.getContext("2d");if(ie!=null){let Y=w.naturalHeight,W=w.naturalWidth;if(D!==void 0&&D.resizedHeight!==void 0&&D.resizedWidth!==void 0&&(Y=D.resizedHeight,W=D.resizedWidth),D!==void 0){if(ee=D,D.tensorFormat!==void 0)throw new Error("Image input config format must be RGBA for HTMLImageElement");if(ee.tensorFormat="RGBA",D.height!==void 0&&D.height!==Y)throw new Error("Image input config height doesn't match HTMLImageElement height");if(ee.height=Y,D.width!==void 0&&D.width!==W)throw new Error("Image input config width doesn't match HTMLImageElement width");ee.width=W}else ee.tensorFormat="RGBA",ee.height=Y,ee.width=W;Z.width=W,Z.height=Y,ie.drawImage(w,0,0,W,Y),K=ie.getImageData(0,0,W,Y).data}else throw new Error("Can not access image data")}else if(U){const Z="RGBA";let ie,Y;if(D!==void 0&&D.resizedWidth!==void 0&&D.resizedHeight!==void 0?(ie=D.resizedHeight,Y=D.resizedWidth):(ie=w.height,Y=w.width),D!==void 0){if(ee=D,D.bitmapFormat!==void 0&&D.bitmapFormat!==Z)throw new Error("Image input config format must be RGBA for ImageData");ee.bitmapFormat="RGBA"}else ee.bitmapFormat="RGBA";if(ee.height=ie,ee.width=Y,D!==void 0){const W=document.createElement("canvas");W.width=Y,W.height=ie;const ne=W.getContext("2d");if(ne!=null)ne.putImageData(w,0,0),K=ne.getImageData(0,0,Y,ie).data;else throw new Error("Can not access image data")}else K=w.data}else if(G){if(D===void 0)throw new Error("Please provide image config with format for Imagebitmap");if(D.bitmapFormat!==void 0)throw new Error("Image input config format must be defined for ImageBitmap");const Z=document.createElement("canvas").getContext("2d");if(Z!=null){const ie=w.height,Y=w.width;if(Z.drawImage(w,0,0,Y,ie),K=Z.getImageData(0,0,Y,ie).data,D!==void 0){if(D.height!==void 0&&D.height!==ie)throw new Error("Image input config height doesn't match ImageBitmap height");if(ee.height=ie,D.width!==void 0&&D.width!==Y)throw new Error("Image input config width doesn't match ImageBitmap width");ee.width=Y}else ee.height=ie,ee.width=Y;return la.bufferToTensor(K,ee)}else throw new Error("Can not access image data")}else{if(q)return new Promise((Z,ie)=>{const Y=document.createElement("canvas"),W=Y.getContext("2d");if(!w||!W)return ie();const ne=new Image;ne.crossOrigin="Anonymous",ne.src=w,ne.onload=()=>{Y.width=ne.width,Y.height=ne.height,W.drawImage(ne,0,0,Y.width,Y.height);const se=W.getImageData(0,0,Y.width,Y.height);if(D!==void 0){if(D.height!==void 0&&D.height!==Y.height)throw new Error("Image input config height doesn't match ImageBitmap height");if(ee.height=Y.height,D.width!==void 0&&D.width!==Y.width)throw new Error("Image input config width doesn't match ImageBitmap width");ee.width=Y.width}else ee.height=Y.height,ee.width=Y.width;Z(la.bufferToTensor(se.data,ee))}});throw new Error("Input data provided is not supported - aborted tensor creation")}if(K!==void 0)return la.bufferToTensor(K,ee);throw new Error("Input data provided is not supported - aborted tensor creation")}toImageData(w){var D,O;const U=document.createElement("canvas").getContext("2d");let G;if(U!=null){const q=this.dims[3],K=this.dims[2],ee=this.dims[1],Z=w!==void 0&&w.format!==void 0?w.format:"RGB",ie=w!==void 0&&((D=w.norm)===null||D===void 0?void 0:D.mean)!==void 0?w.norm.mean:255,Y=w!==void 0&&((O=w.norm)===null||O===void 0?void 0:O.bias)!==void 0?w.norm.bias:0,W=K*q;if(w!==void 0){if(w.height!==void 0&&w.height!==K)throw new Error("Image output config height doesn't match tensor height");if(w.width!==void 0&&w.width!==q)throw new Error("Image output config width doesn't match tensor width");if(w.format!==void 0&&ee===4&&w.format!=="RGBA"||ee===3&&w.format!=="RGB"&&w.format!=="BGR")throw new Error("Tensor format doesn't match input tensor dims")}const ne=4;let se=0,le=1,ce=2,he=3,pe=0,me=W,be=W*2,ge=-1;Z==="RGBA"?(pe=0,me=W,be=W*2,ge=W*3):Z==="RGB"?(pe=0,me=W,be=W*2):Z==="RBG"&&(pe=0,be=W,me=W*2),G=U.createImageData(q,K);for(let ve=0;ve<K*q;se+=ne,le+=ne,ce+=ne,he+=ne,ve++)G.data[se]=(this.data[pe++]-Y)*ie,G.data[le]=(this.data[me++]-Y)*ie,G.data[ce]=(this.data[be++]-Y)*ie,G.data[he]=ge===-1?255:(this.data[ge++]-Y)*ie}else throw new Error("Can not access image data");return G}reshape(w){return new la(this.type,this.data,w)}};const Tensor$1=Tensor$2;let InferenceSession$2=class bp{constructor(w){this.handler=w}async run(w,D,O){const U={};let G={};if(typeof w!="object"||w===null||w instanceof Tensor$1||Array.isArray(w))throw new TypeError("'feeds' must be an object that use input names as keys and OnnxValue as corresponding values.");let q=!0;if(typeof D=="object"){if(D===null)throw new TypeError("Unexpected argument[1]: cannot be null.");if(D instanceof Tensor$1)throw new TypeError("'fetches' cannot be a Tensor");if(Array.isArray(D)){if(D.length===0)throw new TypeError("'fetches' cannot be an empty array.");q=!1;for(const Z of D){if(typeof Z!="string")throw new TypeError("'fetches' must be a string array or an object.");if(this.outputNames.indexOf(Z)===-1)throw new RangeError(`'fetches' contains invalid output name: ${Z}.`);U[Z]=null}if(typeof O=="object"&&O!==null)G=O;else if(typeof O<"u")throw new TypeError("'options' must be an object.")}else{let Z=!1;const ie=Object.getOwnPropertyNames(D);for(const Y of this.outputNames)if(ie.indexOf(Y)!==-1){const W=D[Y];(W===null||W instanceof Tensor$1)&&(Z=!0,q=!1,U[Y]=W)}if(Z){if(typeof O=="object"&&O!==null)G=O;else if(typeof O<"u")throw new TypeError("'options' must be an object.")}else G=D}}else if(typeof D<"u")throw new TypeError("Unexpected argument[1]: must be 'fetches' or 'options'.");for(const Z of this.inputNames)if(typeof w[Z]>"u")throw new Error(`input '${Z}' is missing in 'feeds'.`);if(q)for(const Z of this.outputNames)U[Z]=null;const K=await this.handler.run(w,U,G),ee={};for(const Z in K)Object.hasOwnProperty.call(K,Z)&&(ee[Z]=new Tensor$1(K[Z].type,K[Z].data,K[Z].dims));return ee}static async create(w,D,O,U){let G,q={};if(typeof w=="string"){if(G=w,typeof D=="object"&&D!==null)q=D;else if(typeof D<"u")throw new TypeError("'options' must be an object.")}else if(w instanceof Uint8Array){if(G=w,typeof D=="object"&&D!==null)q=D;else if(typeof D<"u")throw new TypeError("'options' must be an object.")}else if(w instanceof ArrayBuffer||typeof SharedArrayBuffer<"u"&&w instanceof SharedArrayBuffer){const Y=w;let W=0,ne=w.byteLength;if(typeof D=="object"&&D!==null)q=D;else if(typeof D=="number"){if(W=D,!Number.isSafeInteger(W))throw new RangeError("'byteOffset' must be an integer.");if(W<0||W>=Y.byteLength)throw new RangeError(`'byteOffset' is out of range [0, ${Y.byteLength}).`);if(ne=w.byteLength-W,typeof O=="number"){if(ne=O,!Number.isSafeInteger(ne))throw new RangeError("'byteLength' must be an integer.");if(ne<=0||W+ne>Y.byteLength)throw new RangeError(`'byteLength' is out of range (0, ${Y.byteLength-W}].`);if(typeof U=="object"&&U!==null)q=U;else if(typeof U<"u")throw new TypeError("'options' must be an object.")}else if(typeof O<"u")throw new TypeError("'byteLength' must be a number.")}else if(typeof D<"u")throw new TypeError("'options' must be an object.");G=new Uint8Array(Y,W,ne)}else throw new TypeError("Unexpected argument[0]: must be 'path' or 'buffer'.");const ee=(q.executionProviders||[]).map(Y=>typeof Y=="string"?Y:Y.name),ie=await(await resolveBackend(ee)).createSessionHandler(G,q);return new bp(ie)}startProfiling(){this.handler.startProfiling()}endProfiling(){this.handler.endProfiling()}get inputNames(){return this.handler.inputNames}get outputNames(){return this.handler.outputNames}};const InferenceSession$1=InferenceSession$2,lib=Object.freeze(Object.defineProperty({__proto__:null,InferenceSession:InferenceSession$1,Tensor:Tensor$1,env:env$2,registerBackend},Symbol.toStringTag,{value:"Module"})),require$$0=getAugmentedNamespace(lib);/*!
* ONNX Runtime Web v1.14.0
* Copyright (c) Microsoft Corporation. All rights reserved.
* Licensed under the MIT License.
*/var hasRequiredOrtWeb_min;function requireOrtWeb_min(){return hasRequiredOrtWeb_min||(hasRequiredOrtWeb_min=1,(function(module,exports){(function(F,w){module.exports=w(require$$0)})(self,(__WEBPACK_EXTERNAL_MODULE__1670__=>(()=>{var __webpack_modules__={3474:(F,w,D)=>{var O,U=(O=(O=typeof document<"u"&&document.currentScript?document.currentScript.src:void 0)||"/index.js",function(G){function q(){return Xe.buffer!=ke&&vn(Xe.buffer),rt}function K(){return Xe.buffer!=ke&&vn(Xe.buffer),St}function ee(){return Xe.buffer!=ke&&vn(Xe.buffer),Lt}function Z(){return Xe.buffer!=ke&&vn(Xe.buffer),$t}function ie(){return Xe.buffer!=ke&&vn(Xe.buffer),mt}var Y,W,ne;G=G||{},Y||(Y=G!==void 0?G:{}),Y.ready=new Promise((function(De,$e){W=De,ne=$e}));var se,le,ce,he,pe,me,be=Object.assign({},Y),ge="./this.program",ve=(De,$e)=>{throw $e},Se=typeof window=="object",Me=typeof importScripts=="function",Ee=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string",we=Y.ENVIRONMENT_IS_PTHREAD||!1,Re="";function Le(De){return Y.locateFile?Y.locateFile(De,Re):Re+De}if(Ee){let De;Re=Me?D(908).dirname(Re)+"/":"//",me=()=>{pe||(he=D(1384),pe=D(908))},se=function($e,Ye){return me(),$e=pe.normalize($e),he.readFileSync($e,Ye?void 0:"utf8")},ce=$e=>(($e=se($e,!0)).buffer||($e=new Uint8Array($e)),$e),le=($e,Ye,ot)=>{me(),$e=pe.normalize($e),he.readFile($e,(function(Tt,Pt){Tt?ot(Tt):Ye(Pt.buffer)}))},1<process.argv.length&&(ge=process.argv[1].replace(/\\/g,"/")),process.argv.slice(2),process.on("uncaughtException",(function($e){if(!($e instanceof Rn))throw $e})),process.on("unhandledRejection",(function($e){throw $e})),ve=($e,Ye)=>{if(li())throw process.exitCode=$e,Ye;Ye instanceof Rn||Be("exiting due to exception: "+Ye),process.exit($e)},Y.inspect=function(){return"[Emscripten Module object]"};try{De=D(9925)}catch($e){throw console.error('The "worker_threads" module is not supported in this node.js build - perhaps a newer version is needed?'),$e}D.g.Worker=De.Worker}else(Se||Me)&&(Me?Re=self.location.href:typeof document<"u"&&document.currentScript&&(Re=document.currentScript.src),O&&(Re=O),Re=Re.indexOf("blob:")!==0?Re.substr(0,Re.replace(/[?#].*/,"").lastIndexOf("/")+1):"",Ee||(se=De=>{var $e=new XMLHttpRequest;return $e.open("GET",De,!1),$e.send(null),$e.responseText},Me&&(ce=De=>{var $e=new XMLHttpRequest;return $e.open("GET",De,!1),$e.responseType="arraybuffer",$e.send(null),new Uint8Array($e.response)}),le=(De,$e,Ye)=>{var ot=new XMLHttpRequest;ot.open("GET",De,!0),ot.responseType="arraybuffer",ot.onload=()=>{ot.status==200||ot.status==0&&ot.response?$e(ot.response):Ye()},ot.onerror=Ye,ot.send(null)}));Ee&&typeof performance>"u"&&(D.g.performance=D(6953).performance);var Ne=console.log.bind(console),Oe=console.warn.bind(console);Ee&&(me(),Ne=De=>he.writeSync(1,De+`
`),Oe=De=>he.writeSync(2,De+`
`));var Pe,Ce=Y.print||Ne,Be=Y.printErr||Oe;Object.assign(Y,be),be=null,Y.thisProgram&&(ge=Y.thisProgram),Y.quit&&(ve=Y.quit),Y.wasmBinary&&(Pe=Y.wasmBinary);var ze=Y.noExitRuntime||!1;typeof WebAssembly!="object"&&pt("no native wasm support detected");var Xe,lt,ke,rt,St,Lt,$t,mt,bt=!1,Xt=typeof TextDecoder<"u"?new TextDecoder("utf8"):void 0;function hn(De,$e,Ye){var ot=($e>>>=0)+Ye;for(Ye=$e;De[Ye]&&!(Ye>=ot);)++Ye;if(16<Ye-$e&&De.buffer&&Xt)return Xt.decode(De.buffer instanceof SharedArrayBuffer?De.slice($e,Ye):De.subarray($e,Ye));for(ot="";$e<Ye;){var Tt=De[$e++];if(128&Tt){var Pt=63&De[$e++];if((224&Tt)==192)ot+=String.fromCharCode((31&Tt)<<6|Pt);else{var un=63&De[$e++];65536>(Tt=(240&Tt)==224?(15&Tt)<<12|Pt<<6|un:(7&Tt)<<18|Pt<<12|un<<6|63&De[$e++])?ot+=String.fromCharCode(Tt):(Tt-=65536,ot+=String.fromCharCode(55296|Tt>>10,56320|1023&Tt))}}else ot+=String.fromCharCode(Tt)}return ot}function Jt(De,$e){return(De>>>=0)?hn(K(),De,$e):""}function Mn(De,$e,Ye,ot){if(!(0<ot))return 0;var Tt=Ye>>>=0;ot=Ye+ot-1;for(var Pt=0;Pt<De.length;++Pt){var un=De.charCodeAt(Pt);if(55296<=un&&57343>=un&&(un=65536+((1023&un)<<10)|1023&De.charCodeAt(++Pt)),127>=un){if(Ye>=ot)break;$e[Ye++>>>0]=un}else{if(2047>=un){if(Ye+1>=ot)break;$e[Ye++>>>0]=192|un>>6}else{if(65535>=un){if(Ye+2>=ot)break;$e[Ye++>>>0]=224|un>>12}else{if(Ye+3>=ot)break;$e[Ye++>>>0]=240|un>>18,$e[Ye++>>>0]=128|un>>12&63}$e[Ye++>>>0]=128|un>>6&63}$e[Ye++>>>0]=128|63&un}}return $e[Ye>>>0]=0,Ye-Tt}function Zn(De){for(var $e=0,Ye=0;Ye<De.length;++Ye){var ot=De.charCodeAt(Ye);127>=ot?$e++:2047>=ot?$e+=2:55296<=ot&&57343>=ot?($e+=4,++Ye):$e+=3}return $e}function vn(De){ke=De,Y.HEAP8=rt=new Int8Array(De),Y.HEAP16=new Int16Array(De),Y.HEAP32=Lt=new Int32Array(De),Y.HEAPU8=St=new Uint8Array(De),Y.HEAPU16=new Uint16Array(De),Y.HEAPU32=$t=new Uint32Array(De),Y.HEAPF32=new Float32Array(De),Y.HEAPF64=mt=new Float64Array(De)}we&&(ke=Y.buffer);var In=Y.INITIAL_MEMORY||16777216;if(we)Xe=Y.wasmMemory,ke=Y.buffer;else if(Y.wasmMemory)Xe=Y.wasmMemory;else if(!((Xe=new WebAssembly.Memory({initial:In/65536,maximum:65536,shared:!0})).buffer instanceof SharedArrayBuffer))throw Be("requested a shared WebAssembly.Memory but the returned buffer is not a SharedArrayBuffer, indicating that while the browser has SharedArrayBuffer it does not have WebAssembly threads support - you may need to set a flag"),Ee&&console.log("(on node you may need: --experimental-wasm-threads --experimental-wasm-bulk-memory and also use a recent version)"),Error("bad memory");Xe&&(ke=Xe.buffer),In=ke.byteLength,vn(ke);var st,Gn=[],qn=[],ai=[],yn=[];function li(){return ze||!1}function Tn(){var De=Y.preRun.shift();Gn.unshift(De)}var En,Ke=0,Fe=null;function pt(De){throw we?postMessage({cmd:"onAbort",arg:De}):Y.onAbort&&Y.onAbort(De),Be(De="Aborted("+De+")"),bt=!0,De=new WebAssembly.RuntimeError(De+". Build with -sASSERTIONS for more info."),ne(De),De}function zt(){return En.startsWith("data:application/octet-stream;base64,")}function qt(){var De=En;try{if(De==En&&Pe)return new Uint8Array(Pe);if(ce)return ce(De);throw"both async and sync fetching of the wasm failed"}catch($e){pt($e)}}En="ort-wasm-threaded.wasm",zt()||(En=Le(En));var Nt={};function Rn(De){this.name="ExitStatus",this.message="Program terminated with exit("+De+")",this.status=De}function fn(De){(De=Dt.Vb[De])||pt(),Dt.mc(De)}function Nn(De){var $e=Dt.Cc();if(!$e)return 6;Dt.ac.push($e),Dt.Vb[De.Ub]=$e,$e.Ub=De.Ub;var Ye={cmd:"run",start_routine:De.Ic,arg:De.zc,pthread_ptr:De.Ub};return $e.$b=()=>{Ye.time=performance.now(),$e.postMessage(Ye,De.Nc)},$e.loaded&&($e.$b(),delete $e.$b),0}function An(De){if(we)return gn(1,1,De);li()||(Dt.oc(),Y.onExit&&Y.onExit(De),bt=!0),ve(De,new Rn(De))}function Wt(De,$e){if(!$e&&we)throw bn(De),"unwind";li()||we||(Lr(),Bn(ai),Bi(0),zn[1].length&&Wn(1,10),zn[2].length&&Wn(2,10),Dt.oc()),An(De)}var Dt={Yb:[],ac:[],qc:[],Vb:{},fc:function(){we&&Dt.Ec()},Pc:function(){},Ec:function(){Dt.receiveObjectTransfer=Dt.Gc,Dt.threadInitTLS=Dt.pc,Dt.setExitStatus=Dt.nc,ze=!1},nc:function(){},oc:function(){for(var De of Object.values(Dt.Vb))Dt.mc(De);for(De of Dt.Yb)De.terminate();Dt.Yb=[]},mc:function(De){var $e=De.Ub;delete Dt.Vb[$e],Dt.Yb.push(De),Dt.ac.splice(Dt.ac.indexOf(De),1),De.Ub=0,tr($e)},Gc:function(){},pc:function(){Dt.qc.forEach((De=>De()))},Fc:function(De,$e){De.onmessage=Ye=>{var ot=(Ye=Ye.data).cmd;if(De.Ub&&(Dt.Bc=De.Ub),Ye.targetThread&&Ye.targetThread!=ui()){var Tt=Dt.Vb[Ye.Qc];Tt?Tt.postMessage(Ye,Ye.transferList):Be('Internal error! Worker sent a message "'+ot+'" to target pthread '+Ye.targetThread+", but that thread no longer exists!")}else ot==="processProxyingQueue"?ft(Ye.queue):ot==="spawnThread"?Nn(Ye):ot==="cleanupThread"?fn(Ye.thread):ot==="killThread"?(Ye=Ye.thread,ot=Dt.Vb[Ye],delete Dt.Vb[Ye],ot.terminate(),tr(Ye),Dt.ac.splice(Dt.ac.indexOf(ot),1),ot.Ub=0):ot==="cancelThread"?Dt.Vb[Ye.thread].postMessage({cmd:"cancel"}):ot==="loaded"?(De.loaded=!0,$e&&$e(De),De.$b&&(De.$b(),delete De.$b)):ot==="print"?Ce("Thread "+Ye.threadId+": "+Ye.text):ot==="printErr"?Be("Thread "+Ye.threadId+": "+Ye.text):ot==="alert"?alert("Thread "+Ye.threadId+": "+Ye.text):Ye.target==="setimmediate"?De.postMessage(Ye):ot==="onAbort"?Y.onAbort&&Y.onAbort(Ye.arg):ot&&Be("worker sent an unknown command "+ot);Dt.Bc=void 0},De.onerror=Ye=>{throw Be("worker sent an error! "+Ye.filename+":"+Ye.lineno+": "+Ye.message),Ye},Ee&&(De.on("message",(function(Ye){De.onmessage({data:Ye})})),De.on("error",(function(Ye){De.onerror(Ye)})),De.on("detachedExit",(function(){}))),De.postMessage({cmd:"load",urlOrBlob:Y.mainScriptUrlOrBlob||O,wasmMemory:Xe,wasmModule:lt})},yc:function(){var De=Le("ort-wasm-threaded.worker.js");Dt.Yb.push(new Worker(De))},Cc:function(){return Dt.Yb.length==0&&(Dt.yc(),Dt.Fc(Dt.Yb[0])),Dt.Yb.pop()}};function Bn(De){for(;0<De.length;)De.shift()(Y)}function Sn(De){var $e=ni();return De=De(),ti($e),De}function bn(De){if(we)return gn(2,0,De);try{Wt(De)}catch($e){$e instanceof Rn||$e=="unwind"||ve(1,$e)}}Y.PThread=Dt,Y.establishStackSpace=function(){var De=ui(),$e=ee()[De+44>>2>>>0];De=ee()[De+48>>2>>>0],ja($e,$e-De),ti($e)};var kn=[];function nt(De){var $e=kn[De];return $e||(De>=kn.length&&(kn.length=De+1),kn[De]=$e=st.get(De)),$e}Y.invokeEntryPoint=function(De,$e){De=nt(De)($e),li()?Dt.nc(De):Mr(De)};var dn,tn,Zt=[],Bt=0,wt=0;function Qt(De){this.Zb=De,this.Sb=De-24,this.xc=function($e){Z()[this.Sb+4>>2>>>0]=$e},this.bc=function(){return Z()[this.Sb+4>>2>>>0]},this.wc=function($e){Z()[this.Sb+8>>2>>>0]=$e},this.Dc=function(){return Z()[this.Sb+8>>2>>>0]},this.rc=function(){ee()[this.Sb>>2>>>0]=0},this.hc=function($e){$e=$e?1:0,q()[this.Sb+12>>0>>>0]=$e},this.uc=function(){return q()[this.Sb+12>>0>>>0]!=0},this.ic=function($e){$e=$e?1:0,q()[this.Sb+13>>0>>>0]=$e},this.kc=function(){return q()[this.Sb+13>>0>>>0]!=0},this.fc=function($e,Ye){this.cc(0),this.xc($e),this.wc(Ye),this.rc(),this.hc(!1),this.ic(!1)},this.sc=function(){Atomics.add(ee(),this.Sb>>2,1)},this.Hc=function(){return Atomics.sub(ee(),this.Sb>>2,1)===1},this.cc=function($e){Z()[this.Sb+16>>2>>>0]=$e},this.tc=function(){return Z()[this.Sb+16>>2>>>0]},this.vc=function(){if(Qs(this.bc()))return Z()[this.Zb>>2>>>0];var $e=this.tc();return $e!==0?$e:this.Zb}}function Yn(De){return Yr(new Qt(De).Sb)}function Ai(De,$e,Ye,ot){return we?gn(3,1,De,$e,Ye,ot):hi(De,$e,Ye,ot)}function hi(De,$e,Ye,ot){if(typeof SharedArrayBuffer>"u")return Be("Current environment does not support SharedArrayBuffer, pthreads are not available!"),6;var Tt=[];return we&&Tt.length===0?Ai(De,$e,Ye,ot):(De={Ic:Ye,Ub:De,zc:ot,Nc:Tt},we?(De.Oc="spawnThread",postMessage(De,Tt),0):Nn(De))}function Xi(De,$e,Ye){return we?gn(4,1,De,$e,Ye):0}function lr(De,$e){if(we)return gn(5,1,De,$e)}function es(De,$e){if(we)return gn(6,1,De,$e)}function Qr(De,$e,Ye){if(we)return gn(7,1,De,$e,Ye)}function qr(De,$e,Ye){return we?gn(8,1,De,$e,Ye):0}function hr(De,$e){if(we)return gn(9,1,De,$e)}function wr(De,$e,Ye){if(we)return gn(10,1,De,$e,Ye)}function Wr(De,$e,Ye,ot){if(we)return gn(11,1,De,$e,Ye,ot)}function Xr(De,$e,Ye,ot){if(we)return gn(12,1,De,$e,Ye,ot)}function cr(De,$e,Ye,ot){if(we)return gn(13,1,De,$e,Ye,ot)}function ji(De){if(we)return gn(14,1,De)}function Ge(De,$e){if(we)return gn(15,1,De,$e)}function tt(De,$e,Ye){if(we)return gn(16,1,De,$e,Ye)}function ft(De){Atomics.store(ee(),De>>2,1),ui()&&er(De),Atomics.compareExchange(ee(),De>>2,1,0)}function yt(De){return Z()[De>>>2]+4294967296*ee()[De+4>>>2]}function It(De,$e,Ye,ot,Tt,Pt){return we?gn(17,1,De,$e,Ye,ot,Tt,Pt):-52}function kt(De,$e,Ye,ot,Tt,Pt){if(we)return gn(18,1,De,$e,Ye,ot,Tt,Pt)}function Kt(De){var $e=Zn(De)+1,Ye=Yi($e);return Ye&&Mn(De,q(),Ye,$e),Ye}function On(De,$e,Ye){function ot(ei){return(ei=ei.toTimeString().match(/\(([A-Za-z ]+)\)$/))?ei[1]:"GMT"}if(we)return gn(19,1,De,$e,Ye);var Tt=new Date().getFullYear(),Pt=new Date(Tt,0,1),un=new Date(Tt,6,1);Tt=Pt.getTimezoneOffset();var Fn=un.getTimezoneOffset(),Xn=Math.max(Tt,Fn);ee()[De>>2>>>0]=60*Xn,ee()[$e>>2>>>0]=+(Tt!=Fn),De=ot(Pt),$e=ot(un),De=Kt(De),$e=Kt($e),Fn<Tt?(Z()[Ye>>2>>>0]=De,Z()[Ye+4>>2>>>0]=$e):(Z()[Ye>>2>>>0]=$e,Z()[Ye+4>>2>>>0]=De)}function gn(De,$e){var Ye=arguments.length-2,ot=arguments;return Sn((()=>{for(var Tt=Ha(8*Ye),Pt=Tt>>3,un=0;un<Ye;un++){var Fn=ot[2+un];ie()[Pt+un>>>0]=Fn}return Ki(De,Ye,Tt,$e)}))}Y.executeNotifiedProxyingQueue=ft,tn=Ee?()=>{var De=process.hrtime();return 1e3*De[0]+De[1]/1e6}:we?()=>performance.now()-Y.__performance_now_clock_drift:()=>performance.now();var Ue,ct=[],vt={};function _t(){if(!Ue){var De,$e={USER:"web_user",LOGNAME:"web_user",PATH:"/",PWD:"/",HOME:"/home/web_user",LANG:(typeof navigator=="object"&&navigator.languages&&navigator.languages[0]||"C").replace("-","_")+".UTF-8",_:ge||"./this.program"};for(De in vt)vt[De]===void 0?delete $e[De]:$e[De]=vt[De];var Ye=[];for(De in $e)Ye.push(De+"="+$e[De]);Ue=Ye}return Ue}function je(De,$e){if(we)return gn(20,1,De,$e);var Ye=0;return _t().forEach((function(ot,Tt){var Pt=$e+Ye;for(Tt=Z()[De+4*Tt>>2>>>0]=Pt,Pt=0;Pt<ot.length;++Pt)q()[Tt++>>0>>>0]=ot.charCodeAt(Pt);q()[Tt>>0>>>0]=0,Ye+=ot.length+1})),0}function Gt(De,$e){if(we)return gn(21,1,De,$e);var Ye=_t();Z()[De>>2>>>0]=Ye.length;var ot=0;return Ye.forEach((function(Tt){ot+=Tt.length+1})),Z()[$e>>2>>>0]=ot,0}function Yt(De){return we?gn(22,1,De):52}function mn(De,$e,Ye,ot){return we?gn(23,1,De,$e,Ye,ot):52}function _n(De,$e,Ye,ot,Tt){return we?gn(24,1,De,$e,Ye,ot,Tt):70}var zn=[null,[],[]];function Wn(De,$e){var Ye=zn[De];$e===0||$e===10?((De===1?Ce:Be)(hn(Ye,0)),Ye.length=0):Ye.push($e)}function $n(De,$e,Ye,ot){if(we)return gn(25,1,De,$e,Ye,ot);for(var Tt=0,Pt=0;Pt<Ye;Pt++){var un=Z()[$e>>2>>>0],Fn=Z()[$e+4>>2>>>0];$e+=8;for(var Xn=0;Xn<Fn;Xn++)Wn(De,K()[un+Xn>>>0]);Tt+=Fn}return Z()[ot>>2>>>0]=Tt,0}var jn=0;function fi(De){return De%4==0&&(De%100!=0||De%400==0)}var vi=[31,29,31,30,31,30,31,31,30,31,30,31],pi=[31,28,31,30,31,30,31,31,30,31,30,31];function Ti(De,$e,Ye,ot){function Tt(Ut,di,Li){for(Ut=typeof Ut=="number"?Ut.toString():Ut||"";Ut.length<di;)Ut=Li[0]+Ut;return Ut}function Pt(Ut,di){return Tt(Ut,di,"0")}function un(Ut,di){function Li(os){return 0>os?-1:0<os?1:0}var xr;return(xr=Li(Ut.getFullYear()-di.getFullYear()))===0&&(xr=Li(Ut.getMonth()-di.getMonth()))===0&&(xr=Li(Ut.getDate()-di.getDate())),xr}function Fn(Ut){switch(Ut.getDay()){case 0:return new Date(Ut.getFullYear()-1,11,29);case 1:return Ut;case 2:return new Date(Ut.getFullYear(),0,3);case 3:return new Date(Ut.getFullYear(),0,2);case 4:return new Date(Ut.getFullYear(),0,1);case 5:return new Date(Ut.getFullYear()-1,11,31);case 6:return new Date(Ut.getFullYear()-1,11,30)}}function Xn(Ut){var di=Ut.Wb;for(Ut=new Date(new Date(Ut.Xb+1900,0,1).getTime());0<di;){var Li=Ut.getMonth(),xr=(fi(Ut.getFullYear())?vi:pi)[Li];if(!(di>xr-Ut.getDate())){Ut.setDate(Ut.getDate()+di);break}di-=xr-Ut.getDate()+1,Ut.setDate(1),11>Li?Ut.setMonth(Li+1):(Ut.setMonth(0),Ut.setFullYear(Ut.getFullYear()+1))}return Li=new Date(Ut.getFullYear()+1,0,4),di=Fn(new Date(Ut.getFullYear(),0,4)),Li=Fn(Li),0>=un(di,Ut)?0>=un(Li,Ut)?Ut.getFullYear()+1:Ut.getFullYear():Ut.getFullYear()-1}var ei=ee()[ot+40>>2>>>0];for(var Gi in ot={Lc:ee()[ot>>2>>>0],Kc:ee()[ot+4>>2>>>0],dc:ee()[ot+8>>2>>>0],jc:ee()[ot+12>>2>>>0],ec:ee()[ot+16>>2>>>0],Xb:ee()[ot+20>>2>>>0],Tb:ee()[ot+24>>2>>>0],Wb:ee()[ot+28>>2>>>0],Rc:ee()[ot+32>>2>>>0],Jc:ee()[ot+36>>2>>>0],Mc:ei?Jt(ei):""},Ye=Jt(Ye),ei={"%c":"%a %b %d %H:%M:%S %Y","%D":"%m/%d/%y","%F":"%Y-%m-%d","%h":"%b","%r":"%I:%M:%S %p","%R":"%H:%M","%T":"%H:%M:%S","%x":"%m/%d/%y","%X":"%H:%M:%S","%Ec":"%c","%EC":"%C","%Ex":"%m/%d/%y","%EX":"%H:%M:%S","%Ey":"%y","%EY":"%Y","%Od":"%d","%Oe":"%e","%OH":"%H","%OI":"%I","%Om":"%m","%OM":"%M","%OS":"%S","%Ou":"%u","%OU":"%U","%OV":"%V","%Ow":"%w","%OW":"%W","%Oy":"%y"})Ye=Ye.replace(new RegExp(Gi,"g"),ei[Gi]);var Ar="Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),br="January February March April May June July August September October November December".split(" ");for(Gi in ei={"%a":function(Ut){return Ar[Ut.Tb].substring(0,3)},"%A":function(Ut){return Ar[Ut.Tb]},"%b":function(Ut){return br[Ut.ec].substring(0,3)},"%B":function(Ut){return br[Ut.ec]},"%C":function(Ut){return Pt((Ut.Xb+1900)/100|0,2)},"%d":function(Ut){return Pt(Ut.jc,2)},"%e":function(Ut){return Tt(Ut.jc,2," ")},"%g":function(Ut){return Xn(Ut).toString().substring(2)},"%G":function(Ut){return Xn(Ut)},"%H":function(Ut){return Pt(Ut.dc,2)},"%I":function(Ut){return(Ut=Ut.dc)==0?Ut=12:12<Ut&&(Ut-=12),Pt(Ut,2)},"%j":function(Ut){for(var di=0,Li=0;Li<=Ut.ec-1;di+=(fi(Ut.Xb+1900)?vi:pi)[Li++]);return Pt(Ut.jc+di,3)},"%m":function(Ut){return Pt(Ut.ec+1,2)},"%M":function(Ut){return Pt(Ut.Kc,2)},"%n":function(){return`
`},"%p":function(Ut){return 0<=Ut.dc&&12>Ut.dc?"AM":"PM"},"%S":function(Ut){return Pt(Ut.Lc,2)},"%t":function(){return"	"},"%u":function(Ut){return Ut.Tb||7},"%U":function(Ut){return Pt(Math.floor((Ut.Wb+7-Ut.Tb)/7),2)},"%V":function(Ut){var di=Math.floor((Ut.Wb+7-(Ut.Tb+6)%7)/7);if(2>=(Ut.Tb+371-Ut.Wb-2)%7&&di++,di)di==53&&((Li=(Ut.Tb+371-Ut.Wb)%7)==4||Li==3&&fi(Ut.Xb)||(di=1));else{di=52;var Li=(Ut.Tb+7-Ut.Wb-1)%7;(Li==4||Li==5&&fi(Ut.Xb%400-1))&&di++}return Pt(di,2)},"%w":function(Ut){return Ut.Tb},"%W":function(Ut){return Pt(Math.floor((Ut.Wb+7-(Ut.Tb+6)%7)/7),2)},"%y":function(Ut){return(Ut.Xb+1900).toString().substring(2)},"%Y":function(Ut){return Ut.Xb+1900},"%z":function(Ut){var di=0<=(Ut=Ut.Jc);return Ut=Math.abs(Ut)/60,(di?"+":"-")+("0000"+(Ut/60*100+Ut%60)).slice(-4)},"%Z":function(Ut){return Ut.Mc},"%%":function(){return"%"}},Ye=Ye.replace(/%%/g,"\0\0"),ei)Ye.includes(Gi)&&(Ye=Ye.replace(new RegExp(Gi,"g"),ei[Gi](ot)));return Gi=(function(Ut){var di=Array(Zn(Ut)+1);return Mn(Ut,di,0,di.length),di})(Ye=Ye.replace(/\0\0/g,"%")),Gi.length>$e?0:((function(Ut,di){q().set(Ut,di>>>0)})(Gi,De),Gi.length-1)}Dt.fc();var Hn=[null,An,bn,Ai,Xi,lr,es,Qr,qr,hr,wr,Wr,Xr,cr,ji,Ge,tt,It,kt,On,je,Gt,Yt,mn,_n,$n],Di={b:function(De){return Yi(De+24)+24},n:function(De){return(De=new Qt(De)).uc()||(De.hc(!0),Bt--),De.ic(!1),Zt.push(De),De.sc(),De.vc()},ma:function(De){throw Be("Unexpected exception thrown, this is not properly supported - aborting"),bt=!0,De},x:function(){Jn(0);var De=Zt.pop();if(De.Hc()&&!De.kc()){var $e=De.Dc();$e&&nt($e)(De.Zb),Yn(De.Zb)}wt=0},e:function(){var De=wt;if(!De)return jn=0;var $e=new Qt(De);$e.cc(De);var Ye=$e.bc();if(!Ye)return jn=0,De;for(var ot=Array.prototype.slice.call(arguments),Tt=0;Tt<ot.length;Tt++){var Pt=ot[Tt];if(Pt===0||Pt===Ye)break;if(ca(Pt,Ye,$e.Sb+16))return jn=Pt,De}return jn=Ye,De},l:function(){var De=wt;if(!De)return jn=0;var $e=new Qt(De);$e.cc(De);var Ye=$e.bc();if(!Ye)return jn=0,De;for(var ot=Array.prototype.slice.call(arguments),Tt=0;Tt<ot.length;Tt++){var Pt=ot[Tt];if(Pt===0||Pt===Ye)break;if(ca(Pt,Ye,$e.Sb+16))return jn=Pt,De}return jn=Ye,De},h:function(){var De=wt;if(!De)return jn=0;var $e=new Qt(De);$e.cc(De);var Ye=$e.bc();if(!Ye)return jn=0,De;for(var ot=Array.prototype.slice.call(arguments),Tt=0;Tt<ot.length;Tt++){var Pt=ot[Tt];if(Pt===0||Pt===Ye)break;if(ca(Pt,Ye,$e.Sb+16))return jn=Pt,De}return jn=Ye,De},t:Yn,M:function(){var De=Zt.pop();De||pt("no exception to throw");var $e=De.Zb;throw De.kc()||(Zt.push(De),De.ic(!0),De.hc(!1),Bt++),wt=$e,$e},c:function(De,$e,Ye){throw new Qt(De).fc($e,Ye),wt=De,Bt++,De},pa:function(){return Bt},Fa:function(De){Pi(De,!Me,1,!Se),Dt.pc()},T:function(De){we?postMessage({cmd:"cleanupThread",thread:De}):fn(De)},xa:hi,j:function(De){throw wt||(wt=De),De},H:Xi,Ma:lr,ua:es,wa:Qr,oa:qr,Ka:hr,Ca:wr,Ja:Wr,V:Xr,va:cr,sa:ji,La:Ge,ta:tt,Ta:function(){},X:function(){pt("To use dlopen, you need enable dynamic linking, see https://github.com/emscripten-core/emscripten/wiki/Linking")},Ua:function(){pt("To use dlopen, you need enable dynamic linking, see https://github.com/emscripten-core/emscripten/wiki/Linking")},W:function(){return Date.now()},ya:function(){return 2097152},Oa:function(){return!0},za:function(De,$e,Ye,ot){if(De==$e)setTimeout((()=>ft(ot)));else if(we)postMessage({targetThread:De,cmd:"processProxyingQueue",queue:ot});else{if(!(De=Dt.Vb[De]))return;De.postMessage({cmd:"processProxyingQueue",queue:ot})}return 1},Ea:function(){return-1},Pa:function(De,$e){De=new Date(1e3*yt(De)),ee()[$e>>2>>>0]=De.getUTCSeconds(),ee()[$e+4>>2>>>0]=De.getUTCMinutes(),ee()[$e+8>>2>>>0]=De.getUTCHours(),ee()[$e+12>>2>>>0]=De.getUTCDate(),ee()[$e+16>>2>>>0]=De.getUTCMonth(),ee()[$e+20>>2>>>0]=De.getUTCFullYear()-1900,ee()[$e+24>>2>>>0]=De.getUTCDay(),De=(De.getTime()-Date.UTC(De.getUTCFullYear(),0,1,0,0,0,0))/864e5|0,ee()[$e+28>>2>>>0]=De},Qa:function(De,$e){De=new Date(1e3*yt(De)),ee()[$e>>2>>>0]=De.getSeconds(),ee()[$e+4>>2>>>0]=De.getMinutes(),ee()[$e+8>>2>>>0]=De.getHours(),ee()[$e+12>>2>>>0]=De.getDate(),ee()[$e+16>>2>>>0]=De.getMonth(),ee()[$e+20>>2>>>0]=De.getFullYear()-1900,ee()[$e+24>>2>>>0]=De.getDay();var Ye=new Date(De.getFullYear(),0,1),ot=(De.getTime()-Ye.getTime())/864e5|0;ee()[$e+28>>2>>>0]=ot,ee()[$e+36>>2>>>0]=-60*De.getTimezoneOffset(),ot=new Date(De.getFullYear(),6,1).getTimezoneOffset(),De=0|(ot!=(Ye=Ye.getTimezoneOffset())&&De.getTimezoneOffset()==Math.min(Ye,ot)),ee()[$e+32>>2>>>0]=De},Ra:function(De){var $e=new Date(ee()[De+20>>2>>>0]+1900,ee()[De+16>>2>>>0],ee()[De+12>>2>>>0],ee()[De+8>>2>>>0],ee()[De+4>>2>>>0],ee()[De>>2>>>0],0),Ye=ee()[De+32>>2>>>0],ot=$e.getTimezoneOffset(),Tt=new Date($e.getFullYear(),0,1),Pt=new Date($e.getFullYear(),6,1).getTimezoneOffset(),un=Tt.getTimezoneOffset(),Fn=Math.min(un,Pt);return 0>Ye?ee()[De+32>>2>>>0]=+(Pt!=un&&Fn==ot):0<Ye!=(Fn==ot)&&(Pt=Math.max(un,Pt),$e.setTime($e.getTime()+6e4*((0<Ye?Fn:Pt)-ot))),ee()[De+24>>2>>>0]=$e.getDay(),Ye=($e.getTime()-Tt.getTime())/864e5|0,ee()[De+28>>2>>>0]=Ye,ee()[De>>2>>>0]=$e.getSeconds(),ee()[De+4>>2>>>0]=$e.getMinutes(),ee()[De+8>>2>>>0]=$e.getHours(),ee()[De+12>>2>>>0]=$e.getDate(),ee()[De+16>>2>>>0]=$e.getMonth(),$e.getTime()/1e3|0},Aa:It,Ba:kt,Sa:function De($e,Ye,ot){De.Ac||(De.Ac=!0,On($e,Ye,ot))},y:function(){pt("")},U:function(){if(!Ee&&!Me){var De="Blocking on the main thread is very dangerous, see https://emscripten.org/docs/porting/pthreads.html#blocking-on-the-main-browser-thread";dn||(dn={}),dn[De]||(dn[De]=1,Ee&&(De="warning: "+De),Be(De))}},ra:function(){return 4294901760},B:tn,Ia:function(De,$e,Ye){K().copyWithin(De>>>0,$e>>>0,$e+Ye>>>0)},F:function(){return Ee?D(3993).cpus().length:navigator.hardwareConcurrency},Da:function(De,$e,Ye){ct.length=$e,Ye>>=3;for(var ot=0;ot<$e;ot++)ct[ot]=ie()[Ye+ot>>>0];return(0>De?Nt[-De-1]:Hn[De]).apply(null,ct)},qa:function(De){var $e=K().length;if((De>>>=0)<=$e||4294901760<De)return!1;for(var Ye=1;4>=Ye;Ye*=2){var ot=$e*(1+.2/Ye);ot=Math.min(ot,De+100663296);var Tt=Math;ot=Math.max(De,ot),Tt=Tt.min.call(Tt,4294901760,ot+(65536-ot%65536)%65536);e:{try{Xe.grow(Tt-ke.byteLength+65535>>>16),vn(Xe.buffer);var Pt=1;break e}catch{}Pt=void 0}if(Pt)return!0}return!1},Na:function(){throw"unwind"},Ga:je,Ha:Gt,J:Wt,I:Yt,S:mn,ga:_n,R:$n,d:function(){return jn},na:function De($e,Ye){De.lc||(De.lc=(function(){if(typeof crypto=="object"&&typeof crypto.getRandomValues=="function"){var Tt=new Uint8Array(1);return()=>(crypto.getRandomValues(Tt),Tt[0])}if(Ee)try{var Pt=D(Object((function(){var un=new Error("Cannot find module 'crypto'");throw un.code="MODULE_NOT_FOUND",un})()));return()=>Pt.randomBytes(1)[0]}catch{}return()=>pt("randomDevice")})());for(var ot=0;ot<Ye;ot++)q()[$e+ot>>0>>>0]=De.lc();return 0},ia:function(De,$e,Ye){var ot=ni();try{return nt(De)($e,Ye)}catch(Tt){if(ti(ot),Tt!==Tt+0)throw Tt;Jn(1,0)}},ja:function(De,$e,Ye){var ot=ni();try{return nt(De)($e,Ye)}catch(Tt){if(ti(ot),Tt!==Tt+0)throw Tt;Jn(1,0)}},K:function(De){var $e=ni();try{return nt(De)()}catch(Ye){if(ti($e),Ye!==Ye+0)throw Ye;Jn(1,0)}},f:function(De,$e){var Ye=ni();try{return nt(De)($e)}catch(ot){if(ti(Ye),ot!==ot+0)throw ot;Jn(1,0)}},P:function(De,$e,Ye){var ot=ni();try{return nt(De)($e,Ye)}catch(Tt){if(ti(ot),Tt!==Tt+0)throw Tt;Jn(1,0)}},Q:function(De,$e,Ye){var ot=ni();try{return nt(De)($e,Ye)}catch(Tt){if(ti(ot),Tt!==Tt+0)throw Tt;Jn(1,0)}},k:function(De,$e,Ye){var ot=ni();try{return nt(De)($e,Ye)}catch(Tt){if(ti(ot),Tt!==Tt+0)throw Tt;Jn(1,0)}},p:function(De,$e,Ye,ot){var Tt=ni();try{return nt(De)($e,Ye,ot)}catch(Pt){if(ti(Tt),Pt!==Pt+0)throw Pt;Jn(1,0)}},q:function(De,$e,Ye,ot,Tt){var Pt=ni();try{return nt(De)($e,Ye,ot,Tt)}catch(un){if(ti(Pt),un!==un+0)throw un;Jn(1,0)}},N:function(De,$e,Ye,ot,Tt,Pt){var un=ni();try{return nt(De)($e,Ye,ot,Tt,Pt)}catch(Fn){if(ti(un),Fn!==Fn+0)throw Fn;Jn(1,0)}},s:function(De,$e,Ye,ot,Tt,Pt){var un=ni();try{return nt(De)($e,Ye,ot,Tt,Pt)}catch(Fn){if(ti(un),Fn!==Fn+0)throw Fn;Jn(1,0)}},w:function(De,$e,Ye,ot,Tt,Pt,un){var Fn=ni();try{return nt(De)($e,Ye,ot,Tt,Pt,un)}catch(Xn){if(ti(Fn),Xn!==Xn+0)throw Xn;Jn(1,0)}},L:function(De,$e,Ye,ot,Tt,Pt,un,Fn){var Xn=ni();try{return nt(De)($e,Ye,ot,Tt,Pt,un,Fn)}catch(ei){if(ti(Xn),ei!==ei+0)throw ei;Jn(1,0)}},E:function(De,$e,Ye,ot,Tt,Pt,un,Fn,Xn,ei,Gi,Ar){var br=ni();try{return nt(De)($e,Ye,ot,Tt,Pt,un,Fn,Xn,ei,Gi,Ar)}catch(Ut){if(ti(br),Ut!==Ut+0)throw Ut;Jn(1,0)}},aa:function(De,$e,Ye,ot,Tt,Pt,un,Fn){var Xn=ni();try{return Es(De,$e,Ye,ot,Tt,Pt,un,Fn)}catch(ei){if(ti(Xn),ei!==ei+0)throw ei;Jn(1,0)}},_:function(De,$e,Ye,ot,Tt,Pt,un){var Fn=ni();try{return ua(De,$e,Ye,ot,Tt,Pt,un)}catch(Xn){if(ti(Fn),Xn!==Xn+0)throw Xn;Jn(1,0)}},Z:function(De,$e,Ye,ot,Tt){var Pt=ni();try{return Fr(De,$e,Ye,ot,Tt)}catch(un){if(ti(Pt),un!==un+0)throw un;Jn(1,0)}},ca:function(De,$e,Ye,ot){var Tt=ni();try{return ha(De,$e,Ye,ot)}catch(Pt){if(ti(Tt),Pt!==Pt+0)throw Pt;Jn(1,0)}},$:function(De){var $e=ni();try{return Nr(De)}catch(Ye){if(ti($e),Ye!==Ye+0)throw Ye;Jn(1,0)}},ba:function(De,$e){var Ye=ni();try{return qa(De,$e)}catch(ot){if(ti(Ye),ot!==ot+0)throw ot;Jn(1,0)}},Y:function(De,$e,Ye){var ot=ni();try{return da(De,$e,Ye)}catch(Tt){if(ti(ot),Tt!==Tt+0)throw Tt;Jn(1,0)}},g:function(De){var $e=ni();try{nt(De)()}catch(Ye){if(ti($e),Ye!==Ye+0)throw Ye;Jn(1,0)}},r:function(De,$e){var Ye=ni();try{nt(De)($e)}catch(ot){if(ti(Ye),ot!==ot+0)throw ot;Jn(1,0)}},i:function(De,$e,Ye){var ot=ni();try{nt(De)($e,Ye)}catch(Tt){if(ti(ot),Tt!==Tt+0)throw Tt;Jn(1,0)}},ha:function(De,$e,Ye,ot){var Tt=ni();try{nt(De)($e,Ye,ot)}catch(Pt){if(ti(Tt),Pt!==Pt+0)throw Pt;Jn(1,0)}},m:function(De,$e,Ye,ot){var Tt=ni();try{nt(De)($e,Ye,ot)}catch(Pt){if(ti(Tt),Pt!==Pt+0)throw Pt;Jn(1,0)}},v:function(De,$e,Ye,ot,Tt){var Pt=ni();try{nt(De)($e,Ye,ot,Tt)}catch(un){if(ti(Pt),un!==un+0)throw un;Jn(1,0)}},u:function(De,$e,Ye,ot,Tt,Pt){var un=ni();try{nt(De)($e,Ye,ot,Tt,Pt)}catch(Fn){if(ti(un),Fn!==Fn+0)throw Fn;Jn(1,0)}},O:function(De,$e,Ye,ot,Tt,Pt,un){var Fn=ni();try{nt(De)($e,Ye,ot,Tt,Pt,un)}catch(Xn){if(ti(Fn),Xn!==Xn+0)throw Xn;Jn(1,0)}},A:function(De,$e,Ye,ot,Tt,Pt,un,Fn){var Xn=ni();try{nt(De)($e,Ye,ot,Tt,Pt,un,Fn)}catch(ei){if(ti(Xn),ei!==ei+0)throw ei;Jn(1,0)}},ka:function(De,$e,Ye,ot,Tt,Pt,un,Fn,Xn){var ei=ni();try{nt(De)($e,Ye,ot,Tt,Pt,un,Fn,Xn)}catch(Gi){if(ti(ei),Gi!==Gi+0)throw Gi;Jn(1,0)}},C:function(De,$e,Ye,ot,Tt,Pt,un,Fn,Xn,ei,Gi){var Ar=ni();try{nt(De)($e,Ye,ot,Tt,Pt,un,Fn,Xn,ei,Gi)}catch(br){if(ti(Ar),br!==br+0)throw br;Jn(1,0)}},D:function(De,$e,Ye,ot,Tt,Pt,un,Fn,Xn,ei,Gi,Ar,br,Ut,di,Li){var xr=ni();try{nt(De)($e,Ye,ot,Tt,Pt,un,Fn,Xn,ei,Gi,Ar,br,Ut,di,Li)}catch(os){if(ti(xr),os!==os+0)throw os;Jn(1,0)}},fa:function(De,$e,Ye,ot,Tt,Pt,un,Fn){var Xn=ni();try{ss(De,$e,Ye,ot,Tt,Pt,un,Fn)}catch(ei){if(ti(Xn),ei!==ei+0)throw ei;Jn(1,0)}},da:function(De,$e,Ye,ot,Tt,Pt,un,Fn,Xn,ei,Gi,Ar){var br=ni();try{Qa(De,$e,Ye,ot,Tt,Pt,un,Fn,Xn,ei,Gi,Ar)}catch(Ut){if(ti(br),Ut!==Ut+0)throw Ut;Jn(1,0)}},ea:function(De,$e,Ye,ot,Tt,Pt){var un=ni();try{as(De,$e,Ye,ot,Tt,Pt)}catch(Fn){if(ti(un),Fn!==Fn+0)throw Fn;Jn(1,0)}},o:function(De){return De},a:Xe||Y.wasmMemory,G:function(De){jn=De},la:Ti,z:function(De,$e,Ye,ot){return Ti(De,$e,Ye,ot)}};(function(){function De(Tt,Pt){Y.asm=Tt.exports,Dt.qc.push(Y.asm.sb),st=Y.asm.ub,qn.unshift(Y.asm.Va),lt=Pt,we||(Ke--,Y.monitorRunDependencies&&Y.monitorRunDependencies(Ke),Ke==0&&Fe&&(Tt=Fe,Fe=null,Tt()))}function $e(Tt){De(Tt.instance,Tt.module)}function Ye(Tt){return(function(){if(!Pe&&(Se||Me)){if(typeof fetch=="function"&&!En.startsWith("file://"))return fetch(En,{credentials:"same-origin"}).then((function(Pt){if(!Pt.ok)throw"failed to load wasm binary file at '"+En+"'";return Pt.arrayBuffer()})).catch((function(){return qt()}));if(le)return new Promise((function(Pt,un){le(En,(function(Fn){Pt(new Uint8Array(Fn))}),un)}))}return Promise.resolve().then((function(){return qt()}))})().then((function(Pt){return WebAssembly.instantiate(Pt,ot)})).then((function(Pt){return Pt})).then(Tt,(function(Pt){Be("failed to asynchronously prepare wasm: "+Pt),pt(Pt)}))}var ot={a:Di};if(we||(Ke++,Y.monitorRunDependencies&&Y.monitorRunDependencies(Ke)),Y.instantiateWasm)try{return Y.instantiateWasm(ot,De)}catch(Tt){return Be("Module.instantiateWasm callback failed with error: "+Tt),!1}(Pe||typeof WebAssembly.instantiateStreaming!="function"||zt()||En.startsWith("file://")||Ee||typeof fetch!="function"?Ye($e):fetch(En,{credentials:"same-origin"}).then((function(Tt){return WebAssembly.instantiateStreaming(Tt,ot).then($e,(function(Pt){return Be("wasm streaming compile failed: "+Pt),Be("falling back to ArrayBuffer instantiation"),Ye($e)}))}))).catch(ne)})(),Y.___wasm_call_ctors=function(){return(Y.___wasm_call_ctors=Y.asm.Va).apply(null,arguments)},Y._OrtInit=function(){return(Y._OrtInit=Y.asm.Wa).apply(null,arguments)},Y._OrtCreateSessionOptions=function(){return(Y._OrtCreateSessionOptions=Y.asm.Xa).apply(null,arguments)},Y._OrtAppendExecutionProvider=function(){return(Y._OrtAppendExecutionProvider=Y.asm.Ya).apply(null,arguments)},Y._OrtAddSessionConfigEntry=function(){return(Y._OrtAddSessionConfigEntry=Y.asm.Za).apply(null,arguments)},Y._OrtReleaseSessionOptions=function(){return(Y._OrtReleaseSessionOptions=Y.asm._a).apply(null,arguments)},Y._OrtCreateSession=function(){return(Y._OrtCreateSession=Y.asm.$a).apply(null,arguments)},Y._OrtReleaseSession=function(){return(Y._OrtReleaseSession=Y.asm.ab).apply(null,arguments)},Y._OrtGetInputCount=function(){return(Y._OrtGetInputCount=Y.asm.bb).apply(null,arguments)},Y._OrtGetOutputCount=function(){return(Y._OrtGetOutputCount=Y.asm.cb).apply(null,arguments)},Y._OrtGetInputName=function(){return(Y._OrtGetInputName=Y.asm.db).apply(null,arguments)},Y._OrtGetOutputName=function(){return(Y._OrtGetOutputName=Y.asm.eb).apply(null,arguments)},Y._OrtFree=function(){return(Y._OrtFree=Y.asm.fb).apply(null,arguments)},Y._OrtCreateTensor=function(){return(Y._OrtCreateTensor=Y.asm.gb).apply(null,arguments)},Y._OrtGetTensorData=function(){return(Y._OrtGetTensorData=Y.asm.hb).apply(null,arguments)},Y._OrtReleaseTensor=function(){return(Y._OrtReleaseTensor=Y.asm.ib).apply(null,arguments)},Y._OrtCreateRunOptions=function(){return(Y._OrtCreateRunOptions=Y.asm.jb).apply(null,arguments)},Y._OrtAddRunConfigEntry=function(){return(Y._OrtAddRunConfigEntry=Y.asm.kb).apply(null,arguments)},Y._OrtReleaseRunOptions=function(){return(Y._OrtReleaseRunOptions=Y.asm.lb).apply(null,arguments)},Y._OrtRun=function(){return(Y._OrtRun=Y.asm.mb).apply(null,arguments)},Y._OrtEndProfiling=function(){return(Y._OrtEndProfiling=Y.asm.nb).apply(null,arguments)};var ui=Y._pthread_self=function(){return(ui=Y._pthread_self=Y.asm.ob).apply(null,arguments)},Yi=Y._malloc=function(){return(Yi=Y._malloc=Y.asm.pb).apply(null,arguments)},Yr=Y._free=function(){return(Yr=Y._free=Y.asm.qb).apply(null,arguments)},Bi=Y._fflush=function(){return(Bi=Y._fflush=Y.asm.rb).apply(null,arguments)};Y.__emscripten_tls_init=function(){return(Y.__emscripten_tls_init=Y.asm.sb).apply(null,arguments)};var Lr=Y.___funcs_on_exit=function(){return(Lr=Y.___funcs_on_exit=Y.asm.tb).apply(null,arguments)},Pi=Y.__emscripten_thread_init=function(){return(Pi=Y.__emscripten_thread_init=Y.asm.vb).apply(null,arguments)};Y.__emscripten_thread_crashed=function(){return(Y.__emscripten_thread_crashed=Y.asm.wb).apply(null,arguments)};var Wi,Ki=Y._emscripten_run_in_main_runtime_thread_js=function(){return(Ki=Y._emscripten_run_in_main_runtime_thread_js=Y.asm.xb).apply(null,arguments)},er=Y.__emscripten_proxy_execute_task_queue=function(){return(er=Y.__emscripten_proxy_execute_task_queue=Y.asm.yb).apply(null,arguments)},tr=Y.__emscripten_thread_free_data=function(){return(tr=Y.__emscripten_thread_free_data=Y.asm.zb).apply(null,arguments)},Mr=Y.__emscripten_thread_exit=function(){return(Mr=Y.__emscripten_thread_exit=Y.asm.Ab).apply(null,arguments)},Jn=Y._setThrew=function(){return(Jn=Y._setThrew=Y.asm.Bb).apply(null,arguments)},ja=Y._emscripten_stack_set_limits=function(){return(ja=Y._emscripten_stack_set_limits=Y.asm.Cb).apply(null,arguments)},ni=Y.stackSave=function(){return(ni=Y.stackSave=Y.asm.Db).apply(null,arguments)},ti=Y.stackRestore=function(){return(ti=Y.stackRestore=Y.asm.Eb).apply(null,arguments)},Ha=Y.stackAlloc=function(){return(Ha=Y.stackAlloc=Y.asm.Fb).apply(null,arguments)},ca=Y.___cxa_can_catch=function(){return(ca=Y.___cxa_can_catch=Y.asm.Gb).apply(null,arguments)},Qs=Y.___cxa_is_pointer_type=function(){return(Qs=Y.___cxa_is_pointer_type=Y.asm.Hb).apply(null,arguments)},Nr=Y.dynCall_j=function(){return(Nr=Y.dynCall_j=Y.asm.Ib).apply(null,arguments)},ua=Y.dynCall_iiiiij=function(){return(ua=Y.dynCall_iiiiij=Y.asm.Jb).apply(null,arguments)},da=Y.dynCall_jii=function(){return(da=Y.dynCall_jii=Y.asm.Kb).apply(null,arguments)},ss=Y.dynCall_viiiiij=function(){return(ss=Y.dynCall_viiiiij=Y.asm.Lb).apply(null,arguments)},as=Y.dynCall_vjji=function(){return(as=Y.dynCall_vjji=Y.asm.Mb).apply(null,arguments)},Qa=Y.dynCall_viiijjjii=function(){return(Qa=Y.dynCall_viiijjjii=Y.asm.Nb).apply(null,arguments)},ha=Y.dynCall_iij=function(){return(ha=Y.dynCall_iij=Y.asm.Ob).apply(null,arguments)},qa=Y.dynCall_ji=function(){return(qa=Y.dynCall_ji=Y.asm.Pb).apply(null,arguments)},Es=Y.dynCall_iiiiiij=function(){return(Es=Y.dynCall_iiiiiij=Y.asm.Qb).apply(null,arguments)},Fr=Y.dynCall_iiij=function(){return(Fr=Y.dynCall_iiij=Y.asm.Rb).apply(null,arguments)};function fa(){function De(){if(!Wi&&(Wi=!0,Y.calledRun=!0,!bt)&&(we||Bn(qn),W(Y),Y.onRuntimeInitialized&&Y.onRuntimeInitialized(),!we)){if(Y.postRun)for(typeof Y.postRun=="function"&&(Y.postRun=[Y.postRun]);Y.postRun.length;){var $e=Y.postRun.shift();yn.unshift($e)}Bn(yn)}}if(!(0<Ke))if(we)W(Y),we||Bn(qn),postMessage({cmd:"loaded"});else{if(Y.preRun)for(typeof Y.preRun=="function"&&(Y.preRun=[Y.preRun]);Y.preRun.length;)Tn();Bn(Gn),0<Ke||(Y.setStatus?(Y.setStatus("Running..."),setTimeout((function(){setTimeout((function(){Y.setStatus("")}),1),De()}),1)):De())}}if(Y.UTF8ToString=Jt,Y.stringToUTF8=function(De,$e,Ye){return Mn(De,K(),$e,Ye)},Y.lengthBytesUTF8=Zn,Y.keepRuntimeAlive=li,Y.wasmMemory=Xe,Y.stackSave=ni,Y.stackRestore=ti,Y.stackAlloc=Ha,Y.ExitStatus=Rn,Y.PThread=Dt,Fe=function De(){Wi||fa(),Wi||(Fe=De)},Y.preInit)for(typeof Y.preInit=="function"&&(Y.preInit=[Y.preInit]);0<Y.preInit.length;)Y.preInit.pop()();return fa(),G.ready});F.exports=U},932:(F,w,D)=>{var O,U=(O=(O=typeof document<"u"&&document.currentScript?document.currentScript.src:void 0)||"/index.js",function(G){var q,K,ee;G=G||{},q||(q=G!==void 0?G:{}),q.ready=new Promise((function(Ge,tt){K=Ge,ee=tt}));var Z,ie,Y,W,ne,se,le=Object.assign({},q),ce="./this.program",he=(Ge,tt)=>{throw tt},pe=typeof window=="object",me=typeof importScripts=="function",be=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string",ge="";be?(ge=me?D(908).dirname(ge)+"/":"//",se=()=>{ne||(W=D(1384),ne=D(908))},Z=function(Ge,tt){return se(),Ge=ne.normalize(Ge),W.readFileSync(Ge,tt?void 0:"utf8")},Y=Ge=>((Ge=Z(Ge,!0)).buffer||(Ge=new Uint8Array(Ge)),Ge),ie=(Ge,tt,ft)=>{se(),Ge=ne.normalize(Ge),W.readFile(Ge,(function(yt,It){yt?ft(yt):tt(It.buffer)}))},1<process.argv.length&&(ce=process.argv[1].replace(/\\/g,"/")),process.argv.slice(2),process.on("uncaughtException",(function(Ge){if(!(Ge instanceof qn))throw Ge})),process.on("unhandledRejection",(function(Ge){throw Ge})),he=(Ge,tt)=>{if(Ee||0<Xt)throw process.exitCode=Ge,tt;tt instanceof qn||Me("exiting due to exception: "+tt),process.exit(Ge)},q.inspect=function(){return"[Emscripten Module object]"}):(pe||me)&&(me?ge=self.location.href:typeof document<"u"&&document.currentScript&&(ge=document.currentScript.src),O&&(ge=O),ge=ge.indexOf("blob:")!==0?ge.substr(0,ge.replace(/[?#].*/,"").lastIndexOf("/")+1):"",Z=Ge=>{var tt=new XMLHttpRequest;return tt.open("GET",Ge,!1),tt.send(null),tt.responseText},me&&(Y=Ge=>{var tt=new XMLHttpRequest;return tt.open("GET",Ge,!1),tt.responseType="arraybuffer",tt.send(null),new Uint8Array(tt.response)}),ie=(Ge,tt,ft)=>{var yt=new XMLHttpRequest;yt.open("GET",Ge,!0),yt.responseType="arraybuffer",yt.onload=()=>{yt.status==200||yt.status==0&&yt.response?tt(yt.response):ft()},yt.onerror=ft,yt.send(null)});var ve,Se=q.print||console.log.bind(console),Me=q.printErr||console.warn.bind(console);Object.assign(q,le),le=null,q.thisProgram&&(ce=q.thisProgram),q.quit&&(he=q.quit),q.wasmBinary&&(ve=q.wasmBinary);var Ee=q.noExitRuntime||!1;typeof WebAssembly!="object"&&vn("no native wasm support detected");var we,Re,Le,Ne,Oe,Pe,Ce=!1,Be=typeof TextDecoder<"u"?new TextDecoder("utf8"):void 0;function ze(Ge,tt,ft){var yt=(tt>>>=0)+ft;for(ft=tt;Ge[ft]&&!(ft>=yt);)++ft;if(16<ft-tt&&Ge.buffer&&Be)return Be.decode(Ge.subarray(tt,ft));for(yt="";tt<ft;){var It=Ge[tt++];if(128&It){var kt=63&Ge[tt++];if((224&It)==192)yt+=String.fromCharCode((31&It)<<6|kt);else{var Kt=63&Ge[tt++];65536>(It=(240&It)==224?(15&It)<<12|kt<<6|Kt:(7&It)<<18|kt<<12|Kt<<6|63&Ge[tt++])?yt+=String.fromCharCode(It):(It-=65536,yt+=String.fromCharCode(55296|It>>10,56320|1023&It))}}else yt+=String.fromCharCode(It)}return yt}function Xe(Ge,tt){return(Ge>>>=0)?ze(Ne,Ge,tt):""}function lt(Ge,tt,ft,yt){if(!(0<yt))return 0;var It=ft>>>=0;yt=ft+yt-1;for(var kt=0;kt<Ge.length;++kt){var Kt=Ge.charCodeAt(kt);if(55296<=Kt&&57343>=Kt&&(Kt=65536+((1023&Kt)<<10)|1023&Ge.charCodeAt(++kt)),127>=Kt){if(ft>=yt)break;tt[ft++>>>0]=Kt}else{if(2047>=Kt){if(ft+1>=yt)break;tt[ft++>>>0]=192|Kt>>6}else{if(65535>=Kt){if(ft+2>=yt)break;tt[ft++>>>0]=224|Kt>>12}else{if(ft+3>=yt)break;tt[ft++>>>0]=240|Kt>>18,tt[ft++>>>0]=128|Kt>>12&63}tt[ft++>>>0]=128|Kt>>6&63}tt[ft++>>>0]=128|63&Kt}}return tt[ft>>>0]=0,ft-It}function ke(Ge){for(var tt=0,ft=0;ft<Ge.length;++ft){var yt=Ge.charCodeAt(ft);127>=yt?tt++:2047>=yt?tt+=2:55296<=yt&&57343>=yt?(tt+=4,++ft):tt+=3}return tt}function rt(){var Ge=we.buffer;Re=Ge,q.HEAP8=Le=new Int8Array(Ge),q.HEAP16=new Int16Array(Ge),q.HEAP32=Oe=new Int32Array(Ge),q.HEAPU8=Ne=new Uint8Array(Ge),q.HEAPU16=new Uint16Array(Ge),q.HEAPU32=Pe=new Uint32Array(Ge),q.HEAPF32=new Float32Array(Ge),q.HEAPF64=new Float64Array(Ge)}var St,Lt=[],$t=[],mt=[],bt=[],Xt=0;function hn(){var Ge=q.preRun.shift();Lt.unshift(Ge)}var Jt,Mn=0,Zn=null;function vn(Ge){throw q.onAbort&&q.onAbort(Ge),Me(Ge="Aborted("+Ge+")"),Ce=!0,Ge=new WebAssembly.RuntimeError(Ge+". Build with -sASSERTIONS for more info."),ee(Ge),Ge}function In(){return Jt.startsWith("data:application/octet-stream;base64,")}if(Jt="ort-wasm.wasm",!In()){var st=Jt;Jt=q.locateFile?q.locateFile(st,ge):ge+st}function Gn(){var Ge=Jt;try{if(Ge==Jt&&ve)return new Uint8Array(ve);if(Y)return Y(Ge);throw"both async and sync fetching of the wasm failed"}catch(tt){vn(tt)}}function qn(Ge){this.name="ExitStatus",this.message="Program terminated with exit("+Ge+")",this.status=Ge}function ai(Ge){for(;0<Ge.length;)Ge.shift()(q)}var yn=[],li=0,Tn=0;function En(Ge){this.Db=Ge,this.zb=Ge-24,this.Ub=function(tt){Pe[this.zb+4>>2>>>0]=tt},this.Eb=function(){return Pe[this.zb+4>>2>>>0]},this.Sb=function(tt){Pe[this.zb+8>>2>>>0]=tt},this.Wb=function(){return Pe[this.zb+8>>2>>>0]},this.Tb=function(){Oe[this.zb>>2>>>0]=0},this.Ib=function(tt){Le[this.zb+12>>0>>>0]=tt?1:0},this.Pb=function(){return Le[this.zb+12>>0>>>0]!=0},this.Jb=function(tt){Le[this.zb+13>>0>>>0]=tt?1:0},this.Lb=function(){return Le[this.zb+13>>0>>>0]!=0},this.Rb=function(tt,ft){this.Fb(0),this.Ub(tt),this.Sb(ft),this.Tb(),this.Ib(!1),this.Jb(!1)},this.Nb=function(){Oe[this.zb>>2>>>0]+=1},this.Xb=function(){var tt=Oe[this.zb>>2>>>0];return Oe[this.zb>>2>>>0]=tt-1,tt===1},this.Fb=function(tt){Pe[this.zb+16>>2>>>0]=tt},this.Ob=function(){return Pe[this.zb+16>>2>>>0]},this.Qb=function(){if(hi(this.Eb()))return Pe[this.Db>>2>>>0];var tt=this.Ob();return tt!==0?tt:this.Db}}function Ke(Ge){return dn(new En(Ge).zb)}var Fe=[];function pt(Ge){var tt=Fe[Ge];return tt||(Ge>=Fe.length&&(Fe.length=Ge+1),Fe[Ge]=tt=St.get(Ge)),tt}function zt(Ge){var tt=ke(Ge)+1,ft=nt(tt);return ft&&lt(Ge,Le,ft,tt),ft}var qt={};function Nt(){if(!Rn){var Ge,tt={USER:"web_user",LOGNAME:"web_user",PATH:"/",PWD:"/",HOME:"/home/web_user",LANG:(typeof navigator=="object"&&navigator.languages&&navigator.languages[0]||"C").replace("-","_")+".UTF-8",_:ce||"./this.program"};for(Ge in qt)qt[Ge]===void 0?delete tt[Ge]:tt[Ge]=qt[Ge];var ft=[];for(Ge in tt)ft.push(Ge+"="+tt[Ge]);Rn=ft}return Rn}var Rn,fn=[null,[],[]];function Nn(Ge,tt){var ft=fn[Ge];tt===0||tt===10?((Ge===1?Se:Me)(ze(ft,0)),ft.length=0):ft.push(tt)}var An=0;function Wt(Ge){return Ge%4==0&&(Ge%100!=0||Ge%400==0)}var Dt=[31,29,31,30,31,30,31,31,30,31,30,31],Bn=[31,28,31,30,31,30,31,31,30,31,30,31];function Sn(Ge,tt,ft,yt){function It(je,Gt,Yt){for(je=typeof je=="number"?je.toString():je||"";je.length<Gt;)je=Yt[0]+je;return je}function kt(je,Gt){return It(je,Gt,"0")}function Kt(je,Gt){function Yt(_n){return 0>_n?-1:0<_n?1:0}var mn;return(mn=Yt(je.getFullYear()-Gt.getFullYear()))===0&&(mn=Yt(je.getMonth()-Gt.getMonth()))===0&&(mn=Yt(je.getDate()-Gt.getDate())),mn}function On(je){switch(je.getDay()){case 0:return new Date(je.getFullYear()-1,11,29);case 1:return je;case 2:return new Date(je.getFullYear(),0,3);case 3:return new Date(je.getFullYear(),0,2);case 4:return new Date(je.getFullYear(),0,1);case 5:return new Date(je.getFullYear()-1,11,31);case 6:return new Date(je.getFullYear()-1,11,30)}}function gn(je){var Gt=je.Bb;for(je=new Date(new Date(je.Cb+1900,0,1).getTime());0<Gt;){var Yt=je.getMonth(),mn=(Wt(je.getFullYear())?Dt:Bn)[Yt];if(!(Gt>mn-je.getDate())){je.setDate(je.getDate()+Gt);break}Gt-=mn-je.getDate()+1,je.setDate(1),11>Yt?je.setMonth(Yt+1):(je.setMonth(0),je.setFullYear(je.getFullYear()+1))}return Yt=new Date(je.getFullYear()+1,0,4),Gt=On(new Date(je.getFullYear(),0,4)),Yt=On(Yt),0>=Kt(Gt,je)?0>=Kt(Yt,je)?je.getFullYear()+1:je.getFullYear():je.getFullYear()-1}var Ue=Oe[yt+40>>2>>>0];for(var ct in yt={$b:Oe[yt>>2>>>0],Zb:Oe[yt+4>>2>>>0],Gb:Oe[yt+8>>2>>>0],Kb:Oe[yt+12>>2>>>0],Hb:Oe[yt+16>>2>>>0],Cb:Oe[yt+20>>2>>>0],Ab:Oe[yt+24>>2>>>0],Bb:Oe[yt+28>>2>>>0],bc:Oe[yt+32>>2>>>0],Yb:Oe[yt+36>>2>>>0],ac:Ue?Xe(Ue):""},ft=Xe(ft),Ue={"%c":"%a %b %d %H:%M:%S %Y","%D":"%m/%d/%y","%F":"%Y-%m-%d","%h":"%b","%r":"%I:%M:%S %p","%R":"%H:%M","%T":"%H:%M:%S","%x":"%m/%d/%y","%X":"%H:%M:%S","%Ec":"%c","%EC":"%C","%Ex":"%m/%d/%y","%EX":"%H:%M:%S","%Ey":"%y","%EY":"%Y","%Od":"%d","%Oe":"%e","%OH":"%H","%OI":"%I","%Om":"%m","%OM":"%M","%OS":"%S","%Ou":"%u","%OU":"%U","%OV":"%V","%Ow":"%w","%OW":"%W","%Oy":"%y"})ft=ft.replace(new RegExp(ct,"g"),Ue[ct]);var vt="Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),_t="January February March April May June July August September October November December".split(" ");for(ct in Ue={"%a":function(je){return vt[je.Ab].substring(0,3)},"%A":function(je){return vt[je.Ab]},"%b":function(je){return _t[je.Hb].substring(0,3)},"%B":function(je){return _t[je.Hb]},"%C":function(je){return kt((je.Cb+1900)/100|0,2)},"%d":function(je){return kt(je.Kb,2)},"%e":function(je){return It(je.Kb,2," ")},"%g":function(je){return gn(je).toString().substring(2)},"%G":function(je){return gn(je)},"%H":function(je){return kt(je.Gb,2)},"%I":function(je){return(je=je.Gb)==0?je=12:12<je&&(je-=12),kt(je,2)},"%j":function(je){for(var Gt=0,Yt=0;Yt<=je.Hb-1;Gt+=(Wt(je.Cb+1900)?Dt:Bn)[Yt++]);return kt(je.Kb+Gt,3)},"%m":function(je){return kt(je.Hb+1,2)},"%M":function(je){return kt(je.Zb,2)},"%n":function(){return`
`},"%p":function(je){return 0<=je.Gb&&12>je.Gb?"AM":"PM"},"%S":function(je){return kt(je.$b,2)},"%t":function(){return"	"},"%u":function(je){return je.Ab||7},"%U":function(je){return kt(Math.floor((je.Bb+7-je.Ab)/7),2)},"%V":function(je){var Gt=Math.floor((je.Bb+7-(je.Ab+6)%7)/7);if(2>=(je.Ab+371-je.Bb-2)%7&&Gt++,Gt)Gt==53&&((Yt=(je.Ab+371-je.Bb)%7)==4||Yt==3&&Wt(je.Cb)||(Gt=1));else{Gt=52;var Yt=(je.Ab+7-je.Bb-1)%7;(Yt==4||Yt==5&&Wt(je.Cb%400-1))&&Gt++}return kt(Gt,2)},"%w":function(je){return je.Ab},"%W":function(je){return kt(Math.floor((je.Bb+7-(je.Ab+6)%7)/7),2)},"%y":function(je){return(je.Cb+1900).toString().substring(2)},"%Y":function(je){return je.Cb+1900},"%z":function(je){var Gt=0<=(je=je.Yb);return je=Math.abs(je)/60,(Gt?"+":"-")+("0000"+(je/60*100+je%60)).slice(-4)},"%Z":function(je){return je.ac},"%%":function(){return"%"}},ft=ft.replace(/%%/g,"\0\0"),Ue)ft.includes(ct)&&(ft=ft.replace(new RegExp(ct,"g"),Ue[ct](yt)));return ct=(function(je){var Gt=Array(ke(je)+1);return lt(je,Gt,0,Gt.length),Gt})(ft=ft.replace(/\0\0/g,"%")),ct.length>tt?0:(Le.set(ct,Ge>>>0),ct.length-1)}var bn={a:function(Ge){return nt(Ge+24)+24},m:function(Ge){return(Ge=new En(Ge)).Pb()||(Ge.Ib(!0),li--),Ge.Jb(!1),yn.push(Ge),Ge.Nb(),Ge.Qb()},ia:function(Ge){throw Me("Unexpected exception thrown, this is not properly supported - aborting"),Ce=!0,Ge},w:function(){Bt(0);var Ge=yn.pop();if(Ge.Xb()&&!Ge.Lb()){var tt=Ge.Wb();tt&&pt(tt)(Ge.Db),Ke(Ge.Db)}Tn=0},d:function(){var Ge=Tn;if(!Ge)return An=0;var tt=new En(Ge);tt.Fb(Ge);var ft=tt.Eb();if(!ft)return An=0,Ge;for(var yt=Array.prototype.slice.call(arguments),It=0;It<yt.length;It++){var kt=yt[It];if(kt===0||kt===ft)break;if(Ai(kt,ft,tt.zb+16))return An=kt,Ge}return An=ft,Ge},k:function(){var Ge=Tn;if(!Ge)return An=0;var tt=new En(Ge);tt.Fb(Ge);var ft=tt.Eb();if(!ft)return An=0,Ge;for(var yt=Array.prototype.slice.call(arguments),It=0;It<yt.length;It++){var kt=yt[It];if(kt===0||kt===ft)break;if(Ai(kt,ft,tt.zb+16))return An=kt,Ge}return An=ft,Ge},g:function(){var Ge=Tn;if(!Ge)return An=0;var tt=new En(Ge);tt.Fb(Ge);var ft=tt.Eb();if(!ft)return An=0,Ge;for(var yt=Array.prototype.slice.call(arguments),It=0;It<yt.length;It++){var kt=yt[It];if(kt===0||kt===ft)break;if(Ai(kt,ft,tt.zb+16))return An=kt,Ge}return An=ft,Ge},s:Ke,L:function(){var Ge=yn.pop();Ge||vn("no exception to throw");var tt=Ge.Db;throw Ge.Lb()||(yn.push(Ge),Ge.Jb(!0),Ge.Ib(!1),li++),Tn=tt,tt},b:function(Ge,tt,ft){throw new En(Ge).Rb(tt,ft),Tn=Ge,li++,Ge},la:function(){return li},i:function(Ge){throw Tn||(Tn=Ge),Ge},H:function(){return 0},Ba:function(){},pa:function(){},ra:function(){},ka:function(){return 0},za:function(){},ua:function(){},ya:function(){},R:function(){},qa:function(){},na:function(){},Aa:function(){},oa:function(){},Ha:function(){},Ja:function(){vn("To use dlopen, you need enable dynamic linking, see https://github.com/emscripten-core/emscripten/wiki/Linking")},Ia:function(){vn("To use dlopen, you need enable dynamic linking, see https://github.com/emscripten-core/emscripten/wiki/Linking")},S:function(){return Date.now()},Ca:function(){return!0},Da:function(Ge,tt){Ge=new Date(1e3*(Pe[Ge>>>2]+4294967296*Oe[Ge+4>>>2])),Oe[tt>>2>>>0]=Ge.getUTCSeconds(),Oe[tt+4>>2>>>0]=Ge.getUTCMinutes(),Oe[tt+8>>2>>>0]=Ge.getUTCHours(),Oe[tt+12>>2>>>0]=Ge.getUTCDate(),Oe[tt+16>>2>>>0]=Ge.getUTCMonth(),Oe[tt+20>>2>>>0]=Ge.getUTCFullYear()-1900,Oe[tt+24>>2>>>0]=Ge.getUTCDay(),Oe[tt+28>>2>>>0]=(Ge.getTime()-Date.UTC(Ge.getUTCFullYear(),0,1,0,0,0,0))/864e5|0},Ea:function(Ge,tt){Ge=new Date(1e3*(Pe[Ge>>>2]+4294967296*Oe[Ge+4>>>2])),Oe[tt>>2>>>0]=Ge.getSeconds(),Oe[tt+4>>2>>>0]=Ge.getMinutes(),Oe[tt+8>>2>>>0]=Ge.getHours(),Oe[tt+12>>2>>>0]=Ge.getDate(),Oe[tt+16>>2>>>0]=Ge.getMonth(),Oe[tt+20>>2>>>0]=Ge.getFullYear()-1900,Oe[tt+24>>2>>>0]=Ge.getDay();var ft=new Date(Ge.getFullYear(),0,1);Oe[tt+28>>2>>>0]=(Ge.getTime()-ft.getTime())/864e5|0,Oe[tt+36>>2>>>0]=-60*Ge.getTimezoneOffset();var yt=new Date(Ge.getFullYear(),6,1).getTimezoneOffset();ft=ft.getTimezoneOffset(),Oe[tt+32>>2>>>0]=0|(yt!=ft&&Ge.getTimezoneOffset()==Math.min(ft,yt))},Fa:function(Ge){var tt=new Date(Oe[Ge+20>>2>>>0]+1900,Oe[Ge+16>>2>>>0],Oe[Ge+12>>2>>>0],Oe[Ge+8>>2>>>0],Oe[Ge+4>>2>>>0],Oe[Ge>>2>>>0],0),ft=Oe[Ge+32>>2>>>0],yt=tt.getTimezoneOffset(),It=new Date(tt.getFullYear(),0,1),kt=new Date(tt.getFullYear(),6,1).getTimezoneOffset(),Kt=It.getTimezoneOffset(),On=Math.min(Kt,kt);return 0>ft?Oe[Ge+32>>2>>>0]=+(kt!=Kt&&On==yt):0<ft!=(On==yt)&&(kt=Math.max(Kt,kt),tt.setTime(tt.getTime()+6e4*((0<ft?On:kt)-yt))),Oe[Ge+24>>2>>>0]=tt.getDay(),Oe[Ge+28>>2>>>0]=(tt.getTime()-It.getTime())/864e5|0,Oe[Ge>>2>>>0]=tt.getSeconds(),Oe[Ge+4>>2>>>0]=tt.getMinutes(),Oe[Ge+8>>2>>>0]=tt.getHours(),Oe[Ge+12>>2>>>0]=tt.getDate(),Oe[Ge+16>>2>>>0]=tt.getMonth(),tt.getTime()/1e3|0},sa:function(){return-52},ta:function(){},Ga:function Ge(tt,ft,yt){Ge.Vb||(Ge.Vb=!0,(function(It,kt,Kt){function On(_t){return(_t=_t.toTimeString().match(/\(([A-Za-z ]+)\)$/))?_t[1]:"GMT"}var gn=new Date().getFullYear(),Ue=new Date(gn,0,1),ct=new Date(gn,6,1);gn=Ue.getTimezoneOffset();var vt=ct.getTimezoneOffset();Oe[It>>2>>>0]=60*Math.max(gn,vt),Oe[kt>>2>>>0]=+(gn!=vt),It=On(Ue),kt=On(ct),It=zt(It),kt=zt(kt),vt<gn?(Pe[Kt>>2>>>0]=It,Pe[Kt+4>>2>>>0]=kt):(Pe[Kt>>2>>>0]=kt,Pe[Kt+4>>2>>>0]=It)})(tt,ft,yt))},B:function(){vn("")},ma:function(){return 4294901760},I:be?()=>{var Ge=process.hrtime();return 1e3*Ge[0]+Ge[1]/1e6}:()=>performance.now(),xa:function(Ge,tt,ft){Ne.copyWithin(Ge>>>0,tt>>>0,tt+ft>>>0)},G:function(Ge){var tt=Ne.length;if(4294901760<(Ge>>>=0))return!1;for(var ft=1;4>=ft;ft*=2){var yt=tt*(1+.2/ft);yt=Math.min(yt,Ge+100663296);var It=Math;yt=Math.max(Ge,yt),It=It.min.call(It,4294901760,yt+(65536-yt%65536)%65536);e:{try{we.grow(It-Re.byteLength+65535>>>16),rt();var kt=1;break e}catch{}kt=void 0}if(kt)return!0}return!1},va:function(Ge,tt){var ft=0;return Nt().forEach((function(yt,It){var kt=tt+ft;for(It=Pe[Ge+4*It>>2>>>0]=kt,kt=0;kt<yt.length;++kt)Le[It++>>0>>>0]=yt.charCodeAt(kt);Le[It>>0>>>0]=0,ft+=yt.length+1})),0},wa:function(Ge,tt){var ft=Nt();Pe[Ge>>2>>>0]=ft.length;var yt=0;return ft.forEach((function(It){yt+=It.length+1})),Pe[tt>>2>>>0]=yt,0},ba:function(Ge){Ee||0<Xt||(Zt(),ai(mt),tn(0),fn[1].length&&Nn(1,10),fn[2].length&&Nn(2,10)),Ee||0<Xt||(q.onExit&&q.onExit(Ge),Ce=!0),he(Ge,new qn(Ge))},E:function(){return 52},Q:function(){return 52},ca:function(){return 70},P:function(Ge,tt,ft,yt){for(var It=0,kt=0;kt<ft;kt++){var Kt=Pe[tt>>2>>>0],On=Pe[tt+4>>2>>>0];tt+=8;for(var gn=0;gn<On;gn++)Nn(Ge,Ne[Kt+gn>>>0]);It+=On}return Pe[yt>>2>>>0]=It,0},c:function(){return An},ja:function Ge(tt,ft){Ge.Mb||(Ge.Mb=(function(){if(typeof crypto=="object"&&typeof crypto.getRandomValues=="function"){var It=new Uint8Array(1);return()=>(crypto.getRandomValues(It),It[0])}if(be)try{var kt=D(Object((function(){var Kt=new Error("Cannot find module 'crypto'");throw Kt.code="MODULE_NOT_FOUND",Kt})()));return()=>kt.randomBytes(1)[0]}catch{}return()=>vn("randomDevice")})());for(var yt=0;yt<ft;yt++)Le[tt+yt>>0>>>0]=Ge.Mb();return 0},ea:function(Ge,tt,ft){var yt=wt();try{return pt(Ge)(tt,ft)}catch(It){if(Qt(yt),It!==It+0)throw It;Bt(1,0)}},fa:function(Ge,tt,ft){var yt=wt();try{return pt(Ge)(tt,ft)}catch(It){if(Qt(yt),It!==It+0)throw It;Bt(1,0)}},J:function(Ge){var tt=wt();try{return pt(Ge)()}catch(ft){if(Qt(tt),ft!==ft+0)throw ft;Bt(1,0)}},e:function(Ge,tt){var ft=wt();try{return pt(Ge)(tt)}catch(yt){if(Qt(ft),yt!==yt+0)throw yt;Bt(1,0)}},N:function(Ge,tt,ft){var yt=wt();try{return pt(Ge)(tt,ft)}catch(It){if(Qt(yt),It!==It+0)throw It;Bt(1,0)}},O:function(Ge,tt,ft){var yt=wt();try{return pt(Ge)(tt,ft)}catch(It){if(Qt(yt),It!==It+0)throw It;Bt(1,0)}},j:function(Ge,tt,ft){var yt=wt();try{return pt(Ge)(tt,ft)}catch(It){if(Qt(yt),It!==It+0)throw It;Bt(1,0)}},o:function(Ge,tt,ft,yt){var It=wt();try{return pt(Ge)(tt,ft,yt)}catch(kt){if(Qt(It),kt!==kt+0)throw kt;Bt(1,0)}},p:function(Ge,tt,ft,yt,It){var kt=wt();try{return pt(Ge)(tt,ft,yt,It)}catch(Kt){if(Qt(kt),Kt!==Kt+0)throw Kt;Bt(1,0)}},M:function(Ge,tt,ft,yt,It,kt){var Kt=wt();try{return pt(Ge)(tt,ft,yt,It,kt)}catch(On){if(Qt(Kt),On!==On+0)throw On;Bt(1,0)}},r:function(Ge,tt,ft,yt,It,kt){var Kt=wt();try{return pt(Ge)(tt,ft,yt,It,kt)}catch(On){if(Qt(Kt),On!==On+0)throw On;Bt(1,0)}},v:function(Ge,tt,ft,yt,It,kt,Kt){var On=wt();try{return pt(Ge)(tt,ft,yt,It,kt,Kt)}catch(gn){if(Qt(On),gn!==gn+0)throw gn;Bt(1,0)}},K:function(Ge,tt,ft,yt,It,kt,Kt,On){var gn=wt();try{return pt(Ge)(tt,ft,yt,It,kt,Kt,On)}catch(Ue){if(Qt(gn),Ue!==Ue+0)throw Ue;Bt(1,0)}},D:function(Ge,tt,ft,yt,It,kt,Kt,On,gn,Ue,ct,vt){var _t=wt();try{return pt(Ge)(tt,ft,yt,It,kt,Kt,On,gn,Ue,ct,vt)}catch(je){if(Qt(_t),je!==je+0)throw je;Bt(1,0)}},X:function(Ge,tt,ft,yt,It,kt,Kt,On){var gn=wt();try{return Xr(Ge,tt,ft,yt,It,kt,Kt,On)}catch(Ue){if(Qt(gn),Ue!==Ue+0)throw Ue;Bt(1,0)}},V:function(Ge,tt,ft,yt,It,kt,Kt){var On=wt();try{return lr(Ge,tt,ft,yt,It,kt,Kt)}catch(gn){if(Qt(On),gn!==gn+0)throw gn;Bt(1,0)}},U:function(Ge,tt,ft,yt,It){var kt=wt();try{return cr(Ge,tt,ft,yt,It)}catch(Kt){if(Qt(kt),Kt!==Kt+0)throw Kt;Bt(1,0)}},Z:function(Ge,tt,ft,yt){var It=wt();try{return wr(Ge,tt,ft,yt)}catch(kt){if(Qt(It),kt!==kt+0)throw kt;Bt(1,0)}},W:function(Ge){var tt=wt();try{return Xi(Ge)}catch(ft){if(Qt(tt),ft!==ft+0)throw ft;Bt(1,0)}},Y:function(Ge,tt){var ft=wt();try{return Wr(Ge,tt)}catch(yt){if(Qt(ft),yt!==yt+0)throw yt;Bt(1,0)}},T:function(Ge,tt,ft){var yt=wt();try{return es(Ge,tt,ft)}catch(It){if(Qt(yt),It!==It+0)throw It;Bt(1,0)}},f:function(Ge){var tt=wt();try{pt(Ge)()}catch(ft){if(Qt(tt),ft!==ft+0)throw ft;Bt(1,0)}},q:function(Ge,tt){var ft=wt();try{pt(Ge)(tt)}catch(yt){if(Qt(ft),yt!==yt+0)throw yt;Bt(1,0)}},h:function(Ge,tt,ft){var yt=wt();try{pt(Ge)(tt,ft)}catch(It){if(Qt(yt),It!==It+0)throw It;Bt(1,0)}},da:function(Ge,tt,ft,yt){var It=wt();try{pt(Ge)(tt,ft,yt)}catch(kt){if(Qt(It),kt!==kt+0)throw kt;Bt(1,0)}},l:function(Ge,tt,ft,yt){var It=wt();try{pt(Ge)(tt,ft,yt)}catch(kt){if(Qt(It),kt!==kt+0)throw kt;Bt(1,0)}},t:function(Ge,tt,ft,yt,It){var kt=wt();try{pt(Ge)(tt,ft,yt,It)}catch(Kt){if(Qt(kt),Kt!==Kt+0)throw Kt;Bt(1,0)}},u:function(Ge,tt,ft,yt,It,kt){var Kt=wt();try{pt(Ge)(tt,ft,yt,It,kt)}catch(On){if(Qt(Kt),On!==On+0)throw On;Bt(1,0)}},x:function(Ge,tt,ft,yt,It,kt,Kt){var On=wt();try{pt(Ge)(tt,ft,yt,It,kt,Kt)}catch(gn){if(Qt(On),gn!==gn+0)throw gn;Bt(1,0)}},z:function(Ge,tt,ft,yt,It,kt,Kt,On){var gn=wt();try{pt(Ge)(tt,ft,yt,It,kt,Kt,On)}catch(Ue){if(Qt(gn),Ue!==Ue+0)throw Ue;Bt(1,0)}},ga:function(Ge,tt,ft,yt,It,kt,Kt,On,gn){var Ue=wt();try{pt(Ge)(tt,ft,yt,It,kt,Kt,On,gn)}catch(ct){if(Qt(Ue),ct!==ct+0)throw ct;Bt(1,0)}},A:function(Ge,tt,ft,yt,It,kt,Kt,On,gn,Ue,ct){var vt=wt();try{pt(Ge)(tt,ft,yt,It,kt,Kt,On,gn,Ue,ct)}catch(_t){if(Qt(vt),_t!==_t+0)throw _t;Bt(1,0)}},C:function(Ge,tt,ft,yt,It,kt,Kt,On,gn,Ue,ct,vt,_t,je,Gt,Yt){var mn=wt();try{pt(Ge)(tt,ft,yt,It,kt,Kt,On,gn,Ue,ct,vt,_t,je,Gt,Yt)}catch(_n){if(Qt(mn),_n!==_n+0)throw _n;Bt(1,0)}},aa:function(Ge,tt,ft,yt,It,kt,Kt,On){var gn=wt();try{Qr(Ge,tt,ft,yt,It,kt,Kt,On)}catch(Ue){if(Qt(gn),Ue!==Ue+0)throw Ue;Bt(1,0)}},_:function(Ge,tt,ft,yt,It,kt,Kt,On,gn,Ue,ct,vt){var _t=wt();try{hr(Ge,tt,ft,yt,It,kt,Kt,On,gn,Ue,ct,vt)}catch(je){if(Qt(_t),je!==je+0)throw je;Bt(1,0)}},$:function(Ge,tt,ft,yt,It,kt){var Kt=wt();try{qr(Ge,tt,ft,yt,It,kt)}catch(On){if(Qt(Kt),On!==On+0)throw On;Bt(1,0)}},n:function(Ge){return Ge},F:function(Ge){An=Ge},ha:Sn,y:function(Ge,tt,ft,yt){return Sn(Ge,tt,ft,yt)}};(function(){function Ge(It){q.asm=It.exports,we=q.asm.Ka,rt(),St=q.asm.ib,$t.unshift(q.asm.La),Mn--,q.monitorRunDependencies&&q.monitorRunDependencies(Mn),Mn==0&&Zn&&(It=Zn,Zn=null,It())}function tt(It){Ge(It.instance)}function ft(It){return(function(){if(!ve&&(pe||me)){if(typeof fetch=="function"&&!Jt.startsWith("file://"))return fetch(Jt,{credentials:"same-origin"}).then((function(kt){if(!kt.ok)throw"failed to load wasm binary file at '"+Jt+"'";return kt.arrayBuffer()})).catch((function(){return Gn()}));if(ie)return new Promise((function(kt,Kt){ie(Jt,(function(On){kt(new Uint8Array(On))}),Kt)}))}return Promise.resolve().then((function(){return Gn()}))})().then((function(kt){return WebAssembly.instantiate(kt,yt)})).then((function(kt){return kt})).then(It,(function(kt){Me("failed to asynchronously prepare wasm: "+kt),vn(kt)}))}var yt={a:bn};if(Mn++,q.monitorRunDependencies&&q.monitorRunDependencies(Mn),q.instantiateWasm)try{return q.instantiateWasm(yt,Ge)}catch(It){return Me("Module.instantiateWasm callback failed with error: "+It),!1}(ve||typeof WebAssembly.instantiateStreaming!="function"||In()||Jt.startsWith("file://")||be||typeof fetch!="function"?ft(tt):fetch(Jt,{credentials:"same-origin"}).then((function(It){return WebAssembly.instantiateStreaming(It,yt).then(tt,(function(kt){return Me("wasm streaming compile failed: "+kt),Me("falling back to ArrayBuffer instantiation"),ft(tt)}))}))).catch(ee)})(),q.___wasm_call_ctors=function(){return(q.___wasm_call_ctors=q.asm.La).apply(null,arguments)},q._OrtInit=function(){return(q._OrtInit=q.asm.Ma).apply(null,arguments)},q._OrtCreateSessionOptions=function(){return(q._OrtCreateSessionOptions=q.asm.Na).apply(null,arguments)},q._OrtAppendExecutionProvider=function(){return(q._OrtAppendExecutionProvider=q.asm.Oa).apply(null,arguments)},q._OrtAddSessionConfigEntry=function(){return(q._OrtAddSessionConfigEntry=q.asm.Pa).apply(null,arguments)},q._OrtReleaseSessionOptions=function(){return(q._OrtReleaseSessionOptions=q.asm.Qa).apply(null,arguments)},q._OrtCreateSession=function(){return(q._OrtCreateSession=q.asm.Ra).apply(null,arguments)},q._OrtReleaseSession=function(){return(q._OrtReleaseSession=q.asm.Sa).apply(null,arguments)},q._OrtGetInputCount=function(){return(q._OrtGetInputCount=q.asm.Ta).apply(null,arguments)},q._OrtGetOutputCount=function(){return(q._OrtGetOutputCount=q.asm.Ua).apply(null,arguments)},q._OrtGetInputName=function(){return(q._OrtGetInputName=q.asm.Va).apply(null,arguments)},q._OrtGetOutputName=function(){return(q._OrtGetOutputName=q.asm.Wa).apply(null,arguments)},q._OrtFree=function(){return(q._OrtFree=q.asm.Xa).apply(null,arguments)},q._OrtCreateTensor=function(){return(q._OrtCreateTensor=q.asm.Ya).apply(null,arguments)},q._OrtGetTensorData=function(){return(q._OrtGetTensorData=q.asm.Za).apply(null,arguments)},q._OrtReleaseTensor=function(){return(q._OrtReleaseTensor=q.asm._a).apply(null,arguments)},q._OrtCreateRunOptions=function(){return(q._OrtCreateRunOptions=q.asm.$a).apply(null,arguments)},q._OrtAddRunConfigEntry=function(){return(q._OrtAddRunConfigEntry=q.asm.ab).apply(null,arguments)},q._OrtReleaseRunOptions=function(){return(q._OrtReleaseRunOptions=q.asm.bb).apply(null,arguments)},q._OrtRun=function(){return(q._OrtRun=q.asm.cb).apply(null,arguments)},q._OrtEndProfiling=function(){return(q._OrtEndProfiling=q.asm.db).apply(null,arguments)};var kn,nt=q._malloc=function(){return(nt=q._malloc=q.asm.eb).apply(null,arguments)},dn=q._free=function(){return(dn=q._free=q.asm.fb).apply(null,arguments)},tn=q._fflush=function(){return(tn=q._fflush=q.asm.gb).apply(null,arguments)},Zt=q.___funcs_on_exit=function(){return(Zt=q.___funcs_on_exit=q.asm.hb).apply(null,arguments)},Bt=q._setThrew=function(){return(Bt=q._setThrew=q.asm.jb).apply(null,arguments)},wt=q.stackSave=function(){return(wt=q.stackSave=q.asm.kb).apply(null,arguments)},Qt=q.stackRestore=function(){return(Qt=q.stackRestore=q.asm.lb).apply(null,arguments)},Yn=q.stackAlloc=function(){return(Yn=q.stackAlloc=q.asm.mb).apply(null,arguments)},Ai=q.___cxa_can_catch=function(){return(Ai=q.___cxa_can_catch=q.asm.nb).apply(null,arguments)},hi=q.___cxa_is_pointer_type=function(){return(hi=q.___cxa_is_pointer_type=q.asm.ob).apply(null,arguments)},Xi=q.dynCall_j=function(){return(Xi=q.dynCall_j=q.asm.pb).apply(null,arguments)},lr=q.dynCall_iiiiij=function(){return(lr=q.dynCall_iiiiij=q.asm.qb).apply(null,arguments)},es=q.dynCall_jii=function(){return(es=q.dynCall_jii=q.asm.rb).apply(null,arguments)},Qr=q.dynCall_viiiiij=function(){return(Qr=q.dynCall_viiiiij=q.asm.sb).apply(null,arguments)},qr=q.dynCall_vjji=function(){return(qr=q.dynCall_vjji=q.asm.tb).apply(null,arguments)},hr=q.dynCall_viiijjjii=function(){return(hr=q.dynCall_viiijjjii=q.asm.ub).apply(null,arguments)},wr=q.dynCall_iij=function(){return(wr=q.dynCall_iij=q.asm.vb).apply(null,arguments)},Wr=q.dynCall_ji=function(){return(Wr=q.dynCall_ji=q.asm.wb).apply(null,arguments)},Xr=q.dynCall_iiiiiij=function(){return(Xr=q.dynCall_iiiiiij=q.asm.xb).apply(null,arguments)},cr=q.dynCall_iiij=function(){return(cr=q.dynCall_iiij=q.asm.yb).apply(null,arguments)};function ji(){function Ge(){if(!kn&&(kn=!0,q.calledRun=!0,!Ce)){if(ai($t),K(q),q.onRuntimeInitialized&&q.onRuntimeInitialized(),q.postRun)for(typeof q.postRun=="function"&&(q.postRun=[q.postRun]);q.postRun.length;){var tt=q.postRun.shift();bt.unshift(tt)}ai(bt)}}if(!(0<Mn)){if(q.preRun)for(typeof q.preRun=="function"&&(q.preRun=[q.preRun]);q.preRun.length;)hn();ai(Lt),0<Mn||(q.setStatus?(q.setStatus("Running..."),setTimeout((function(){setTimeout((function(){q.setStatus("")}),1),Ge()}),1)):Ge())}}if(q.UTF8ToString=Xe,q.stringToUTF8=function(Ge,tt,ft){return lt(Ge,Ne,tt,ft)},q.lengthBytesUTF8=ke,q.stackSave=wt,q.stackRestore=Qt,q.stackAlloc=Yn,Zn=function Ge(){kn||ji(),kn||(Zn=Ge)},q.preInit)for(typeof q.preInit=="function"&&(q.preInit=[q.preInit]);0<q.preInit.length;)q.preInit.pop()();return ji(),G.ready});F.exports=U},4537:F=>{F.exports=function(w,D){for(var O=new Array(arguments.length-1),U=0,G=2,q=!0;G<arguments.length;)O[U++]=arguments[G++];return new Promise((function(K,ee){O[U]=function(Z){if(q)if(q=!1,Z)ee(Z);else{for(var ie=new Array(arguments.length-1),Y=0;Y<ie.length;)ie[Y++]=arguments[Y];K.apply(null,ie)}};try{w.apply(D||null,O)}catch(Z){q&&(q=!1,ee(Z))}}))}},7419:(F,w)=>{var D=w;D.length=function(K){var ee=K.length;if(!ee)return 0;for(var Z=0;--ee%4>1&&K.charAt(ee)==="=";)++Z;return Math.ceil(3*K.length)/4-Z};for(var O=new Array(64),U=new Array(123),G=0;G<64;)U[O[G]=G<26?G+65:G<52?G+71:G<62?G-4:G-59|43]=G++;D.encode=function(K,ee,Z){for(var ie,Y=null,W=[],ne=0,se=0;ee<Z;){var le=K[ee++];switch(se){case 0:W[ne++]=O[le>>2],ie=(3&le)<<4,se=1;break;case 1:W[ne++]=O[ie|le>>4],ie=(15&le)<<2,se=2;break;case 2:W[ne++]=O[ie|le>>6],W[ne++]=O[63&le],se=0}ne>8191&&((Y||(Y=[])).push(String.fromCharCode.apply(String,W)),ne=0)}return se&&(W[ne++]=O[ie],W[ne++]=61,se===1&&(W[ne++]=61)),Y?(ne&&Y.push(String.fromCharCode.apply(String,W.slice(0,ne))),Y.join("")):String.fromCharCode.apply(String,W.slice(0,ne))};var q="invalid encoding";D.decode=function(K,ee,Z){for(var ie,Y=Z,W=0,ne=0;ne<K.length;){var se=K.charCodeAt(ne++);if(se===61&&W>1)break;if((se=U[se])===void 0)throw Error(q);switch(W){case 0:ie=se,W=1;break;case 1:ee[Z++]=ie<<2|(48&se)>>4,ie=se,W=2;break;case 2:ee[Z++]=(15&ie)<<4|(60&se)>>2,ie=se,W=3;break;case 3:ee[Z++]=(3&ie)<<6|se,W=0}}if(W===1)throw Error(q);return Z-Y},D.test=function(K){return/^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(K)}},9211:F=>{function w(){this._listeners={}}F.exports=w,w.prototype.on=function(D,O,U){return(this._listeners[D]||(this._listeners[D]=[])).push({fn:O,ctx:U||this}),this},w.prototype.off=function(D,O){if(D===void 0)this._listeners={};else if(O===void 0)this._listeners[D]=[];else for(var U=this._listeners[D],G=0;G<U.length;)U[G].fn===O?U.splice(G,1):++G;return this},w.prototype.emit=function(D){var O=this._listeners[D];if(O){for(var U=[],G=1;G<arguments.length;)U.push(arguments[G++]);for(G=0;G<O.length;)O[G].fn.apply(O[G++].ctx,U)}return this}},945:F=>{function w(q){return typeof Float32Array<"u"?(function(){var K=new Float32Array([-0]),ee=new Uint8Array(K.buffer),Z=ee[3]===128;function ie(se,le,ce){K[0]=se,le[ce]=ee[0],le[ce+1]=ee[1],le[ce+2]=ee[2],le[ce+3]=ee[3]}function Y(se,le,ce){K[0]=se,le[ce]=ee[3],le[ce+1]=ee[2],le[ce+2]=ee[1],le[ce+3]=ee[0]}function W(se,le){return ee[0]=se[le],ee[1]=se[le+1],ee[2]=se[le+2],ee[3]=se[le+3],K[0]}function ne(se,le){return ee[3]=se[le],ee[2]=se[le+1],ee[1]=se[le+2],ee[0]=se[le+3],K[0]}q.writeFloatLE=Z?ie:Y,q.writeFloatBE=Z?Y:ie,q.readFloatLE=Z?W:ne,q.readFloatBE=Z?ne:W})():(function(){function K(Z,ie,Y,W){var ne=ie<0?1:0;if(ne&&(ie=-ie),ie===0)Z(1/ie>0?0:2147483648,Y,W);else if(isNaN(ie))Z(2143289344,Y,W);else if(ie>34028234663852886e22)Z((ne<<31|2139095040)>>>0,Y,W);else if(ie<11754943508222875e-54)Z((ne<<31|Math.round(ie/1401298464324817e-60))>>>0,Y,W);else{var se=Math.floor(Math.log(ie)/Math.LN2);Z((ne<<31|se+127<<23|8388607&Math.round(ie*Math.pow(2,-se)*8388608))>>>0,Y,W)}}function ee(Z,ie,Y){var W=Z(ie,Y),ne=2*(W>>31)+1,se=W>>>23&255,le=8388607&W;return se===255?le?NaN:ne*(1/0):se===0?1401298464324817e-60*ne*le:ne*Math.pow(2,se-150)*(le+8388608)}q.writeFloatLE=K.bind(null,D),q.writeFloatBE=K.bind(null,O),q.readFloatLE=ee.bind(null,U),q.readFloatBE=ee.bind(null,G)})(),typeof Float64Array<"u"?(function(){var K=new Float64Array([-0]),ee=new Uint8Array(K.buffer),Z=ee[7]===128;function ie(se,le,ce){K[0]=se,le[ce]=ee[0],le[ce+1]=ee[1],le[ce+2]=ee[2],le[ce+3]=ee[3],le[ce+4]=ee[4],le[ce+5]=ee[5],le[ce+6]=ee[6],le[ce+7]=ee[7]}function Y(se,le,ce){K[0]=se,le[ce]=ee[7],le[ce+1]=ee[6],le[ce+2]=ee[5],le[ce+3]=ee[4],le[ce+4]=ee[3],le[ce+5]=ee[2],le[ce+6]=ee[1],le[ce+7]=ee[0]}function W(se,le){return ee[0]=se[le],ee[1]=se[le+1],ee[2]=se[le+2],ee[3]=se[le+3],ee[4]=se[le+4],ee[5]=se[le+5],ee[6]=se[le+6],ee[7]=se[le+7],K[0]}function ne(se,le){return ee[7]=se[le],ee[6]=se[le+1],ee[5]=se[le+2],ee[4]=se[le+3],ee[3]=se[le+4],ee[2]=se[le+5],ee[1]=se[le+6],ee[0]=se[le+7],K[0]}q.writeDoubleLE=Z?ie:Y,q.writeDoubleBE=Z?Y:ie,q.readDoubleLE=Z?W:ne,q.readDoubleBE=Z?ne:W})():(function(){function K(Z,ie,Y,W,ne,se){var le=W<0?1:0;if(le&&(W=-W),W===0)Z(0,ne,se+ie),Z(1/W>0?0:2147483648,ne,se+Y);else if(isNaN(W))Z(0,ne,se+ie),Z(2146959360,ne,se+Y);else if(W>17976931348623157e292)Z(0,ne,se+ie),Z((le<<31|2146435072)>>>0,ne,se+Y);else{var ce;if(W<22250738585072014e-324)Z((ce=W/5e-324)>>>0,ne,se+ie),Z((le<<31|ce/4294967296)>>>0,ne,se+Y);else{var he=Math.floor(Math.log(W)/Math.LN2);he===1024&&(he=1023),Z(4503599627370496*(ce=W*Math.pow(2,-he))>>>0,ne,se+ie),Z((le<<31|he+1023<<20|1048576*ce&1048575)>>>0,ne,se+Y)}}}function ee(Z,ie,Y,W,ne){var se=Z(W,ne+ie),le=Z(W,ne+Y),ce=2*(le>>31)+1,he=le>>>20&2047,pe=4294967296*(1048575&le)+se;return he===2047?pe?NaN:ce*(1/0):he===0?5e-324*ce*pe:ce*Math.pow(2,he-1075)*(pe+4503599627370496)}q.writeDoubleLE=K.bind(null,D,0,4),q.writeDoubleBE=K.bind(null,O,4,0),q.readDoubleLE=ee.bind(null,U,0,4),q.readDoubleBE=ee.bind(null,G,4,0)})(),q}function D(q,K,ee){K[ee]=255&q,K[ee+1]=q>>>8&255,K[ee+2]=q>>>16&255,K[ee+3]=q>>>24}function O(q,K,ee){K[ee]=q>>>24,K[ee+1]=q>>>16&255,K[ee+2]=q>>>8&255,K[ee+3]=255&q}function U(q,K){return(q[K]|q[K+1]<<8|q[K+2]<<16|q[K+3]<<24)>>>0}function G(q,K){return(q[K]<<24|q[K+1]<<16|q[K+2]<<8|q[K+3])>>>0}F.exports=w(w)},7199:module=>{function inquire(moduleName){try{var mod=eval("quire".replace(/^/,"re"))(moduleName);if(mod&&(mod.length||Object.keys(mod).length))return mod}catch(F){}return null}module.exports=inquire},6662:F=>{F.exports=function(w,D,O){var U=O||8192,G=U>>>1,q=null,K=U;return function(ee){if(ee<1||ee>G)return w(ee);K+ee>U&&(q=w(U),K=0);var Z=D.call(q,K,K+=ee);return 7&K&&(K=1+(7|K)),Z}}},4997:(F,w)=>{var D=w;D.length=function(O){for(var U=0,G=0,q=0;q<O.length;++q)(G=O.charCodeAt(q))<128?U+=1:G<2048?U+=2:(64512&G)==55296&&(64512&O.charCodeAt(q+1))==56320?(++q,U+=4):U+=3;return U},D.read=function(O,U,G){if(G-U<1)return"";for(var q,K=null,ee=[],Z=0;U<G;)(q=O[U++])<128?ee[Z++]=q:q>191&&q<224?ee[Z++]=(31&q)<<6|63&O[U++]:q>239&&q<365?(q=((7&q)<<18|(63&O[U++])<<12|(63&O[U++])<<6|63&O[U++])-65536,ee[Z++]=55296+(q>>10),ee[Z++]=56320+(1023&q)):ee[Z++]=(15&q)<<12|(63&O[U++])<<6|63&O[U++],Z>8191&&((K||(K=[])).push(String.fromCharCode.apply(String,ee)),Z=0);return K?(Z&&K.push(String.fromCharCode.apply(String,ee.slice(0,Z))),K.join("")):String.fromCharCode.apply(String,ee.slice(0,Z))},D.write=function(O,U,G){for(var q,K,ee=G,Z=0;Z<O.length;++Z)(q=O.charCodeAt(Z))<128?U[G++]=q:q<2048?(U[G++]=q>>6|192,U[G++]=63&q|128):(64512&q)==55296&&(64512&(K=O.charCodeAt(Z+1)))==56320?(q=65536+((1023&q)<<10)+(1023&K),++Z,U[G++]=q>>18|240,U[G++]=q>>12&63|128,U[G++]=q>>6&63|128,U[G++]=63&q|128):(U[G++]=q>>12|224,U[G++]=q>>6&63|128,U[G++]=63&q|128);return G-ee}},3442:(F,w)=>{w.__esModule=!0;var D=(function(){function O(U){if(!U)throw new TypeError("Invalid argument; `value` has no value.");this.value=O.EMPTY,U&&O.isGuid(U)&&(this.value=U)}return O.isGuid=function(U){var G=U.toString();return U&&(U instanceof O||O.validator.test(G))},O.create=function(){return new O([O.gen(2),O.gen(1),O.gen(1),O.gen(1),O.gen(3)].join("-"))},O.createEmpty=function(){return new O("emptyguid")},O.parse=function(U){return new O(U)},O.raw=function(){return[O.gen(2),O.gen(1),O.gen(1),O.gen(1),O.gen(3)].join("-")},O.gen=function(U){for(var G="",q=0;q<U;q++)G+=(65536*(1+Math.random())|0).toString(16).substring(1);return G},O.prototype.equals=function(U){return O.isGuid(U)&&this.value===U.toString()},O.prototype.isEmpty=function(){return this.value===O.EMPTY},O.prototype.toString=function(){return this.value},O.prototype.toJSON=function(){return{value:this.value}},O.validator=new RegExp("^[a-z0-9]{8}-[a-z0-9]{4}-[a-z0-9]{4}-[a-z0-9]{4}-[a-z0-9]{12}$","i"),O.EMPTY="00000000-0000-0000-0000-000000000000",O})();w.Guid=D},3720:F=>{F.exports=D;var w=null;try{w=new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0,1,13,2,96,0,1,127,96,4,127,127,127,127,1,127,3,7,6,0,1,1,1,1,1,6,6,1,127,1,65,0,11,7,50,6,3,109,117,108,0,1,5,100,105,118,95,115,0,2,5,100,105,118,95,117,0,3,5,114,101,109,95,115,0,4,5,114,101,109,95,117,0,5,8,103,101,116,95,104,105,103,104,0,0,10,191,1,6,4,0,35,0,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,126,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,127,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,128,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,129,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,130,34,4,66,32,135,167,36,0,32,4,167,11])),{}).exports}catch{}function D(Ee,we,Re){this.low=0|Ee,this.high=0|we,this.unsigned=!!Re}function O(Ee){return(Ee&&Ee.__isLong__)===!0}D.prototype.__isLong__,Object.defineProperty(D.prototype,"__isLong__",{value:!0}),D.isLong=O;var U={},G={};function q(Ee,we){var Re,Le,Ne;return we?(Ne=0<=(Ee>>>=0)&&Ee<256)&&(Le=G[Ee])?Le:(Re=ee(Ee,(0|Ee)<0?-1:0,!0),Ne&&(G[Ee]=Re),Re):(Ne=-128<=(Ee|=0)&&Ee<128)&&(Le=U[Ee])?Le:(Re=ee(Ee,Ee<0?-1:0,!1),Ne&&(U[Ee]=Re),Re)}function K(Ee,we){if(isNaN(Ee))return we?he:ce;if(we){if(Ee<0)return he;if(Ee>=ne)return ve}else{if(Ee<=-se)return Se;if(Ee+1>=se)return ge}return Ee<0?K(-Ee,we).neg():ee(Ee%W|0,Ee/W|0,we)}function ee(Ee,we,Re){return new D(Ee,we,Re)}D.fromInt=q,D.fromNumber=K,D.fromBits=ee;var Z=Math.pow;function ie(Ee,we,Re){if(Ee.length===0)throw Error("empty string");if(Ee==="NaN"||Ee==="Infinity"||Ee==="+Infinity"||Ee==="-Infinity")return ce;if(typeof we=="number"?(Re=we,we=!1):we=!!we,(Re=Re||10)<2||36<Re)throw RangeError("radix");var Le;if((Le=Ee.indexOf("-"))>0)throw Error("interior hyphen");if(Le===0)return ie(Ee.substring(1),we,Re).neg();for(var Ne=K(Z(Re,8)),Oe=ce,Pe=0;Pe<Ee.length;Pe+=8){var Ce=Math.min(8,Ee.length-Pe),Be=parseInt(Ee.substring(Pe,Pe+Ce),Re);if(Ce<8){var ze=K(Z(Re,Ce));Oe=Oe.mul(ze).add(K(Be))}else Oe=(Oe=Oe.mul(Ne)).add(K(Be))}return Oe.unsigned=we,Oe}function Y(Ee,we){return typeof Ee=="number"?K(Ee,we):typeof Ee=="string"?ie(Ee,we):ee(Ee.low,Ee.high,typeof we=="boolean"?we:Ee.unsigned)}D.fromString=ie,D.fromValue=Y;var W=4294967296,ne=W*W,se=ne/2,le=q(1<<24),ce=q(0);D.ZERO=ce;var he=q(0,!0);D.UZERO=he;var pe=q(1);D.ONE=pe;var me=q(1,!0);D.UONE=me;var be=q(-1);D.NEG_ONE=be;var ge=ee(-1,2147483647,!1);D.MAX_VALUE=ge;var ve=ee(-1,-1,!0);D.MAX_UNSIGNED_VALUE=ve;var Se=ee(0,-2147483648,!1);D.MIN_VALUE=Se;var Me=D.prototype;Me.toInt=function(){return this.unsigned?this.low>>>0:this.low},Me.toNumber=function(){return this.unsigned?(this.high>>>0)*W+(this.low>>>0):this.high*W+(this.low>>>0)},Me.toString=function(Ee){if((Ee=Ee||10)<2||36<Ee)throw RangeError("radix");if(this.isZero())return"0";if(this.isNegative()){if(this.eq(Se)){var we=K(Ee),Re=this.div(we),Le=Re.mul(we).sub(this);return Re.toString(Ee)+Le.toInt().toString(Ee)}return"-"+this.neg().toString(Ee)}for(var Ne=K(Z(Ee,6),this.unsigned),Oe=this,Pe="";;){var Ce=Oe.div(Ne),Be=(Oe.sub(Ce.mul(Ne)).toInt()>>>0).toString(Ee);if((Oe=Ce).isZero())return Be+Pe;for(;Be.length<6;)Be="0"+Be;Pe=""+Be+Pe}},Me.getHighBits=function(){return this.high},Me.getHighBitsUnsigned=function(){return this.high>>>0},Me.getLowBits=function(){return this.low},Me.getLowBitsUnsigned=function(){return this.low>>>0},Me.getNumBitsAbs=function(){if(this.isNegative())return this.eq(Se)?64:this.neg().getNumBitsAbs();for(var Ee=this.high!=0?this.high:this.low,we=31;we>0&&(Ee&1<<we)==0;we--);return this.high!=0?we+33:we+1},Me.isZero=function(){return this.high===0&&this.low===0},Me.eqz=Me.isZero,Me.isNegative=function(){return!this.unsigned&&this.high<0},Me.isPositive=function(){return this.unsigned||this.high>=0},Me.isOdd=function(){return(1&this.low)==1},Me.isEven=function(){return(1&this.low)==0},Me.equals=function(Ee){return O(Ee)||(Ee=Y(Ee)),(this.unsigned===Ee.unsigned||this.high>>>31!=1||Ee.high>>>31!=1)&&this.high===Ee.high&&this.low===Ee.low},Me.eq=Me.equals,Me.notEquals=function(Ee){return!this.eq(Ee)},Me.neq=Me.notEquals,Me.ne=Me.notEquals,Me.lessThan=function(Ee){return this.comp(Ee)<0},Me.lt=Me.lessThan,Me.lessThanOrEqual=function(Ee){return this.comp(Ee)<=0},Me.lte=Me.lessThanOrEqual,Me.le=Me.lessThanOrEqual,Me.greaterThan=function(Ee){return this.comp(Ee)>0},Me.gt=Me.greaterThan,Me.greaterThanOrEqual=function(Ee){return this.comp(Ee)>=0},Me.gte=Me.greaterThanOrEqual,Me.ge=Me.greaterThanOrEqual,Me.compare=function(Ee){if(O(Ee)||(Ee=Y(Ee)),this.eq(Ee))return 0;var we=this.isNegative(),Re=Ee.isNegative();return we&&!Re?-1:!we&&Re?1:this.unsigned?Ee.high>>>0>this.high>>>0||Ee.high===this.high&&Ee.low>>>0>this.low>>>0?-1:1:this.sub(Ee).isNegative()?-1:1},Me.comp=Me.compare,Me.negate=function(){return!this.unsigned&&this.eq(Se)?Se:this.not().add(pe)},Me.neg=Me.negate,Me.add=function(Ee){O(Ee)||(Ee=Y(Ee));var we=this.high>>>16,Re=65535&this.high,Le=this.low>>>16,Ne=65535&this.low,Oe=Ee.high>>>16,Pe=65535&Ee.high,Ce=Ee.low>>>16,Be=0,ze=0,Xe=0,lt=0;return Xe+=(lt+=Ne+(65535&Ee.low))>>>16,ze+=(Xe+=Le+Ce)>>>16,Be+=(ze+=Re+Pe)>>>16,Be+=we+Oe,ee((Xe&=65535)<<16|(lt&=65535),(Be&=65535)<<16|(ze&=65535),this.unsigned)},Me.subtract=function(Ee){return O(Ee)||(Ee=Y(Ee)),this.add(Ee.neg())},Me.sub=Me.subtract,Me.multiply=function(Ee){if(this.isZero())return ce;if(O(Ee)||(Ee=Y(Ee)),w)return ee(w.mul(this.low,this.high,Ee.low,Ee.high),w.get_high(),this.unsigned);if(Ee.isZero())return ce;if(this.eq(Se))return Ee.isOdd()?Se:ce;if(Ee.eq(Se))return this.isOdd()?Se:ce;if(this.isNegative())return Ee.isNegative()?this.neg().mul(Ee.neg()):this.neg().mul(Ee).neg();if(Ee.isNegative())return this.mul(Ee.neg()).neg();if(this.lt(le)&&Ee.lt(le))return K(this.toNumber()*Ee.toNumber(),this.unsigned);var we=this.high>>>16,Re=65535&this.high,Le=this.low>>>16,Ne=65535&this.low,Oe=Ee.high>>>16,Pe=65535&Ee.high,Ce=Ee.low>>>16,Be=65535&Ee.low,ze=0,Xe=0,lt=0,ke=0;return lt+=(ke+=Ne*Be)>>>16,Xe+=(lt+=Le*Be)>>>16,lt&=65535,Xe+=(lt+=Ne*Ce)>>>16,ze+=(Xe+=Re*Be)>>>16,Xe&=65535,ze+=(Xe+=Le*Ce)>>>16,Xe&=65535,ze+=(Xe+=Ne*Pe)>>>16,ze+=we*Be+Re*Ce+Le*Pe+Ne*Oe,ee((lt&=65535)<<16|(ke&=65535),(ze&=65535)<<16|(Xe&=65535),this.unsigned)},Me.mul=Me.multiply,Me.divide=function(Ee){if(O(Ee)||(Ee=Y(Ee)),Ee.isZero())throw Error("division by zero");var we,Re,Le;if(w)return this.unsigned||this.high!==-2147483648||Ee.low!==-1||Ee.high!==-1?ee((this.unsigned?w.div_u:w.div_s)(this.low,this.high,Ee.low,Ee.high),w.get_high(),this.unsigned):this;if(this.isZero())return this.unsigned?he:ce;if(this.unsigned){if(Ee.unsigned||(Ee=Ee.toUnsigned()),Ee.gt(this))return he;if(Ee.gt(this.shru(1)))return me;Le=he}else{if(this.eq(Se))return Ee.eq(pe)||Ee.eq(be)?Se:Ee.eq(Se)?pe:(we=this.shr(1).div(Ee).shl(1)).eq(ce)?Ee.isNegative()?pe:be:(Re=this.sub(Ee.mul(we)),Le=we.add(Re.div(Ee)));if(Ee.eq(Se))return this.unsigned?he:ce;if(this.isNegative())return Ee.isNegative()?this.neg().div(Ee.neg()):this.neg().div(Ee).neg();if(Ee.isNegative())return this.div(Ee.neg()).neg();Le=ce}for(Re=this;Re.gte(Ee);){we=Math.max(1,Math.floor(Re.toNumber()/Ee.toNumber()));for(var Ne=Math.ceil(Math.log(we)/Math.LN2),Oe=Ne<=48?1:Z(2,Ne-48),Pe=K(we),Ce=Pe.mul(Ee);Ce.isNegative()||Ce.gt(Re);)Ce=(Pe=K(we-=Oe,this.unsigned)).mul(Ee);Pe.isZero()&&(Pe=pe),Le=Le.add(Pe),Re=Re.sub(Ce)}return Le},Me.div=Me.divide,Me.modulo=function(Ee){return O(Ee)||(Ee=Y(Ee)),w?ee((this.unsigned?w.rem_u:w.rem_s)(this.low,this.high,Ee.low,Ee.high),w.get_high(),this.unsigned):this.sub(this.div(Ee).mul(Ee))},Me.mod=Me.modulo,Me.rem=Me.modulo,Me.not=function(){return ee(~this.low,~this.high,this.unsigned)},Me.and=function(Ee){return O(Ee)||(Ee=Y(Ee)),ee(this.low&Ee.low,this.high&Ee.high,this.unsigned)},Me.or=function(Ee){return O(Ee)||(Ee=Y(Ee)),ee(this.low|Ee.low,this.high|Ee.high,this.unsigned)},Me.xor=function(Ee){return O(Ee)||(Ee=Y(Ee)),ee(this.low^Ee.low,this.high^Ee.high,this.unsigned)},Me.shiftLeft=function(Ee){return O(Ee)&&(Ee=Ee.toInt()),(Ee&=63)==0?this:Ee<32?ee(this.low<<Ee,this.high<<Ee|this.low>>>32-Ee,this.unsigned):ee(0,this.low<<Ee-32,this.unsigned)},Me.shl=Me.shiftLeft,Me.shiftRight=function(Ee){return O(Ee)&&(Ee=Ee.toInt()),(Ee&=63)==0?this:Ee<32?ee(this.low>>>Ee|this.high<<32-Ee,this.high>>Ee,this.unsigned):ee(this.high>>Ee-32,this.high>=0?0:-1,this.unsigned)},Me.shr=Me.shiftRight,Me.shiftRightUnsigned=function(Ee){if(O(Ee)&&(Ee=Ee.toInt()),(Ee&=63)==0)return this;var we=this.high;return Ee<32?ee(this.low>>>Ee|we<<32-Ee,we>>>Ee,this.unsigned):ee(Ee===32?we:we>>>Ee-32,0,this.unsigned)},Me.shru=Me.shiftRightUnsigned,Me.shr_u=Me.shiftRightUnsigned,Me.toSigned=function(){return this.unsigned?ee(this.low,this.high,!1):this},Me.toUnsigned=function(){return this.unsigned?this:ee(this.low,this.high,!0)},Me.toBytes=function(Ee){return Ee?this.toBytesLE():this.toBytesBE()},Me.toBytesLE=function(){var Ee=this.high,we=this.low;return[255&we,we>>>8&255,we>>>16&255,we>>>24,255&Ee,Ee>>>8&255,Ee>>>16&255,Ee>>>24]},Me.toBytesBE=function(){var Ee=this.high,we=this.low;return[Ee>>>24,Ee>>>16&255,Ee>>>8&255,255&Ee,we>>>24,we>>>16&255,we>>>8&255,255&we]},D.fromBytes=function(Ee,we,Re){return Re?D.fromBytesLE(Ee,we):D.fromBytesBE(Ee,we)},D.fromBytesLE=function(Ee,we){return new D(Ee[0]|Ee[1]<<8|Ee[2]<<16|Ee[3]<<24,Ee[4]|Ee[5]<<8|Ee[6]<<16|Ee[7]<<24,we)},D.fromBytesBE=function(Ee,we){return new D(Ee[4]<<24|Ee[5]<<16|Ee[6]<<8|Ee[7],Ee[0]<<24|Ee[1]<<16|Ee[2]<<8|Ee[3],we)}},1446:(F,w,D)=>{var O,U,G,q=D(2100),K=q.Reader,ee=q.Writer,Z=q.util,ie=q.roots.default||(q.roots.default={});ie.onnx=((G={}).Version=(O={},(U=Object.create(O))[O[0]="_START_VERSION"]=0,U[O[1]="IR_VERSION_2017_10_10"]=1,U[O[2]="IR_VERSION_2017_10_30"]=2,U[O[3]="IR_VERSION_2017_11_3"]=3,U[O[4]="IR_VERSION_2019_1_22"]=4,U[O[5]="IR_VERSION"]=5,U),G.AttributeProto=(function(){function Y(W){if(this.floats=[],this.ints=[],this.strings=[],this.tensors=[],this.graphs=[],W)for(var ne=Object.keys(W),se=0;se<ne.length;++se)W[ne[se]]!=null&&(this[ne[se]]=W[ne[se]])}return Y.prototype.name="",Y.prototype.refAttrName="",Y.prototype.docString="",Y.prototype.type=0,Y.prototype.f=0,Y.prototype.i=Z.Long?Z.Long.fromBits(0,0,!1):0,Y.prototype.s=Z.newBuffer([]),Y.prototype.t=null,Y.prototype.g=null,Y.prototype.floats=Z.emptyArray,Y.prototype.ints=Z.emptyArray,Y.prototype.strings=Z.emptyArray,Y.prototype.tensors=Z.emptyArray,Y.prototype.graphs=Z.emptyArray,Y.create=function(W){return new Y(W)},Y.encode=function(W,ne){if(ne||(ne=ee.create()),W.name!=null&&W.hasOwnProperty("name")&&ne.uint32(10).string(W.name),W.f!=null&&W.hasOwnProperty("f")&&ne.uint32(21).float(W.f),W.i!=null&&W.hasOwnProperty("i")&&ne.uint32(24).int64(W.i),W.s!=null&&W.hasOwnProperty("s")&&ne.uint32(34).bytes(W.s),W.t!=null&&W.hasOwnProperty("t")&&ie.onnx.TensorProto.encode(W.t,ne.uint32(42).fork()).ldelim(),W.g!=null&&W.hasOwnProperty("g")&&ie.onnx.GraphProto.encode(W.g,ne.uint32(50).fork()).ldelim(),W.floats!=null&&W.floats.length){ne.uint32(58).fork();for(var se=0;se<W.floats.length;++se)ne.float(W.floats[se]);ne.ldelim()}if(W.ints!=null&&W.ints.length){for(ne.uint32(66).fork(),se=0;se<W.ints.length;++se)ne.int64(W.ints[se]);ne.ldelim()}if(W.strings!=null&&W.strings.length)for(se=0;se<W.strings.length;++se)ne.uint32(74).bytes(W.strings[se]);if(W.tensors!=null&&W.tensors.length)for(se=0;se<W.tensors.length;++se)ie.onnx.TensorProto.encode(W.tensors[se],ne.uint32(82).fork()).ldelim();if(W.graphs!=null&&W.graphs.length)for(se=0;se<W.graphs.length;++se)ie.onnx.GraphProto.encode(W.graphs[se],ne.uint32(90).fork()).ldelim();return W.docString!=null&&W.hasOwnProperty("docString")&&ne.uint32(106).string(W.docString),W.type!=null&&W.hasOwnProperty("type")&&ne.uint32(160).int32(W.type),W.refAttrName!=null&&W.hasOwnProperty("refAttrName")&&ne.uint32(170).string(W.refAttrName),ne},Y.encodeDelimited=function(W,ne){return this.encode(W,ne).ldelim()},Y.decode=function(W,ne){W instanceof K||(W=K.create(W));for(var se=ne===void 0?W.len:W.pos+ne,le=new ie.onnx.AttributeProto;W.pos<se;){var ce=W.uint32();switch(ce>>>3){case 1:le.name=W.string();break;case 21:le.refAttrName=W.string();break;case 13:le.docString=W.string();break;case 20:le.type=W.int32();break;case 2:le.f=W.float();break;case 3:le.i=W.int64();break;case 4:le.s=W.bytes();break;case 5:le.t=ie.onnx.TensorProto.decode(W,W.uint32());break;case 6:le.g=ie.onnx.GraphProto.decode(W,W.uint32());break;case 7:if(le.floats&&le.floats.length||(le.floats=[]),(7&ce)==2)for(var he=W.uint32()+W.pos;W.pos<he;)le.floats.push(W.float());else le.floats.push(W.float());break;case 8:if(le.ints&&le.ints.length||(le.ints=[]),(7&ce)==2)for(he=W.uint32()+W.pos;W.pos<he;)le.ints.push(W.int64());else le.ints.push(W.int64());break;case 9:le.strings&&le.strings.length||(le.strings=[]),le.strings.push(W.bytes());break;case 10:le.tensors&&le.tensors.length||(le.tensors=[]),le.tensors.push(ie.onnx.TensorProto.decode(W,W.uint32()));break;case 11:le.graphs&&le.graphs.length||(le.graphs=[]),le.graphs.push(ie.onnx.GraphProto.decode(W,W.uint32()));break;default:W.skipType(7&ce)}}return le},Y.decodeDelimited=function(W){return W instanceof K||(W=new K(W)),this.decode(W,W.uint32())},Y.verify=function(W){if(typeof W!="object"||W===null)return"object expected";if(W.name!=null&&W.hasOwnProperty("name")&&!Z.isString(W.name))return"name: string expected";if(W.refAttrName!=null&&W.hasOwnProperty("refAttrName")&&!Z.isString(W.refAttrName))return"refAttrName: string expected";if(W.docString!=null&&W.hasOwnProperty("docString")&&!Z.isString(W.docString))return"docString: string expected";if(W.type!=null&&W.hasOwnProperty("type"))switch(W.type){default:return"type: enum value expected";case 0:case 1:case 2:case 3:case 4:case 5:case 6:case 7:case 8:case 9:case 10:}if(W.f!=null&&W.hasOwnProperty("f")&&typeof W.f!="number")return"f: number expected";if(W.i!=null&&W.hasOwnProperty("i")&&!(Z.isInteger(W.i)||W.i&&Z.isInteger(W.i.low)&&Z.isInteger(W.i.high)))return"i: integer|Long expected";if(W.s!=null&&W.hasOwnProperty("s")&&!(W.s&&typeof W.s.length=="number"||Z.isString(W.s)))return"s: buffer expected";if(W.t!=null&&W.hasOwnProperty("t")&&(se=ie.onnx.TensorProto.verify(W.t)))return"t."+se;if(W.g!=null&&W.hasOwnProperty("g")&&(se=ie.onnx.GraphProto.verify(W.g)))return"g."+se;if(W.floats!=null&&W.hasOwnProperty("floats")){if(!Array.isArray(W.floats))return"floats: array expected";for(var ne=0;ne<W.floats.length;++ne)if(typeof W.floats[ne]!="number")return"floats: number[] expected"}if(W.ints!=null&&W.hasOwnProperty("ints")){if(!Array.isArray(W.ints))return"ints: array expected";for(ne=0;ne<W.ints.length;++ne)if(!(Z.isInteger(W.ints[ne])||W.ints[ne]&&Z.isInteger(W.ints[ne].low)&&Z.isInteger(W.ints[ne].high)))return"ints: integer|Long[] expected"}if(W.strings!=null&&W.hasOwnProperty("strings")){if(!Array.isArray(W.strings))return"strings: array expected";for(ne=0;ne<W.strings.length;++ne)if(!(W.strings[ne]&&typeof W.strings[ne].length=="number"||Z.isString(W.strings[ne])))return"strings: buffer[] expected"}if(W.tensors!=null&&W.hasOwnProperty("tensors")){if(!Array.isArray(W.tensors))return"tensors: array expected";for(ne=0;ne<W.tensors.length;++ne)if(se=ie.onnx.TensorProto.verify(W.tensors[ne]))return"tensors."+se}if(W.graphs!=null&&W.hasOwnProperty("graphs")){if(!Array.isArray(W.graphs))return"graphs: array expected";for(ne=0;ne<W.graphs.length;++ne){var se;if(se=ie.onnx.GraphProto.verify(W.graphs[ne]))return"graphs."+se}}return null},Y.fromObject=function(W){if(W instanceof ie.onnx.AttributeProto)return W;var ne=new ie.onnx.AttributeProto;switch(W.name!=null&&(ne.name=String(W.name)),W.refAttrName!=null&&(ne.refAttrName=String(W.refAttrName)),W.docString!=null&&(ne.docString=String(W.docString)),W.type){case"UNDEFINED":case 0:ne.type=0;break;case"FLOAT":case 1:ne.type=1;break;case"INT":case 2:ne.type=2;break;case"STRING":case 3:ne.type=3;break;case"TENSOR":case 4:ne.type=4;break;case"GRAPH":case 5:ne.type=5;break;case"FLOATS":case 6:ne.type=6;break;case"INTS":case 7:ne.type=7;break;case"STRINGS":case 8:ne.type=8;break;case"TENSORS":case 9:ne.type=9;break;case"GRAPHS":case 10:ne.type=10}if(W.f!=null&&(ne.f=Number(W.f)),W.i!=null&&(Z.Long?(ne.i=Z.Long.fromValue(W.i)).unsigned=!1:typeof W.i=="string"?ne.i=parseInt(W.i,10):typeof W.i=="number"?ne.i=W.i:typeof W.i=="object"&&(ne.i=new Z.LongBits(W.i.low>>>0,W.i.high>>>0).toNumber())),W.s!=null&&(typeof W.s=="string"?Z.base64.decode(W.s,ne.s=Z.newBuffer(Z.base64.length(W.s)),0):W.s.length&&(ne.s=W.s)),W.t!=null){if(typeof W.t!="object")throw TypeError(".onnx.AttributeProto.t: object expected");ne.t=ie.onnx.TensorProto.fromObject(W.t)}if(W.g!=null){if(typeof W.g!="object")throw TypeError(".onnx.AttributeProto.g: object expected");ne.g=ie.onnx.GraphProto.fromObject(W.g)}if(W.floats){if(!Array.isArray(W.floats))throw TypeError(".onnx.AttributeProto.floats: array expected");ne.floats=[];for(var se=0;se<W.floats.length;++se)ne.floats[se]=Number(W.floats[se])}if(W.ints){if(!Array.isArray(W.ints))throw TypeError(".onnx.AttributeProto.ints: array expected");for(ne.ints=[],se=0;se<W.ints.length;++se)Z.Long?(ne.ints[se]=Z.Long.fromValue(W.ints[se])).unsigned=!1:typeof W.ints[se]=="string"?ne.ints[se]=parseInt(W.ints[se],10):typeof W.ints[se]=="number"?ne.ints[se]=W.ints[se]:typeof W.ints[se]=="object"&&(ne.ints[se]=new Z.LongBits(W.ints[se].low>>>0,W.ints[se].high>>>0).toNumber())}if(W.strings){if(!Array.isArray(W.strings))throw TypeError(".onnx.AttributeProto.strings: array expected");for(ne.strings=[],se=0;se<W.strings.length;++se)typeof W.strings[se]=="string"?Z.base64.decode(W.strings[se],ne.strings[se]=Z.newBuffer(Z.base64.length(W.strings[se])),0):W.strings[se].length&&(ne.strings[se]=W.strings[se])}if(W.tensors){if(!Array.isArray(W.tensors))throw TypeError(".onnx.AttributeProto.tensors: array expected");for(ne.tensors=[],se=0;se<W.tensors.length;++se){if(typeof W.tensors[se]!="object")throw TypeError(".onnx.AttributeProto.tensors: object expected");ne.tensors[se]=ie.onnx.TensorProto.fromObject(W.tensors[se])}}if(W.graphs){if(!Array.isArray(W.graphs))throw TypeError(".onnx.AttributeProto.graphs: array expected");for(ne.graphs=[],se=0;se<W.graphs.length;++se){if(typeof W.graphs[se]!="object")throw TypeError(".onnx.AttributeProto.graphs: object expected");ne.graphs[se]=ie.onnx.GraphProto.fromObject(W.graphs[se])}}return ne},Y.toObject=function(W,ne){ne||(ne={});var se={};if((ne.arrays||ne.defaults)&&(se.floats=[],se.ints=[],se.strings=[],se.tensors=[],se.graphs=[]),ne.defaults){if(se.name="",se.f=0,Z.Long){var le=new Z.Long(0,0,!1);se.i=ne.longs===String?le.toString():ne.longs===Number?le.toNumber():le}else se.i=ne.longs===String?"0":0;ne.bytes===String?se.s="":(se.s=[],ne.bytes!==Array&&(se.s=Z.newBuffer(se.s))),se.t=null,se.g=null,se.docString="",se.type=ne.enums===String?"UNDEFINED":0,se.refAttrName=""}if(W.name!=null&&W.hasOwnProperty("name")&&(se.name=W.name),W.f!=null&&W.hasOwnProperty("f")&&(se.f=ne.json&&!isFinite(W.f)?String(W.f):W.f),W.i!=null&&W.hasOwnProperty("i")&&(typeof W.i=="number"?se.i=ne.longs===String?String(W.i):W.i:se.i=ne.longs===String?Z.Long.prototype.toString.call(W.i):ne.longs===Number?new Z.LongBits(W.i.low>>>0,W.i.high>>>0).toNumber():W.i),W.s!=null&&W.hasOwnProperty("s")&&(se.s=ne.bytes===String?Z.base64.encode(W.s,0,W.s.length):ne.bytes===Array?Array.prototype.slice.call(W.s):W.s),W.t!=null&&W.hasOwnProperty("t")&&(se.t=ie.onnx.TensorProto.toObject(W.t,ne)),W.g!=null&&W.hasOwnProperty("g")&&(se.g=ie.onnx.GraphProto.toObject(W.g,ne)),W.floats&&W.floats.length){se.floats=[];for(var ce=0;ce<W.floats.length;++ce)se.floats[ce]=ne.json&&!isFinite(W.floats[ce])?String(W.floats[ce]):W.floats[ce]}if(W.ints&&W.ints.length)for(se.ints=[],ce=0;ce<W.ints.length;++ce)typeof W.ints[ce]=="number"?se.ints[ce]=ne.longs===String?String(W.ints[ce]):W.ints[ce]:se.ints[ce]=ne.longs===String?Z.Long.prototype.toString.call(W.ints[ce]):ne.longs===Number?new Z.LongBits(W.ints[ce].low>>>0,W.ints[ce].high>>>0).toNumber():W.ints[ce];if(W.strings&&W.strings.length)for(se.strings=[],ce=0;ce<W.strings.length;++ce)se.strings[ce]=ne.bytes===String?Z.base64.encode(W.strings[ce],0,W.strings[ce].length):ne.bytes===Array?Array.prototype.slice.call(W.strings[ce]):W.strings[ce];if(W.tensors&&W.tensors.length)for(se.tensors=[],ce=0;ce<W.tensors.length;++ce)se.tensors[ce]=ie.onnx.TensorProto.toObject(W.tensors[ce],ne);if(W.graphs&&W.graphs.length)for(se.graphs=[],ce=0;ce<W.graphs.length;++ce)se.graphs[ce]=ie.onnx.GraphProto.toObject(W.graphs[ce],ne);return W.docString!=null&&W.hasOwnProperty("docString")&&(se.docString=W.docString),W.type!=null&&W.hasOwnProperty("type")&&(se.type=ne.enums===String?ie.onnx.AttributeProto.AttributeType[W.type]:W.type),W.refAttrName!=null&&W.hasOwnProperty("refAttrName")&&(se.refAttrName=W.refAttrName),se},Y.prototype.toJSON=function(){return this.constructor.toObject(this,q.util.toJSONOptions)},Y.AttributeType=(function(){var W={},ne=Object.create(W);return ne[W[0]="UNDEFINED"]=0,ne[W[1]="FLOAT"]=1,ne[W[2]="INT"]=2,ne[W[3]="STRING"]=3,ne[W[4]="TENSOR"]=4,ne[W[5]="GRAPH"]=5,ne[W[6]="FLOATS"]=6,ne[W[7]="INTS"]=7,ne[W[8]="STRINGS"]=8,ne[W[9]="TENSORS"]=9,ne[W[10]="GRAPHS"]=10,ne})(),Y})(),G.ValueInfoProto=(function(){function Y(W){if(W)for(var ne=Object.keys(W),se=0;se<ne.length;++se)W[ne[se]]!=null&&(this[ne[se]]=W[ne[se]])}return Y.prototype.name="",Y.prototype.type=null,Y.prototype.docString="",Y.create=function(W){return new Y(W)},Y.encode=function(W,ne){return ne||(ne=ee.create()),W.name!=null&&W.hasOwnProperty("name")&&ne.uint32(10).string(W.name),W.type!=null&&W.hasOwnProperty("type")&&ie.onnx.TypeProto.encode(W.type,ne.uint32(18).fork()).ldelim(),W.docString!=null&&W.hasOwnProperty("docString")&&ne.uint32(26).string(W.docString),ne},Y.encodeDelimited=function(W,ne){return this.encode(W,ne).ldelim()},Y.decode=function(W,ne){W instanceof K||(W=K.create(W));for(var se=ne===void 0?W.len:W.pos+ne,le=new ie.onnx.ValueInfoProto;W.pos<se;){var ce=W.uint32();switch(ce>>>3){case 1:le.name=W.string();break;case 2:le.type=ie.onnx.TypeProto.decode(W,W.uint32());break;case 3:le.docString=W.string();break;default:W.skipType(7&ce)}}return le},Y.decodeDelimited=function(W){return W instanceof K||(W=new K(W)),this.decode(W,W.uint32())},Y.verify=function(W){if(typeof W!="object"||W===null)return"object expected";if(W.name!=null&&W.hasOwnProperty("name")&&!Z.isString(W.name))return"name: string expected";if(W.type!=null&&W.hasOwnProperty("type")){var ne=ie.onnx.TypeProto.verify(W.type);if(ne)return"type."+ne}return W.docString!=null&&W.hasOwnProperty("docString")&&!Z.isString(W.docString)?"docString: string expected":null},Y.fromObject=function(W){if(W instanceof ie.onnx.ValueInfoProto)return W;var ne=new ie.onnx.ValueInfoProto;if(W.name!=null&&(ne.name=String(W.name)),W.type!=null){if(typeof W.type!="object")throw TypeError(".onnx.ValueInfoProto.type: object expected");ne.type=ie.onnx.TypeProto.fromObject(W.type)}return W.docString!=null&&(ne.docString=String(W.docString)),ne},Y.toObject=function(W,ne){ne||(ne={});var se={};return ne.defaults&&(se.name="",se.type=null,se.docString=""),W.name!=null&&W.hasOwnProperty("name")&&(se.name=W.name),W.type!=null&&W.hasOwnProperty("type")&&(se.type=ie.onnx.TypeProto.toObject(W.type,ne)),W.docString!=null&&W.hasOwnProperty("docString")&&(se.docString=W.docString),se},Y.prototype.toJSON=function(){return this.constructor.toObject(this,q.util.toJSONOptions)},Y})(),G.NodeProto=(function(){function Y(W){if(this.input=[],this.output=[],this.attribute=[],W)for(var ne=Object.keys(W),se=0;se<ne.length;++se)W[ne[se]]!=null&&(this[ne[se]]=W[ne[se]])}return Y.prototype.input=Z.emptyArray,Y.prototype.output=Z.emptyArray,Y.prototype.name="",Y.prototype.opType="",Y.prototype.domain="",Y.prototype.attribute=Z.emptyArray,Y.prototype.docString="",Y.create=function(W){return new Y(W)},Y.encode=function(W,ne){if(ne||(ne=ee.create()),W.input!=null&&W.input.length)for(var se=0;se<W.input.length;++se)ne.uint32(10).string(W.input[se]);if(W.output!=null&&W.output.length)for(se=0;se<W.output.length;++se)ne.uint32(18).string(W.output[se]);if(W.name!=null&&W.hasOwnProperty("name")&&ne.uint32(26).string(W.name),W.opType!=null&&W.hasOwnProperty("opType")&&ne.uint32(34).string(W.opType),W.attribute!=null&&W.attribute.length)for(se=0;se<W.attribute.length;++se)ie.onnx.AttributeProto.encode(W.attribute[se],ne.uint32(42).fork()).ldelim();return W.docString!=null&&W.hasOwnProperty("docString")&&ne.uint32(50).string(W.docString),W.domain!=null&&W.hasOwnProperty("domain")&&ne.uint32(58).string(W.domain),ne},Y.encodeDelimited=function(W,ne){return this.encode(W,ne).ldelim()},Y.decode=function(W,ne){W instanceof K||(W=K.create(W));for(var se=ne===void 0?W.len:W.pos+ne,le=new ie.onnx.NodeProto;W.pos<se;){var ce=W.uint32();switch(ce>>>3){case 1:le.input&&le.input.length||(le.input=[]),le.input.push(W.string());break;case 2:le.output&&le.output.length||(le.output=[]),le.output.push(W.string());break;case 3:le.name=W.string();break;case 4:le.opType=W.string();break;case 7:le.domain=W.string();break;case 5:le.attribute&&le.attribute.length||(le.attribute=[]),le.attribute.push(ie.onnx.AttributeProto.decode(W,W.uint32()));break;case 6:le.docString=W.string();break;default:W.skipType(7&ce)}}return le},Y.decodeDelimited=function(W){return W instanceof K||(W=new K(W)),this.decode(W,W.uint32())},Y.verify=function(W){if(typeof W!="object"||W===null)return"object expected";if(W.input!=null&&W.hasOwnProperty("input")){if(!Array.isArray(W.input))return"input: array expected";for(var ne=0;ne<W.input.length;++ne)if(!Z.isString(W.input[ne]))return"input: string[] expected"}if(W.output!=null&&W.hasOwnProperty("output")){if(!Array.isArray(W.output))return"output: array expected";for(ne=0;ne<W.output.length;++ne)if(!Z.isString(W.output[ne]))return"output: string[] expected"}if(W.name!=null&&W.hasOwnProperty("name")&&!Z.isString(W.name))return"name: string expected";if(W.opType!=null&&W.hasOwnProperty("opType")&&!Z.isString(W.opType))return"opType: string expected";if(W.domain!=null&&W.hasOwnProperty("domain")&&!Z.isString(W.domain))return"domain: string expected";if(W.attribute!=null&&W.hasOwnProperty("attribute")){if(!Array.isArray(W.attribute))return"attribute: array expected";for(ne=0;ne<W.attribute.length;++ne){var se=ie.onnx.AttributeProto.verify(W.attribute[ne]);if(se)return"attribute."+se}}return W.docString!=null&&W.hasOwnProperty("docString")&&!Z.isString(W.docString)?"docString: string expected":null},Y.fromObject=function(W){if(W instanceof ie.onnx.NodeProto)return W;var ne=new ie.onnx.NodeProto;if(W.input){if(!Array.isArray(W.input))throw TypeError(".onnx.NodeProto.input: array expected");ne.input=[];for(var se=0;se<W.input.length;++se)ne.input[se]=String(W.input[se])}if(W.output){if(!Array.isArray(W.output))throw TypeError(".onnx.NodeProto.output: array expected");for(ne.output=[],se=0;se<W.output.length;++se)ne.output[se]=String(W.output[se])}if(W.name!=null&&(ne.name=String(W.name)),W.opType!=null&&(ne.opType=String(W.opType)),W.domain!=null&&(ne.domain=String(W.domain)),W.attribute){if(!Array.isArray(W.attribute))throw TypeError(".onnx.NodeProto.attribute: array expected");for(ne.attribute=[],se=0;se<W.attribute.length;++se){if(typeof W.attribute[se]!="object")throw TypeError(".onnx.NodeProto.attribute: object expected");ne.attribute[se]=ie.onnx.AttributeProto.fromObject(W.attribute[se])}}return W.docString!=null&&(ne.docString=String(W.docString)),ne},Y.toObject=function(W,ne){ne||(ne={});var se={};if((ne.arrays||ne.defaults)&&(se.input=[],se.output=[],se.attribute=[]),ne.defaults&&(se.name="",se.opType="",se.docString="",se.domain=""),W.input&&W.input.length){se.input=[];for(var le=0;le<W.input.length;++le)se.input[le]=W.input[le]}if(W.output&&W.output.length)for(se.output=[],le=0;le<W.output.length;++le)se.output[le]=W.output[le];if(W.name!=null&&W.hasOwnProperty("name")&&(se.name=W.name),W.opType!=null&&W.hasOwnProperty("opType")&&(se.opType=W.opType),W.attribute&&W.attribute.length)for(se.attribute=[],le=0;le<W.attribute.length;++le)se.attribute[le]=ie.onnx.AttributeProto.toObject(W.attribute[le],ne);return W.docString!=null&&W.hasOwnProperty("docString")&&(se.docString=W.docString),W.domain!=null&&W.hasOwnProperty("domain")&&(se.domain=W.domain),se},Y.prototype.toJSON=function(){return this.constructor.toObject(this,q.util.toJSONOptions)},Y})(),G.ModelProto=(function(){function Y(W){if(this.opsetImport=[],this.metadataProps=[],W)for(var ne=Object.keys(W),se=0;se<ne.length;++se)W[ne[se]]!=null&&(this[ne[se]]=W[ne[se]])}return Y.prototype.irVersion=Z.Long?Z.Long.fromBits(0,0,!1):0,Y.prototype.opsetImport=Z.emptyArray,Y.prototype.producerName="",Y.prototype.producerVersion="",Y.prototype.domain="",Y.prototype.modelVersion=Z.Long?Z.Long.fromBits(0,0,!1):0,Y.prototype.docString="",Y.prototype.graph=null,Y.prototype.metadataProps=Z.emptyArray,Y.create=function(W){return new Y(W)},Y.encode=function(W,ne){if(ne||(ne=ee.create()),W.irVersion!=null&&W.hasOwnProperty("irVersion")&&ne.uint32(8).int64(W.irVersion),W.producerName!=null&&W.hasOwnProperty("producerName")&&ne.uint32(18).string(W.producerName),W.producerVersion!=null&&W.hasOwnProperty("producerVersion")&&ne.uint32(26).string(W.producerVersion),W.domain!=null&&W.hasOwnProperty("domain")&&ne.uint32(34).string(W.domain),W.modelVersion!=null&&W.hasOwnProperty("modelVersion")&&ne.uint32(40).int64(W.modelVersion),W.docString!=null&&W.hasOwnProperty("docString")&&ne.uint32(50).string(W.docString),W.graph!=null&&W.hasOwnProperty("graph")&&ie.onnx.GraphProto.encode(W.graph,ne.uint32(58).fork()).ldelim(),W.opsetImport!=null&&W.opsetImport.length)for(var se=0;se<W.opsetImport.length;++se)ie.onnx.OperatorSetIdProto.encode(W.opsetImport[se],ne.uint32(66).fork()).ldelim();if(W.metadataProps!=null&&W.metadataProps.length)for(se=0;se<W.metadataProps.length;++se)ie.onnx.StringStringEntryProto.encode(W.metadataProps[se],ne.uint32(114).fork()).ldelim();return ne},Y.encodeDelimited=function(W,ne){return this.encode(W,ne).ldelim()},Y.decode=function(W,ne){W instanceof K||(W=K.create(W));for(var se=ne===void 0?W.len:W.pos+ne,le=new ie.onnx.ModelProto;W.pos<se;){var ce=W.uint32();switch(ce>>>3){case 1:le.irVersion=W.int64();break;case 8:le.opsetImport&&le.opsetImport.length||(le.opsetImport=[]),le.opsetImport.push(ie.onnx.OperatorSetIdProto.decode(W,W.uint32()));break;case 2:le.producerName=W.string();break;case 3:le.producerVersion=W.string();break;case 4:le.domain=W.string();break;case 5:le.modelVersion=W.int64();break;case 6:le.docString=W.string();break;case 7:le.graph=ie.onnx.GraphProto.decode(W,W.uint32());break;case 14:le.metadataProps&&le.metadataProps.length||(le.metadataProps=[]),le.metadataProps.push(ie.onnx.StringStringEntryProto.decode(W,W.uint32()));break;default:W.skipType(7&ce)}}return le},Y.decodeDelimited=function(W){return W instanceof K||(W=new K(W)),this.decode(W,W.uint32())},Y.verify=function(W){if(typeof W!="object"||W===null)return"object expected";if(W.irVersion!=null&&W.hasOwnProperty("irVersion")&&!(Z.isInteger(W.irVersion)||W.irVersion&&Z.isInteger(W.irVersion.low)&&Z.isInteger(W.irVersion.high)))return"irVersion: integer|Long expected";if(W.opsetImport!=null&&W.hasOwnProperty("opsetImport")){if(!Array.isArray(W.opsetImport))return"opsetImport: array expected";for(var ne=0;ne<W.opsetImport.length;++ne)if(se=ie.onnx.OperatorSetIdProto.verify(W.opsetImport[ne]))return"opsetImport."+se}if(W.producerName!=null&&W.hasOwnProperty("producerName")&&!Z.isString(W.producerName))return"producerName: string expected";if(W.producerVersion!=null&&W.hasOwnProperty("producerVersion")&&!Z.isString(W.producerVersion))return"producerVersion: string expected";if(W.domain!=null&&W.hasOwnProperty("domain")&&!Z.isString(W.domain))return"domain: string expected";if(W.modelVersion!=null&&W.hasOwnProperty("modelVersion")&&!(Z.isInteger(W.modelVersion)||W.modelVersion&&Z.isInteger(W.modelVersion.low)&&Z.isInteger(W.modelVersion.high)))return"modelVersion: integer|Long expected";if(W.docString!=null&&W.hasOwnProperty("docString")&&!Z.isString(W.docString))return"docString: string expected";if(W.graph!=null&&W.hasOwnProperty("graph")&&(se=ie.onnx.GraphProto.verify(W.graph)))return"graph."+se;if(W.metadataProps!=null&&W.hasOwnProperty("metadataProps")){if(!Array.isArray(W.metadataProps))return"metadataProps: array expected";for(ne=0;ne<W.metadataProps.length;++ne){var se;if(se=ie.onnx.StringStringEntryProto.verify(W.metadataProps[ne]))return"metadataProps."+se}}return null},Y.fromObject=function(W){if(W instanceof ie.onnx.ModelProto)return W;var ne=new ie.onnx.ModelProto;if(W.irVersion!=null&&(Z.Long?(ne.irVersion=Z.Long.fromValue(W.irVersion)).unsigned=!1:typeof W.irVersion=="string"?ne.irVersion=parseInt(W.irVersion,10):typeof W.irVersion=="number"?ne.irVersion=W.irVersion:typeof W.irVersion=="object"&&(ne.irVersion=new Z.LongBits(W.irVersion.low>>>0,W.irVersion.high>>>0).toNumber())),W.opsetImport){if(!Array.isArray(W.opsetImport))throw TypeError(".onnx.ModelProto.opsetImport: array expected");ne.opsetImport=[];for(var se=0;se<W.opsetImport.length;++se){if(typeof W.opsetImport[se]!="object")throw TypeError(".onnx.ModelProto.opsetImport: object expected");ne.opsetImport[se]=ie.onnx.OperatorSetIdProto.fromObject(W.opsetImport[se])}}if(W.producerName!=null&&(ne.producerName=String(W.producerName)),W.producerVersion!=null&&(ne.producerVersion=String(W.producerVersion)),W.domain!=null&&(ne.domain=String(W.domain)),W.modelVersion!=null&&(Z.Long?(ne.modelVersion=Z.Long.fromValue(W.modelVersion)).unsigned=!1:typeof W.modelVersion=="string"?ne.modelVersion=parseInt(W.modelVersion,10):typeof W.modelVersion=="number"?ne.modelVersion=W.modelVersion:typeof W.modelVersion=="object"&&(ne.modelVersion=new Z.LongBits(W.modelVersion.low>>>0,W.modelVersion.high>>>0).toNumber())),W.docString!=null&&(ne.docString=String(W.docString)),W.graph!=null){if(typeof W.graph!="object")throw TypeError(".onnx.ModelProto.graph: object expected");ne.graph=ie.onnx.GraphProto.fromObject(W.graph)}if(W.metadataProps){if(!Array.isArray(W.metadataProps))throw TypeError(".onnx.ModelProto.metadataProps: array expected");for(ne.metadataProps=[],se=0;se<W.metadataProps.length;++se){if(typeof W.metadataProps[se]!="object")throw TypeError(".onnx.ModelProto.metadataProps: object expected");ne.metadataProps[se]=ie.onnx.StringStringEntryProto.fromObject(W.metadataProps[se])}}return ne},Y.toObject=function(W,ne){ne||(ne={});var se={};if((ne.arrays||ne.defaults)&&(se.opsetImport=[],se.metadataProps=[]),ne.defaults){if(Z.Long){var le=new Z.Long(0,0,!1);se.irVersion=ne.longs===String?le.toString():ne.longs===Number?le.toNumber():le}else se.irVersion=ne.longs===String?"0":0;se.producerName="",se.producerVersion="",se.domain="",Z.Long?(le=new Z.Long(0,0,!1),se.modelVersion=ne.longs===String?le.toString():ne.longs===Number?le.toNumber():le):se.modelVersion=ne.longs===String?"0":0,se.docString="",se.graph=null}if(W.irVersion!=null&&W.hasOwnProperty("irVersion")&&(typeof W.irVersion=="number"?se.irVersion=ne.longs===String?String(W.irVersion):W.irVersion:se.irVersion=ne.longs===String?Z.Long.prototype.toString.call(W.irVersion):ne.longs===Number?new Z.LongBits(W.irVersion.low>>>0,W.irVersion.high>>>0).toNumber():W.irVersion),W.producerName!=null&&W.hasOwnProperty("producerName")&&(se.producerName=W.producerName),W.producerVersion!=null&&W.hasOwnProperty("producerVersion")&&(se.producerVersion=W.producerVersion),W.domain!=null&&W.hasOwnProperty("domain")&&(se.domain=W.domain),W.modelVersion!=null&&W.hasOwnProperty("modelVersion")&&(typeof W.modelVersion=="number"?se.modelVersion=ne.longs===String?String(W.modelVersion):W.modelVersion:se.modelVersion=ne.longs===String?Z.Long.prototype.toString.call(W.modelVersion):ne.longs===Number?new Z.LongBits(W.modelVersion.low>>>0,W.modelVersion.high>>>0).toNumber():W.modelVersion),W.docString!=null&&W.hasOwnProperty("docString")&&(se.docString=W.docString),W.graph!=null&&W.hasOwnProperty("graph")&&(se.graph=ie.onnx.GraphProto.toObject(W.graph,ne)),W.opsetImport&&W.opsetImport.length){se.opsetImport=[];for(var ce=0;ce<W.opsetImport.length;++ce)se.opsetImport[ce]=ie.onnx.OperatorSetIdProto.toObject(W.opsetImport[ce],ne)}if(W.metadataProps&&W.metadataProps.length)for(se.metadataProps=[],ce=0;ce<W.metadataProps.length;++ce)se.metadataProps[ce]=ie.onnx.StringStringEntryProto.toObject(W.metadataProps[ce],ne);return se},Y.prototype.toJSON=function(){return this.constructor.toObject(this,q.util.toJSONOptions)},Y})(),G.StringStringEntryProto=(function(){function Y(W){if(W)for(var ne=Object.keys(W),se=0;se<ne.length;++se)W[ne[se]]!=null&&(this[ne[se]]=W[ne[se]])}return Y.prototype.key="",Y.prototype.value="",Y.create=function(W){return new Y(W)},Y.encode=function(W,ne){return ne||(ne=ee.create()),W.key!=null&&W.hasOwnProperty("key")&&ne.uint32(10).string(W.key),W.value!=null&&W.hasOwnProperty("value")&&ne.uint32(18).string(W.value),ne},Y.encodeDelimited=function(W,ne){return this.encode(W,ne).ldelim()},Y.decode=function(W,ne){W instanceof K||(W=K.create(W));for(var se=ne===void 0?W.len:W.pos+ne,le=new ie.onnx.StringStringEntryProto;W.pos<se;){var ce=W.uint32();switch(ce>>>3){case 1:le.key=W.string();break;case 2:le.value=W.string();break;default:W.skipType(7&ce)}}return le},Y.decodeDelimited=function(W){return W instanceof K||(W=new K(W)),this.decode(W,W.uint32())},Y.verify=function(W){return typeof W!="object"||W===null?"object expected":W.key!=null&&W.hasOwnProperty("key")&&!Z.isString(W.key)?"key: string expected":W.value!=null&&W.hasOwnProperty("value")&&!Z.isString(W.value)?"value: string expected":null},Y.fromObject=function(W){if(W instanceof ie.onnx.StringStringEntryProto)return W;var ne=new ie.onnx.StringStringEntryProto;return W.key!=null&&(ne.key=String(W.key)),W.value!=null&&(ne.value=String(W.value)),ne},Y.toObject=function(W,ne){ne||(ne={});var se={};return ne.defaults&&(se.key="",se.value=""),W.key!=null&&W.hasOwnProperty("key")&&(se.key=W.key),W.value!=null&&W.hasOwnProperty("value")&&(se.value=W.value),se},Y.prototype.toJSON=function(){return this.constructor.toObject(this,q.util.toJSONOptions)},Y})(),G.TensorAnnotation=(function(){function Y(W){if(this.quantParameterTensorNames=[],W)for(var ne=Object.keys(W),se=0;se<ne.length;++se)W[ne[se]]!=null&&(this[ne[se]]=W[ne[se]])}return Y.prototype.tensorName="",Y.prototype.quantParameterTensorNames=Z.emptyArray,Y.create=function(W){return new Y(W)},Y.encode=function(W,ne){if(ne||(ne=ee.create()),W.tensorName!=null&&W.hasOwnProperty("tensorName")&&ne.uint32(10).string(W.tensorName),W.quantParameterTensorNames!=null&&W.quantParameterTensorNames.length)for(var se=0;se<W.quantParameterTensorNames.length;++se)ie.onnx.StringStringEntryProto.encode(W.quantParameterTensorNames[se],ne.uint32(18).fork()).ldelim();return ne},Y.encodeDelimited=function(W,ne){return this.encode(W,ne).ldelim()},Y.decode=function(W,ne){W instanceof K||(W=K.create(W));for(var se=ne===void 0?W.len:W.pos+ne,le=new ie.onnx.TensorAnnotation;W.pos<se;){var ce=W.uint32();switch(ce>>>3){case 1:le.tensorName=W.string();break;case 2:le.quantParameterTensorNames&&le.quantParameterTensorNames.length||(le.quantParameterTensorNames=[]),le.quantParameterTensorNames.push(ie.onnx.StringStringEntryProto.decode(W,W.uint32()));break;default:W.skipType(7&ce)}}return le},Y.decodeDelimited=function(W){return W instanceof K||(W=new K(W)),this.decode(W,W.uint32())},Y.verify=function(W){if(typeof W!="object"||W===null)return"object expected";if(W.tensorName!=null&&W.hasOwnProperty("tensorName")&&!Z.isString(W.tensorName))return"tensorName: string expected";if(W.quantParameterTensorNames!=null&&W.hasOwnProperty("quantParameterTensorNames")){if(!Array.isArray(W.quantParameterTensorNames))return"quantParameterTensorNames: array expected";for(var ne=0;ne<W.quantParameterTensorNames.length;++ne){var se=ie.onnx.StringStringEntryProto.verify(W.quantParameterTensorNames[ne]);if(se)return"quantParameterTensorNames."+se}}return null},Y.fromObject=function(W){if(W instanceof ie.onnx.TensorAnnotation)return W;var ne=new ie.onnx.TensorAnnotation;if(W.tensorName!=null&&(ne.tensorName=String(W.tensorName)),W.quantParameterTensorNames){if(!Array.isArray(W.quantParameterTensorNames))throw TypeError(".onnx.TensorAnnotation.quantParameterTensorNames: array expected");ne.quantParameterTensorNames=[];for(var se=0;se<W.quantParameterTensorNames.length;++se){if(typeof W.quantParameterTensorNames[se]!="object")throw TypeError(".onnx.TensorAnnotation.quantParameterTensorNames: object expected");ne.quantParameterTensorNames[se]=ie.onnx.StringStringEntryProto.fromObject(W.quantParameterTensorNames[se])}}return ne},Y.toObject=function(W,ne){ne||(ne={});var se={};if((ne.arrays||ne.defaults)&&(se.quantParameterTensorNames=[]),ne.defaults&&(se.tensorName=""),W.tensorName!=null&&W.hasOwnProperty("tensorName")&&(se.tensorName=W.tensorName),W.quantParameterTensorNames&&W.quantParameterTensorNames.length){se.quantParameterTensorNames=[];for(var le=0;le<W.quantParameterTensorNames.length;++le)se.quantParameterTensorNames[le]=ie.onnx.StringStringEntryProto.toObject(W.quantParameterTensorNames[le],ne)}return se},Y.prototype.toJSON=function(){return this.constructor.toObject(this,q.util.toJSONOptions)},Y})(),G.GraphProto=(function(){function Y(W){if(this.node=[],this.initializer=[],this.input=[],this.output=[],this.valueInfo=[],this.quantizationAnnotation=[],W)for(var ne=Object.keys(W),se=0;se<ne.length;++se)W[ne[se]]!=null&&(this[ne[se]]=W[ne[se]])}return Y.prototype.node=Z.emptyArray,Y.prototype.name="",Y.prototype.initializer=Z.emptyArray,Y.prototype.docString="",Y.prototype.input=Z.emptyArray,Y.prototype.output=Z.emptyArray,Y.prototype.valueInfo=Z.emptyArray,Y.prototype.quantizationAnnotation=Z.emptyArray,Y.create=function(W){return new Y(W)},Y.encode=function(W,ne){if(ne||(ne=ee.create()),W.node!=null&&W.node.length)for(var se=0;se<W.node.length;++se)ie.onnx.NodeProto.encode(W.node[se],ne.uint32(10).fork()).ldelim();if(W.name!=null&&W.hasOwnProperty("name")&&ne.uint32(18).string(W.name),W.initializer!=null&&W.initializer.length)for(se=0;se<W.initializer.length;++se)ie.onnx.TensorProto.encode(W.initializer[se],ne.uint32(42).fork()).ldelim();if(W.docString!=null&&W.hasOwnProperty("docString")&&ne.uint32(82).string(W.docString),W.input!=null&&W.input.length)for(se=0;se<W.input.length;++se)ie.onnx.ValueInfoProto.encode(W.input[se],ne.uint32(90).fork()).ldelim();if(W.output!=null&&W.output.length)for(se=0;se<W.output.length;++se)ie.onnx.ValueInfoProto.encode(W.output[se],ne.uint32(98).fork()).ldelim();if(W.valueInfo!=null&&W.valueInfo.length)for(se=0;se<W.valueInfo.length;++se)ie.onnx.ValueInfoProto.encode(W.valueInfo[se],ne.uint32(106).fork()).ldelim();if(W.quantizationAnnotation!=null&&W.quantizationAnnotation.length)for(se=0;se<W.quantizationAnnotation.length;++se)ie.onnx.TensorAnnotation.encode(W.quantizationAnnotation[se],ne.uint32(114).fork()).ldelim();return ne},Y.encodeDelimited=function(W,ne){return this.encode(W,ne).ldelim()},Y.decode=function(W,ne){W instanceof K||(W=K.create(W));for(var se=ne===void 0?W.len:W.pos+ne,le=new ie.onnx.GraphProto;W.pos<se;){var ce=W.uint32();switch(ce>>>3){case 1:le.node&&le.node.length||(le.node=[]),le.node.push(ie.onnx.NodeProto.decode(W,W.uint32()));break;case 2:le.name=W.string();break;case 5:le.initializer&&le.initializer.length||(le.initializer=[]),le.initializer.push(ie.onnx.TensorProto.decode(W,W.uint32()));break;case 10:le.docString=W.string();break;case 11:le.input&&le.input.length||(le.input=[]),le.input.push(ie.onnx.ValueInfoProto.decode(W,W.uint32()));break;case 12:le.output&&le.output.length||(le.output=[]),le.output.push(ie.onnx.ValueInfoProto.decode(W,W.uint32()));break;case 13:le.valueInfo&&le.valueInfo.length||(le.valueInfo=[]),le.valueInfo.push(ie.onnx.ValueInfoProto.decode(W,W.uint32()));break;case 14:le.quantizationAnnotation&&le.quantizationAnnotation.length||(le.quantizationAnnotation=[]),le.quantizationAnnotation.push(ie.onnx.TensorAnnotation.decode(W,W.uint32()));break;default:W.skipType(7&ce)}}return le},Y.decodeDelimited=function(W){return W instanceof K||(W=new K(W)),this.decode(W,W.uint32())},Y.verify=function(W){if(typeof W!="object"||W===null)return"object expected";if(W.node!=null&&W.hasOwnProperty("node")){if(!Array.isArray(W.node))return"node: array expected";for(var ne=0;ne<W.node.length;++ne)if(se=ie.onnx.NodeProto.verify(W.node[ne]))return"node."+se}if(W.name!=null&&W.hasOwnProperty("name")&&!Z.isString(W.name))return"name: string expected";if(W.initializer!=null&&W.hasOwnProperty("initializer")){if(!Array.isArray(W.initializer))return"initializer: array expected";for(ne=0;ne<W.initializer.length;++ne)if(se=ie.onnx.TensorProto.verify(W.initializer[ne]))return"initializer."+se}if(W.docString!=null&&W.hasOwnProperty("docString")&&!Z.isString(W.docString))return"docString: string expected";if(W.input!=null&&W.hasOwnProperty("input")){if(!Array.isArray(W.input))return"input: array expected";for(ne=0;ne<W.input.length;++ne)if(se=ie.onnx.ValueInfoProto.verify(W.input[ne]))return"input."+se}if(W.output!=null&&W.hasOwnProperty("output")){if(!Array.isArray(W.output))return"output: array expected";for(ne=0;ne<W.output.length;++ne)if(se=ie.onnx.ValueInfoProto.verify(W.output[ne]))return"output."+se}if(W.valueInfo!=null&&W.hasOwnProperty("valueInfo")){if(!Array.isArray(W.valueInfo))return"valueInfo: array expected";for(ne=0;ne<W.valueInfo.length;++ne)if(se=ie.onnx.ValueInfoProto.verify(W.valueInfo[ne]))return"valueInfo."+se}if(W.quantizationAnnotation!=null&&W.hasOwnProperty("quantizationAnnotation")){if(!Array.isArray(W.quantizationAnnotation))return"quantizationAnnotation: array expected";for(ne=0;ne<W.quantizationAnnotation.length;++ne){var se;if(se=ie.onnx.TensorAnnotation.verify(W.quantizationAnnotation[ne]))return"quantizationAnnotation."+se}}return null},Y.fromObject=function(W){if(W instanceof ie.onnx.GraphProto)return W;var ne=new ie.onnx.GraphProto;if(W.node){if(!Array.isArray(W.node))throw TypeError(".onnx.GraphProto.node: array expected");ne.node=[];for(var se=0;se<W.node.length;++se){if(typeof W.node[se]!="object")throw TypeError(".onnx.GraphProto.node: object expected");ne.node[se]=ie.onnx.NodeProto.fromObject(W.node[se])}}if(W.name!=null&&(ne.name=String(W.name)),W.initializer){if(!Array.isArray(W.initializer))throw TypeError(".onnx.GraphProto.initializer: array expected");for(ne.initializer=[],se=0;se<W.initializer.length;++se){if(typeof W.initializer[se]!="object")throw TypeError(".onnx.GraphProto.initializer: object expected");ne.initializer[se]=ie.onnx.TensorProto.fromObject(W.initializer[se])}}if(W.docString!=null&&(ne.docString=String(W.docString)),W.input){if(!Array.isArray(W.input))throw TypeError(".onnx.GraphProto.input: array expected");for(ne.input=[],se=0;se<W.input.length;++se){if(typeof W.input[se]!="object")throw TypeError(".onnx.GraphProto.input: object expected");ne.input[se]=ie.onnx.ValueInfoProto.fromObject(W.input[se])}}if(W.output){if(!Array.isArray(W.output))throw TypeError(".onnx.GraphProto.output: array expected");for(ne.output=[],se=0;se<W.output.length;++se){if(typeof W.output[se]!="object")throw TypeError(".onnx.GraphProto.output: object expected");ne.output[se]=ie.onnx.ValueInfoProto.fromObject(W.output[se])}}if(W.valueInfo){if(!Array.isArray(W.valueInfo))throw TypeError(".onnx.GraphProto.valueInfo: array expected");for(ne.valueInfo=[],se=0;se<W.valueInfo.length;++se){if(typeof W.valueInfo[se]!="object")throw TypeError(".onnx.GraphProto.valueInfo: object expected");ne.valueInfo[se]=ie.onnx.ValueInfoProto.fromObject(W.valueInfo[se])}}if(W.quantizationAnnotation){if(!Array.isArray(W.quantizationAnnotation))throw TypeError(".onnx.GraphProto.quantizationAnnotation: array expected");for(ne.quantizationAnnotation=[],se=0;se<W.quantizationAnnotation.length;++se){if(typeof W.quantizationAnnotation[se]!="object")throw TypeError(".onnx.GraphProto.quantizationAnnotation: object expected");ne.quantizationAnnotation[se]=ie.onnx.TensorAnnotation.fromObject(W.quantizationAnnotation[se])}}return ne},Y.toObject=function(W,ne){ne||(ne={});var se={};if((ne.arrays||ne.defaults)&&(se.node=[],se.initializer=[],se.input=[],se.output=[],se.valueInfo=[],se.quantizationAnnotation=[]),ne.defaults&&(se.name="",se.docString=""),W.node&&W.node.length){se.node=[];for(var le=0;le<W.node.length;++le)se.node[le]=ie.onnx.NodeProto.toObject(W.node[le],ne)}if(W.name!=null&&W.hasOwnProperty("name")&&(se.name=W.name),W.initializer&&W.initializer.length)for(se.initializer=[],le=0;le<W.initializer.length;++le)se.initializer[le]=ie.onnx.TensorProto.toObject(W.initializer[le],ne);if(W.docString!=null&&W.hasOwnProperty("docString")&&(se.docString=W.docString),W.input&&W.input.length)for(se.input=[],le=0;le<W.input.length;++le)se.input[le]=ie.onnx.ValueInfoProto.toObject(W.input[le],ne);if(W.output&&W.output.length)for(se.output=[],le=0;le<W.output.length;++le)se.output[le]=ie.onnx.ValueInfoProto.toObject(W.output[le],ne);if(W.valueInfo&&W.valueInfo.length)for(se.valueInfo=[],le=0;le<W.valueInfo.length;++le)se.valueInfo[le]=ie.onnx.ValueInfoProto.toObject(W.valueInfo[le],ne);if(W.quantizationAnnotation&&W.quantizationAnnotation.length)for(se.quantizationAnnotation=[],le=0;le<W.quantizationAnnotation.length;++le)se.quantizationAnnotation[le]=ie.onnx.TensorAnnotation.toObject(W.quantizationAnnotation[le],ne);return se},Y.prototype.toJSON=function(){return this.constructor.toObject(this,q.util.toJSONOptions)},Y})(),G.TensorProto=(function(){function Y(W){if(this.dims=[],this.floatData=[],this.int32Data=[],this.stringData=[],this.int64Data=[],this.externalData=[],this.doubleData=[],this.uint64Data=[],W)for(var ne=Object.keys(W),se=0;se<ne.length;++se)W[ne[se]]!=null&&(this[ne[se]]=W[ne[se]])}return Y.prototype.dims=Z.emptyArray,Y.prototype.dataType=0,Y.prototype.segment=null,Y.prototype.floatData=Z.emptyArray,Y.prototype.int32Data=Z.emptyArray,Y.prototype.stringData=Z.emptyArray,Y.prototype.int64Data=Z.emptyArray,Y.prototype.name="",Y.prototype.docString="",Y.prototype.rawData=Z.newBuffer([]),Y.prototype.externalData=Z.emptyArray,Y.prototype.dataLocation=0,Y.prototype.doubleData=Z.emptyArray,Y.prototype.uint64Data=Z.emptyArray,Y.create=function(W){return new Y(W)},Y.encode=function(W,ne){if(ne||(ne=ee.create()),W.dims!=null&&W.dims.length){ne.uint32(10).fork();for(var se=0;se<W.dims.length;++se)ne.int64(W.dims[se]);ne.ldelim()}if(W.dataType!=null&&W.hasOwnProperty("dataType")&&ne.uint32(16).int32(W.dataType),W.segment!=null&&W.hasOwnProperty("segment")&&ie.onnx.TensorProto.Segment.encode(W.segment,ne.uint32(26).fork()).ldelim(),W.floatData!=null&&W.floatData.length){for(ne.uint32(34).fork(),se=0;se<W.floatData.length;++se)ne.float(W.floatData[se]);ne.ldelim()}if(W.int32Data!=null&&W.int32Data.length){for(ne.uint32(42).fork(),se=0;se<W.int32Data.length;++se)ne.int32(W.int32Data[se]);ne.ldelim()}if(W.stringData!=null&&W.stringData.length)for(se=0;se<W.stringData.length;++se)ne.uint32(50).bytes(W.stringData[se]);if(W.int64Data!=null&&W.int64Data.length){for(ne.uint32(58).fork(),se=0;se<W.int64Data.length;++se)ne.int64(W.int64Data[se]);ne.ldelim()}if(W.name!=null&&W.hasOwnProperty("name")&&ne.uint32(66).string(W.name),W.rawData!=null&&W.hasOwnProperty("rawData")&&ne.uint32(74).bytes(W.rawData),W.doubleData!=null&&W.doubleData.length){for(ne.uint32(82).fork(),se=0;se<W.doubleData.length;++se)ne.double(W.doubleData[se]);ne.ldelim()}if(W.uint64Data!=null&&W.uint64Data.length){for(ne.uint32(90).fork(),se=0;se<W.uint64Data.length;++se)ne.uint64(W.uint64Data[se]);ne.ldelim()}if(W.docString!=null&&W.hasOwnProperty("docString")&&ne.uint32(98).string(W.docString),W.externalData!=null&&W.externalData.length)for(se=0;se<W.externalData.length;++se)ie.onnx.StringStringEntryProto.encode(W.externalData[se],ne.uint32(106).fork()).ldelim();return W.dataLocation!=null&&W.hasOwnProperty("dataLocation")&&ne.uint32(112).int32(W.dataLocation),ne},Y.encodeDelimited=function(W,ne){return this.encode(W,ne).ldelim()},Y.decode=function(W,ne){W instanceof K||(W=K.create(W));for(var se=ne===void 0?W.len:W.pos+ne,le=new ie.onnx.TensorProto;W.pos<se;){var ce=W.uint32();switch(ce>>>3){case 1:if(le.dims&&le.dims.length||(le.dims=[]),(7&ce)==2)for(var he=W.uint32()+W.pos;W.pos<he;)le.dims.push(W.int64());else le.dims.push(W.int64());break;case 2:le.dataType=W.int32();break;case 3:le.segment=ie.onnx.TensorProto.Segment.decode(W,W.uint32());break;case 4:if(le.floatData&&le.floatData.length||(le.floatData=[]),(7&ce)==2)for(he=W.uint32()+W.pos;W.pos<he;)le.floatData.push(W.float());else le.floatData.push(W.float());break;case 5:if(le.int32Data&&le.int32Data.length||(le.int32Data=[]),(7&ce)==2)for(he=W.uint32()+W.pos;W.pos<he;)le.int32Data.push(W.int32());else le.int32Data.push(W.int32());break;case 6:le.stringData&&le.stringData.length||(le.stringData=[]),le.stringData.push(W.bytes());break;case 7:if(le.int64Data&&le.int64Data.length||(le.int64Data=[]),(7&ce)==2)for(he=W.uint32()+W.pos;W.pos<he;)le.int64Data.push(W.int64());else le.int64Data.push(W.int64());break;case 8:le.name=W.string();break;case 12:le.docString=W.string();break;case 9:le.rawData=W.bytes();break;case 13:le.externalData&&le.externalData.length||(le.externalData=[]),le.externalData.push(ie.onnx.StringStringEntryProto.decode(W,W.uint32()));break;case 14:le.dataLocation=W.int32();break;case 10:if(le.doubleData&&le.doubleData.length||(le.doubleData=[]),(7&ce)==2)for(he=W.uint32()+W.pos;W.pos<he;)le.doubleData.push(W.double());else le.doubleData.push(W.double());break;case 11:if(le.uint64Data&&le.uint64Data.length||(le.uint64Data=[]),(7&ce)==2)for(he=W.uint32()+W.pos;W.pos<he;)le.uint64Data.push(W.uint64());else le.uint64Data.push(W.uint64());break;default:W.skipType(7&ce)}}return le},Y.decodeDelimited=function(W){return W instanceof K||(W=new K(W)),this.decode(W,W.uint32())},Y.verify=function(W){if(typeof W!="object"||W===null)return"object expected";if(W.dims!=null&&W.hasOwnProperty("dims")){if(!Array.isArray(W.dims))return"dims: array expected";for(var ne=0;ne<W.dims.length;++ne)if(!(Z.isInteger(W.dims[ne])||W.dims[ne]&&Z.isInteger(W.dims[ne].low)&&Z.isInteger(W.dims[ne].high)))return"dims: integer|Long[] expected"}if(W.dataType!=null&&W.hasOwnProperty("dataType")&&!Z.isInteger(W.dataType))return"dataType: integer expected";if(W.segment!=null&&W.hasOwnProperty("segment")&&(se=ie.onnx.TensorProto.Segment.verify(W.segment)))return"segment."+se;if(W.floatData!=null&&W.hasOwnProperty("floatData")){if(!Array.isArray(W.floatData))return"floatData: array expected";for(ne=0;ne<W.floatData.length;++ne)if(typeof W.floatData[ne]!="number")return"floatData: number[] expected"}if(W.int32Data!=null&&W.hasOwnProperty("int32Data")){if(!Array.isArray(W.int32Data))return"int32Data: array expected";for(ne=0;ne<W.int32Data.length;++ne)if(!Z.isInteger(W.int32Data[ne]))return"int32Data: integer[] expected"}if(W.stringData!=null&&W.hasOwnProperty("stringData")){if(!Array.isArray(W.stringData))return"stringData: array expected";for(ne=0;ne<W.stringData.length;++ne)if(!(W.stringData[ne]&&typeof W.stringData[ne].length=="number"||Z.isString(W.stringData[ne])))return"stringData: buffer[] expected"}if(W.int64Data!=null&&W.hasOwnProperty("int64Data")){if(!Array.isArray(W.int64Data))return"int64Data: array expected";for(ne=0;ne<W.int64Data.length;++ne)if(!(Z.isInteger(W.int64Data[ne])||W.int64Data[ne]&&Z.isInteger(W.int64Data[ne].low)&&Z.isInteger(W.int64Data[ne].high)))return"int64Data: integer|Long[] expected"}if(W.name!=null&&W.hasOwnProperty("name")&&!Z.isString(W.name))return"name: string expected";if(W.docString!=null&&W.hasOwnProperty("docString")&&!Z.isString(W.docString))return"docString: string expected";if(W.rawData!=null&&W.hasOwnProperty("rawData")&&!(W.rawData&&typeof W.rawData.length=="number"||Z.isString(W.rawData)))return"rawData: buffer expected";if(W.externalData!=null&&W.hasOwnProperty("externalData")){if(!Array.isArray(W.externalData))return"externalData: array expected";for(ne=0;ne<W.externalData.length;++ne){var se;if(se=ie.onnx.StringStringEntryProto.verify(W.externalData[ne]))return"externalData."+se}}if(W.dataLocation!=null&&W.hasOwnProperty("dataLocation"))switch(W.dataLocation){default:return"dataLocation: enum value expected";case 0:case 1:}if(W.doubleData!=null&&W.hasOwnProperty("doubleData")){if(!Array.isArray(W.doubleData))return"doubleData: array expected";for(ne=0;ne<W.doubleData.length;++ne)if(typeof W.doubleData[ne]!="number")return"doubleData: number[] expected"}if(W.uint64Data!=null&&W.hasOwnProperty("uint64Data")){if(!Array.isArray(W.uint64Data))return"uint64Data: array expected";for(ne=0;ne<W.uint64Data.length;++ne)if(!(Z.isInteger(W.uint64Data[ne])||W.uint64Data[ne]&&Z.isInteger(W.uint64Data[ne].low)&&Z.isInteger(W.uint64Data[ne].high)))return"uint64Data: integer|Long[] expected"}return null},Y.fromObject=function(W){if(W instanceof ie.onnx.TensorProto)return W;var ne=new ie.onnx.TensorProto;if(W.dims){if(!Array.isArray(W.dims))throw TypeError(".onnx.TensorProto.dims: array expected");ne.dims=[];for(var se=0;se<W.dims.length;++se)Z.Long?(ne.dims[se]=Z.Long.fromValue(W.dims[se])).unsigned=!1:typeof W.dims[se]=="string"?ne.dims[se]=parseInt(W.dims[se],10):typeof W.dims[se]=="number"?ne.dims[se]=W.dims[se]:typeof W.dims[se]=="object"&&(ne.dims[se]=new Z.LongBits(W.dims[se].low>>>0,W.dims[se].high>>>0).toNumber())}if(W.dataType!=null&&(ne.dataType=0|W.dataType),W.segment!=null){if(typeof W.segment!="object")throw TypeError(".onnx.TensorProto.segment: object expected");ne.segment=ie.onnx.TensorProto.Segment.fromObject(W.segment)}if(W.floatData){if(!Array.isArray(W.floatData))throw TypeError(".onnx.TensorProto.floatData: array expected");for(ne.floatData=[],se=0;se<W.floatData.length;++se)ne.floatData[se]=Number(W.floatData[se])}if(W.int32Data){if(!Array.isArray(W.int32Data))throw TypeError(".onnx.TensorProto.int32Data: array expected");for(ne.int32Data=[],se=0;se<W.int32Data.length;++se)ne.int32Data[se]=0|W.int32Data[se]}if(W.stringData){if(!Array.isArray(W.stringData))throw TypeError(".onnx.TensorProto.stringData: array expected");for(ne.stringData=[],se=0;se<W.stringData.length;++se)typeof W.stringData[se]=="string"?Z.base64.decode(W.stringData[se],ne.stringData[se]=Z.newBuffer(Z.base64.length(W.stringData[se])),0):W.stringData[se].length&&(ne.stringData[se]=W.stringData[se])}if(W.int64Data){if(!Array.isArray(W.int64Data))throw TypeError(".onnx.TensorProto.int64Data: array expected");for(ne.int64Data=[],se=0;se<W.int64Data.length;++se)Z.Long?(ne.int64Data[se]=Z.Long.fromValue(W.int64Data[se])).unsigned=!1:typeof W.int64Data[se]=="string"?ne.int64Data[se]=parseInt(W.int64Data[se],10):typeof W.int64Data[se]=="number"?ne.int64Data[se]=W.int64Data[se]:typeof W.int64Data[se]=="object"&&(ne.int64Data[se]=new Z.LongBits(W.int64Data[se].low>>>0,W.int64Data[se].high>>>0).toNumber())}if(W.name!=null&&(ne.name=String(W.name)),W.docString!=null&&(ne.docString=String(W.docString)),W.rawData!=null&&(typeof W.rawData=="string"?Z.base64.decode(W.rawData,ne.rawData=Z.newBuffer(Z.base64.length(W.rawData)),0):W.rawData.length&&(ne.rawData=W.rawData)),W.externalData){if(!Array.isArray(W.externalData))throw TypeError(".onnx.TensorProto.externalData: array expected");for(ne.externalData=[],se=0;se<W.externalData.length;++se){if(typeof W.externalData[se]!="object")throw TypeError(".onnx.TensorProto.externalData: object expected");ne.externalData[se]=ie.onnx.StringStringEntryProto.fromObject(W.externalData[se])}}switch(W.dataLocation){case"DEFAULT":case 0:ne.dataLocation=0;break;case"EXTERNAL":case 1:ne.dataLocation=1}if(W.doubleData){if(!Array.isArray(W.doubleData))throw TypeError(".onnx.TensorProto.doubleData: array expected");for(ne.doubleData=[],se=0;se<W.doubleData.length;++se)ne.doubleData[se]=Number(W.doubleData[se])}if(W.uint64Data){if(!Array.isArray(W.uint64Data))throw TypeError(".onnx.TensorProto.uint64Data: array expected");for(ne.uint64Data=[],se=0;se<W.uint64Data.length;++se)Z.Long?(ne.uint64Data[se]=Z.Long.fromValue(W.uint64Data[se])).unsigned=!0:typeof W.uint64Data[se]=="string"?ne.uint64Data[se]=parseInt(W.uint64Data[se],10):typeof W.uint64Data[se]=="number"?ne.uint64Data[se]=W.uint64Data[se]:typeof W.uint64Data[se]=="object"&&(ne.uint64Data[se]=new Z.LongBits(W.uint64Data[se].low>>>0,W.uint64Data[se].high>>>0).toNumber(!0))}return ne},Y.toObject=function(W,ne){ne||(ne={});var se={};if((ne.arrays||ne.defaults)&&(se.dims=[],se.floatData=[],se.int32Data=[],se.stringData=[],se.int64Data=[],se.doubleData=[],se.uint64Data=[],se.externalData=[]),ne.defaults&&(se.dataType=0,se.segment=null,se.name="",ne.bytes===String?se.rawData="":(se.rawData=[],ne.bytes!==Array&&(se.rawData=Z.newBuffer(se.rawData))),se.docString="",se.dataLocation=ne.enums===String?"DEFAULT":0),W.dims&&W.dims.length){se.dims=[];for(var le=0;le<W.dims.length;++le)typeof W.dims[le]=="number"?se.dims[le]=ne.longs===String?String(W.dims[le]):W.dims[le]:se.dims[le]=ne.longs===String?Z.Long.prototype.toString.call(W.dims[le]):ne.longs===Number?new Z.LongBits(W.dims[le].low>>>0,W.dims[le].high>>>0).toNumber():W.dims[le]}if(W.dataType!=null&&W.hasOwnProperty("dataType")&&(se.dataType=W.dataType),W.segment!=null&&W.hasOwnProperty("segment")&&(se.segment=ie.onnx.TensorProto.Segment.toObject(W.segment,ne)),W.floatData&&W.floatData.length)for(se.floatData=[],le=0;le<W.floatData.length;++le)se.floatData[le]=ne.json&&!isFinite(W.floatData[le])?String(W.floatData[le]):W.floatData[le];if(W.int32Data&&W.int32Data.length)for(se.int32Data=[],le=0;le<W.int32Data.length;++le)se.int32Data[le]=W.int32Data[le];if(W.stringData&&W.stringData.length)for(se.stringData=[],le=0;le<W.stringData.length;++le)se.stringData[le]=ne.bytes===String?Z.base64.encode(W.stringData[le],0,W.stringData[le].length):ne.bytes===Array?Array.prototype.slice.call(W.stringData[le]):W.stringData[le];if(W.int64Data&&W.int64Data.length)for(se.int64Data=[],le=0;le<W.int64Data.length;++le)typeof W.int64Data[le]=="number"?se.int64Data[le]=ne.longs===String?String(W.int64Data[le]):W.int64Data[le]:se.int64Data[le]=ne.longs===String?Z.Long.prototype.toString.call(W.int64Data[le]):ne.longs===Number?new Z.LongBits(W.int64Data[le].low>>>0,W.int64Data[le].high>>>0).toNumber():W.int64Data[le];if(W.name!=null&&W.hasOwnProperty("name")&&(se.name=W.name),W.rawData!=null&&W.hasOwnProperty("rawData")&&(se.rawData=ne.bytes===String?Z.base64.encode(W.rawData,0,W.rawData.length):ne.bytes===Array?Array.prototype.slice.call(W.rawData):W.rawData),W.doubleData&&W.doubleData.length)for(se.doubleData=[],le=0;le<W.doubleData.length;++le)se.doubleData[le]=ne.json&&!isFinite(W.doubleData[le])?String(W.doubleData[le]):W.doubleData[le];if(W.uint64Data&&W.uint64Data.length)for(se.uint64Data=[],le=0;le<W.uint64Data.length;++le)typeof W.uint64Data[le]=="number"?se.uint64Data[le]=ne.longs===String?String(W.uint64Data[le]):W.uint64Data[le]:se.uint64Data[le]=ne.longs===String?Z.Long.prototype.toString.call(W.uint64Data[le]):ne.longs===Number?new Z.LongBits(W.uint64Data[le].low>>>0,W.uint64Data[le].high>>>0).toNumber(!0):W.uint64Data[le];if(W.docString!=null&&W.hasOwnProperty("docString")&&(se.docString=W.docString),W.externalData&&W.externalData.length)for(se.externalData=[],le=0;le<W.externalData.length;++le)se.externalData[le]=ie.onnx.StringStringEntryProto.toObject(W.externalData[le],ne);return W.dataLocation!=null&&W.hasOwnProperty("dataLocation")&&(se.dataLocation=ne.enums===String?ie.onnx.TensorProto.DataLocation[W.dataLocation]:W.dataLocation),se},Y.prototype.toJSON=function(){return this.constructor.toObject(this,q.util.toJSONOptions)},Y.DataType=(function(){var W={},ne=Object.create(W);return ne[W[0]="UNDEFINED"]=0,ne[W[1]="FLOAT"]=1,ne[W[2]="UINT8"]=2,ne[W[3]="INT8"]=3,ne[W[4]="UINT16"]=4,ne[W[5]="INT16"]=5,ne[W[6]="INT32"]=6,ne[W[7]="INT64"]=7,ne[W[8]="STRING"]=8,ne[W[9]="BOOL"]=9,ne[W[10]="FLOAT16"]=10,ne[W[11]="DOUBLE"]=11,ne[W[12]="UINT32"]=12,ne[W[13]="UINT64"]=13,ne[W[14]="COMPLEX64"]=14,ne[W[15]="COMPLEX128"]=15,ne[W[16]="BFLOAT16"]=16,ne})(),Y.Segment=(function(){function W(ne){if(ne)for(var se=Object.keys(ne),le=0;le<se.length;++le)ne[se[le]]!=null&&(this[se[le]]=ne[se[le]])}return W.prototype.begin=Z.Long?Z.Long.fromBits(0,0,!1):0,W.prototype.end=Z.Long?Z.Long.fromBits(0,0,!1):0,W.create=function(ne){return new W(ne)},W.encode=function(ne,se){return se||(se=ee.create()),ne.begin!=null&&ne.hasOwnProperty("begin")&&se.uint32(8).int64(ne.begin),ne.end!=null&&ne.hasOwnProperty("end")&&se.uint32(16).int64(ne.end),se},W.encodeDelimited=function(ne,se){return this.encode(ne,se).ldelim()},W.decode=function(ne,se){ne instanceof K||(ne=K.create(ne));for(var le=se===void 0?ne.len:ne.pos+se,ce=new ie.onnx.TensorProto.Segment;ne.pos<le;){var he=ne.uint32();switch(he>>>3){case 1:ce.begin=ne.int64();break;case 2:ce.end=ne.int64();break;default:ne.skipType(7&he)}}return ce},W.decodeDelimited=function(ne){return ne instanceof K||(ne=new K(ne)),this.decode(ne,ne.uint32())},W.verify=function(ne){return typeof ne!="object"||ne===null?"object expected":ne.begin!=null&&ne.hasOwnProperty("begin")&&!(Z.isInteger(ne.begin)||ne.begin&&Z.isInteger(ne.begin.low)&&Z.isInteger(ne.begin.high))?"begin: integer|Long expected":ne.end!=null&&ne.hasOwnProperty("end")&&!(Z.isInteger(ne.end)||ne.end&&Z.isInteger(ne.end.low)&&Z.isInteger(ne.end.high))?"end: integer|Long expected":null},W.fromObject=function(ne){if(ne instanceof ie.onnx.TensorProto.Segment)return ne;var se=new ie.onnx.TensorProto.Segment;return ne.begin!=null&&(Z.Long?(se.begin=Z.Long.fromValue(ne.begin)).unsigned=!1:typeof ne.begin=="string"?se.begin=parseInt(ne.begin,10):typeof ne.begin=="number"?se.begin=ne.begin:typeof ne.begin=="object"&&(se.begin=new Z.LongBits(ne.begin.low>>>0,ne.begin.high>>>0).toNumber())),ne.end!=null&&(Z.Long?(se.end=Z.Long.fromValue(ne.end)).unsigned=!1:typeof ne.end=="string"?se.end=parseInt(ne.end,10):typeof ne.end=="number"?se.end=ne.end:typeof ne.end=="object"&&(se.end=new Z.LongBits(ne.end.low>>>0,ne.end.high>>>0).toNumber())),se},W.toObject=function(ne,se){se||(se={});var le={};if(se.defaults){if(Z.Long){var ce=new Z.Long(0,0,!1);le.begin=se.longs===String?ce.toString():se.longs===Number?ce.toNumber():ce}else le.begin=se.longs===String?"0":0;Z.Long?(ce=new Z.Long(0,0,!1),le.end=se.longs===String?ce.toString():se.longs===Number?ce.toNumber():ce):le.end=se.longs===String?"0":0}return ne.begin!=null&&ne.hasOwnProperty("begin")&&(typeof ne.begin=="number"?le.begin=se.longs===String?String(ne.begin):ne.begin:le.begin=se.longs===String?Z.Long.prototype.toString.call(ne.begin):se.longs===Number?new Z.LongBits(ne.begin.low>>>0,ne.begin.high>>>0).toNumber():ne.begin),ne.end!=null&&ne.hasOwnProperty("end")&&(typeof ne.end=="number"?le.end=se.longs===String?String(ne.end):ne.end:le.end=se.longs===String?Z.Long.prototype.toString.call(ne.end):se.longs===Number?new Z.LongBits(ne.end.low>>>0,ne.end.high>>>0).toNumber():ne.end),le},W.prototype.toJSON=function(){return this.constructor.toObject(this,q.util.toJSONOptions)},W})(),Y.DataLocation=(function(){var W={},ne=Object.create(W);return ne[W[0]="DEFAULT"]=0,ne[W[1]="EXTERNAL"]=1,ne})(),Y})(),G.TensorShapeProto=(function(){function Y(W){if(this.dim=[],W)for(var ne=Object.keys(W),se=0;se<ne.length;++se)W[ne[se]]!=null&&(this[ne[se]]=W[ne[se]])}return Y.prototype.dim=Z.emptyArray,Y.create=function(W){return new Y(W)},Y.encode=function(W,ne){if(ne||(ne=ee.create()),W.dim!=null&&W.dim.length)for(var se=0;se<W.dim.length;++se)ie.onnx.TensorShapeProto.Dimension.encode(W.dim[se],ne.uint32(10).fork()).ldelim();return ne},Y.encodeDelimited=function(W,ne){return this.encode(W,ne).ldelim()},Y.decode=function(W,ne){W instanceof K||(W=K.create(W));for(var se=ne===void 0?W.len:W.pos+ne,le=new ie.onnx.TensorShapeProto;W.pos<se;){var ce=W.uint32();ce>>>3==1?(le.dim&&le.dim.length||(le.dim=[]),le.dim.push(ie.onnx.TensorShapeProto.Dimension.decode(W,W.uint32()))):W.skipType(7&ce)}return le},Y.decodeDelimited=function(W){return W instanceof K||(W=new K(W)),this.decode(W,W.uint32())},Y.verify=function(W){if(typeof W!="object"||W===null)return"object expected";if(W.dim!=null&&W.hasOwnProperty("dim")){if(!Array.isArray(W.dim))return"dim: array expected";for(var ne=0;ne<W.dim.length;++ne){var se=ie.onnx.TensorShapeProto.Dimension.verify(W.dim[ne]);if(se)return"dim."+se}}return null},Y.fromObject=function(W){if(W instanceof ie.onnx.TensorShapeProto)return W;var ne=new ie.onnx.TensorShapeProto;if(W.dim){if(!Array.isArray(W.dim))throw TypeError(".onnx.TensorShapeProto.dim: array expected");ne.dim=[];for(var se=0;se<W.dim.length;++se){if(typeof W.dim[se]!="object")throw TypeError(".onnx.TensorShapeProto.dim: object expected");ne.dim[se]=ie.onnx.TensorShapeProto.Dimension.fromObject(W.dim[se])}}return ne},Y.toObject=function(W,ne){ne||(ne={});var se={};if((ne.arrays||ne.defaults)&&(se.dim=[]),W.dim&&W.dim.length){se.dim=[];for(var le=0;le<W.dim.length;++le)se.dim[le]=ie.onnx.TensorShapeProto.Dimension.toObject(W.dim[le],ne)}return se},Y.prototype.toJSON=function(){return this.constructor.toObject(this,q.util.toJSONOptions)},Y.Dimension=(function(){function W(se){if(se)for(var le=Object.keys(se),ce=0;ce<le.length;++ce)se[le[ce]]!=null&&(this[le[ce]]=se[le[ce]])}var ne;return W.prototype.dimValue=Z.Long?Z.Long.fromBits(0,0,!1):0,W.prototype.dimParam="",W.prototype.denotation="",Object.defineProperty(W.prototype,"value",{get:Z.oneOfGetter(ne=["dimValue","dimParam"]),set:Z.oneOfSetter(ne)}),W.create=function(se){return new W(se)},W.encode=function(se,le){return le||(le=ee.create()),se.dimValue!=null&&se.hasOwnProperty("dimValue")&&le.uint32(8).int64(se.dimValue),se.dimParam!=null&&se.hasOwnProperty("dimParam")&&le.uint32(18).string(se.dimParam),se.denotation!=null&&se.hasOwnProperty("denotation")&&le.uint32(26).string(se.denotation),le},W.encodeDelimited=function(se,le){return this.encode(se,le).ldelim()},W.decode=function(se,le){se instanceof K||(se=K.create(se));for(var ce=le===void 0?se.len:se.pos+le,he=new ie.onnx.TensorShapeProto.Dimension;se.pos<ce;){var pe=se.uint32();switch(pe>>>3){case 1:he.dimValue=se.int64();break;case 2:he.dimParam=se.string();break;case 3:he.denotation=se.string();break;default:se.skipType(7&pe)}}return he},W.decodeDelimited=function(se){return se instanceof K||(se=new K(se)),this.decode(se,se.uint32())},W.verify=function(se){if(typeof se!="object"||se===null)return"object expected";var le={};if(se.dimValue!=null&&se.hasOwnProperty("dimValue")&&(le.value=1,!(Z.isInteger(se.dimValue)||se.dimValue&&Z.isInteger(se.dimValue.low)&&Z.isInteger(se.dimValue.high))))return"dimValue: integer|Long expected";if(se.dimParam!=null&&se.hasOwnProperty("dimParam")){if(le.value===1)return"value: multiple values";if(le.value=1,!Z.isString(se.dimParam))return"dimParam: string expected"}return se.denotation!=null&&se.hasOwnProperty("denotation")&&!Z.isString(se.denotation)?"denotation: string expected":null},W.fromObject=function(se){if(se instanceof ie.onnx.TensorShapeProto.Dimension)return se;var le=new ie.onnx.TensorShapeProto.Dimension;return se.dimValue!=null&&(Z.Long?(le.dimValue=Z.Long.fromValue(se.dimValue)).unsigned=!1:typeof se.dimValue=="string"?le.dimValue=parseInt(se.dimValue,10):typeof se.dimValue=="number"?le.dimValue=se.dimValue:typeof se.dimValue=="object"&&(le.dimValue=new Z.LongBits(se.dimValue.low>>>0,se.dimValue.high>>>0).toNumber())),se.dimParam!=null&&(le.dimParam=String(se.dimParam)),se.denotation!=null&&(le.denotation=String(se.denotation)),le},W.toObject=function(se,le){le||(le={});var ce={};return le.defaults&&(ce.denotation=""),se.dimValue!=null&&se.hasOwnProperty("dimValue")&&(typeof se.dimValue=="number"?ce.dimValue=le.longs===String?String(se.dimValue):se.dimValue:ce.dimValue=le.longs===String?Z.Long.prototype.toString.call(se.dimValue):le.longs===Number?new Z.LongBits(se.dimValue.low>>>0,se.dimValue.high>>>0).toNumber():se.dimValue,le.oneofs&&(ce.value="dimValue")),se.dimParam!=null&&se.hasOwnProperty("dimParam")&&(ce.dimParam=se.dimParam,le.oneofs&&(ce.value="dimParam")),se.denotation!=null&&se.hasOwnProperty("denotation")&&(ce.denotation=se.denotation),ce},W.prototype.toJSON=function(){return this.constructor.toObject(this,q.util.toJSONOptions)},W})(),Y})(),G.TypeProto=(function(){function Y(ne){if(ne)for(var se=Object.keys(ne),le=0;le<se.length;++le)ne[se[le]]!=null&&(this[se[le]]=ne[se[le]])}var W;return Y.prototype.tensorType=null,Y.prototype.denotation="",Object.defineProperty(Y.prototype,"value",{get:Z.oneOfGetter(W=["tensorType"]),set:Z.oneOfSetter(W)}),Y.create=function(ne){return new Y(ne)},Y.encode=function(ne,se){return se||(se=ee.create()),ne.tensorType!=null&&ne.hasOwnProperty("tensorType")&&ie.onnx.TypeProto.Tensor.encode(ne.tensorType,se.uint32(10).fork()).ldelim(),ne.denotation!=null&&ne.hasOwnProperty("denotation")&&se.uint32(50).string(ne.denotation),se},Y.encodeDelimited=function(ne,se){return this.encode(ne,se).ldelim()},Y.decode=function(ne,se){ne instanceof K||(ne=K.create(ne));for(var le=se===void 0?ne.len:ne.pos+se,ce=new ie.onnx.TypeProto;ne.pos<le;){var he=ne.uint32();switch(he>>>3){case 1:ce.tensorType=ie.onnx.TypeProto.Tensor.decode(ne,ne.uint32());break;case 6:ce.denotation=ne.string();break;default:ne.skipType(7&he)}}return ce},Y.decodeDelimited=function(ne){return ne instanceof K||(ne=new K(ne)),this.decode(ne,ne.uint32())},Y.verify=function(ne){if(typeof ne!="object"||ne===null)return"object expected";if(ne.tensorType!=null&&ne.hasOwnProperty("tensorType")){var se=ie.onnx.TypeProto.Tensor.verify(ne.tensorType);if(se)return"tensorType."+se}return ne.denotation!=null&&ne.hasOwnProperty("denotation")&&!Z.isString(ne.denotation)?"denotation: string expected":null},Y.fromObject=function(ne){if(ne instanceof ie.onnx.TypeProto)return ne;var se=new ie.onnx.TypeProto;if(ne.tensorType!=null){if(typeof ne.tensorType!="object")throw TypeError(".onnx.TypeProto.tensorType: object expected");se.tensorType=ie.onnx.TypeProto.Tensor.fromObject(ne.tensorType)}return ne.denotation!=null&&(se.denotation=String(ne.denotation)),se},Y.toObject=function(ne,se){se||(se={});var le={};return se.defaults&&(le.denotation=""),ne.tensorType!=null&&ne.hasOwnProperty("tensorType")&&(le.tensorType=ie.onnx.TypeProto.Tensor.toObject(ne.tensorType,se),se.oneofs&&(le.value="tensorType")),ne.denotation!=null&&ne.hasOwnProperty("denotation")&&(le.denotation=ne.denotation),le},Y.prototype.toJSON=function(){return this.constructor.toObject(this,q.util.toJSONOptions)},Y.Tensor=(function(){function ne(se){if(se)for(var le=Object.keys(se),ce=0;ce<le.length;++ce)se[le[ce]]!=null&&(this[le[ce]]=se[le[ce]])}return ne.prototype.elemType=0,ne.prototype.shape=null,ne.create=function(se){return new ne(se)},ne.encode=function(se,le){return le||(le=ee.create()),se.elemType!=null&&se.hasOwnProperty("elemType")&&le.uint32(8).int32(se.elemType),se.shape!=null&&se.hasOwnProperty("shape")&&ie.onnx.TensorShapeProto.encode(se.shape,le.uint32(18).fork()).ldelim(),le},ne.encodeDelimited=function(se,le){return this.encode(se,le).ldelim()},ne.decode=function(se,le){se instanceof K||(se=K.create(se));for(var ce=le===void 0?se.len:se.pos+le,he=new ie.onnx.TypeProto.Tensor;se.pos<ce;){var pe=se.uint32();switch(pe>>>3){case 1:he.elemType=se.int32();break;case 2:he.shape=ie.onnx.TensorShapeProto.decode(se,se.uint32());break;default:se.skipType(7&pe)}}return he},ne.decodeDelimited=function(se){return se instanceof K||(se=new K(se)),this.decode(se,se.uint32())},ne.verify=function(se){if(typeof se!="object"||se===null)return"object expected";if(se.elemType!=null&&se.hasOwnProperty("elemType")&&!Z.isInteger(se.elemType))return"elemType: integer expected";if(se.shape!=null&&se.hasOwnProperty("shape")){var le=ie.onnx.TensorShapeProto.verify(se.shape);if(le)return"shape."+le}return null},ne.fromObject=function(se){if(se instanceof ie.onnx.TypeProto.Tensor)return se;var le=new ie.onnx.TypeProto.Tensor;if(se.elemType!=null&&(le.elemType=0|se.elemType),se.shape!=null){if(typeof se.shape!="object")throw TypeError(".onnx.TypeProto.Tensor.shape: object expected");le.shape=ie.onnx.TensorShapeProto.fromObject(se.shape)}return le},ne.toObject=function(se,le){le||(le={});var ce={};return le.defaults&&(ce.elemType=0,ce.shape=null),se.elemType!=null&&se.hasOwnProperty("elemType")&&(ce.elemType=se.elemType),se.shape!=null&&se.hasOwnProperty("shape")&&(ce.shape=ie.onnx.TensorShapeProto.toObject(se.shape,le)),ce},ne.prototype.toJSON=function(){return this.constructor.toObject(this,q.util.toJSONOptions)},ne})(),Y})(),G.OperatorSetIdProto=(function(){function Y(W){if(W)for(var ne=Object.keys(W),se=0;se<ne.length;++se)W[ne[se]]!=null&&(this[ne[se]]=W[ne[se]])}return Y.prototype.domain="",Y.prototype.version=Z.Long?Z.Long.fromBits(0,0,!1):0,Y.create=function(W){return new Y(W)},Y.encode=function(W,ne){return ne||(ne=ee.create()),W.domain!=null&&W.hasOwnProperty("domain")&&ne.uint32(10).string(W.domain),W.version!=null&&W.hasOwnProperty("version")&&ne.uint32(16).int64(W.version),ne},Y.encodeDelimited=function(W,ne){return this.encode(W,ne).ldelim()},Y.decode=function(W,ne){W instanceof K||(W=K.create(W));for(var se=ne===void 0?W.len:W.pos+ne,le=new ie.onnx.OperatorSetIdProto;W.pos<se;){var ce=W.uint32();switch(ce>>>3){case 1:le.domain=W.string();break;case 2:le.version=W.int64();break;default:W.skipType(7&ce)}}return le},Y.decodeDelimited=function(W){return W instanceof K||(W=new K(W)),this.decode(W,W.uint32())},Y.verify=function(W){return typeof W!="object"||W===null?"object expected":W.domain!=null&&W.hasOwnProperty("domain")&&!Z.isString(W.domain)?"domain: string expected":W.version!=null&&W.hasOwnProperty("version")&&!(Z.isInteger(W.version)||W.version&&Z.isInteger(W.version.low)&&Z.isInteger(W.version.high))?"version: integer|Long expected":null},Y.fromObject=function(W){if(W instanceof ie.onnx.OperatorSetIdProto)return W;var ne=new ie.onnx.OperatorSetIdProto;return W.domain!=null&&(ne.domain=String(W.domain)),W.version!=null&&(Z.Long?(ne.version=Z.Long.fromValue(W.version)).unsigned=!1:typeof W.version=="string"?ne.version=parseInt(W.version,10):typeof W.version=="number"?ne.version=W.version:typeof W.version=="object"&&(ne.version=new Z.LongBits(W.version.low>>>0,W.version.high>>>0).toNumber())),ne},Y.toObject=function(W,ne){ne||(ne={});var se={};if(ne.defaults)if(se.domain="",Z.Long){var le=new Z.Long(0,0,!1);se.version=ne.longs===String?le.toString():ne.longs===Number?le.toNumber():le}else se.version=ne.longs===String?"0":0;return W.domain!=null&&W.hasOwnProperty("domain")&&(se.domain=W.domain),W.version!=null&&W.hasOwnProperty("version")&&(typeof W.version=="number"?se.version=ne.longs===String?String(W.version):W.version:se.version=ne.longs===String?Z.Long.prototype.toString.call(W.version):ne.longs===Number?new Z.LongBits(W.version.low>>>0,W.version.high>>>0).toNumber():W.version),se},Y.prototype.toJSON=function(){return this.constructor.toObject(this,q.util.toJSONOptions)},Y})(),G),F.exports=ie},2100:(F,w,D)=>{F.exports=D(9482)},9482:(F,w,D)=>{var O=w;function U(){O.util._configure(),O.Writer._configure(O.BufferWriter),O.Reader._configure(O.BufferReader)}O.build="minimal",O.Writer=D(1173),O.BufferWriter=D(3155),O.Reader=D(1408),O.BufferReader=D(593),O.util=D(9693),O.rpc=D(5994),O.roots=D(5054),O.configure=U,U()},1408:(F,w,D)=>{F.exports=ee;var O,U=D(9693),G=U.LongBits,q=U.utf8;function K(le,ce){return RangeError("index out of range: "+le.pos+" + "+(ce||1)+" > "+le.len)}function ee(le){this.buf=le,this.pos=0,this.len=le.length}var Z,ie=typeof Uint8Array<"u"?function(le){if(le instanceof Uint8Array||Array.isArray(le))return new ee(le);throw Error("illegal buffer")}:function(le){if(Array.isArray(le))return new ee(le);throw Error("illegal buffer")},Y=function(){return U.Buffer?function(le){return(ee.create=function(ce){return U.Buffer.isBuffer(ce)?new O(ce):ie(ce)})(le)}:ie};function W(){var le=new G(0,0),ce=0;if(!(this.len-this.pos>4)){for(;ce<3;++ce){if(this.pos>=this.len)throw K(this);if(le.lo=(le.lo|(127&this.buf[this.pos])<<7*ce)>>>0,this.buf[this.pos++]<128)return le}return le.lo=(le.lo|(127&this.buf[this.pos++])<<7*ce)>>>0,le}for(;ce<4;++ce)if(le.lo=(le.lo|(127&this.buf[this.pos])<<7*ce)>>>0,this.buf[this.pos++]<128)return le;if(le.lo=(le.lo|(127&this.buf[this.pos])<<28)>>>0,le.hi=(le.hi|(127&this.buf[this.pos])>>4)>>>0,this.buf[this.pos++]<128)return le;if(ce=0,this.len-this.pos>4){for(;ce<5;++ce)if(le.hi=(le.hi|(127&this.buf[this.pos])<<7*ce+3)>>>0,this.buf[this.pos++]<128)return le}else for(;ce<5;++ce){if(this.pos>=this.len)throw K(this);if(le.hi=(le.hi|(127&this.buf[this.pos])<<7*ce+3)>>>0,this.buf[this.pos++]<128)return le}throw Error("invalid varint encoding")}function ne(le,ce){return(le[ce-4]|le[ce-3]<<8|le[ce-2]<<16|le[ce-1]<<24)>>>0}function se(){if(this.pos+8>this.len)throw K(this,8);return new G(ne(this.buf,this.pos+=4),ne(this.buf,this.pos+=4))}ee.create=Y(),ee.prototype._slice=U.Array.prototype.subarray||U.Array.prototype.slice,ee.prototype.uint32=(Z=4294967295,function(){if(Z=(127&this.buf[this.pos])>>>0,this.buf[this.pos++]<128||(Z=(Z|(127&this.buf[this.pos])<<7)>>>0,this.buf[this.pos++]<128)||(Z=(Z|(127&this.buf[this.pos])<<14)>>>0,this.buf[this.pos++]<128)||(Z=(Z|(127&this.buf[this.pos])<<21)>>>0,this.buf[this.pos++]<128)||(Z=(Z|(15&this.buf[this.pos])<<28)>>>0,this.buf[this.pos++]<128))return Z;if((this.pos+=5)>this.len)throw this.pos=this.len,K(this,10);return Z}),ee.prototype.int32=function(){return 0|this.uint32()},ee.prototype.sint32=function(){var le=this.uint32();return le>>>1^-(1&le)|0},ee.prototype.bool=function(){return this.uint32()!==0},ee.prototype.fixed32=function(){if(this.pos+4>this.len)throw K(this,4);return ne(this.buf,this.pos+=4)},ee.prototype.sfixed32=function(){if(this.pos+4>this.len)throw K(this,4);return 0|ne(this.buf,this.pos+=4)},ee.prototype.float=function(){if(this.pos+4>this.len)throw K(this,4);var le=U.float.readFloatLE(this.buf,this.pos);return this.pos+=4,le},ee.prototype.double=function(){if(this.pos+8>this.len)throw K(this,4);var le=U.float.readDoubleLE(this.buf,this.pos);return this.pos+=8,le},ee.prototype.bytes=function(){var le=this.uint32(),ce=this.pos,he=this.pos+le;if(he>this.len)throw K(this,le);return this.pos+=le,Array.isArray(this.buf)?this.buf.slice(ce,he):ce===he?new this.buf.constructor(0):this._slice.call(this.buf,ce,he)},ee.prototype.string=function(){var le=this.bytes();return q.read(le,0,le.length)},ee.prototype.skip=function(le){if(typeof le=="number"){if(this.pos+le>this.len)throw K(this,le);this.pos+=le}else do if(this.pos>=this.len)throw K(this);while(128&this.buf[this.pos++]);return this},ee.prototype.skipType=function(le){switch(le){case 0:this.skip();break;case 1:this.skip(8);break;case 2:this.skip(this.uint32());break;case 3:for(;(le=7&this.uint32())!=4;)this.skipType(le);break;case 5:this.skip(4);break;default:throw Error("invalid wire type "+le+" at offset "+this.pos)}return this},ee._configure=function(le){O=le,ee.create=Y(),O._configure();var ce=U.Long?"toLong":"toNumber";U.merge(ee.prototype,{int64:function(){return W.call(this)[ce](!1)},uint64:function(){return W.call(this)[ce](!0)},sint64:function(){return W.call(this).zzDecode()[ce](!1)},fixed64:function(){return se.call(this)[ce](!0)},sfixed64:function(){return se.call(this)[ce](!1)}})}},593:(F,w,D)=>{F.exports=G;var O=D(1408);(G.prototype=Object.create(O.prototype)).constructor=G;var U=D(9693);function G(q){O.call(this,q)}G._configure=function(){U.Buffer&&(G.prototype._slice=U.Buffer.prototype.slice)},G.prototype.string=function(){var q=this.uint32();return this.buf.utf8Slice?this.buf.utf8Slice(this.pos,this.pos=Math.min(this.pos+q,this.len)):this.buf.toString("utf-8",this.pos,this.pos=Math.min(this.pos+q,this.len))},G._configure()},5054:F=>{F.exports={}},5994:(F,w,D)=>{w.Service=D(7948)},7948:(F,w,D)=>{F.exports=U;var O=D(9693);function U(G,q,K){if(typeof G!="function")throw TypeError("rpcImpl must be a function");O.EventEmitter.call(this),this.rpcImpl=G,this.requestDelimited=!!q,this.responseDelimited=!!K}(U.prototype=Object.create(O.EventEmitter.prototype)).constructor=U,U.prototype.rpcCall=function G(q,K,ee,Z,ie){if(!Z)throw TypeError("request must be specified");var Y=this;if(!ie)return O.asPromise(G,Y,q,K,ee,Z);if(Y.rpcImpl)try{return Y.rpcImpl(q,K[Y.requestDelimited?"encodeDelimited":"encode"](Z).finish(),(function(W,ne){if(W)return Y.emit("error",W,q),ie(W);if(ne!==null){if(!(ne instanceof ee))try{ne=ee[Y.responseDelimited?"decodeDelimited":"decode"](ne)}catch(se){return Y.emit("error",se,q),ie(se)}return Y.emit("data",ne,q),ie(null,ne)}Y.end(!0)}))}catch(W){return Y.emit("error",W,q),void setTimeout((function(){ie(W)}),0)}else setTimeout((function(){ie(Error("already ended"))}),0)},U.prototype.end=function(G){return this.rpcImpl&&(G||this.rpcImpl(null,null,null),this.rpcImpl=null,this.emit("end").off()),this}},1945:(F,w,D)=>{F.exports=U;var O=D(9693);function U(ee,Z){this.lo=ee>>>0,this.hi=Z>>>0}var G=U.zero=new U(0,0);G.toNumber=function(){return 0},G.zzEncode=G.zzDecode=function(){return this},G.length=function(){return 1};var q=U.zeroHash="\0\0\0\0\0\0\0\0";U.fromNumber=function(ee){if(ee===0)return G;var Z=ee<0;Z&&(ee=-ee);var ie=ee>>>0,Y=(ee-ie)/4294967296>>>0;return Z&&(Y=~Y>>>0,ie=~ie>>>0,++ie>4294967295&&(ie=0,++Y>4294967295&&(Y=0))),new U(ie,Y)},U.from=function(ee){if(typeof ee=="number")return U.fromNumber(ee);if(O.isString(ee)){if(!O.Long)return U.fromNumber(parseInt(ee,10));ee=O.Long.fromString(ee)}return ee.low||ee.high?new U(ee.low>>>0,ee.high>>>0):G},U.prototype.toNumber=function(ee){if(!ee&&this.hi>>>31){var Z=1+~this.lo>>>0,ie=~this.hi>>>0;return Z||(ie=ie+1>>>0),-(Z+4294967296*ie)}return this.lo+4294967296*this.hi},U.prototype.toLong=function(ee){return O.Long?new O.Long(0|this.lo,0|this.hi,!!ee):{low:0|this.lo,high:0|this.hi,unsigned:!!ee}};var K=String.prototype.charCodeAt;U.fromHash=function(ee){return ee===q?G:new U((K.call(ee,0)|K.call(ee,1)<<8|K.call(ee,2)<<16|K.call(ee,3)<<24)>>>0,(K.call(ee,4)|K.call(ee,5)<<8|K.call(ee,6)<<16|K.call(ee,7)<<24)>>>0)},U.prototype.toHash=function(){return String.fromCharCode(255&this.lo,this.lo>>>8&255,this.lo>>>16&255,this.lo>>>24,255&this.hi,this.hi>>>8&255,this.hi>>>16&255,this.hi>>>24)},U.prototype.zzEncode=function(){var ee=this.hi>>31;return this.hi=((this.hi<<1|this.lo>>>31)^ee)>>>0,this.lo=(this.lo<<1^ee)>>>0,this},U.prototype.zzDecode=function(){var ee=-(1&this.lo);return this.lo=((this.lo>>>1|this.hi<<31)^ee)>>>0,this.hi=(this.hi>>>1^ee)>>>0,this},U.prototype.length=function(){var ee=this.lo,Z=(this.lo>>>28|this.hi<<4)>>>0,ie=this.hi>>>24;return ie===0?Z===0?ee<16384?ee<128?1:2:ee<2097152?3:4:Z<16384?Z<128?5:6:Z<2097152?7:8:ie<128?9:10}},9693:function(F,w,D){var O=w;function U(q,K,ee){for(var Z=Object.keys(K),ie=0;ie<Z.length;++ie)q[Z[ie]]!==void 0&&ee||(q[Z[ie]]=K[Z[ie]]);return q}function G(q){function K(ee,Z){if(!(this instanceof K))return new K(ee,Z);Object.defineProperty(this,"message",{get:function(){return ee}}),Error.captureStackTrace?Error.captureStackTrace(this,K):Object.defineProperty(this,"stack",{value:new Error().stack||""}),Z&&U(this,Z)}return(K.prototype=Object.create(Error.prototype)).constructor=K,Object.defineProperty(K.prototype,"name",{get:function(){return q}}),K.prototype.toString=function(){return this.name+": "+this.message},K}O.asPromise=D(4537),O.base64=D(7419),O.EventEmitter=D(9211),O.float=D(945),O.inquire=D(7199),O.utf8=D(4997),O.pool=D(6662),O.LongBits=D(1945),O.isNode=!!(D.g!==void 0&&D.g&&D.g.process&&D.g.process.versions&&D.g.process.versions.node),O.global=O.isNode&&D.g||typeof window<"u"&&window||typeof self<"u"&&self||this,O.emptyArray=Object.freeze?Object.freeze([]):[],O.emptyObject=Object.freeze?Object.freeze({}):{},O.isInteger=Number.isInteger||function(q){return typeof q=="number"&&isFinite(q)&&Math.floor(q)===q},O.isString=function(q){return typeof q=="string"||q instanceof String},O.isObject=function(q){return q&&typeof q=="object"},O.isset=O.isSet=function(q,K){var ee=q[K];return!(ee==null||!q.hasOwnProperty(K))&&(typeof ee!="object"||(Array.isArray(ee)?ee.length:Object.keys(ee).length)>0)},O.Buffer=(function(){try{var q=O.inquire("buffer").Buffer;return q.prototype.utf8Write?q:null}catch{return null}})(),O._Buffer_from=null,O._Buffer_allocUnsafe=null,O.newBuffer=function(q){return typeof q=="number"?O.Buffer?O._Buffer_allocUnsafe(q):new O.Array(q):O.Buffer?O._Buffer_from(q):typeof Uint8Array>"u"?q:new Uint8Array(q)},O.Array=typeof Uint8Array<"u"?Uint8Array:Array,O.Long=O.global.dcodeIO&&O.global.dcodeIO.Long||O.global.Long||O.inquire("long"),O.key2Re=/^true|false|0|1$/,O.key32Re=/^-?(?:0|[1-9][0-9]*)$/,O.key64Re=/^(?:[\\x00-\\xff]{8}|-?(?:0|[1-9][0-9]*))$/,O.longToHash=function(q){return q?O.LongBits.from(q).toHash():O.LongBits.zeroHash},O.longFromHash=function(q,K){var ee=O.LongBits.fromHash(q);return O.Long?O.Long.fromBits(ee.lo,ee.hi,K):ee.toNumber(!!K)},O.merge=U,O.lcFirst=function(q){return q.charAt(0).toLowerCase()+q.substring(1)},O.newError=G,O.ProtocolError=G("ProtocolError"),O.oneOfGetter=function(q){for(var K={},ee=0;ee<q.length;++ee)K[q[ee]]=1;return function(){for(var Z=Object.keys(this),ie=Z.length-1;ie>-1;--ie)if(K[Z[ie]]===1&&this[Z[ie]]!==void 0&&this[Z[ie]]!==null)return Z[ie]}},O.oneOfSetter=function(q){return function(K){for(var ee=0;ee<q.length;++ee)q[ee]!==K&&delete this[q[ee]]}},O.toJSONOptions={longs:String,enums:String,bytes:String,json:!0},O._configure=function(){var q=O.Buffer;q?(O._Buffer_from=q.from!==Uint8Array.from&&q.from||function(K,ee){return new q(K,ee)},O._Buffer_allocUnsafe=q.allocUnsafe||function(K){return new q(K)}):O._Buffer_from=O._Buffer_allocUnsafe=null}},1173:(F,w,D)=>{F.exports=Y;var O,U=D(9693),G=U.LongBits,q=U.base64,K=U.utf8;function ee(pe,me,be){this.fn=pe,this.len=me,this.next=void 0,this.val=be}function Z(){}function ie(pe){this.head=pe.head,this.tail=pe.tail,this.len=pe.len,this.next=pe.states}function Y(){this.len=0,this.head=new ee(Z,0,0),this.tail=this.head,this.states=null}var W=function(){return U.Buffer?function(){return(Y.create=function(){return new O})()}:function(){return new Y}};function ne(pe,me,be){me[be]=255&pe}function se(pe,me){this.len=pe,this.next=void 0,this.val=me}function le(pe,me,be){for(;pe.hi;)me[be++]=127&pe.lo|128,pe.lo=(pe.lo>>>7|pe.hi<<25)>>>0,pe.hi>>>=7;for(;pe.lo>127;)me[be++]=127&pe.lo|128,pe.lo=pe.lo>>>7;me[be++]=pe.lo}function ce(pe,me,be){me[be]=255&pe,me[be+1]=pe>>>8&255,me[be+2]=pe>>>16&255,me[be+3]=pe>>>24}Y.create=W(),Y.alloc=function(pe){return new U.Array(pe)},U.Array!==Array&&(Y.alloc=U.pool(Y.alloc,U.Array.prototype.subarray)),Y.prototype._push=function(pe,me,be){return this.tail=this.tail.next=new ee(pe,me,be),this.len+=me,this},se.prototype=Object.create(ee.prototype),se.prototype.fn=function(pe,me,be){for(;pe>127;)me[be++]=127&pe|128,pe>>>=7;me[be]=pe},Y.prototype.uint32=function(pe){return this.len+=(this.tail=this.tail.next=new se((pe>>>=0)<128?1:pe<16384?2:pe<2097152?3:pe<268435456?4:5,pe)).len,this},Y.prototype.int32=function(pe){return pe<0?this._push(le,10,G.fromNumber(pe)):this.uint32(pe)},Y.prototype.sint32=function(pe){return this.uint32((pe<<1^pe>>31)>>>0)},Y.prototype.uint64=function(pe){var me=G.from(pe);return this._push(le,me.length(),me)},Y.prototype.int64=Y.prototype.uint64,Y.prototype.sint64=function(pe){var me=G.from(pe).zzEncode();return this._push(le,me.length(),me)},Y.prototype.bool=function(pe){return this._push(ne,1,pe?1:0)},Y.prototype.fixed32=function(pe){return this._push(ce,4,pe>>>0)},Y.prototype.sfixed32=Y.prototype.fixed32,Y.prototype.fixed64=function(pe){var me=G.from(pe);return this._push(ce,4,me.lo)._push(ce,4,me.hi)},Y.prototype.sfixed64=Y.prototype.fixed64,Y.prototype.float=function(pe){return this._push(U.float.writeFloatLE,4,pe)},Y.prototype.double=function(pe){return this._push(U.float.writeDoubleLE,8,pe)};var he=U.Array.prototype.set?function(pe,me,be){me.set(pe,be)}:function(pe,me,be){for(var ge=0;ge<pe.length;++ge)me[be+ge]=pe[ge]};Y.prototype.bytes=function(pe){var me=pe.length>>>0;if(!me)return this._push(ne,1,0);if(U.isString(pe)){var be=Y.alloc(me=q.length(pe));q.decode(pe,be,0),pe=be}return this.uint32(me)._push(he,me,pe)},Y.prototype.string=function(pe){var me=K.length(pe);return me?this.uint32(me)._push(K.write,me,pe):this._push(ne,1,0)},Y.prototype.fork=function(){return this.states=new ie(this),this.head=this.tail=new ee(Z,0,0),this.len=0,this},Y.prototype.reset=function(){return this.states?(this.head=this.states.head,this.tail=this.states.tail,this.len=this.states.len,this.states=this.states.next):(this.head=this.tail=new ee(Z,0,0),this.len=0),this},Y.prototype.ldelim=function(){var pe=this.head,me=this.tail,be=this.len;return this.reset().uint32(be),be&&(this.tail.next=pe.next,this.tail=me,this.len+=be),this},Y.prototype.finish=function(){for(var pe=this.head.next,me=this.constructor.alloc(this.len),be=0;pe;)pe.fn(pe.val,me,be),be+=pe.len,pe=pe.next;return me},Y._configure=function(pe){O=pe,Y.create=W(),O._configure()}},3155:(F,w,D)=>{F.exports=G;var O=D(1173);(G.prototype=Object.create(O.prototype)).constructor=G;var U=D(9693);function G(){O.call(this)}function q(K,ee,Z){K.length<40?U.utf8.write(K,ee,Z):ee.utf8Write?ee.utf8Write(K,Z):ee.write(K,Z)}G._configure=function(){G.alloc=U._Buffer_allocUnsafe,G.writeBytesBuffer=U.Buffer&&U.Buffer.prototype instanceof Uint8Array&&U.Buffer.prototype.set.name==="set"?function(K,ee,Z){ee.set(K,Z)}:function(K,ee,Z){if(K.copy)K.copy(ee,Z,0,K.length);else for(var ie=0;ie<K.length;)ee[Z++]=K[ie++]}},G.prototype.bytes=function(K){U.isString(K)&&(K=U._Buffer_from(K,"base64"));var ee=K.length>>>0;return this.uint32(ee),ee&&this._push(G.writeBytesBuffer,ee,K),this},G.prototype.string=function(K){var ee=U.Buffer.byteLength(K);return this.uint32(ee),ee&&this._push(q,ee,K),this},G._configure()},7714:(F,w,D)=>{w.R=void 0;const O=D(6919),U=D(7448);w.R=new class{async init(){}async createSessionHandler(G,q){const K=new O.Session(q);return await K.loadModel(G),new U.OnnxjsSessionHandler(K)}}},4200:(F,w,D)=>{w.c8=w.rX=void 0;const O=D(1670),U=D(5381),G=D(2157),q=D(2306);w.rX=()=>{if((typeof O.env.wasm.initTimeout!="number"||O.env.wasm.initTimeout<0)&&(O.env.wasm.initTimeout=0),typeof O.env.wasm.simd!="boolean"&&(O.env.wasm.simd=!0),typeof O.env.wasm.proxy!="boolean"&&(O.env.wasm.proxy=!1),typeof O.env.wasm.numThreads!="number"||!Number.isInteger(O.env.wasm.numThreads)||O.env.wasm.numThreads<=0){const K=typeof navigator>"u"?(0,U.cpus)().length:navigator.hardwareConcurrency;O.env.wasm.numThreads=Math.min(4,Math.ceil((K||1)/2))}},w.c8=new class{async init(){(0,w.rX)(),await(0,G.initWasm)()}async createSessionHandler(K,ee){const Z=new q.OnnxruntimeWebAssemblySessionHandler;return await Z.loadModel(K,ee),Promise.resolve(Z)}}},6018:function(F,w,D){var O=this&&this.__createBinding||(Object.create?function(q,K,ee,Z){Z===void 0&&(Z=ee);var ie=Object.getOwnPropertyDescriptor(K,ee);ie&&!("get"in ie?!K.__esModule:ie.writable||ie.configurable)||(ie={enumerable:!0,get:function(){return K[ee]}}),Object.defineProperty(q,Z,ie)}:function(q,K,ee,Z){Z===void 0&&(Z=ee),q[Z]=K[ee]}),U=this&&this.__exportStar||function(q,K){for(var ee in q)ee==="default"||Object.prototype.hasOwnProperty.call(K,ee)||O(K,q,ee)};Object.defineProperty(w,"__esModule",{value:!0}),U(D(1670),w);const G=D(1670);{const q=D(7714).R;(0,G.registerBackend)("webgl",q,-10)}{const q=D(4200).c8;(0,G.registerBackend)("cpu",q,10),(0,G.registerBackend)("wasm",q,10),(0,G.registerBackend)("xnnpack",q,9)}},246:(F,w)=>{Object.defineProperty(w,"__esModule",{value:!0}),w.createAttributeWithCacheKey=void 0;class D{constructor(U){Object.assign(this,U)}get cacheKey(){return this._cacheKey||(this._cacheKey=Object.getOwnPropertyNames(this).sort().map((U=>`${this[U]}`)).join(";")),this._cacheKey}}w.createAttributeWithCacheKey=O=>new D(O)},7778:(F,w,D)=>{Object.defineProperty(w,"__esModule",{value:!0}),w.Attribute=void 0;const O=D(1446),U=D(9395),G=D(9162),q=D(2517);var K=U.onnxruntime.experimental.fbs;class ee{constructor(ie){if(this._attributes=new Map,ie!=null){for(const Y of ie)Y instanceof O.onnx.AttributeProto?this._attributes.set(Y.name,[ee.getValue(Y),ee.getType(Y)]):Y instanceof K.Attribute&&this._attributes.set(Y.name(),[ee.getValue(Y),ee.getType(Y)]);if(this._attributes.size<ie.length)throw new Error("duplicated attribute names")}}set(ie,Y,W){this._attributes.set(ie,[W,Y])}delete(ie){this._attributes.delete(ie)}getFloat(ie,Y){return this.get(ie,"float",Y)}getInt(ie,Y){return this.get(ie,"int",Y)}getString(ie,Y){return this.get(ie,"string",Y)}getTensor(ie,Y){return this.get(ie,"tensor",Y)}getFloats(ie,Y){return this.get(ie,"floats",Y)}getInts(ie,Y){return this.get(ie,"ints",Y)}getStrings(ie,Y){return this.get(ie,"strings",Y)}getTensors(ie,Y){return this.get(ie,"tensors",Y)}get(ie,Y,W){const ne=this._attributes.get(ie);if(ne===void 0){if(W!==void 0)return W;throw new Error(`required attribute not found: ${ie}`)}if(ne[1]!==Y)throw new Error(`type mismatch: expected ${Y} but got ${ne[1]}`);return ne[0]}static getType(ie){const Y=ie instanceof O.onnx.AttributeProto?ie.type:ie.type();switch(Y){case O.onnx.AttributeProto.AttributeType.FLOAT:return"float";case O.onnx.AttributeProto.AttributeType.INT:return"int";case O.onnx.AttributeProto.AttributeType.STRING:return"string";case O.onnx.AttributeProto.AttributeType.TENSOR:return"tensor";case O.onnx.AttributeProto.AttributeType.FLOATS:return"floats";case O.onnx.AttributeProto.AttributeType.INTS:return"ints";case O.onnx.AttributeProto.AttributeType.STRINGS:return"strings";case O.onnx.AttributeProto.AttributeType.TENSORS:return"tensors";default:throw new Error(`attribute type is not supported yet: ${O.onnx.AttributeProto.AttributeType[Y]}`)}}static getValue(ie){const Y=ie instanceof O.onnx.AttributeProto?ie.type:ie.type();if(Y===O.onnx.AttributeProto.AttributeType.GRAPH||Y===O.onnx.AttributeProto.AttributeType.GRAPHS)throw new Error("graph attribute is not supported yet");const W=this.getValueNoCheck(ie);if(Y===O.onnx.AttributeProto.AttributeType.INT&&q.LongUtil.isLong(W))return q.LongUtil.longToNumber(W);if(Y===O.onnx.AttributeProto.AttributeType.INTS){const ne=W,se=new Array(ne.length);for(let le=0;le<ne.length;le++){const ce=ne[le];se[le]=q.LongUtil.longToNumber(ce)}return se}if(Y===O.onnx.AttributeProto.AttributeType.TENSOR)return ie instanceof O.onnx.AttributeProto?G.Tensor.fromProto(W):G.Tensor.fromOrtTensor(W);if(Y===O.onnx.AttributeProto.AttributeType.TENSORS){if(ie instanceof O.onnx.AttributeProto)return W.map((ne=>G.Tensor.fromProto(ne)));if(ie instanceof K.Attribute)return W.map((ne=>G.Tensor.fromOrtTensor(ne)))}if(Y===O.onnx.AttributeProto.AttributeType.STRING&&ie instanceof O.onnx.AttributeProto){const ne=W;return(0,q.decodeUtf8String)(ne)}return Y===O.onnx.AttributeProto.AttributeType.STRINGS&&ie instanceof O.onnx.AttributeProto?W.map(q.decodeUtf8String):W}static getValueNoCheck(ie){return ie instanceof O.onnx.AttributeProto?this.getValueNoCheckFromOnnxFormat(ie):this.getValueNoCheckFromOrtFormat(ie)}static getValueNoCheckFromOnnxFormat(ie){switch(ie.type){case O.onnx.AttributeProto.AttributeType.FLOAT:return ie.f;case O.onnx.AttributeProto.AttributeType.INT:return ie.i;case O.onnx.AttributeProto.AttributeType.STRING:return ie.s;case O.onnx.AttributeProto.AttributeType.TENSOR:return ie.t;case O.onnx.AttributeProto.AttributeType.GRAPH:return ie.g;case O.onnx.AttributeProto.AttributeType.FLOATS:return ie.floats;case O.onnx.AttributeProto.AttributeType.INTS:return ie.ints;case O.onnx.AttributeProto.AttributeType.STRINGS:return ie.strings;case O.onnx.AttributeProto.AttributeType.TENSORS:return ie.tensors;case O.onnx.AttributeProto.AttributeType.GRAPHS:return ie.graphs;default:throw new Error(`unsupported attribute type: ${O.onnx.AttributeProto.AttributeType[ie.type]}`)}}static getValueNoCheckFromOrtFormat(ie){switch(ie.type()){case K.AttributeType.FLOAT:return ie.f();case K.AttributeType.INT:return ie.i();case K.AttributeType.STRING:return ie.s();case K.AttributeType.TENSOR:return ie.t();case K.AttributeType.GRAPH:return ie.g();case K.AttributeType.FLOATS:return ie.floatsArray();case K.AttributeType.INTS:{const Y=[];for(let W=0;W<ie.intsLength();W++)Y.push(ie.ints(W));return Y}case K.AttributeType.STRINGS:{const Y=[];for(let W=0;W<ie.stringsLength();W++)Y.push(ie.strings(W));return Y}case K.AttributeType.TENSORS:{const Y=[];for(let W=0;W<ie.tensorsLength();W++)Y.push(ie.tensors(W));return Y}default:throw new Error(`unsupported attribute type: ${K.AttributeType[ie.type()]}`)}}}w.Attribute=ee},7091:(F,w,D)=>{Object.defineProperty(w,"__esModule",{value:!0}),w.resolveBackend=w.backend=void 0;const O=D(5038),U=new Map;async function G(q){const K=w.backend;if(K[q]!==void 0&&(function(ee){const Z=ee;return"initialize"in Z&&typeof Z.initialize=="function"&&"createSessionHandler"in Z&&typeof Z.createSessionHandler=="function"&&"dispose"in Z&&typeof Z.dispose=="function"})(K[q])){const ee=K[q];let Z=ee.initialize();if(typeof Z=="object"&&"then"in Z&&(Z=await Z),Z)return U.set(q,ee),ee}}w.backend={webgl:new O.WebGLBackend},w.resolveBackend=async function q(K){if(!K)return q(["webgl"]);{const ee=typeof K=="string"?[K]:K;for(const Z of ee){const ie=U.get(Z);if(ie)return ie;const Y=await G(Z);if(Y)return Y}}throw new Error("no available backend to use")}},5038:(F,w,D)=>{Object.defineProperty(w,"__esModule",{value:!0}),w.WebGLBackend=void 0;const O=D(1670),U=D(6231),G=D(6416),q=D(7305);w.WebGLBackend=class{get contextId(){return O.env.webgl.contextId}set contextId(K){O.env.webgl.contextId=K}get matmulMaxBatchSize(){return O.env.webgl.matmulMaxBatchSize}set matmulMaxBatchSize(K){O.env.webgl.matmulMaxBatchSize=K}get textureCacheMode(){return O.env.webgl.textureCacheMode}set textureCacheMode(K){O.env.webgl.textureCacheMode=K}get pack(){return O.env.webgl.pack}set pack(K){O.env.webgl.pack=K}get async(){return O.env.webgl.async}set async(K){O.env.webgl.async=K}initialize(){try{return this.glContext=(0,q.createWebGLContext)(this.contextId),typeof this.matmulMaxBatchSize!="number"&&(this.matmulMaxBatchSize=16),typeof this.textureCacheMode!="string"&&(this.textureCacheMode="full"),typeof this.pack!="boolean"&&(this.pack=!1),typeof this.async!="boolean"&&(this.async=!1),U.Logger.setWithEnv(O.env),U.Logger.verbose("WebGLBackend",`Created WebGLContext: ${typeof this.glContext} with matmulMaxBatchSize: ${this.matmulMaxBatchSize}; textureCacheMode: ${this.textureCacheMode}; pack: ${this.pack}; async: ${this.async}.`),!0}catch(K){return U.Logger.warning("WebGLBackend",`Unable to initialize WebGLBackend. ${K}`),!1}}createSessionHandler(K){return new G.WebGLSessionHandler(this,K)}dispose(){this.glContext.dispose()}}},5107:(F,w,D)=>{Object.defineProperty(w,"__esModule",{value:!0}),w.CoordsGlslLib=void 0;const O=D(2517),U=D(8520),G=D(5060),q=D(7859),K=D(9390);class ee extends U.GlslLib{constructor(ie){super(ie)}getFunctions(){return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({},this.offsetToCoords()),this.coordsToOffset()),this.toVec()),this.valueFrom()),this.getCommonUtilFuncs()),this.getInputsSamplingSnippets()),this.getOutputSamplingSnippet())}getCustomTypes(){return{}}offsetToCoords(){return{offsetToCoords:new U.GlslLibRoutine(`
      vec2 offsetToCoords(int offset, int width, int height) {
        int t = offset / width;
        int s = offset - t*width;
        vec2 coords = (vec2(s,t) + vec2(0.5,0.5)) / vec2(width, height);
        return coords;
      }
      `)}}coordsToOffset(){return{coordsToOffset:new U.GlslLibRoutine(`
      int coordsToOffset(vec2 coords, int width, int height) {
        float s = coords.s * float(width);
        float t = coords.t * float(height);
        int offset = int(t) * width + int(s);
        return offset;
      }
      `)}}getOutputSamplingSnippet(){const ie=this.context.outputTextureLayout;return ie.isPacked?this.getPackedOutputSamplingSnippet(ie):this.getUnpackedOutputSamplingSnippet(ie)}getPackedOutputSamplingSnippet(ie){const Y=ie.unpackedShape,W=[ie.width,ie.height],ne={},se="getOutputCoords";switch(Y.length){case 0:ne[se]=this.getOutputScalarCoords();break;case 1:ne[se]=this.getOutputPacked1DCoords(Y,W);break;case 2:ne[se]=this.getOutputPacked2DCoords(Y,W);break;case 3:ne[se]=this.getOutputPacked3DCoords(Y,W);break;default:ne[se]=this.getOutputPackedNDCoords(Y,W)}const le=`
      void setOutput(vec4 val) {
        ${(0,G.getGlsl)(this.context.glContext.version).output} = val;
      }
    `;return ne.floatTextureSetRGBA=new U.GlslLibRoutine(le),ne}getUnpackedOutputSamplingSnippet(ie){const Y=ie.unpackedShape,W=[ie.width,ie.height],ne={},se="getOutputCoords";switch(Y.length){case 0:ne[se]=this.getOutputScalarCoords();break;case 1:ne[se]=this.getOutputUnpacked1DCoords(Y,W);break;case 2:ne[se]=this.getOutputUnpacked2DCoords(Y,W);break;case 3:ne[se]=this.getOutputUnpacked3DCoords(Y,W);break;case 4:ne[se]=this.getOutputUnpacked4DCoords(Y,W);break;case 5:ne[se]=this.getOutputUnpacked5DCoords(Y,W);break;case 6:ne[se]=this.getOutputUnpacked6DCoords(Y,W);break;default:throw new Error(`Unsupported output dimensionality: ${Y.length}`)}const le=`
        void setOutput(float val) {
          ${(0,G.getGlsl)(this.context.glContext.version).output} = vec4(val, 0, 0, 0);
        }
    `;return ne.floatTextureSetR=new U.GlslLibRoutine(le),ne}getOutputScalarCoords(){return new U.GlslLibRoutine(`
      int getOutputCoords() {
        return 0;
      }
    `)}getOutputPacked1DCoords(ie,Y){const W=Y;let ne="";return W[0]===1?(ne=`
          int getOutputCoords() {
            return 2 * int(TexCoords.y * ${W[1]}.0);
          }
        `,new U.GlslLibRoutine(ne)):W[1]===1?(ne=`
          int getOutputCoords() {
            return 2 * int(TexCoords.x * ${W[0]}.0);
          }
        `,new U.GlslLibRoutine(ne)):(ne=`
        int getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                 vec2(${W[0]}, ${W[1]}));
          return 2 * (resTexRC.y * ${W[0]} + resTexRC.x);
        }
      `,new U.GlslLibRoutine(ne))}getOutputPacked2DCoords(ie,Y){let W="";if(O.ArrayUtil.arraysEqual(ie,Y))return W=`
        ivec2 getOutputCoords() {
          return 2 * ivec2(TexCoords.xy * vec2(${Y[0]}, ${Y[1]}));
        }
      `,new U.GlslLibRoutine(W);const ne=Y,se=Math.ceil(ie[1]/2);return W=`
        ivec2 getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${ne[0]}, ${ne[1]}));

          int index = resTexRC.y * ${ne[0]} + resTexRC.x;

          // reverse r and c order for packed texture
          int r = imod(index, ${se}) * 2;
          int c = 2 * (index / ${se});

          return ivec2(r, c);
        }
      `,new U.GlslLibRoutine(W)}getOutputPacked3DCoords(ie,Y){const W=[Y[0],Y[1]],ne=Math.ceil(ie[2]/2),se=ne*Math.ceil(ie[1]/2),le=`
        ivec3 getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${W[0]}, ${W[1]}));
          int index = resTexRC.y * ${W[0]} + resTexRC.x;

          int b = index / ${se};
          index -= b * ${se};

          // reverse r and c order for packed texture
          int r = imod(index, ${ne}) * 2;
          int c = 2 * (index / ${ne});

          return ivec3(b, r, c);
        }
      `;return new U.GlslLibRoutine(le)}getOutputPackedNDCoords(ie,Y){const W=[Y[0],Y[1]],ne=Math.ceil(ie[ie.length-1]/2),se=ne*Math.ceil(ie[ie.length-2]/2);let le=se,ce="",he="b, r, c";for(let me=2;me<ie.length-1;me++)le*=ie[ie.length-me-1],ce=`
      int b${me} = index / ${le};
      index -= b${me} * ${le};
    `+ce,he=`b${me}, `+he;const pe=`
      ivec${ie.length} getOutputCoords() {
        ivec2 resTexRC = ivec2(TexCoords.xy *
                              vec2(${W[0]}, ${W[1]}));
        int index = resTexRC.y * ${W[0]} + resTexRC.x;

        ${ce}

        int b = index / ${se};
        index -= b * ${se};

        // reverse r and c order for packed texture
        int r = imod(index, ${ne}) * 2;
        int c = 2 * (index / ${ne});

        return ivec${ie.length}(${he});
      }
    `;return new U.GlslLibRoutine(pe)}getOutputUnpacked1DCoords(ie,Y){const W=`
        int getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${Y[0]}, ${Y[1]}));
          return resTexRC.y * ${Y[0]} + resTexRC.x;
        }
      `;return new U.GlslLibRoutine(W)}getOutputUnpacked2DCoords(ie,Y){const W=`
        ivec2 getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${Y[0]}, ${Y[1]}));
          int index = resTexRC.y * ${Y[0]} + resTexRC.x;
          int r = index / ${ie[1]};
          int c = index - r * ${ie[1]};
          return ivec2(r, c);
        }
      `;return new U.GlslLibRoutine(W)}getOutputUnpacked3DCoords(ie,Y){let W="";const ne=ie.length;let se=null;ne<2&&(se=[]),se=new Array(ne-1),se[ne-2]=ie[ne-1];for(let he=ne-3;he>=0;--he)se[he]=se[he+1]*ie[he+1];const le=["r","c","d"],ce=se.map(((he,pe)=>`int ${le[pe]} = index / ${he}; ${pe===se.length-1?`int ${le[pe+1]} = index - ${le[pe]} * ${he}`:`index -= ${le[pe]} * ${he}`};`)).join("");return W=`
        ivec3 getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${Y[0]}, ${Y[1]}));
          int index = resTexRC.y * ${Y[0]} + resTexRC.x;
          ${ce}
          return ivec3(r, c, d);
        }
      `,new U.GlslLibRoutine(W)}getOutputUnpacked4DCoords(ie,Y){let W="";const ne=ie.length;let se=null;ne<2&&(se=[]),se=new Array(ne-1),se[ne-2]=ie[ne-1];for(let he=ne-3;he>=0;--he)se[he]=se[he+1]*ie[he+1];const le=["r","c","d","d2"],ce=se.map(((he,pe)=>`int ${le[pe]} = index / ${he}; ${pe===se.length-1?`int ${le[pe+1]} = index - ${le[pe]} * ${he}`:`index -= ${le[pe]} * ${he}`};`)).join("");return W=`
      ivec4 getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${Y[0]}, ${Y[1]}));
          int index = resTexRC.y * ${Y[0]} + resTexRC.x;
          ${ce}
          return ivec4(r, c, d, d2);
        }
      `,new U.GlslLibRoutine(W)}getOutputUnpacked5DCoords(ie,Y){let W="";const ne=ie.length;let se=null;ne<2&&(se=[]),se=new Array(ne-1),se[ne-2]=ie[ne-1];for(let he=ne-3;he>=0;--he)se[he]=se[he+1]*ie[he+1];const le=["r","c","d","d2","d3"],ce=se.map(((he,pe)=>`int ${le[pe]} = index / ${he}; ${pe===se.length-1?`int ${le[pe+1]} = index - ${le[pe]} * ${he}`:`index -= ${le[pe]} * ${he}`};`)).join("");return W=`
      ivec5 getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${Y[0]}, ${Y[1]}));
          int index = resTexRC.y * ${Y[0]} + resTexRC.x;
          ${ce}
          return ivec5(r, c, d, d2, d3);
        }
      `,new U.GlslLibRoutine(W)}getOutputUnpacked6DCoords(ie,Y){let W="";const ne=ie.length;let se=null;ne<2&&(se=[]),se=new Array(ne-1),se[ne-2]=ie[ne-1];for(let he=ne-3;he>=0;--he)se[he]=se[he+1]*ie[he+1];const le=["r","c","d","d2","d3","d4"],ce=se.map(((he,pe)=>`int ${le[pe]} = index / ${he}; ${pe===se.length-1?`int ${le[pe+1]} = index - ${le[pe]} * ${he}`:`index -= ${le[pe]} * ${he}`};`)).join("");return W=`
     ivec6 getOutputCoords() {
         ivec2 resTexRC = ivec2(TexCoords.xy *
                               vec2(${Y[0]}, ${Y[1]}));
         int index = resTexRC.y * ${Y[0]} + resTexRC.x;
         ${ce}
         return ivec6(r, c, d, d2, d3, d4);
       }
     `,new U.GlslLibRoutine(W)}getCommonUtilFuncs(){const ie={};let Y="uvFromFlat";ie[Y]=new U.GlslLibRoutine(`
    vec2 uvFromFlat(int texNumR, int texNumC, int index) {
      int texC = index / texNumR;
      int texR = index - texC * texNumR;
      // TODO: swap texR, texC order in following function so row is corresponding to u and column is corresponding to
      //       v.
      return (vec2(texR, texC) + halfCR) / vec2(texNumR, texNumC);
    }
    `),Y="packedUVfrom1D",ie[Y]=new U.GlslLibRoutine(`
      vec2 packedUVfrom1D(int texNumR, int texNumC, int index) {
        int texelIndex = index / 2;
        int texR = texelIndex / texNumC;
        int texC = texelIndex - texR * texNumC;
        return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
      }
      `),Y="packedUVfrom2D",ie[Y]=new U.GlslLibRoutine(`
      vec2 packedUVfrom2D(int texNumR, int texNumC, int texelsInLogicalRow, int row, int col) {
        int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);
        int texR = texelIndex / texNumC;
        int texC = texelIndex - texR * texNumC;
        return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
      }
      `),Y="packedUVfrom3D",ie[Y]=new U.GlslLibRoutine(`
      vec2 packedUVfrom3D(int texNumR, int texNumC,
          int texelsInBatch, int texelsInLogicalRow, int b,
          int row, int col) {
        int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);
        int texR = index / texNumC;
        int texC = index - texR * texNumC;
        return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
      }
      `),Y="sampleTexture";const W=(0,G.getGlsl)(this.context.glContext.version);return ie[Y]=new U.GlslLibRoutine(`
        float sampleTexture(sampler2D textureSampler, vec2 uv) {
            return ${W.texture2D}(textureSampler, uv).r;
        }`),ie}getInputsSamplingSnippets(){const ie={},Y=this.context.outputTextureLayout;return this.context.programInfo.inputNames.forEach(((W,ne)=>{const se=this.context.inputTextureLayouts[ne],le=(0,K.generateShaderFuncNameFromInputSamplerName)(W);se.isPacked?ie[le]=this.getPackedSamplerFromInput(le,W,se):ie[le]=this.getUnpackedSamplerFromInput(le,W,se);const ce=(0,K.generateShaderFuncNameFromInputSamplerNameAtOutCoords)(W);se.unpackedShape.length<=Y.unpackedShape.length&&(se.isPacked?ie[ce]=this.getPackedSamplerAtOutputCoords(ce,se,Y,W):ie[ce]=this.getUnpackedSamplerAtOutputCoords(ce,se,Y,W))})),ie}getPackedSamplerAtOutputCoords(ie,Y,W,ne){const se=Y.unpackedShape,le=W.unpackedShape,ce=ne,he=(0,K.generateShaderFuncNameFromInputSamplerName)(ce),pe=se.length,me=le.length,be=O.BroadcastUtil.getBroadcastDims(se,le),ge=(0,K.getCoordsDataType)(me),ve=me-pe;let Se;const Me=(0,K.getGlChannels)();Se=pe===0?"":me<2&&be.length>=1?"coords = 0;":be.map((Oe=>`coords.${Me[Oe+ve]} = 0;`)).join(`
`);let Ee="";Ee=me<2&&pe>0?"coords":se.map(((Oe,Pe)=>`coords.${Me[Pe+ve]}`)).join(", ");let we="return outputValue;";const Re=O.ShapeUtil.size(se)===1,Le=O.ShapeUtil.size(le)===1;if(pe!==1||Re||Le){if(Re&&!Le)we=me===1?`
          return vec4(outputValue.x, outputValue.x, 0., 0.);
        `:`
          return vec4(outputValue.x);
        `;else if(be.length){const Oe=pe-2,Pe=pe-1;be.indexOf(Oe)>-1&&be.indexOf(Pe)>-1?we="return vec4(outputValue.x);":be.indexOf(Oe)>-1?we="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":be.indexOf(Pe)>-1&&(we="return vec4(outputValue.xx, outputValue.zz);")}}else we=`
        return vec4(outputValue.xy, outputValue.xy);
      `;const Ne=`
      vec4 ${ie}() {
        ${ge} coords = getOutputCoords();
        
        int lastDim = coords.${Me[me-1]};
        coords.${Me[me-1]} = coords.${Me[me-2]};
        coords.${Me[me-2]} = lastDim;
      
        ${Se}
        vec4 outputValue = ${he}(${Ee});
        ${we}
      }
    `;return new U.GlslLibRoutine(Ne,["coordinates.getOutputCoords"])}getUnpackedSamplerAtOutputCoords(ie,Y,W,ne){const se=[W.width,W.height],le=[Y.width,Y.height],ce=Y.unpackedShape.length,he=W.unpackedShape.length,pe=Y.unpackedShape,me=W.unpackedShape,be=(0,K.generateShaderFuncNameFromInputSamplerName)(ne);if(ce===he&&O.ArrayUtil.arraysEqual(le,se)){const Le=`
          float ${ie}() {
            return sampleTexture(${ne}, TexCoords);
          }
        `;return new U.GlslLibRoutine(Le,["coordinates.sampleTexture"])}const ge=(0,K.getCoordsDataType)(he),ve=O.BroadcastUtil.getBroadcastDims(pe,me),Se=he-ce;let Me;const Ee=(0,K.getGlChannels)();Me=ce===0?"":he<2&&ve.length>=1?"coords = 0;":ve.map((Le=>`coords.${Ee[Le+Se]} = 0;`)).join(`
`);let we="";we=he<2&&ce>0?"coords":Y.unpackedShape.map(((Le,Ne)=>`coords.${Ee[Ne+Se]}`)).join(", ");const Re=`
        float ${ie}() {
          ${ge} coords = getOutputCoords();
          ${Me}
          return ${be}(${we});
        }
      `;return new U.GlslLibRoutine(Re,["coordinates.getOutputCoords"])}getPackedSamplerFromInput(ie,Y,W){switch(W.unpackedShape.length){case 0:return this.getPackedSamplerScalar(ie,Y);case 1:return this.getPackedSampler1D(ie,Y,W);case 2:return this.getPackedSampler2D(ie,Y,W);case 3:return this.getPackedSampler3D(ie,Y,W);default:return this.getPackedSamplerND(ie,Y,W)}}getUnpackedSamplerFromInput(ie,Y,W){const ne=W.unpackedShape;switch(ne.length){case 0:return this.getUnpackedSamplerScalar(ie,Y,W);case 1:return this.getUnpackedSampler1D(ie,Y,W);case 2:return this.getUnpackedSampler2D(ie,Y,W);case 3:return this.getUnpackedSampler3D(ie,Y,W);case 4:return this.getUnpackedSampler4D(ie,Y,W);case 5:return this.getUnpackedSampler5D(ie,Y,W);case 6:return this.getUnpackedSampler6D(ie,Y,W);default:throw new Error(`Unsupported dimension ${ne.length}-D`)}}getPackedSamplerScalar(ie,Y){const W=`
          vec4 ${ie}() {
            return ${(0,G.getGlsl)(this.context.glContext.version).texture2D}(${Y}, halfCR);
          }
        `;return new U.GlslLibRoutine(W)}getPackedSampler1D(ie,Y,W){const ne=[W.width,W.height],se=[ne[1],ne[0]],le=(0,G.getGlsl)(this.context.glContext.version),ce=`vec4 ${ie}(int index) {
      vec2 uv = packedUVfrom1D(
      ${se[0]}, ${se[1]}, index);
      return ${le.texture2D}(${Y}, uv);
    }`;return new U.GlslLibRoutine(ce,["coordinates.packedUVfrom1D"])}getPackedSampler2D(ie,Y,W){const ne=W.unpackedShape,se=[W.width,W.height],le=(0,G.getGlsl)(this.context.glContext.version),ce=se[0],he=se[1];if(se!=null&&O.ArrayUtil.arraysEqual(ne,se)){const ge=`vec4 ${ie}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${he}.0, ${ce}.0);
        return ${le.texture2D}(${Y}, uv);
      }`;return new U.GlslLibRoutine(ge)}const pe=se,me=Math.ceil(ne[1]/2),be=`vec4 ${ie}(int row, int col) {
      vec2 uv = packedUVfrom2D(${pe[1]}, ${pe[0]}, ${me}, row, col);
      return ${le.texture2D}(${Y}, uv);
    }`;return new U.GlslLibRoutine(be,["coordinates.packedUVfrom2D"])}getPackedSampler3D(ie,Y,W){const ne=W.unpackedShape,se=[W.width,W.height],le=[se[0],se[1]],ce=(0,G.getGlsl)(this.context.glContext.version);if(ne[0]===1){const ge=ne.slice(1),ve=[1,2],Se=(0,K.squeezeInputShape)(ne,ge),Me=["b","row","col"],Ee=JSON.parse(JSON.stringify(W));Ee.unpackedShape=Se;const we=this.getPackedSamplerFromInput(ie,Y,Ee),Re=`${we.routineBody}
      vec4 ${ie}(int b, int row, int col) {
        return ${ie}(${(0,K.getSqueezedParams)(Me,ve)});
      } `;return new U.GlslLibRoutine(Re,we.dependencies)}const he=le[0],pe=le[1],me=Math.ceil(ne[2]/2),be=`vec4 ${ie}(int b, int row, int col) {
      vec2 uv = packedUVfrom3D(
        ${pe}, ${he}, ${me*Math.ceil(ne[1]/2)}, ${me}, b, row, col);
      return ${ce.texture2D}(${Y}, uv);}`;return new U.GlslLibRoutine(be,["coordinates.packedUVfrom3D"])}getPackedSamplerND(ie,Y,W){const ne=W.unpackedShape,se=ne.length,le=[W.width,W.height],ce=(0,G.getGlsl)(this.context.glContext.version),he=[le[0],le[1]],pe=he[1],me=he[0],be=Math.ceil(ne[se-1]/2);let ge=be*Math.ceil(ne[se-2]/2),ve="int b, int row, int col",Se=`b * ${ge} + (row / 2) * ${be} + (col / 2)`;for(let Ee=2;Ee<se-1;Ee++)ve=`int b${Ee}, `+ve,ge*=ne[se-Ee-1],Se=`b${Ee} * ${ge} + `+Se;const Me=`vec4 ${ie}(${ve}) {
      int index = ${Se};
      int texR = index / ${me};
      int texC = index - texR * ${me};
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${me}, ${pe});
      return ${ce.texture2D}(${Y}, uv);
    }`;return new U.GlslLibRoutine(Me)}getUnpackedSamplerScalar(ie,Y,W){const[ne,se]=[W.width,W.height];if(ne===1&&se===1){const ce=`
          float ${ie}() {
            return sampleTexture(${Y}, halfCR);
          }
        `;return new U.GlslLibRoutine(ce,["coordinates.sampleTexture"])}const le=`
        float ${ie}() {
          int offset_${Y} = coordsToOffset(TexCoords, ${ne}, ${se});
          vec2 uv = uvFromFlat(${ne}, ${se}, offset_${Y});
          return sampleTexture(${Y}, uv);
        }
      `;return new U.GlslLibRoutine(le,["coordinates.uvFromFlat","coordinates.sampleTexture","coordinates.coordsToOffset"])}getUnpackedSampler1D(ie,Y,W){const ne=W.width,se=W.height;if(se===1&&ne===1){const ce=`
        float ${ie}(int index) {
          return sampleTexture(${Y}, halfCR);
        }
      `;return new U.GlslLibRoutine(ce,["coordinates.sampleTexture"])}if(se===1){const ce=`
          float ${ie}(int index) {
            vec2 uv = vec2((float(index) + 0.5) / ${ne}.0, 0.5);
            return sampleTexture(${Y}, uv);
          }
        `;return new U.GlslLibRoutine(ce,["coordinates.sampleTexture"])}if(ne===1){const ce=`
          float ${ie}(int index) {
            vec2 uv = vec2(0.5, (float(index) + 0.5) / ${se}.0);
            return sampleTexture(${Y}, uv);
          }
        `;return new U.GlslLibRoutine(ce,["coordinates.sampleTexture"])}const le=`
        float ${ie}(int index) {
          vec2 uv = uvFromFlat(${ne}, ${se}, index);
          return sampleTexture(${Y}, uv);
        }
      `;return new U.GlslLibRoutine(le,["coordinates.uvFromFlat","coordinates.sampleTexture"])}getUnpackedSampler2D(ie,Y,W){const ne=W.unpackedShape,se=[W.height,W.width];if(se!=null&&O.ArrayUtil.arraysEqual(ne,se)){const ge=`
          float ${ie}(int row, int col) {
            vec2 uv = (vec2(row, col) + halfCR) / vec2(${se[1]}.0, ${se[0]}.0);
            return sampleTexture(${Y}, uv);
          }
        `;return new U.GlslLibRoutine(ge,["coordinates.sampleTexture"])}const{newShape:le,keptDims:ce}=(0,q.squeezeShape)(ne),he=le;if(he.length<ne.length){const ge=(0,K.squeezeInputShape)(ne,he),ve=JSON.parse(JSON.stringify(W));ve.unpackedShape=ge;const Se=["col","row"],Me=`
          ${this.getUnpackedSamplerFromInput(ie,Y,ve).routineBody}
          float ${ie}(int row, int col) {
            return ${ie}(${(0,K.getSqueezedParams)(Se,ce)});
          }
        `;return new U.GlslLibRoutine(Me,["coordinates.sampleTexture"])}const pe=se[1],me=se[0];if(me===1){const ge=`
          float ${ie}(int row, int col) {
            int offset_${Y} = coordsToOffset(TexCoords, ${pe}, ${me});
            float index = dot(vec3(row, col, offset_${Y}), vec3(${ne[1]}, 1, 1));
            vec2 uv = vec2(0.5, (index + 0.5) / ${pe}.0);
            return sampleTexture(${Y}, uv);
          }
        `;return new U.GlslLibRoutine(ge,["coordinates.sampleTexture","coordinates.coordsToOffset"])}if(pe===1){const ge=`
          float ${ie}(int row, int col) {
            int offset_${Y} = coordsToOffset(TexCoords, ${pe}, ${me});
            float index = dot(vec3(row, col, offset_${Y}), vec3(${ne[1]}, 1, 1));
            vec2 uv = vec2((index + 0.5) / ${me}.0, 0.5);
            return sampleTexture(${Y}, uv);
          }
        `;return new U.GlslLibRoutine(ge,["coordinates.sampleTexture","coordinates.coordsToOffset"])}const be=`
        float ${ie}(int row, int col) {
          int index = col * ${ne[1]} + row;
          vec2 uv = uvFromFlat(${pe}, ${me}, index);
          return sampleTexture(${Y}, uv);
        }
      `;return new U.GlslLibRoutine(be,["coordinates.uvFromFlat","coordinates.sampleTexture","coordinates.coordsToOffset"])}getUnpackedSampler3D(ie,Y,W){const ne=W.unpackedShape,se=ne[1]*ne[2],le=ne[2],{newShape:ce,keptDims:he}=(0,q.squeezeShape)(ne),pe=ce;if(pe.length<ne.length){const be=(0,K.squeezeInputShape)(ne,pe),ge=["batch","col","row"],ve=JSON.parse(JSON.stringify(W));ve.unpackedShape=be;const Se=this.getUnpackedSamplerFromInput(ie,Y,ve),Me=he.reverse(),Ee=`
          ${Se.routineBody}
          float ${ie}(int batch, int row, int col) {
            return ${ie}(${(0,K.getSqueezedParams)(ge,Me)});
          }
        `;return new U.GlslLibRoutine(Ee,Se.dependencies)}const me=`
          float ${ie}(int depth, int row, int col) {
            // Explicitly use integer operations as dot() only works on floats.
            int index = depth * ${se} + col * ${le} + row;
            vec2 uv = uvFromFlat(${W.width}, ${W.height}, index);
            return sampleTexture(${Y}, uv);
          }
      `;return new U.GlslLibRoutine(me,["coordinates.uvFromFlat","coordinates.sampleTexture","coordinates.coordsToOffset"])}getUnpackedSampler4D(ie,Y,W){const ne=W.unpackedShape,se=ne[3],le=ne[2]*se,ce=`
        float ${ie}(int row, int col, int depth, int depth2) {
          int index = row * ${ne[1]*le} + col * ${le} +
              depth2 * ${se} + depth;
          vec2 uv = uvFromFlat(${W.width}, ${W.height}, index);
          return sampleTexture(${Y}, uv);
        }
      `;return new U.GlslLibRoutine(ce,["coordinates.uvFromFlat","coordinates.sampleTexture"])}getUnpackedSampler5D(ie,Y,W){const ne=W.unpackedShape,se=ne[4],le=ne[3]*se,ce=ne[2]*le,he=ne[1]*ce,{newShape:pe,keptDims:me}=(0,q.squeezeShape)(ne);if(pe.length<ne.length){const ge=(0,K.squeezeInputShape)(ne,pe),ve=["row","col","depth","depth2","depth3"],Se=JSON.parse(JSON.stringify(W));Se.unpackedShape=ge;const Me=`
          ${this.getUnpackedSamplerFromInput(ie,Y,Se).routineBody}
          float ${ie}(int row, int col, int depth, int depth2, int depth3) {
            return ${ie}(${(0,K.getSqueezedParams)(ve,me)});
          }
        `;return new U.GlslLibRoutine(Me,["coordinates.sampleTexture","coordinates.uvFromFlat"])}const be=`
        float ${ie}(int row, int col, int depth, int depth2, int depth3) {
          int index = row * ${he} + col * ${ce} + depth * ${le} +
          depth3 * ${se} + depth2;
          vec2 uv = uvFromFlat(${W.width}, ${W.height}, index);
          return sampleTexture(${Y}, uv);
        }
      `;return new U.GlslLibRoutine(be,["coordinates.sampleTexture","coordinates.uvFromFlat"])}getUnpackedSampler6D(ie,Y,W){const ne=W.unpackedShape,se=ne[5],le=ne[4]*se,ce=ne[3]*le,he=ne[2]*ce,pe=ne[1]*he,{newShape:me,keptDims:be}=(0,q.squeezeShape)(ne);if(me.length<ne.length){const ve=(0,K.squeezeInputShape)(ne,me),Se=["row","col","depth","depth2","depth3","depth4"],Me=JSON.parse(JSON.stringify(W));Me.unpackedShape=ve;const Ee=`
            ${this.getUnpackedSamplerFromInput(ie,Y,Me).routineBody}
            float ${ie}(int row, int col, int depth,
              int depth2, int depth3, int depth4) {
              return ${ie}(${(0,K.getSqueezedParams)(Se,be)});
            }
          `;return new U.GlslLibRoutine(Ee,["coordinates.sampleTexture","coordinates.uvFromFlat"])}const ge=`
          float ${ie}(int row, int col, int depth,
            int depth2, int depth3, int depth4) {
            int index = row * ${pe} + col * ${he} + depth * ${ce} +
            depth2 * ${le} + depth3 * ${se} + depth4;
            vec2 uv = uvFromFlat(${W.width}, ${W.height}, index);
            return sampleTexture(${Y}, uv);
          }
        `;return new U.GlslLibRoutine(ge,["coordinates.uvFromFlat","coordinates.sampleTexture","coordinates.coordsToOffset"])}toVec(){const ie=this.context.outputTextureLayout,Y=ie.shape.length,W=ie.strides,ne=ie.width,se=ie.height,le=[];for(let he=0;he<Y-1;++he)le.push(`
        c[${he}] = offset / ${W[he]};`),le.push(`
        offset -= c[${he}] * ${W[he]};`);le.push(`
        c[${Y-1}] = offset;`);const ce=`
      void toVec(vec2 texCoords, out int c[${Y}]) {
        int offset = coordsToOffset(texCoords, ${ne}, ${se});
        ${le.join("")}
      }
      void toVec(int offset, out int c[${Y}]) {
        ${le.join("")}
      }
    `;return{toVec:new U.GlslLibRoutine(ce,["coordinates.coordsToOffset"])}}valueFrom(){const ie={};return this.context.programInfo.inputNames.forEach(((Y,W)=>{const ne=this.context.inputTextureLayouts[W],se=(ne.unpackedShape.length>0?ne.unpackedShape:ne.shape).length;let le=`_${Y}`;ie[le]=new U.GlslLibRoutine(this.getValueFromSingle(Y,se,ne.width,ne.height,!1),[`shapeUtils.indicesToOffset${le}`,"coordinates.offsetToCoords","fragcolor.getColorAsFloat"]),le+="_T",ie[le]=new U.GlslLibRoutine(this.getValueFromSingle(Y,se,ne.width,ne.height,!0),[`shapeUtils.indicesToOffset${le}`,"coordinates.offsetToCoords","fragcolor.getColorAsFloat"])})),ie}getValueFromSingle(ie,Y,W,ne,se){let le=`_${ie}`;return se&&(le+="_T"),`
        float ${le}(int m[${Y}]) {
          int offset = indicesToOffset${le}(m);
          vec2 coords = offsetToCoords(offset, ${W}, ${ne});
          float value = getColorAsFloat(${(0,G.getGlsl)(this.context.glContext.version).texture2D}(${ie}, coords));
          return value;
        }
        `}getPackedValueFrom(ie,Y,W,ne,se){let le=`_${ie}_Pack`;return se&&(le+="_T"),`
        vec4 ${le}(int m[${Y}]) {
          int offset = indicesToOffset_${ie}(m);
          vec2 coords = offsetToCoords(offset, ${W}, ${ne});
          return ${(0,G.getGlsl)(this.context.glContext.version).texture2D}(${ie}, coords);
        }
        `}}w.CoordsGlslLib=ee},8520:(F,w)=>{var D;Object.defineProperty(w,"__esModule",{value:!0}),w.TopologicalSortGlslRoutines=w.GlslLibRoutineNode=w.GlslLibRoutine=w.GlslLib=w.GlslContext=w.FunctionType=void 0,(D=w.FunctionType||(w.FunctionType={}))[D.ValueBased=0]="ValueBased",D[D.Positional=1]="Positional",w.GlslContext=class{constructor(O,U,G,q){this.glContext=O,this.programInfo=U,this.inputTextureLayouts=G,this.outputTextureLayout=q}},w.GlslLib=class{constructor(O){this.context=O}},w.GlslLibRoutine=class{constructor(O,U){this.routineBody=O,this.dependencies=U}},w.GlslLibRoutineNode=class{constructor(O,U,G){this.name=O,this.dependencies=G||[],U&&(this.routineBody=U)}addDependency(O){O&&this.dependencies.push(O)}},w.TopologicalSortGlslRoutines=class{static returnOrderedNodes(O){if(!O||O.length===0)return[];if(O.length===1)return O;const U=new Set,G=new Set,q=new Array;return this.createOrderedNodes(O,U,G,q),q}static createOrderedNodes(O,U,G,q){for(let K=0;K<O.length;++K)this.dfsTraverse(O[K],U,G,q)}static dfsTraverse(O,U,G,q){if(!O||G.has(O.name))return;if(U.has(O.name))throw new Error("Cyclic dependency detected. Can't topologically sort routines needed for shader.");U.add(O.name);const K=O.dependencies;if(K&&K.length>0)for(let ee=0;ee<K.length;++ee)this.dfsTraverse(K[ee],U,G,q);q.push(O),G.add(O.name),U.delete(O.name)}}},7341:(F,w,D)=>{Object.defineProperty(w,"__esModule",{value:!0}),w.EncodingGlslLib=void 0;const O=D(8520);class U extends O.GlslLib{constructor(q){super(q)}getFunctions(){return Object.assign(Object.assign({},this.encodeFloat32()),this.decodeFloat32())}getCustomTypes(){return{}}encodeFloat32(){return{encode:new O.GlslLibRoutine(`highp vec4 encode(highp float f) {
        return vec4(f, 0.0, 0.0, 0.0);
      }
        `)}}decodeFloat32(){return{decode:new O.GlslLibRoutine(`highp float decode(highp vec4 rgba) {
        return rgba.r;
      }
        `)}}encodeUint8(){const q=U.isLittleEndian()?"rgba.rgba=rgba.abgr;":"";return{encode:new O.GlslLibRoutine(`
      highp vec4 encode(highp float f) {
        highp float F = abs(f);
        highp float Sign = step(0.0,-f);
        highp float Exponent = floor(log2(F));
        highp float Mantissa = (exp2(- Exponent) * F);
        Exponent = floor(log2(F) + 127.0) + floor(log2(Mantissa));
        highp vec4 rgba;
        rgba[0] = 128.0 * Sign  + floor(Exponent*exp2(-1.0));
        rgba[1] = 128.0 * mod(Exponent,2.0) + mod(floor(Mantissa*128.0),128.0);
        rgba[2] = floor(mod(floor(Mantissa*exp2(23.0 -8.0)),exp2(8.0)));
        rgba[3] = floor(exp2(23.0)*mod(Mantissa,exp2(-15.0)));
        ${q}
        rgba = rgba / 255.0; // values need to be normalized to [0,1]
        return rgba;
    }
        `)}}decodeUint8(){const q=U.isLittleEndian()?"rgba.rgba=rgba.abgr;":"";return{decode:new O.GlslLibRoutine(`
        highp float decode(highp vec4 rgba) {
          rgba = rgba * 255.0; // values need to be de-normalized from [0,1] to [0,255]
          ${q}
          highp float Sign = 1.0 - step(128.0,rgba[0])*2.0;
          highp float Exponent = 2.0 * mod(rgba[0],128.0) + step(128.0,rgba[1]) - 127.0;
          highp float Mantissa = mod(rgba[1],128.0)*65536.0 + rgba[2]*256.0 +rgba[3] + float(0x800000);
          highp float Result =  Sign * exp2(Exponent) * (Mantissa * exp2(-23.0 ));
          return Result;
      }
        `)}}static isLittleEndian(){const q=new ArrayBuffer(4),K=new Uint32Array(q),ee=new Uint8Array(q);if(K[0]=3735928559,ee[0]===239)return!0;if(ee[0]===222)return!1;throw new Error("unknown endianness")}}w.EncodingGlslLib=U},9894:(F,w,D)=>{Object.defineProperty(w,"__esModule",{value:!0}),w.FragColorGlslLib=void 0;const O=D(8520),U=D(5060);class G extends O.GlslLib{constructor(K){super(K)}getFunctions(){return Object.assign(Object.assign({},this.setFragColor()),this.getColorAsFloat())}getCustomTypes(){return{}}setFragColor(){const K=(0,U.getGlsl)(this.context.glContext.version);return{setFragColor:new O.GlslLibRoutine(`
        void setFragColor(float value) {
            ${K.output} = encode(value);
        }
        `,["encoding.encode"])}}getColorAsFloat(){return{getColorAsFloat:new O.GlslLibRoutine(`
        float getColorAsFloat(vec4 color) {
            return decode(color);
        }
        `,["encoding.decode"])}}}w.FragColorGlslLib=G},2848:(F,w)=>{Object.defineProperty(w,"__esModule",{value:!0}),w.replaceInlines=void 0;const D=/@inline[\s\n\r]+(\w+)[\s\n\r]+([0-9a-zA-Z_]+)\s*\(([^)]*)\)\s*{(([^}]|[\n\r])*)}/gm;w.replaceInlines=function(O){const U={};let G;for(;(G=D.exec(O))!==null;){const q=G[3].split(",").map((K=>{const ee=K.trim().split(" ");return ee&&ee.length===2?{type:ee[0],name:ee[1]}:null})).filter((K=>K!==null));U[G[2]]={params:q,body:G[4]}}for(const q in U){const K="(\\w+)?\\s+([_0-9a-zA-Z]+)\\s+=\\s+__FUNC__\\((.*)\\)\\s*;".replace("__FUNC__",q),ee=new RegExp(K,"gm");for(;(G=ee.exec(O))!==null;){const Z=G[1],ie=G[2],Y=G[3].split(","),W=Z?`${Z} ${ie};`:"";let ne=U[q].body,se="";U[q].params.forEach(((ce,he)=>{ce&&(se+=`${ce.type} ${ce.name} = ${Y[he]};
`)})),ne=`${se}
 ${ne}`,ne=ne.replace("return",`${ie} = `);const le=`
      ${W}
      {
        ${ne}
      }
      `;O=O.replace(G[0],le)}}return O.replace(D,"")}},8879:(F,w,D)=>{Object.defineProperty(w,"__esModule",{value:!0}),w.GlslPreprocessor=void 0;const O=D(8520),U=D(2848),G=D(5483),q=D(5060);w.GlslPreprocessor=class{constructor(K,ee,Z,ie){this.libs={},this.glslLibRoutineDependencyGraph={},this.context=new O.GlslContext(K,ee,Z,ie),Object.keys(G.glslRegistry).forEach((W=>{const ne=new G.glslRegistry[W](this.context);this.libs[W]=ne}));const Y=this.glslLibRoutineDependencyGraph;for(const W in this.libs){const ne=this.libs[W].getFunctions();for(const se in ne){const le=W+"."+se;let ce;Y[le]?(ce=Y[le],ce.routineBody=ne[se].routineBody):(ce=new O.GlslLibRoutineNode(le,ne[se].routineBody),Y[le]=ce);const he=ne[se].dependencies;if(he)for(let pe=0;pe<he.length;++pe)if(Y[he[pe]])ce.addDependency(Y[he[pe]]);else{const me=new O.GlslLibRoutineNode(he[pe]);Y[he[pe]]=me,ce.addDependency(me)}}}}preprocess(){const K=this.context.programInfo;let ee=K.shaderSource;return this.context.programInfo.hasMain||(ee=`${ee}
      ${(0,q.getDefaultFragShaderMain)(this.context.glContext.version,this.context.outputTextureLayout.shape.length)}`),ee=(0,U.replaceInlines)(ee),`${(0,q.getFragShaderPreamble)(this.context.glContext.version)}
    ${this.getUniforms(K.inputNames,K.variables)}
    ${this.getImports(ee)}
    ${ee}`}getImports(K){const ee=this.selectGlslLibRoutinesToBeIncluded(K);if(ee.length===0)return"";let Z="";for(let ie=0;ie<ee.length;++ie){if(!ee[ie].routineBody)throw new Error(`Missing body for the Glsl Library routine: ${ee[ie].name}`);Z+=ee[ie].routineBody+`
`}return Z}selectGlslLibRoutinesToBeIncluded(K){const ee=[];return Object.keys(this.glslLibRoutineDependencyGraph).forEach((Z=>{const ie=Z.split(".")[1];K.indexOf(ie)!==-1&&ee.push(this.glslLibRoutineDependencyGraph[Z])})),O.TopologicalSortGlslRoutines.returnOrderedNodes(ee)}getUniforms(K,ee){const Z=[];if(K)for(const ie of K)Z.push(`uniform sampler2D ${ie};`);if(ee)for(const ie of ee)Z.push(`uniform ${ie.type} ${ie.name}${ie.arrayLength?`[${ie.arrayLength}]`:""};`);return Z.join(`
`)}}},5483:(F,w,D)=>{Object.defineProperty(w,"__esModule",{value:!0}),w.glslRegistry=void 0;const O=D(5107),U=D(7341),G=D(9894),q=D(2655),K=D(3891);w.glslRegistry={encoding:U.EncodingGlslLib,fragcolor:G.FragColorGlslLib,vec:K.VecGlslLib,shapeUtils:q.ShapeUtilsGlslLib,coordinates:O.CoordsGlslLib}},2655:(F,w,D)=>{Object.defineProperty(w,"__esModule",{value:!0}),w.ShapeUtilsGlslLib=void 0;const O=D(8520);class U extends O.GlslLib{constructor(q){super(q)}getFunctions(){return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({},this.bcastIndex()),this.bcastMatmulIndex()),this.offsetToIndices()),this.indicesToOffset()),this.incrementIndices())}getCustomTypes(){return{}}bcastIndex(){const q=this.context.outputTextureLayout.shape.length,K={};return this.context.programInfo.inputNames.forEach(((ee,Z)=>{const ie=this.context.inputTextureLayouts[Z].unpackedShape;if(ie.length<=q){const Y=ie.length,W=q-Y,ne=`bcastIndices_${ee}`;let se="";for(let ce=0;ce<Y;++ce)se+=`
          realIndices[${ce}] = int( mod(float(bcastedIndices[${W+ce}]), ${ie[ce]}.0) );
          `;const le=`
        void ${ne} (int bcastedIndices[${q}], out int realIndices[${Y}]) {
          ${se}
        }
        `;K[ne]=new O.GlslLibRoutine(le)}})),K}bcastMatmulIndex(){const q=this.context.outputTextureLayout.shape.length,K={};return this.context.programInfo.inputNames.forEach(((ee,Z)=>{const ie=this.context.inputTextureLayouts[Z].shape;if(!(ie.length<2||ie.length>q)){const Y=ie.length,W=q-Y,ne=`bcastMatmulIndices_${ee}`;let se="";for(let ce=0;ce<Y-2;++ce)se+=`
          realIndices[${ce}] = int( mod(float(bcastedIndices[${W+ce}]), ${ie[ce]}.0) );
          `;const le=`
        void ${ne}(int bcastedIndices[${q}], out int realIndices[${Y}]) {
          ${se}
          realIndices[${Y-1}] = bcastedIndices[${q-1}];
          realIndices[${Y-2}] = bcastedIndices[${q-2}];
        }
        `;K[ne]=new O.GlslLibRoutine(le)}})),K}indicesToOffset(){const q={};return this.context.programInfo.inputNames.forEach(((K,ee)=>{const Z=this.context.inputTextureLayouts[ee].shape,ie=this.context.inputTextureLayouts[ee].strides,Y=Z.length;let W=`indicesToOffset_${K}`;q[W]=new O.GlslLibRoutine(U.indexToOffsetSingle(W,Y,ie)),W=`indicesToOffset_${K}_T`,q[W]=new O.GlslLibRoutine(U.indexToOffsetSingle(W,Y,ie.slice().reverse()))})),q}static indexToOffsetSingle(q,K,ee){let Z="";for(let ie=K-1;ie>=0;--ie)Z+=`
        offset += indices[${ie}] * ${ee[ie]};
        `;return`
      int ${q}(int indices[${K}]) {
        int offset = 0;
        ${Z}
        return offset;
      }
      `}offsetToIndices(){const q={};return this.context.programInfo.inputNames.forEach(((K,ee)=>{const Z=this.context.inputTextureLayouts[ee].shape,ie=this.context.inputTextureLayouts[ee].strides,Y=Z.length;let W=`offsetToIndices_${K}`;q[W]=new O.GlslLibRoutine(U.offsetToIndicesSingle(W,Y,ie)),W=`offsetToIndices_${K}_T`,q[W]=new O.GlslLibRoutine(U.offsetToIndicesSingle(W,Y,ie.slice().reverse()))})),q}static offsetToIndicesSingle(q,K,ee){const Z=[];for(let ie=0;ie<K-1;++ie)Z.push(`
      indices[${ie}] = offset / ${ee[ie]};`),Z.push(`
        offset -= indices[${ie}] * ${ee[ie]};`);return Z.push(`
      indices[${K-1}] = offset;`),`
      void ${q}(int offset, out int indices[${K}]) {
        ${Z.join("")}
      }
      `}incrementIndices(){const q={};return this.context.programInfo.inputNames.forEach(((K,ee)=>{const Z=this.context.inputTextureLayouts[ee].shape,ie=Z.length,Y=`incrementIndices_${K}`;let W="";for(let se=0;se<ie;++se)W+=`
        shape[${se}] = ${Z[se]};`;const ne=`
        void ${Y}(int axis, out int indices[${ie}]) {
          int shape[${ie}];
          ${W};
          for(int i = ${ie} -1 ; i >= 0; --i) {
            if(i > axis) continue;
            indices[i] += 1;
            if(indices[i] < shape[i]) {
              break;
            }
            indices[i] = 0;
          }
        }
        `;q[Y]=new O.GlslLibRoutine(ne)})),q}}w.ShapeUtilsGlslLib=U},5060:(F,w)=>{Object.defineProperty(w,"__esModule",{value:!0}),w.getDefaultFragShaderMain=w.getFragShaderPreamble=w.getVertexShaderSource=w.getGlsl=void 0;const D={version:"",attribute:"attribute",varyingVertex:"varying",varyingFrag:"varying",texture2D:"texture2D",output:"gl_FragColor",outputDeclaration:""},O={version:"#version 300 es",attribute:"in",varyingVertex:"out",varyingFrag:"in",texture2D:"texture",output:"outputColor",outputDeclaration:"out vec4 outputColor;"};function U(G){return G===1?D:O}w.getGlsl=U,w.getVertexShaderSource=function(G){const q=U(G);return`${q.version}
      precision highp float;
      ${q.attribute} vec3 position;
      ${q.attribute} vec2 textureCoord;

      ${q.varyingVertex} vec2 TexCoords;

      void main()
      {
          gl_Position = vec4(position, 1.0);
          TexCoords = textureCoord;
      }`},w.getFragShaderPreamble=function(G){const q=U(G);return`${q.version}
    precision highp float;
    precision highp int;
    precision highp sampler2D;
    ${q.varyingFrag} vec2 TexCoords;
    ${q.outputDeclaration}
    const vec2 halfCR = vec2(0.5, 0.5);

    // Custom vector types to handle higher dimenalities.
    struct ivec5
    {
      int x;
      int y;
      int z;
      int w;
      int u;
    };

    struct ivec6
    {
      int x;
      int y;
      int z;
      int w;
      int u;
      int v;
    };

    int imod(int x, int y) {
      return x - y * (x / y);
    }

    `},w.getDefaultFragShaderMain=function(G,q){return`
  void main() {
    int indices[${q}];
    toVec(TexCoords, indices);
    vec4 result = vec4(process(indices));
    ${U(G).output} = result;
  }
  `}},3891:(F,w,D)=>{Object.defineProperty(w,"__esModule",{value:!0}),w.VecGlslLib=void 0;const O=D(8520);class U extends O.GlslLib{constructor(q){super(q)}getCustomTypes(){return{}}getFunctions(){return Object.assign(Object.assign(Object.assign(Object.assign({},this.binaryVecFunctions()),this.copyVec()),this.setVecItem()),this.getVecItem())}binaryVecFunctions(){const q=this.context.outputTextureLayout.shape.length,K={add:"+=",sub:"-=",mul:"*=",div:"/="},ee={};for(const Z in K){const ie=`${Z}Vec`;let Y="";for(let ne=0;ne<q;++ne)Y+=`
          dest[${ne}] ${K[Z]} src[${ne}];
          `;const W=`
        void ${ie}(int src[${q}], out int dest[${q}]) {
          ${Y}
        }
        `;ee[ie]=new O.GlslLibRoutine(W)}return ee}copyVec(){const q=this.context.outputTextureLayout.shape.length;let K="";for(let Z=0;Z<q;++Z)K+=`
        dest[${Z}] = src[${Z}];
        `;const ee=`
      void copyVec(int src[${q}], out int dest[${q}]) {
        ${K}
      }
      `;return{copyVec:new O.GlslLibRoutine(ee)}}setVecItem(){const q=this.context.outputTextureLayout.shape.length;let K=`
        if(index < 0)
            index =${q} + index;
        if (index == 0)
            m[0] = value;
        `;for(let Z=1;Z<q-1;++Z)K+=`
        else if (index == ${Z})
            m[${Z}] = value;
            `;K+=`
        else
            m[${q-1}] = value;
        `;const ee=`
      void setVecItem(out int m[${q}], int index, int value) {
        ${K}
      }
        `;return{setVecItem:new O.GlslLibRoutine(ee)}}getVecItem(){const q=this.context.outputTextureLayout.shape.length;let K=`
        if(index < 0)
            index = ${q} + index;
        if (index == 0)
            return m[0];
      `;for(let Z=1;Z<q-1;++Z)K+=`
        else if (index == ${Z})
            return m[${Z}];
      `;K+=`
        else
            return m[${q-1}];
        `;const ee=`
      int getVecItem(int m[${q}], int index) {
        ${K}
      }
    `;return{getVecItem:new O.GlslLibRoutine(ee)}}}w.VecGlslLib=U},8316:(F,w,D)=>{Object.defineProperty(w,"__esModule",{value:!0}),w.WebGLInferenceHandler=void 0;const O=D(6231),U=D(9162),G=D(2517),q=D(2403),K=D(7019),ee=D(8710),Z=D(5611),ie=D(4057),Y=D(2039);w.WebGLInferenceHandler=class{constructor(W){this.session=W,this.packedTextureDataCache=new Map,this.unpackedTextureDataCache=new Map}calculateTextureWidthAndHeight(W,ne){return(0,ie.calculateTextureWidthAndHeight)(this.session.layoutStrategy,W,ne)}executeProgram(W,ne){if(ne.length<W.inputNames.length)throw new Error(`Input size mustn't be less than ${W.inputNames.length}.`);if(W.inputNames.length!==W.inputTypes.length)throw new Error("input names size does not match input types");const se=[];for(let be=0;be<W.inputNames.length;++be)se[be]=this.getOrCreateTextureData(ne[be],W.inputTypes[be]);const le=((be,ge)=>{const ve=ge.map((Me=>`${Me.unpackedShape.join(",")};${Me.width}x${Me.height}`)).join("_");let Se=be.name;return be.cacheHint&&(Se+="["+be.cacheHint+"]"),Se+=":"+ve,Se})(W,se);let ce=this.session.programManager.getArtifact(le);const he=ce?ce.programInfo:typeof W.get=="function"?W.get():W,pe=(0,ie.createTextureLayoutFromTextureType)(this.session.layoutStrategy,he.output.dims,he.output.textureType),me=this.createTextureData(pe,he.output.type);return ce||(ce=this.session.programManager.build(he,se,me),this.session.programManager.setArtifact(le,ce)),this.runProgram(ce,se,me),me}run(W,ne){return this.executeProgram(W,ne).tensor}runProgram(W,ne,se){for(let le=0;le<ne.length;++le)if(!!ne[le].isPacked!=(W.programInfo.inputTypes[le]===Y.TextureType.packed))throw new Error(`input[${le}] property packed inconsistent`);if(!!se.isPacked!=(W.programInfo.output.textureType===Y.TextureType.packed))throw new Error("output property packed inconsistent");this.session.programManager.run(W,ne,se)}getOrCreateTextureData(W,ne){let se=this.getTextureData(W.dataId,ne===Y.TextureType.packed);if(!se&&(se=this.getTextureData(W.dataId,ne!==Y.TextureType.packed),se))return ne===Y.TextureType.packed?this.pack(se):this.unpack(se);if(!se){const le=(0,ie.createTextureLayoutFromTextureType)(this.session.layoutStrategy,W.dims,ne);if(ne===Y.TextureType.packedLastDimension){const pe=W.dims;if(pe.length===4){const me=[pe[0],Math.ceil(pe[1]*pe[2]*pe[3]/4)],be=(0,ie.createTextureLayoutFromTextureType)(this.session.layoutStrategy,me,ne);let ge=W.numberData;if(pe[1]*pe[2]*pe[3]%4!=0){const ve=pe[0],Se=pe[1]*pe[2]*pe[3],Me=Math.ceil(Se*1/4)*4;ge=new Float32Array(ve*Me);for(let Ee=0;Ee<ve;++Ee){const we=Ee*Se,Re=Ee*Me+Ee%1*Se;ge.set(W.numberData.subarray(we,we+Se),Re)}}return this.createTextureData(be,W.type,ge,W,1)}}if(ne===Y.TextureType.packed){const ce=(0,ie.createTextureLayoutFromShape)(this.session.layoutStrategy,W.dims,1,[],{reverseWH:!0}),he=this.createTextureData(ce,W.type,W.numberData,W,1);se=this.pack(he)}else se=this.createTextureData(le,W.type,W.numberData,W,1)}return se}createTextureDataFromLayoutBindTensor(W,ne,se,le){return this.createTextureData(W,ne,se,le,1)}createTextureData(W,ne,se,le,ce){O.Logger.verbose("InferenceHandler",`Creating TextureData: layout:[${JSON.stringify(W)}]`);const he=this.session.textureManager.createTextureFromLayout(ne,W,se,ce);return this.createTextureDataFromTexture(W,ne,he,le)}reshapeUnpacked(W,ne){const se=this.getOrCreateTextureData(W,Y.TextureType.unpacked),le={channels:se.channels,height:se.height,width:se.width,shape:ne.length!==0?ne:[1],strides:G.ShapeUtil.computeStrides(ne),unpackedShape:ne};return this.createTextureDataFromTexture(le,W.type,se.texture).tensor}reshapePacked(W,ne){const se=this.getOrCreateTextureData(W,Y.TextureType.packed);if((0,K.isReshapeCheap)(W.dims,ne)){const me={channels:se.channels,height:se.height,width:se.width,shape:ne.length!==0?ne:[1],strides:G.ShapeUtil.computeStrides(ne),unpackedShape:ne,isPacked:!0};return this.createTextureDataFromTexture(me,W.type,se.texture).tensor}const le=(0,K.processDims3D)(W.dims),ce=(0,K.processDims3D)(ne),he=this.reshapePacked(W,le),pe=this.run((0,K.createPackedReshape3DProgramInfoLoader)(this,he,ce),[he]);return this.reshapePacked(pe,ne)}cast(W,ne){const se=this.getOrCreateTextureData(W,Y.TextureType.unpacked);return this.createTextureDataFromTexture(se,ne,se.texture).tensor}createTextureDataFromTexture(W,ne,se,le,ce){const he=Object.assign(Object.assign({},W),{tensor:le||new U.Tensor(W.unpackedShape,ne,(pe=>this.readTexture(he)),(async pe=>this.readTextureAsync(he)),void 0,ce),texture:se});return this.setTextureData(he.tensor.dataId,he,W.isPacked),he}getTextureData(W,ne=!1){return this.session.isInitializer(W)?this.session.getTextureData(W,ne):ne?this.packedTextureDataCache.get(W):this.unpackedTextureDataCache.get(W)}setTextureData(W,ne,se=!1){this.session.isInitializer(W)?this.session.setTextureData(W,ne,se):(se?this.packedTextureDataCache:this.unpackedTextureDataCache).set(W,ne)}isTextureLayoutCached(W,ne=!1){return!!this.getTextureData(W.dataId,ne)}dispose(){this.session.textureManager.clearActiveTextures(),this.packedTextureDataCache.forEach((W=>this.session.textureManager.releaseTexture(W))),this.packedTextureDataCache=new Map,this.unpackedTextureDataCache.forEach((W=>this.session.textureManager.releaseTexture(W))),this.unpackedTextureDataCache=new Map}readTexture(W){return W.isPacked?this.readTexture(this.unpack(W)):this.session.backend.glContext.isFloat32DownloadSupported?this.session.textureManager.readTexture(W,W.tensor.type,W.channels):this.session.textureManager.readUint8TextureAsFloat((0,ee.encodeAsUint8)(this,W))}async readTextureAsync(W){return W.isPacked?this.readTextureAsync(this.unpack(W)):this.session.backend.glContext.isFloat32DownloadSupported?this.session.textureManager.readTextureAsync(W,W.tensor.type,W.channels):this.session.textureManager.readUint8TextureAsFloat((0,ee.encodeAsUint8)(this,W))}pack(W){return this.executeProgram((0,q.createPackProgramInfoLoader)(this,W.tensor),[W.tensor])}unpack(W){return this.executeProgram((0,Z.createUnpackProgramInfoLoader)(this,W.tensor),[W.tensor])}}},1640:function(F,w,D){var O=this&&this.__createBinding||(Object.create?function(Xe,lt,ke,rt){rt===void 0&&(rt=ke);var St=Object.getOwnPropertyDescriptor(lt,ke);St&&!("get"in St?!lt.__esModule:St.writable||St.configurable)||(St={enumerable:!0,get:function(){return lt[ke]}}),Object.defineProperty(Xe,rt,St)}:function(Xe,lt,ke,rt){rt===void 0&&(rt=ke),Xe[rt]=lt[ke]}),U=this&&this.__setModuleDefault||(Object.create?function(Xe,lt){Object.defineProperty(Xe,"default",{enumerable:!0,value:lt})}:function(Xe,lt){Xe.default=lt}),G=this&&this.__importStar||function(Xe){if(Xe&&Xe.__esModule)return Xe;var lt={};if(Xe!=null)for(var ke in Xe)ke!=="default"&&Object.prototype.hasOwnProperty.call(Xe,ke)&&O(lt,Xe,ke);return U(lt,Xe),lt};Object.defineProperty(w,"__esModule",{value:!0}),w.WEBGL_OP_RESOLVE_RULES=void 0;const q=D(2898),K=G(D(7839)),ee=D(4196),Z=D(2069),ie=D(8138),Y=D(9663),W=D(5193),ne=D(7992),se=D(1253),le=D(4776),ce=D(6572),he=D(3346),pe=D(5623),me=D(2870),be=D(2143),ge=D(4939),ve=D(718),Se=D(2268),Me=D(8117),Ee=D(2278),we=D(5524),Re=D(5975),Le=D(3933),Ne=D(6558),Oe=D(5723),Pe=D(3738),Ce=G(D(4909)),Be=D(8428),ze=D(9793);w.WEBGL_OP_RESOLVE_RULES=[["Abs","","6+",Ce.abs],["Acos","","7+",Ce.acos],["Add","","7+",K.add],["And","","7+",K.and],["Asin","","7+",Ce.asin],["Atan","","7+",Ce.atan],["AveragePool","","7+",be.averagePool,be.parseAveragePoolAttributes],["BatchNormalization","","7+",q.batchNormalization,q.parseBatchNormalizationAttributes],["Cast","","6+",ee.cast,ee.parseCastAttributes],["Ceil","","6+",Ce.ceil],["Clip","","6-10",Ce.clip,Ce.parseClipAttributes],["Clip","","11+",Ce.clipV11],["Concat","","4+",Z.concat,Z.parseConcatAttributes],["Conv","","1+",ie.conv,ie.parseConvAttributes],["ConvTranspose","","1+",Y.convTranspose,Y.parseConvTransposeAttributes],["Cos","","7+",Ce.cos],["Div","","7+",K.div],["Dropout","","7+",Ce.identity],["DepthToSpace","","1+",W.depthToSpace,W.parseDepthToSpaceAttributes],["Equal","","7+",K.equal],["Elu","","6+",Ce.elu,Ce.parseEluAttributes],["Exp","","6+",Ce.exp],["Flatten","","1+",ne.flatten,ne.parseFlattenAttributes],["Floor","","6+",Ce.floor],["FusedConv","com.microsoft","1+",ie.conv,ie.parseConvAttributes],["Gather","","1+",se.gather,se.parseGatherAttributes],["Gemm","","7-10",le.gemm,le.parseGemmAttributesV7],["Gemm","","11+",le.gemm,le.parseGemmAttributesV11],["GlobalAveragePool","","1+",be.globalAveragePool,be.parseGlobalAveragePoolAttributes],["GlobalMaxPool","","1+",be.globalMaxPool],["Greater","","7+",K.greater],["Identity","","1+",Ce.identity],["ImageScaler","","1+",ce.imageScaler,ce.parseImageScalerAttributes],["InstanceNormalization","","6+",he.instanceNormalization,he.parseInstanceNormalizationAttributes],["LeakyRelu","","6+",Ce.leakyRelu,Ce.parseLeakyReluAttributes],["Less","","7+",K.less],["Log","","6+",Ce.log],["MatMul","","1+",pe.matMul,pe.parseMatMulAttributes],["MaxPool","","1+",be.maxPool,be.parseMaxPoolAttributes],["Mul","","7+",K.mul],["Neg","","6+",Ce.neg],["Not","","1+",Ce.not],["Or","","7+",K.or],["Pad","","2-10",me.padV2,me.parsePadAttributesV2],["Pad","","11+",me.padV11,me.parsePadAttributesV11],["Pow","","7+",K.pow],["PRelu","","7+",K.pRelu],["ReduceLogSum","","1+",ge.reduceLogSum,ge.parseReduceAttributes],["ReduceMax","","1+",ge.reduceMax,ge.parseReduceAttributes],["ReduceMean","","1+",ge.reduceMean,ge.parseReduceAttributes],["ReduceMin","","1+",ge.reduceMin,ge.parseReduceAttributes],["ReduceProd","","1+",ge.reduceProd,ge.parseReduceAttributes],["ReduceSum","","1-12",ge.reduceSum,ge.parseReduceAttributes],["ReduceSumSquare","","1+",ge.reduceLogSumSquare,ge.parseReduceAttributes],["Relu","","6+",Ce.relu],["Reshape","","5+",ve.reshape],["Resize","","10",Se.resize,Se.parseResizeAttributesV10],["Resize","","11+",Se.resize,Se.parseResizeAttributesV11],["Shape","","1+",Me.shape],["Sigmoid","","6+",Ce.sigmoid],["Sin","","7+",Ce.sin],["Slice","","10+",Ee.sliceV10],["Slice","","1-9",Ee.slice,Ee.parseSliceAttributes],["Softmax","","1-12",we.softmax,we.parseSoftmaxAttributes],["Softmax","","13+",we.softmaxV13,we.parseSoftmaxAttributesV13],["Split","","2-12",Re.split,Re.parseSplitAttributes],["Sqrt","","6+",Ce.sqrt],["Squeeze","","1-12",Le.squeeze,Le.parseSqueezeAttributes],["Squeeze","","13+",Le.squeezeV13],["Sub","","7+",K.sub],["Sum","","6+",Ne.sum],["Tan","","7+",Ce.tan],["Tanh","","6+",Ce.tanh],["Tile","","6+",Oe.tile],["Transpose","","1+",Pe.transpose,Pe.parseTransposeAttributes],["Upsample","","7-8",ze.upsample,ze.parseUpsampleAttributesV7],["Upsample","","9",ze.upsample,ze.parseUpsampleAttributesV9],["Unsqueeze","","1-12",Be.unsqueeze,Be.parseUnsqueezeAttributes],["Unsqueeze","","13+",Be.unsqueezeV13],["Xor","","7+",K.xor]]},2898:(F,w,D)=>{Object.defineProperty(w,"__esModule",{value:!0}),w.parseBatchNormalizationAttributes=w.batchNormalization=void 0;const O=D(246),U=D(5060),G=D(2039),q={name:"BatchNormalization",inputNames:["A","Scale","B","Mean","Variance"],inputTypes:[G.TextureType.unpacked,G.TextureType.unpacked,G.TextureType.unpacked,G.TextureType.unpacked,G.TextureType.unpacked]};w.batchNormalization=(Z,ie,Y)=>(ee(ie),[Z.run(Object.assign(Object.assign({},q),{cacheHint:Y.cacheKey,get:()=>K(Z,ie,Y)}),ie)]),w.parseBatchNormalizationAttributes=Z=>{const ie=Z.attributes.getFloat("epsilon",1e-5),Y=Z.attributes.getFloat("momentum",.9),W=Z.attributes.getInt("spatial",1);return(0,O.createAttributeWithCacheKey)({epsilon:ie,momentum:Y,spatial:W})};const K=(Z,ie,Y)=>{const W=(0,U.getGlsl)(Z.session.backend.glContext.version),ne=ie[0].dims.length,[se,le]=Z.calculateTextureWidthAndHeight(ie[1].dims,G.TextureType.unpacked),ce=`
  float process(int[${ne}] indices) {
    vec2 position = offsetToCoords(indices[1], ${se}, ${le});
    float scale = getColorAsFloat(${W.texture2D}(Scale, position));
    float mean = getColorAsFloat(${W.texture2D}(Mean, position));
    float variance = getColorAsFloat(${W.texture2D}(Variance, position));
    float b = getColorAsFloat(${W.texture2D}(B, position));

    return scale * ( (_A(indices) - mean) / sqrt(variance + float(${Y.epsilon})) ) + b;
  }`;return Object.assign(Object.assign({},q),{output:{dims:ie[0].dims,type:ie[0].type,textureType:G.TextureType.unpacked},shaderSource:ce})},ee=Z=>{if(!Z||Z.length!==5)throw new Error("BatchNormalization requires 5 inputs.");const ie=Z[0],Y=Z[1],W=Z[2],ne=Z[3],se=Z[4];if(ie.dims.length<3||Y.dims.length!==1||W.dims.length!==1||ne.dims.length!==1||se.dims.length!==1)throw new Error("invalid input shape.");if(Y.dims[0]!==ie.dims[1]||W.dims[0]!==ie.dims[1]||ne.dims[0]!==ie.dims[1]||se.dims[0]!==ie.dims[1])throw new Error("invalid input shape.");if(ie.type!=="float32"&&ie.type!=="float64"||Y.type!=="float32"&&Y.type!=="float64"||W.type!=="float32"&&W.type!=="float64"||ne.type!=="float32"&&ne.type!=="float64"||se.type!=="float32"&&se.type!=="float64")throw new Error("invalid input tensor types.")}},7839:(F,w,D)=>{Object.defineProperty(w,"__esModule",{value:!0}),w.xor=w.sub=w.pRelu=w.pow=w.or=w.mul=w.less=w.greater=w.equal=w.div=w.and=w.add=w.glslPRelu=w.glslPow=w.glslXor=w.glslOr=w.glslAnd=w.glslLess=w.glslGreater=w.glslEqual=w.glslSub=w.glslMul=w.glslDiv=w.glslAdd=void 0;const O=D(2517),U=D(8520),G=D(5060),q=D(2039);function K(){const ge="add_";return{body:`
  float ${ge}(float a, float b) {
    return a + b;
  }
  vec4 ${ge}(vec4 v1, vec4 v2) {
    return v1 + v2;
  }
  `,name:ge,type:U.FunctionType.ValueBased}}function ee(){const ge="div_";return{body:`
  float ${ge}(float a, float b) {
    return a / b;
  }
  vec4 ${ge}(vec4 v1, vec4 v2) {
    return v1 / v2;
  }
  `,name:ge,type:U.FunctionType.ValueBased}}function Z(){const ge="mul_";return{body:`
  float ${ge}(float a, float b) {
    return a * b;
  }
  vec4 ${ge}(vec4 v1, vec4 v2) {
    return v1 * v2;
  }
  `,name:ge,type:U.FunctionType.ValueBased}}function ie(){const ge="sub_";return{body:`
  float ${ge}(float a, float b) {
    return a - b;
  }
  vec4 ${ge}(vec4 v1, vec4 v2) {
    return v1 - v2;
  }
  `,name:ge,type:U.FunctionType.ValueBased}}function Y(){const ge="equal_";return{body:`
  float ${ge}(float a, float b) {
    return float(a == b);
  }
  vec4 ${ge}(vec4 v1, vec4 v2) {
    return vec4(equal(v1, v2));
  }
  `,name:ge,type:U.FunctionType.ValueBased}}function W(){const ge="greater_";return{body:`
  float ${ge}(float a, float b) {
    return float(a > b);
  }
  vec4 ${ge}(vec4 v1, vec4 v2) {
    return vec4( v1.r > v2.r ,
      v1.g > v2.g,
      v1.b > v2.b,
      v1.a > v2.a );
  }
  `,name:ge,type:U.FunctionType.ValueBased}}function ne(){const ge="less_";return{body:`
  float ${ge}(float a, float b) {
    return float(a < b);
  }
  vec4 ${ge}(vec4 v1, vec4 v2) {
    return vec4( v1.r < v2.r ,
                v1.g < v2.g,
                v1.b < v2.b,
                v1.a < v2.a );
  }
  `,name:ge,type:U.FunctionType.ValueBased}}function se(){const ge="and_";return{body:`
  float ${ge}(float a, float b) {
    return float( bool(a) && bool(b) );
  }
  vec4 ${ge}(vec4 v1, vec4 v2) {
    bvec4 b1 = bvec4(v1);
    bvec4 b2 = bvec4(v2);
    return vec4( b1.r && b2.r ,
                b1.g && b2.g,
                b1.b && b2.b,
                b1.a && b2.a );
  }
  `,name:ge,type:U.FunctionType.ValueBased}}function le(){return{body:`
  float or_(float a, float b) {
    return float( bool(a) || bool(b) );
  }
  vec4 or_(vec4 v1, vec4 v2) {
    bvec4 b1 = bvec4(v1);
    bvec4 b2 = bvec4(v2);
    return vec4( b1.r || b2.r ,
                b1.g || b2.g,
                b1.b || b2.b,
                b1.a || b2.a );
  }
  `,name:"or_",type:U.FunctionType.ValueBased}}function ce(){const ge="xor_";return{body:`
  float ${ge}(float a, float b) {
    return float( bool(a) ^^ bool(b) );
  }
  vec4 ${ge}(vec4 v1, vec4 v2) {
    bvec4 b1 = bvec4(v1);
    bvec4 b2 = bvec4(v2);
    return vec4( b1.r ^^ b2.r ,
                b1.g ^^ b2.g,
                b1.b ^^ b2.b,
                b1.a ^^ b2.a );
  }
  `,name:ge,type:U.FunctionType.ValueBased}}function he(){return(function(ge){const ve=`${ge}_`;return{body:`
  float ${ve}(float a, float b) {
    return ${ge}(a, b);
  }
  vec4 ${ve}(vec4 v1, vec4 v2) {
    return ${ge}(v1, v2);
  }
  `,name:ve,type:U.FunctionType.ValueBased}})("pow")}function pe(){const ge="prelu_";return{body:`
  float ${ge}(float a, float b) {
    return a < 0.0 ? a * b: a;
  }
  vec4 ${ge}(vec4 v1, vec4 v2) {
    return vec4(
      v1.r < 0.0 ? v1.r * v2.r: v1.r,
      v1.g < 0.0 ? v1.g * v2.g: v1.g,
      v1.b < 0.0 ? v1.b * v2.b: v1.b,
      v1.a < 0.0 ? v1.a * v2.a: v1.a
      );
  }
  `,name:ge,type:U.FunctionType.ValueBased}}w.glslAdd=K,w.glslDiv=ee,w.glslMul=Z,w.glslSub=ie,w.glslEqual=Y,w.glslGreater=W,w.glslLess=ne,w.glslAnd=se,w.glslOr=le,w.glslXor=ce,w.glslPow=he,w.glslPRelu=pe;const me=(ge,ve,Se,Me=ve[0].type,Ee)=>{const we=ge.session.pack?q.TextureType.packed:q.TextureType.unpacked;return{name:Se.name,inputNames:["A","B"],inputTypes:[we,we],cacheHint:Ee,get:()=>be(ge,ve,Se,Me)}},be=(ge,ve,Se,Me=ve[0].type)=>{const Ee=ge.session.pack?q.TextureType.packed:q.TextureType.unpacked,we=!O.ShapeUtil.areEqual(ve[0].dims,ve[1].dims);let Re=ve[0].dims;const Le=ge.session.pack;if(we){const Pe=O.BroadcastUtil.calcShape(ve[0].dims,ve[1].dims,!1);if(!Pe)throw new Error("Can't perform binary op on the given tensors");Re=Pe;const Ce=Re.length,Be=ve[0].dims.length!==0?ve[0].dims.length:1,ze=ve[1].dims.length!==0?ve[1].dims.length:1,Xe=ve[0].dims.length!==0?"bcastIndices_A(indices, aindices);":"aindices[0] = 0;",lt=ve[1].dims.length!==0?"bcastIndices_B(indices, bindices);":"bindices[0] = 0;",ke=(0,G.getGlsl)(ge.session.backend.glContext.version),rt=Le?`
      ${Se.body}
      void main() {
        vec4 a = getAAtOutCoords();
        vec4 b = getBAtOutCoords();
        vec4 result = ${Se.name}(a, b);
        ${ke.output} = result;
      }`:`
      ${Se.body}
      float process(int indices[${Ce}]) {
        int aindices[${Be}];
        int bindices[${ze}];
        ${Xe}
        ${lt}
        return ${Se.name}(_A(aindices), _B(bindices));
      }`;return{name:Se.name,inputNames:["A","B"],inputTypes:[Ee,Ee],output:{dims:Re,type:Me,textureType:Ee},shaderSource:rt,hasMain:Le}}const Ne=(0,G.getGlsl)(ge.session.backend.glContext.version),Oe=`
    ${Se.body}
    void main() {
      vec4 v1 = ${Ne.texture2D}(A, TexCoords);
      vec4 v2 = ${Ne.texture2D}(B, TexCoords);
      vec4 result = ${Se.name}(v1, v2);
      ${Ne.output} = result;
    }
    `;return{name:Se.name,inputNames:["A","B"],inputTypes:[Ee,Ee],output:{dims:ve[0].dims,type:Me,textureType:Ee},shaderSource:Oe,hasMain:!0}};w.add=(ge,ve)=>[ge.run(me(ge,ve,K()),ve)],w.and=(ge,ve)=>[ge.run(me(ge,ve,se(),"bool"),ve)],w.div=(ge,ve)=>[ge.run(me(ge,ve,ee()),ve)],w.equal=(ge,ve)=>[ge.run(me(ge,ve,Y(),"bool"),ve)],w.greater=(ge,ve)=>[ge.run(me(ge,ve,W(),"bool"),ve)],w.less=(ge,ve)=>[ge.run(me(ge,ve,ne(),"bool"),ve)],w.mul=(ge,ve)=>[ge.run(me(ge,ve,Z()),ve)],w.or=(ge,ve)=>[ge.run(me(ge,ve,le(),"bool"),ve)],w.pow=(ge,ve)=>[ge.run(me(ge,ve,he()),ve)],w.pRelu=(ge,ve)=>[ge.run(me(ge,ve,pe()),ve)],w.sub=(ge,ve)=>[ge.run(me(ge,ve,ie()),ve)],w.xor=(ge,ve)=>[ge.run(me(ge,ve,ce(),"bool"),ve)]},4196:(F,w,D)=>{Object.defineProperty(w,"__esModule",{value:!0}),w.parseCastAttributes=w.cast=void 0;const O=D(2517);w.cast=(G,q,K)=>(U(q),[G.cast(q[0],K)]),w.parseCastAttributes=G=>O.ProtoUtil.tensorDataTypeFromProto(G.attributes.getInt("to"));const U=G=>{if(!G||G.length!==1)throw new Error("Cast requires 1 input.");if(G[0].type==="string")throw new Error("Invalid input type.")}},1163:(F,w,D)=>{Object.defineProperty(w,"__esModule",{value:!0}),w.createPackedConcatProgramInfoLoader=void 0;const O=D(5060),U=D(2039),G=D(9390),q=D(2827);w.createPackedConcatProgramInfoLoader=(ee,Z,ie)=>{const Y=(W=Z.length,ne=ie.cacheKey,{name:"Concat (packed)",inputNames:Array.from({length:W},((se,le)=>`X${le}`)),inputTypes:Array(W).fill(U.TextureType.packed),cacheHint:ne});var W,ne;return Object.assign(Object.assign({},Y),{get:()=>((se,le,ce,he)=>{const pe=ce[0].dims.slice();if(he>=pe.length||he<-1*pe.length)throw new Error("axis specified for concat doesn't match input dimensionality");he<0&&(he=pe.length+he);const me=pe.slice(0);for(let Xe=1;Xe<ce.length;Xe++){const lt=ce[Xe].dims.slice();for(let ke=0;ke<pe.length;ke++)if(ke===he)me[he]+=lt[ke];else if(pe[ke]!==lt[ke])throw new Error("non concat dimensions must match")}const be=me.length,ge=(0,q.getChannels)("coords",be),ve=(0,G.getCoordsDataType)(be),Se=(0,q.unpackFromChannel)(),Me=ce.map((Xe=>Xe.dims)),Ee=(0,G.getGlChannels)(be),we=new Array(Me.length-1);we[0]=Me[0][he];for(let Xe=1;Xe<we.length;Xe++)we[Xe]=we[Xe-1]+Me[Xe][he];const Re=Ee[he],Le=Ee.slice(-2),Ne=Ee.join();let Oe=`if (${Re} < ${we[0]}) {
        return getChannel(
            getX0(${Ne}), vec2(${Le.join()}));
        }`;for(let Xe=1;Xe<we.length;Xe++){const lt=we[Xe-1];Oe+=`
            if (${Re} < ${we[Xe]}  && ${Re} >= ${we[Xe-1]}) {
              return getChannel(
                getX${Xe}(${K(Ee,Re,lt)}),
                vec2(${K(Le,Re,lt)}));
            }`}const Pe=we.length,Ce=we[we.length-1];Oe+=`
            return getChannel(
              getX${Pe}(${K(Ee,Re,Ce)}),
              vec2(${K(Le,Re,Ce)}));`;const Be=(0,O.getGlsl)(se.session.backend.glContext.version),ze=`
          ${Se}
          float getValue(${Ee.map((Xe=>"int "+Xe))}) {
            ${Oe}
          }

          void main() {
            ${ve} coords = getOutputCoords();
            int lastDim = coords.${Ee[be-1]};
            coords.${Ee[be-1]} = coords.${Ee[be-2]};
            coords.${Ee[be-2]} = lastDim;

            vec4 result = vec4(getValue(${ge}), 0., 0., 0.);

            ${ge[be-1]} = ${ge[be-1]} + 1;
            if (${ge[be-1]} < ${me[be-1]}) {
              result.g = getValue(${ge});
            }

            ${ge[be-2]} = ${ge[be-2]} + 1;
            if (${ge[be-2]} < ${me[be-2]}) {
              result.a = getValue(${ge});
            }

            ${ge[be-1]} = ${ge[be-1]} - 1;
            if (${ge[be-2]} < ${me[be-2]} &&
                ${ge[be-1]} < ${me[be-1]}) {
              result.b = getValue(${ge});
            }
            ${Be.output} = result;
          }
        `;return Object.assign(Object.assign({},le),{output:{dims:me,type:ce[0].type,textureType:U.TextureType.packed},shaderSource:ze,hasMain:!0})})(ee,Y,Z,ie.axis)})};const K=(ee,Z,ie)=>{const Y=ee.indexOf(Z);return ee.map(((W,ne)=>ne===Y?`${W} - ${ie}`:W)).join()}},2069:(F,w,D)=>{Object.defineProperty(w,"__esModule",{value:!0}),w.parseConcatAttributes=w.concat=void 0;const O=D(246),U=D(2039),G=D(1163);w.concat=(W,ne,se)=>(Y(ne),W.session.pack&&ne[0].dims.length>1?[W.run((0,G.createPackedConcatProgramInfoLoader)(W,ne,se),ne)]:[W.run(q(W,ne,se),ne)]);const q=(W,ne,se)=>{const le=(ce=ne.length,he=se.cacheKey,{name:"Concat",inputNames:Array.from({length:ce},((pe,me)=>`X${me}`)),inputTypes:Array(ce).fill(U.TextureType.unpacked),cacheHint:he});var ce,he;return Object.assign(Object.assign({},le),{get:()=>((pe,me,be,ge)=>{const ve=be[0].dims.slice();if(ge>=ve.length||ge<-1*ve.length)throw new Error("axis specified for concat doesn't match input dimensionality");ge<0&&(ge=ve.length+ge);const Se=ve.slice(0);for(let Ne=1;Ne<be.length;Ne++){const Oe=be[Ne].dims.slice();for(let Pe=0;Pe<ve.length;Pe++)if(Pe===ge)Se[ge]+=Oe[Pe];else if(ve[Pe]!==Oe[Pe])throw new Error("non concat dimensions must match")}const Me=Se.length,Ee=new Array(be.length);let we=0;for(let Ne=0;Ne<Ee.length;++Ne)we+=be[Ne].dims[ge],Ee[Ne]=we;let Re="";Re=be.length<5?K(Ee):ee(Ee);const Le=`
        ${Z(be.length,Me)}
        ${ie(Ee)}
        ${Re}
        float process(int indices[${Me}]) {
          int textureIndex = getTextureWhereDataResides (indices[${ge}]);

          if(textureIndex != 0) {
            indices[${ge}] = indices[${ge}] - int(getSizeInConcatAxisValueFromIndex(textureIndex-int(1)));
          }

          return fetchDataFromCorrectTexture(textureIndex, indices);
        }`;return Object.assign(Object.assign({},me),{output:{dims:Se,type:be[0].type,textureType:U.TextureType.unpacked},shaderSource:Le})})(0,le,ne,se.axis)})},K=W=>`int getTextureWhereDataResides(int index) {
      ${W.map(((ne,se)=>`if(index<${ne}) {return ${se};}
`)).join("")}
    }`,ee=W=>K(W),Z=(W,ne)=>{const se=[`float fetchDataFromCorrectTexture(int textureIndex, int indices[${ne}]) {`];for(let le=0;le<W;++le)le===0?se.push(`	if (textureIndex == ${le}) { return _X${le}(indices); }`):le===W-1?se.push(`	else { return _X${le}(indices); }`):se.push(`	else if (textureIndex == ${le}) { return _X${le}(indices); }`);return se.push("	}"),se.join(`
`)},ie=W=>{const ne=["int getSizeInConcatAxisValueFromIndex(int index) {"];for(let se=0;se<W.length;++se)se===0?ne.push(`	if (index == ${se}) { return ${W[se]}; }`):se===W.length-1?ne.push(`	else { return ${W[se]}; }`):ne.push(`	else if (index == ${se}) { return ${W[se]}; }`);return ne.push("	}"),ne.join(`
`)};w.parseConcatAttributes=W=>(0,O.createAttributeWithCacheKey)({axis:W.attributes.getInt("axis")});const Y=W=>{if(!W||W.length<1)throw new Error("too few inputs");const ne=W[0].type,se=W[0].dims.length;if(ne==="string")throw new Error("string tensor is not supported yet");for(const le of W){if(le.type!==ne)throw new Error("input tensors should be one type");if(le.dims.length!==se)throw new Error("input tensors should have the same shape")}}},4770:(F,w,D)=>{Object.defineProperty(w,"__esModule",{value:!0}),w.createUnpackedGroupedConvProgramInfoLoader=void 0;const O=D(6231),U=D(5060),G=D(2039),q=D(8138),K=D(2823);w.createUnpackedGroupedConvProgramInfoLoader=(ee,Z,ie)=>{const Y=(W=Z.length>2,ne=ie.cacheKey,{name:"GroupedConv",inputNames:W?["X","W","Bias"]:["X","W"],inputTypes:W?[G.TextureType.unpacked,G.TextureType.unpacked,G.TextureType.unpacked]:[G.TextureType.unpacked,G.TextureType.unpacked],cacheHint:ne});var W,ne;return Object.assign(Object.assign({},Y),{get:()=>((se,le,ce,he)=>{const pe=le.length>2?"value += getBias(output_channel);":"",me=le[0].dims.slice(),be=le[1].dims.slice(),ge=be[0]/he.group;O.Logger.verbose("GroupedConv",`autpPad:${he.autoPad}, dilations:${he.dilations}, group:${he.group}, kernelShape:${he.kernelShape}, pads:${he.pads}, strides:${he.strides}`);const ve=(0,q.calculateOutputShape)(me,be,he.dilations,he.pads,he.strides),Se=(0,U.getGlsl)(se.session.backend.glContext.version),{activationFunction:Me,applyActivation:Ee}=(0,K.getActivationSnippet)(he),we=`
  const ivec2 strides = ivec2(${he.strides[0]}, ${he.strides[1]});
  const ivec2 pads = ivec2(${he.pads[0]}, ${he.pads[1]});
  ${Me}
  void main() {
    ivec4 coords = getOutputCoords();
    int batch = coords.x;
    int output_channel = coords.y;
    ivec2 xRCCorner = coords.zw * strides - pads;
    int group_id = output_channel / ${ge};

    float value = 0.0;
    for (int wInChannel = 0; wInChannel < ${be[1]}; wInChannel++) {
      int input_channel = group_id * ${be[1]} + wInChannel;
      for (int wHeight = 0; wHeight < ${be[2]}; wHeight++) {
        int xHeight = xRCCorner.x + wHeight * ${he.dilations[0]};

        if (xHeight < 0 || xHeight >= ${me[2]}) {
          continue;
        }

        for (int wWidth = 0; wWidth < ${be[3]}; wWidth++) {
          int xWidth = xRCCorner.y + wWidth * ${he.dilations[1]};
          if (xWidth < 0 || xWidth >= ${me[3]}) {
            continue;
          }

          float xVal = getX(batch, input_channel, xWidth, xHeight);
          float wVal = getW(output_channel, wInChannel, wWidth, wHeight);
          value += xVal*wVal;
        }
      }
    }
    ${pe}
    ${Ee}
    ${Se.output} = vec4(value, .0, .0, .0);
  }
`;return Object.assign(Object.assign({},ce),{output:{dims:ve,type:le[0].type,textureType:G.TextureType.unpacked},shaderSource:we,hasMain:!0})})(ee,Z,Y,ie)})}},1386:(F,w,D)=>{Object.defineProperty(w,"__esModule",{value:!0}),w.conv2DPacked=w.conv2DPackedPointwise=void 0;const O=D(8138),U=D(8555),G=D(708);w.conv2DPackedPointwise=(q,K,ee)=>{const Z=K[0].dims,ie=K[1].dims,Y=(0,O.calculateOutputShape)(Z,ie,ee.dilations,ee.pads,ee.strides),W=q.reshapePacked(K[0],[Z[1],Z[2]*Z[3]]),ne=q.reshapePacked(K[1],[ie[0],ie[1]]),se=K.length>2?[ne,W,K[2]]:[ne,W],le=q.run((0,G.createPackedMatmulProgramInfoLoader)(q,se,ee),se);return q.reshapePacked(le,Y)},w.conv2DPacked=(q,K,ee)=>{const Z=K[0].dims,ie=K[1].dims,Y=(0,O.calculateOutputShape)(Z,ie,ee.dilations,ee.pads,ee.strides),W=q.run((0,U.createPackedIm2ColProgramInfoLoader)(q,K[0],K[1],Y,ee),[K[0]]),ne=q.reshapePacked(K[1],[ie[0],ie[1]*ie[2]*ie[3]]),se=K.length===3?[ne,W,K[2]]:[ne,W],le=q.run((0,G.createPackedMatmulProgramInfoLoader)(q,se,ee),se);return q.reshapePacked(le,Y)}},9663:(F,w,D)=>{Object.defineProperty(w,"__esModule",{value:!0}),w.parseConvTransposeAttributes=w.convTranspose=void 0;const O=D(246),U=D(5060),G=D(2039),q=D(2823),K=(ne,se,le,ce,he,pe)=>(ne-1)*se+le+(ce-1)*he+1-pe,ee=(ne,se,le,ce,he)=>{const pe=Math.floor(ne/2);se==="SAME_UPPER"?(le[ce]=pe,le[he]=ne-pe):se==="SAME_LOWER"&&(le[ce]=ne-pe,le[he]=pe)};w.convTranspose=(ne,se,le)=>(W(se,le),Z(ne,se,le));const Z=(ne,se,le)=>{const ce=Y(le,se);return[ie(ne,se,ce)]},ie=(ne,se,le)=>ne.run(((ce,he,pe)=>{const me=(be=he.length>2,ge=pe.cacheKey,{name:"ConvTranspose",inputNames:be?["X","W","B"]:["X","W"],inputTypes:be?[G.TextureType.unpacked,G.TextureType.unpacked,G.TextureType.unpacked]:[G.TextureType.unpacked,G.TextureType.unpacked],cacheHint:ge});var be,ge;return Object.assign(Object.assign({},me),{get:()=>((ve,Se,Me,Ee)=>{const we=Se.length>2?"getB(output_channel)":"0.0",Re=Se[0].dims,Le=Se[1].dims,Ne=Le[1],Oe=Le[0]/Ee.group,Pe=[Se[0].dims[0],Se[1].dims[1]*Ee.group,...Ee.outputShape],Ce=(0,U.getGlsl)(ve.session.backend.glContext.version),{activationFunction:Be,applyActivation:ze}=(0,q.getActivationSnippet)(Ee),Xe=`
  const ivec2 strides = ivec2(${Ee.strides[0]}, ${Ee.strides[1]});
  const ivec2 pads = ivec2(${Ee.pads[0]}, ${Ee.pads[1]});
  ${Be}
  void main() {
    ivec4 coords = getOutputCoords();
    int batch = coords.x;
    int output_channel = coords.y;

    ivec2 loc = coords.zw + pads;

    int group_id = output_channel / ${Ne};
    int wOutChannel = output_channel - group_id * ${Ne};

    float value = ${we};
    for (int inChannelOffset = 0; inChannelOffset < ${Oe}; inChannelOffset++) {
      int input_channel = group_id * ${Oe} + inChannelOffset;
      for (int wWOff = 0; wWOff < ${Le[2]}; wWOff++) {
        for (int wHOff = 0; wHOff < ${Le[3]}; wHOff++) {
          ivec2 wOff = ivec2(wWOff * ${Ee.dilations[0]}, wHOff * ${Ee.dilations[1]});
          ivec2 wLoc = loc - wOff;
          ivec2 wLocIn = wLoc / strides;
          if (
            wLocIn * strides == wLoc &&
            wLocIn.x >= 0 && wLocIn.x < ${Re[2]} &&
            wLocIn.y >= 0 && wLocIn.y < ${Re[3]}
          ) {
            float xVal = getX(batch, input_channel, wLocIn.y, wLocIn.x);
            float wVal = getW(input_channel, wOutChannel, wHOff, wWOff);
            value += xVal * wVal;
          }
        }
      }
    }
    ${ze}
    ${Ce.output} = vec4(value, .0, .0, .0);
  }
`;return Object.assign(Object.assign({},Me),{output:{dims:Pe,type:Se[0].type,textureType:G.TextureType.unpacked},shaderSource:Xe,hasMain:!0})})(ce,he,me,pe)})})(ne,se,le),se),Y=(ne,se)=>{const le=ne.kernelShape.slice();if(ne.kernelShape.length===0)for(let me=2;me<se[1].dims.length;++me)le.push(se[1].dims[me]);const ce=ne.pads.slice(),he=ne.outputShape.slice();((me,be,ge,ve,Se,Me,Ee,we)=>{const Re=me.length-2,Le=we.length===0;for(let Ne=0;Ne<Re;++Ne){const Oe=Le?me[Ne+2]*Me[Ne]:we[Ne],Pe=K(me[Ne+2],Me[Ne],Se[Ne],be[Ne],ge[Ne],Oe);ee(Pe,ve,Se,Ne,Ne+Re),Le&&we.push(Me[Ne]*(me[Ne+2]-1)+Ee[Ne]+(be[Ne]-1)*ge[Ne]+1-Se[Ne]-Se[Ne+Re])}})(se[0].dims,le,ne.dilations,ne.autoPad,ce,ne.strides,ne.outputPadding,he);const pe=Object.assign({},ne);return Object.assign(pe,{kernelShape:le,pads:ce,outputShape:he,cacheKey:ne.cacheKey}),pe};w.parseConvTransposeAttributes=ne=>{const se=ne.attributes,le=(0,q.parseInternalActivationAttributes)(se),ce=se.getString("auto_pad","NOTSET"),he=se.getInts("dilations",[1,1]),pe=se.getInt("group",1),me=se.getInts("kernel_shape",[]),be=se.getInts("output_padding",[0,0]),ge=se.getInts("output_shape",[]),ve=se.getInts("pads",[0,0,0,0]),Se=se.getInts("strides",[1,1]);return(0,O.createAttributeWithCacheKey)(Object.assign({autoPad:ce,dilations:he,group:pe,kernelShape:me,outputPadding:be,outputShape:ge,pads:ve,strides:Se},le))};const W=(ne,se)=>{if(!ne||ne.length!==2&&ne.length!==3)throw new Error("Conv requires 2 or 3 inputs");if(ne[0].dims.length!==4||ne[1].dims.length!==4)throw new Error("currently only support 2-dimensional conv");if(ne[0].dims[1]!==ne[1].dims[0])throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");const le=ne[1].dims[1]*se.group;if(ne.length===3&&(ne[2].dims.length!==1||ne[2].dims[0]!==le))throw new Error("invalid bias");const ce=ne[0].dims.length-2;if(se.dilations.length!==ce)throw new Error(`dilations should be ${ce}D`);if(se.strides.length!==ce)throw new Error(`strides should be ${ce}D`);if(se.pads.length!==2*ce)throw new Error(`pads should be ${2*ce}D`);if(se.outputPadding.length!==ce)throw new Error(`output_padding should be ${ce}D`);if(se.kernelShape.length!==0&&se.kernelShape.length!==ne[1].dims.length-2)throw new Error("invalid kernel shape");if(se.outputShape.length!==0&&se.outputShape.length!==ne[0].dims.length-2)throw new Error("invalid output shape");if(ne[0].type!=="float32"||ne[1].type!=="float32")throw new Error("ConvTranspose input(X,W) should be float tensor");if(ne.length===3&&ne[2].type!=="float32")throw new Error("ConvTranspose input(bias) should be float tensor")}},8138:(F,w,D)=>{Object.defineProperty(w,"__esModule",{value:!0}),w.parseConvAttributes=w.conv=w.calculateOutputShape=void 0;const O=D(246),U=D(2517),G=D(4770),q=D(1386),K=D(9828),ee=D(2823),Z=D(3248),ie=D(5623);w.calculateOutputShape=(ce,he,pe,me,be)=>{const ge=ce[0],ve=ce.slice(2),Se=ve.length,Me=he[0],Ee=he.slice(2).map(((Re,Le)=>Re+(Re-1)*(pe[Le]-1))),we=ve.map(((Re,Le)=>Re+me[Le]+me[Le+Se])).map(((Re,Le)=>Math.floor((Re-Ee[Le]+be[Le])/be[Le])));return[ge,Me].concat(...we)},w.conv=(ce,he,pe)=>(le(he,pe),Y(ce,he,pe));const Y=(ce,he,pe)=>{const me=se(pe,he),be=ce.session.pack,ge=me.kernelShape[0]===1&&me.kernelShape[1]===1;return me.group>1?[ce.run((0,G.createUnpackedGroupedConvProgramInfoLoader)(ce,he,me),he)]:ge&&be?[W(ce,he,me)]:be&&he[0].dims.length===4&&he[0].dims[0]===1&&!ge?[(0,q.conv2DPacked)(ce,he,me)]:[ne(ce,he,me)]},W=(ce,he,pe)=>{const me=he[0].dims,be=he[1].dims,ge=(0,w.calculateOutputShape)(me,be,pe.dilations,pe.pads,pe.strides),ve=ce.reshapeUnpacked(he[0],[me[1],me[2]*me[3]]),Se=ce.reshapeUnpacked(he[1],[be[0],be[1]]),Me=he.length>2?[Se,ve,he[2]]:[Se,ve],Ee=ce.run((0,ie.createMatmulProgramInfoLoader)(Me,pe),Me);return ce.reshapeUnpacked(Ee,ge)},ne=(ce,he,pe)=>{const me=he[0].dims,be=he[1].dims,ge=(0,w.calculateOutputShape)(me,be,pe.dilations,pe.pads,pe.strides),ve=ce.run((0,Z.createIm2ColProgramInfoLoader)(ce,he[0],he[1],ge,pe),[he[0]]),Se=he.length===3?[ve,he[1],he[2]]:[ve,he[1]];return ce.run((0,K.createDotProductProgramInfoLoader)(ce,he,ge,pe),Se)},se=(ce,he)=>{const pe=ce.kernelShape.slice();if(ce.kernelShape.length===0)for(let ge=2;ge<he[1].dims.length;++ge)pe.push(he[1].dims[ge]);const me=ce.pads.slice();U.PoolConvUtil.adjustPadsBasedOnAutoPad(he[0].dims,ce.strides,ce.dilations,pe,me,ce.autoPad);const be=Object.assign({},ce);return Object.assign(be,{kernelShape:pe,pads:me,cacheKey:ce.cacheKey}),be};w.parseConvAttributes=ce=>{const he=ce.attributes,pe=(0,ee.parseInternalActivationAttributes)(he),me=he.getString("auto_pad","NOTSET"),be=he.getInts("dilations",[1,1]),ge=he.getInt("group",1),ve=he.getInts("kernel_shape",[]),Se=he.getInts("pads",[0,0,0,0]),Me=he.getInts("strides",[1,1]);return(0,O.createAttributeWithCacheKey)(Object.assign({autoPad:me,dilations:be,group:ge,kernelShape:ve,pads:Se,strides:Me},pe))};const le=(ce,he)=>{if(!ce||ce.length!==2&&ce.length!==3)throw new Error("Conv requires 2 or 3 inputs");if(ce[0].dims.length!==4||ce[1].dims.length!==4)throw new Error("currently only support 2-dimensional conv");if(ce[0].dims[1]!==ce[1].dims[1]*he.group)throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");if(ce.length===3&&(ce[2].dims.length!==1||ce[1].dims[0]!==ce[2].dims[0]))throw new Error("invalid bias");const pe=ce[0].dims.length-2;if(he.dilations.length!==pe)throw new Error(`dilations should be ${pe}D`);if(he.strides.length!==pe)throw new Error(`strides should be ${pe}D`);if(he.pads.length!==2*pe)throw new Error(`pads should be ${2*pe}D`);if(he.kernelShape.length!==0&&he.kernelShape.length!==ce[1].dims.length-2)throw new Error("invalid kernel shape");if(ce[0].type!=="float32"||ce[1].type!=="float32")throw new Error("Conv input(X,W) should be float tensor");if(ce.length===3&&ce[2].type!=="float32")throw new Error("Conv input(bias) should be float tensor")}},5193:(F,w,D)=>{Object.defineProperty(w,"__esModule",{value:!0}),w.parseDepthToSpaceAttributes=w.depthToSpace=void 0;const O=D(3738);w.depthToSpace=(G,q,K)=>{U(q);const ee=K.blocksize,Z=ee*ee,ie=K.mode==="DCR"?[0,3,4,1,5,2]:[0,1,4,2,5,3],Y=K.mode==="DCR"?[q[0].dims[0],ee,ee,q[0].dims[1]/Z,q[0].dims[2],q[0].dims[3]]:[q[0].dims[0],q[0].dims[1]/Z,ee,ee,q[0].dims[2],q[0].dims[3]],W=G.reshapeUnpacked(q[0],Y),ne={perm:ie,cacheKey:`${ie}`},[se]=(0,O.transpose)(G,[W],ne),le=[q[0].dims[0],q[0].dims[1]/Z,q[0].dims[2]*ee,q[0].dims[3]*ee];return[G.reshapeUnpacked(se,le)]},w.parseDepthToSpaceAttributes=G=>{const q=G.attributes.getInt("blocksize");if(q<1)throw new Error(`blocksize must be >= 1, but got : ${q} for DepthToSpace`);const K=G.attributes.getString("mode","DCR");if(K!=="DCR"&&K!=="CRD")throw new Error(`unrecognized mode: ${K} for DepthToSpace`);return{mode:K,blocksize:q}};const U=G=>{if(G.length!==1)throw new Error(`DepthToSpace expect 1 inputs, but got ${G.length}`);if(G[0].type==="string"||G[0].dims.length!==4)throw new TypeError("DepthToSpace input should be a 4-D numeric tensor")}},9828:(F,w,D)=>{Object.defineProperty(w,"__esModule",{value:!0}),w.createDotProductProgramInfoLoader=void 0;const O=D(2517),U=D(5060),G=D(2039),q=D(2823),K=D(3248);w.createDotProductProgramInfoLoader=(ee,Z,ie,Y)=>{const W=((ne,se)=>({name:"ConvDotProduct",inputNames:ne?["Im2Col","K","B"]:["Im2Col","K"],inputTypes:ne?[G.TextureType.unpacked,G.TextureType.packedLastDimension,G.TextureType.unpacked]:[G.TextureType.unpacked,G.TextureType.packedLastDimension],cacheKey:se.activationCacheKey}))(Z.length>2,Y);return Object.assign(Object.assign({},W),{get:()=>((ne,se,le,ce,he)=>{const pe=le[0].dims,me=le[1].dims,be=[me[0],Math.ceil(pe[1]*me[2]*me[3]/4)],ge=(0,K.calculateIm2ColDims)(pe,me,ce),[ve,Se]=ne.calculateTextureWidthAndHeight(be,G.TextureType.packedLastDimension),Me=O.ShapeUtil.computeStrides(ge),[Ee,we]=ne.calculateTextureWidthAndHeight(ge,G.TextureType.packedLastDimension),Re=ce.length,Le=le.length<3?"0.0":"_B(b)",Ne=Math.ceil(pe[1]*me[2]*me[3]/4),{activationFunction:Oe,applyActivation:Pe}=(0,q.getActivationSnippet)(he),Ce=(0,U.getGlsl)(ne.session.backend.glContext.version),Be=`
${Oe}
float process(int indices[${Re}]) {
  int b[1];
  b[0] = indices[1];
  int im2col[4];
  im2col[0] = indices[0];
  im2col[1] = indices[2];
  im2col[2] = indices[3];
  int im2colOffset = im2col[0] * ${Me[0]} + im2col[1] * ${Me[1]} + im2col[2] * ${Me[2]};
  int kernelOffset = indices[1] * ${be[1]};
  float value = ${Le};
  for (int i = 0; i < ${Ne}; ++i) {
    vec2 im2colCoords = offsetToCoords(im2colOffset, ${Ee}, ${we});
    vec2 kernelCoords = offsetToCoords(kernelOffset, ${ve}, ${Se});
    value += dot(${Ce.texture2D}(Im2Col, im2colCoords), ${Ce.texture2D}(K, kernelCoords));
    ++im2colOffset;
    ++kernelOffset;
  }
  ${Pe}
  return value;
}`;return Object.assign(Object.assign({},se),{output:{dims:ce,type:le[0].type,textureType:G.TextureType.unpacked},shaderSource:Be})})(ee,W,Z,ie,Y)})}},7992:(F,w,D)=>{Object.defineProperty(w,"__esModule",{value:!0}),w.parseFlattenAttributes=w.flatten=void 0;const O=D(2517);w.flatten=(G,q,K)=>{U(q,K);const ee=O.ShapeUtil.flattenShape(q[0].dims,K);return[G.reshapeUnpacked(q[0],ee)]},w.parseFlattenAttributes=G=>G.attributes.getInt("axis",1);const U=(G,q)=>{if(!G||G.length!==1)throw new Error("Flatten requires 1 input.");const K=G[0].dims.length;if(K===0)throw new Error("scalar tensor is not supported.");if(q<-K||q>K)throw new Error("Invalid axis");if(G[0].type==="string")throw new Error("string tensor is not supported.")}},2823:(F,w,D)=>{Object.defineProperty(w,"__esModule",{value:!0}),w.parseInternalActivationAttributes=w.getActivationSnippet=void 0;const O=D(2517),U=D(4909);w.getActivationSnippet=function(G){let q;switch(G.activation){case"Relu":q=(0,U.glslRelu)();break;case"Sigmoid":q=(0,U.glslSigmoid)();break;case"Clip":q=(0,U.glslClip)(G.clipMin,G.clipMax);break;default:return{activationFunction:"",applyActivation:""}}const K=q.name;return{activationFunction:q.body,applyActivation:`value = ${K}_(value);`}},w.parseInternalActivationAttributes=G=>{const q=G.getString("activation","");if(q==="Clip"){const[K,ee]=G.getFloats("activation_params",[O.MIN_CLIP,O.MAX_CLIP]);return{activation:q,clipMax:ee,clipMin:K,activationCacheKey:`${q}:${K},${ee}`}}return{activation:q,activationCacheKey:q}}},1253:(F,w,D)=>{Object.defineProperty(w,"__esModule",{value:!0}),w.parseGatherAttributes=w.gather=void 0;const O=D(246),U=D(782),G=D(2517),q=D(2039);w.gather=(ie,Y,W)=>(Z(Y,W.axis),[ie.run(ee(ie,Y,W),Y)]),w.parseGatherAttributes=ie=>(0,O.createAttributeWithCacheKey)({axis:ie.attributes.getInt("axis",0)});const K={name:"Gather",inputNames:["A","B"],inputTypes:[q.TextureType.unpacked,q.TextureType.unpacked]},ee=(ie,Y,W)=>{const ne=Object.assign(Object.assign({},K),{cacheHint:W.cacheKey});return Object.assign(Object.assign({},ne),{get:()=>((se,le,ce,he)=>{const pe=ce[0].dims.slice(),me=ce[1].dims.slice(),be=new Array(pe.length+me.length-1);he=G.ShapeUtil.normalizeAxis(he,pe.length);const ge=[];for(let Se=0;Se<be.length;Se++)Se<he?(be[Se]=pe[Se],ge.push(`inputIdx[${Se}] = outputIdx[${Se}];`)):Se<he+me.length?(be[Se]=me[Se-he],ge.push(`indexDataIdx[${Se-he}] = outputIdx[${Se}];`)):(be[Se]=pe[Se-me.length+1],ge.push(`inputIdx[${Se-me.length+1}] = outputIdx[${Se}];`));const ve=`
      float process(int outputIdx[${be.length||1}]) {
        int inputIdx[${pe.length}];
        int indexDataIdx[${me.length||1}];
        indexDataIdx[0] = 0;
        ${ge.join(`
        `)}
        int idx = int(_B(indexDataIdx));
        inputIdx[${he}] = idx < 0 ? idx + ${pe[he]} : idx;
        return _A(inputIdx);
      }`;return Object.assign(Object.assign({},le),{output:{dims:be,type:ce[0].type,textureType:q.TextureType.unpacked},shaderSource:ve})})(0,ne,Y,W.axis)})},Z=(ie,Y)=>{if(!ie||ie.length!==2)throw new Error("Gather requires 2 inputs.");const W=ie[0].dims.length;if(W<1)throw new Error("Invalid input shape.");if(Y<-W||Y>W-1)throw new Error("Invalid axis.");if(U.NUMBER_TYPES.indexOf(ie[0].type)===-1)throw new Error("Invaid input type.");if(ie[1].type!=="int32"&&ie[1].type!=="int16")throw new Error("Invaid input type.")}},4776:(F,w,D)=>{Object.defineProperty(w,"__esModule",{value:!0}),w.parseGemmAttributesV11=w.parseGemmAttributesV7=w.gemm=void 0;const O=D(246),U=D(2517),G=D(2039);w.gemm=(ie,Y,W)=>(Z(Y,W),[ie.run(K(Y,W),Y)]);const q=(ie,Y)=>{const W=ie.attributes.getInt("transA",0)!==0,ne=ie.attributes.getInt("transB",0)!==0,se=ie.attributes.getFloat("alpha",1),le=ie.attributes.getFloat("beta",1);return(0,O.createAttributeWithCacheKey)({transA:W,transB:ne,alpha:se,beta:le,isOptionalC:Y})};w.parseGemmAttributesV7=ie=>q(ie,!1),w.parseGemmAttributesV11=ie=>q(ie,!0);const K=(ie,Y)=>{const W={name:"Gemm",inputNames:ie.length===3?["A","B","C"]:["A","B"],inputTypes:ie.length===3?[G.TextureType.unpacked,G.TextureType.unpacked,G.TextureType.unpacked]:[G.TextureType.unpacked,G.TextureType.unpacked],key:Y.cacheKey};return Object.assign(Object.assign({},W),{get:()=>ee(W,ie,Y)})},ee=(ie,Y,W)=>{const ne=Y[0].dims.slice(),se=Y[1].dims.slice(),[le,ce]=U.GemmUtil.getShapeOfGemmResult(ne,W.transA,se,W.transB,Y.length===3?Y[2].dims:void 0),he=[le,ce];if(!he)throw new Error("Can't use gemm on the given tensors");let pe=ne[ne.length-1],me="";W.transA&&(pe=ne[0]),W.transA&&W.transB?me="value += _A_T(a) * _B_T(b);":W.transA&&!W.transB?me="value += _A_T(a) * _B(b);":!W.transA&&W.transB?me="value += _A(a) * _B_T(b);":W.transA||W.transB||(me="value += _A(a) * _B(b);");const be=he.length,ge=`
      float process(int indices[${be}]) {
          int a[${be}];
          int b[${be}];
          ${Y.length===3?`int c[${Y[2].dims.length}];`:""}

          copyVec(indices, a);
          copyVec(indices, b);
          ${Y.length===3?"bcastIndices_C(indices, c);":""}

          float value = 0.0;
          for (int k=0; k<${pe}; ++k) {
              a[${be-1}] = k;
              b[${be-2}] = k;
              ${me}
          }

          value = value * alpha;
          ${Y.length===3?"value += beta * _C(c);":""}
          return value;
      }`;return Object.assign(Object.assign({},ie),{output:{dims:he,type:Y[0].type,textureType:G.TextureType.unpacked},variables:[{name:"alpha",type:"float",data:W.alpha},{name:"beta",type:"float",data:W.beta}],shaderSource:ge})},Z=(ie,Y)=>{if(!ie)throw new Error("Input is missing");if(Y.isOptionalC&&(ie.length<2||ie.length>3))throw new Error("Invaid input shape.");if(!Y.isOptionalC&&ie.length!==3)throw new Error("Gemm requires 3 inputs");if(ie.length===3&&ie[2].dims.length!==1&&ie[2].dims.length!==2)throw new Error("Invalid input shape of C");if(ie[0].type!=="float32"&&ie[0].type!=="float64"||ie[1].type!=="float32"&&ie[1].type!=="float64"||ie.length===3&&ie[2].type!=="float32"&&ie[2].type!=="float64")throw new Error("Invalid input type.");if(ie[0].type!==ie[1].type||ie.length===3&&ie[0].type!==ie[2].type)throw new Error("Input types are mismatched")}},8555:(F,w,D)=>{Object.defineProperty(w,"__esModule",{value:!0}),w.createPackedIm2ColProgramInfoLoader=void 0;const O=D(5060),U=D(2039),G=D(2827);w.createPackedIm2ColProgramInfoLoader=(q,K,ee,Z,ie)=>{const Y=(W=ie.cacheKey,{name:"Im2Col (packed)",inputNames:["A"],inputTypes:[U.TextureType.packed],cacheHint:W});var W;return Object.assign(Object.assign({},Y),{get:()=>((ne,se,le,ce,he,pe)=>{const me=le.dims,be=ce.dims,ge=he.length,ve=[be[1]*be[2]*be[3],he[2]*he[3]],Se=be[2]*be[3],Me=(0,G.unpackFromChannel)(),Ee=(0,O.getGlsl)(ne.session.backend.glContext.version);let we="";for(let Le=0;Le<=1;Le++)for(let Ne=0;Ne<=1;Ne++)we+=`
            blockIndex = rc.x + ${Ne};
            pos = rc.y + ${Le};

            if(blockIndex < ${ve[1]} && pos < ${ve[0]}) {
              offsetY = int(blockIndex / (${he[ge-1]})) * ${pe.strides[0]} -
                ${pe.pads[0]};
              d0 = offsetY + ${pe.dilations[0]} * (imod(pos, ${Se}) / ${be[2]});

              if(d0 < ${me[2]} && d0 >= 0) {
                offsetX = imod(blockIndex, ${he[ge-1]}) * ${pe.strides[1]} -
                  ${pe.pads[1]};
                d1 = offsetX + ${pe.dilations[1]} * imod(imod(pos, ${Se}), ${be[2]});

                if(d1 < ${me[3]} && d1 >= 0) {

                  ch = int(float(pos)/ ${Se}.);
                    innerDims = vec2(d0, d1);
                    result[${2*Le+Ne}] = getChannel(
                      getA(0, ch, int(innerDims.x),
                      int(innerDims.y)), innerDims);
                }
              }
            }

          `;const Re=`
      ${Me}

      void main() {
        ivec2 rc = getOutputCoords();
          vec4 result = vec4(0.0);
          int blockIndex, pos, offsetY, d0, offsetX, d1, ch;
          vec2 innerDims;
          ${we}
          ${Ee.output} = result;
      }
            `;return Object.assign(Object.assign({},se),{output:{dims:ve,type:le.type,textureType:U.TextureType.packed},shaderSource:Re,hasMain:!0})})(q,Y,K,ee,Z,ie)})}},3248:(F,w,D)=>{Object.defineProperty(w,"__esModule",{value:!0}),w.calculateIm2ColDims=w.createIm2ColProgramInfoLoader=void 0;const O=D(2039);w.createIm2ColProgramInfoLoader=(U,G,q,K,ee)=>{const Z=(ie=ee.cacheKey,{name:"Im2Col",inputNames:["X"],inputTypes:[O.TextureType.unpacked],cacheHint:ie});var ie;return Object.assign(Object.assign({},Z),{get:()=>((Y,W,ne,se,le,ce)=>{const he=ne.dims,pe=se.dims,me=le.length,be=(0,w.calculateIm2ColDims)(he,pe,le,4),ge=`
        const int XC = ${he[1]};
        const int XH = ${he[2]};
        const int XW = ${he[3]};
        const int KH = ${ce.kernelShape[0]};
        const int KW = ${ce.kernelShape[1]};
        const int dilationH = ${ce.dilations[0]};
        const int dilationW = ${ce.dilations[1]};
        const int strideH = ${ce.strides[0]};
        const int strideW = ${ce.strides[1]};
        const int padH = ${ce.pads[0]};
        const int padW = ${ce.pads[1]};
        const int KHKW = KH*KW;
        const int XCKHKW = XC * KHKW;
        const int outputChannels = 4;
        vec4 process(int indices[${me}]) {
          int b  = indices[0]; // batch size
          int oh = indices[1] * strideH - padH; //output height
          int ow = indices[2] * strideW - padW; //output width
          int p = indices[3] * outputChannels; //patch
          vec4 value = vec4(0.0);
          for(int i=0; i < outputChannels; ++i) {
            if(p < XCKHKW) {
              int patchC = p / KHKW;
              int patchH = (p - patchC*KHKW) / KW;
              int patchW = (p - patchC*KHKW) - patchH * KW;
              int xh2 = oh + patchH * dilationH;
              int xw2 = ow + patchW * dilationW;
              int x[${he.length}];
              x[0] = b;
              x[1] = patchC;
              x[2] = xh2;
              x[3] = xw2;
              if(xh2 >= 0 &&
                  xh2 < XH &&
                  xw2 >= 0 &&
                  xw2 < XW) {
                value[i] = _X(x);
              }
            }
            ++p;
          }
          return value;
        }
        `;return Object.assign(Object.assign({},W),{output:{dims:be,type:ne.type,textureType:O.TextureType.packedLastDimension},shaderSource:ge})})(0,Z,G,q,K,ee)})},w.calculateIm2ColDims=(U,G,q,K=4)=>[q[0],q[2],q[3],Math.ceil(U[1]*G[2]*G[3]/K)]},6572:(F,w,D)=>{Object.defineProperty(w,"__esModule",{value:!0}),w.parseImageScalerAttributes=w.imageScaler=void 0;const O=D(246),U=D(2039);w.imageScaler=(Z,ie,Y)=>(ee(ie),[Z.run(q(Z,ie,Y),ie)]),w.parseImageScalerAttributes=Z=>{const ie=Z.attributes.getFloat("scale"),Y=Z.attributes.getFloats("bias");return(0,O.createAttributeWithCacheKey)({scale:ie,bias:Y})};const G={name:"ImageScaler",inputNames:["X"],inputTypes:[U.TextureType.unpacked]},q=(Z,ie,Y)=>{const W=Object.assign(Object.assign({},G),{cacheHint:Y.cacheKey});return Object.assign(Object.assign({},W),{get:()=>((ne,se,le,ce)=>{const he=le[0].dims.slice(),pe=he.length,me=`
      ${K(ce.bias.length)}
      float process(int indices[${pe}]) {
        return _X(indices) * scale + getBias(bias, indices[1]);
      }`;return Object.assign(Object.assign({},se),{output:{dims:he,type:le[0].type,textureType:U.TextureType.unpacked},variables:[{name:"bias",type:"float",arrayLength:ce.bias.length,data:ce.bias},{name:"scale",type:"float",data:ce.scale}],shaderSource:me})})(0,W,ie,Y)})},K=Z=>{const ie=[`float getBias(float bias[${Z}], int channel) {`];for(let Y=0;Y<Z;++Y)Y===0?ie.push(`	if (channel == ${Y}) { return bias[${Y}]; }`):Y===Z-1?ie.push(`	else { return bias[${Y}]; }`):ie.push(`	else if (channel == ${Y}) { return bias[${Y}]; }`);return ie.push("	}"),ie.join(`
`)},ee=Z=>{if(!Z||Z.length!==1)throw new Error("ImageScaler requires 1 input.");if(Z[0].dims.length!==4)throw new Error("Invalid input shape.");if(Z[0].type!=="float32"&&Z[0].type!=="float64")throw new Error("Invalid input type.")}},3346:(F,w,D)=>{Object.defineProperty(w,"__esModule",{value:!0}),w.parseInstanceNormalizationAttributes=w.instanceNormalization=void 0;const O=D(5060),U=D(2039);w.instanceNormalization=(ie,Y,W)=>{Z(Y);const ne=ie.run(q(Y[0]),Y);return[ie.run(ee(ie,Y[0],W,ne.dims),[Y[0],ne,Y[1],Y[2]])]},w.parseInstanceNormalizationAttributes=ie=>ie.attributes.getFloat("epsilon",1e-5);const G={name:"InstanceNormalization_MeanAndVariance",inputNames:["X"],inputTypes:[U.TextureType.unpacked]},q=ie=>Object.assign(Object.assign({},G),{get:()=>((Y,W)=>{const ne=W.dims.slice(),se=ne[1],le=ne[2]*ne[3],ce=[ne[0],se],he=`
      vec4 process(int[2] indices) {
        vec4 v = vec4(0.0);
        int a[4];
        a[0] = indices[0];
        a[1] = indices[1];
        float temp = 0.0;
        for(int a2=0; a2<${ne[2]}; a2++) {
          a[2] = a2;
          for(int a3=0; a3<${ne[3]}; a3++) {
            a[3] = a3;
            float x = _X(a);
            temp += x;
          }
        }
        float mean = temp / float(${le});
        temp = 0.0;
        for(int a2=0; a2<${ne[2]}; a2++) {
          a[2] = a2;
          for(int a3=0; a3<${ne[3]}; a3++) {
            a[3] = a3;
            float x = _X(a);
            temp += (x - mean) * (x - mean);
          }
        }
        v.r = mean;
        v.g = temp / float(${le});

        return v;
      }`;return Object.assign(Object.assign({},Y),{output:{dims:ce,type:W.type,textureType:U.TextureType.packedLastDimension},shaderSource:he})})(G,ie)}),K={name:"InstanceNormalization_ComputeOutput",inputNames:["X","MeanAndVariance","Scale","B"],inputTypes:[U.TextureType.unpacked,U.TextureType.packedLastDimension,U.TextureType.unpacked,U.TextureType.unpacked]},ee=(ie,Y,W,ne)=>{const se=Object.assign(Object.assign({},K),{cacheHint:`${W}`});return Object.assign(Object.assign({},se),{get:()=>((le,ce,he,pe,me)=>{const be=(0,O.getGlsl)(le.session.backend.glContext.version),[ge,ve]=le.calculateTextureWidthAndHeight(me,U.TextureType.packedLastDimension),[Se,Me]=[ge/4,ve],Ee=`
      vec4 get_MeanAndVariance(int[2] mv) {
        int offset = indicesToOffset_MeanAndVariance(mv);
        vec2 coords = offsetToCoords(offset, ${Se}, ${Me});
        return ${be.texture2D}(MeanAndVariance, coords);
      }

      float process(int[4] indices) {
        int mv[2];
        mv[0] = indices[0];
        mv[1] = indices[1];
        vec4 mean_and_variance = get_MeanAndVariance(mv);
        float mean = mean_and_variance.r;
        float variance = mean_and_variance.g;

        int sb[1];
        sb[0] = indices[1];
        float scale = _Scale(sb);
        float b = _B(sb);

        return scale * (_X(indices) - mean) / sqrt(variance + epsilon) + b;
      }`;return Object.assign(Object.assign({},ce),{output:{dims:he.dims,type:he.type,textureType:U.TextureType.unpacked},variables:[{name:"epsilon",type:"float",data:pe}],shaderSource:Ee})})(ie,se,Y,W,ne)})},Z=ie=>{if(!ie||ie.length!==3)throw new Error("InstanceNormalization requires 3 inputs.");const Y=ie[0],W=ie[1],ne=ie[2];if(Y.dims.length<3||W.dims.length!==1||ne.dims.length!==1)throw new Error("Invalid input shape.");if(W.dims[0]!==Y.dims[1]||ne.dims[0]!==Y.dims[1])throw new Error("Input shapes are mismatched.");if(Y.type!=="float32"&&Y.type!=="float64"||W.type!=="float32"&&W.type!=="float64"||ne.type!=="float32"&&ne.type!=="float64")throw new Error("Invalid input type.");if(ie[0].dims.length!==4)throw new Error("Only support 4-D input shape.")}},708:(F,w,D)=>{Object.defineProperty(w,"__esModule",{value:!0}),w.createPackedMatmulProgramInfoLoader=void 0;const O=D(2517),U=D(5060),G=D(2039),q=D(9390),K=D(2823),ee=D(5623);w.createPackedMatmulProgramInfoLoader=(Z,ie,Y)=>{const W=(ne=ie.length>2,se=Y.activationCacheKey,{name:"MatMul (packed)",inputNames:ne?["A","B","Bias"]:["A","B"],inputTypes:ne?[G.TextureType.packed,G.TextureType.packed,G.TextureType.packed]:[G.TextureType.packed,G.TextureType.packed],cacheHint:se});var ne,se;return Object.assign(Object.assign({},W),{get:()=>((le,ce,he,pe)=>{const me=he.length>2,be=me?"value += getBiasForMatmul();":"",ge=he[0].dims,ve=he[1].dims,Se=O.BroadcastUtil.calcShape(ge,ve,!0),Me=!O.ShapeUtil.areEqual(he[0].dims,he[1].dims);if(!Se)throw new Error("Can't use matmul on the given tensors");const Ee=ge[ge.length-1],we=Math.ceil(Ee/2),Re=ge.length,Le=ve.length,Ne=(0,U.getGlsl)(le.session.backend.glContext.version),Oe=(0,q.getCoordsDataType)(Se.length),Pe=Se.length,Ce=(0,q.getGlChannels)(),{activationFunction:Be,applyActivation:ze}=(0,K.getActivationSnippet)(pe),Xe=me?`${(0,ee.getBiasForMatmul)(Oe,Ce,he[2].dims,Se,!0)}`:"",lt=Me?`${(function(Lt,$t,mt,bt){let Xt=[],hn=[];const Jt=mt[0].dims,Mn=mt[1].dims,Zn=Jt.length,vn=Mn.length,In=bt.length,st=In-Zn,Gn=In-vn;Xt=Jt.map(((En,Ke)=>`coords.${$t[Ke+st]}`)),Xt[Zn-1]="i*2",Xt.join(", "),hn=Mn.map(((En,Ke)=>`coords.${$t[Ke+Gn]}`)),hn[vn-2]="i*2",hn.join(", ");const qn=O.BroadcastUtil.getBroadcastDims(Jt,bt),ai=O.BroadcastUtil.getBroadcastDims(Mn,bt),yn=qn.map((En=>`coords.${$t[En+st]} = 0;`)).join(`
`),li=ai.map((En=>`coords.${$t[En+Gn]} = 0;`)).join(`
`),Tn=`int lastDim = coords.${$t[In-1]};
  coords.${$t[In-1]} = coords.${$t[In-2]};
  coords.${$t[In-2]} = lastDim;`;return`
vec4 getAAtOutCoordsMatmul(int i) {
  ${Lt} coords = getOutputCoords();
  ${Tn}
  ${yn}
  vec4 outputValue = getA(${Xt});
  return outputValue;
}

vec4 getBAtOutCoordsMatmul(int i) {
  ${Lt} coords = getOutputCoords();
  ${Tn}
  ${li}
  vec4 outputValue = getB(${hn});
  return outputValue;
}`})(Oe,Ce,he,Se)}`:"",ke=Me?"getAAtOutCoordsMatmul(i)":`getA(${(function(Lt,$t){let mt="";for(let bt=0;bt<$t-2;bt++)mt+=`rc.${Lt[bt]}, `;return mt+=`rc.${Lt[$t-2]}, i*2`,mt})(Ce,Re)})`,rt=Me?"getBAtOutCoordsMatmul(i)":`getB(${(function(Lt,$t){let mt="";for(let bt=0;bt<$t-2;bt++)mt+=`rc.${Lt[bt]}, `;return mt+=`i*2, rc.${Lt[$t-1]}`,mt})(Ce,Le)})`,St=`
            ${lt}
            ${Xe}
            ${Be}
            void main() {
              ${Me?"":`${Oe} rc =
          getOutputCoords(); int lastDim = rc.${Ce[Pe-1]}; rc.${Ce[Pe-1]} =
          rc.${Ce[Pe-2]}; rc.${Ce[Pe-2]} = lastDim;
      `}

              vec4 value = vec4(0);
              for (int i = 0; i < ${we}; i++) {
                vec4 a = ${ke};
                vec4 b = ${rt};

                value += (a.rrbb * b.rgrg);
                value += (a.ggaa * b.baba);
              }
              ${be}
              ${ze}
              ${Ne.output} = value;
            }`;return Object.assign(Object.assign({},ce),{output:{dims:Se,type:he[0].type,textureType:G.TextureType.packed},shaderSource:St,hasMain:!0})})(Z,W,ie,Y)})}},5623:(F,w,D)=>{Object.defineProperty(w,"__esModule",{value:!0}),w.getBiasForMatmul=w.createMatmulProgramInfoLoader=w.parseMatMulAttributes=w.matMul=void 0;const O=D(2517),U=D(2039),G=D(9390),q=D(2823),K=D(708);function ee(Y,W){const ne=(se=Y.length>2,le=W.activationCacheKey,{name:"MatMul",inputNames:se?["A","B","Bias"]:["A","B"],inputTypes:se?[U.TextureType.unpacked,U.TextureType.unpacked,U.TextureType.unpacked]:[U.TextureType.unpacked,U.TextureType.unpacked],cacheHint:le});var se,le;return Object.assign(Object.assign({},ne),{get:()=>(function(ce,he,pe){const me=he[0].dims,be=he[1].dims,ge=O.BroadcastUtil.calcShape(me,be,!0);if(!ge)throw new Error("Can't use matmul on the given tensors");const ve=(0,G.getCoordsDataType)(ge.length),Se=(0,G.getGlChannels)(),{activationFunction:Me,applyActivation:Ee}=(0,q.getActivationSnippet)(pe),we=he.length>2,Re=we?"value += getBiasForMatmul();":"",Le=we?`${ie(ve,Se,he[2].dims,ge,!1)}`:"",Ne=ge.length,Oe=me.length,Pe=be.length,Ce=`
    ${Me}
    ${Le}
    float process(int indices[${Ne}]) {
        int a[${Oe}];
        int b[${Pe}];
        bcastMatmulIndices_A(indices, a);
        bcastMatmulIndices_B(indices, b);

        float value;
        for (int k=0; k<${me[me.length-1]}; ++k) {
            a[${Oe-1}] = k;
            b[${Pe-2}] = k;
            value += _A(a) * _B(b);
        }
        ${Re}
        ${Ee}
        return value;
    }`;return Object.assign(Object.assign({},ce),{output:{dims:ge,type:he[0].type,textureType:U.TextureType.unpacked},shaderSource:Ce})})(ne,Y,W)})}w.matMul=(Y,W,ne)=>(Z(W),Y.session.pack?[Y.run((0,K.createPackedMatmulProgramInfoLoader)(Y,W,ne),W)]:[Y.run(ee(W,ne),W)]),w.parseMatMulAttributes=Y=>(0,q.parseInternalActivationAttributes)(Y.attributes),w.createMatmulProgramInfoLoader=ee;const Z=Y=>{if(!Y||Y.length!==2)throw new Error("MatMul requires 2 inputs.");if(Y[0].dims[Y[0].dims.length-1]!==Y[1].dims[Y[1].dims.length-2])throw new Error("shared dimension does not match.");if(Y[0].type!=="float32"&&Y[0].type!=="float64"||Y[1].type!=="float32"&&Y[1].type!=="float64")throw new Error("inputs should be float type");if(Y[0].type!==Y[1].type)throw new Error("inputs types should match")};function ie(Y,W,ne,se,le){let ce="";const he=ne.length,pe=se.length,me=pe-he;ce=pe<2&&he>0?"coords":ne.map(((ve,Se)=>`coords.${W[Se+me]}`)).join(", ");const be=O.BroadcastUtil.getBroadcastDims(ne,se).map((ve=>`coords.${W[ve+me]} = 0;`)).join(`
`);let ge="vec4(outputValue.xx, outputValue.yy)";return O.ShapeUtil.size(ne)===1&&(ge="vec4(outputValue.x)"),le?`
vec4 getBiasForMatmul() {
  ${Y} coords = getOutputCoords();
  ${be}
  vec4 outputValue = getBias(${ce});
  return ${ge};
}`:`
float getBiasForMatmul() {
  ${Y} coords = getOutputCoords();
  ${be}
  return getBias(coords.x);
}`}w.getBiasForMatmul=ie},2403:(F,w,D)=>{Object.defineProperty(w,"__esModule",{value:!0}),w.createPackProgramInfoLoader=void 0;const O=D(5060),U=D(2039),G=D(9390),q=D(2827),K={name:"pack",inputNames:["A"],inputTypes:[U.TextureType.unpackedReversed]};w.createPackProgramInfoLoader=(ee,Z)=>Object.assign(Object.assign({},K),{get:()=>((ie,Y)=>{const W=(0,O.getGlsl)(ie.session.backend.glContext.version),ne=Y.dims,se=ne.length,le=Y.dims.length,ce=(0,G.getCoordsDataType)(le),he=(0,q.getChannels)("rc",le),pe=(me=le,be=he,ge=ne[ne.length-2],ve=ne[ne.length-1],me===0||me===1?"":`
    int r = ${be[me-2]};
    int c = ${be[me-1]};
    int rp1 = ${be[me-2]} + 1;
    int cp1 = ${be[me-1]} + 1;
    bool rEdge = rp1 >= ${ve};
    bool cEdge = cp1 >= ${ge};
    `);var me,be,ge,ve;let Se;Se=se===0?[1,1]:se===1?[ne[0],1]:[ne[le-1],ne[le-2]];const Me=(function(Re,Le,Ne){if(Re===0)return"false";if(Re===1)return`rc > ${Le[0]}`;let Oe="";for(let Pe=Re-2;Pe<Re;Pe++)Oe+=`${Ne[Pe]} >= ${Le[Pe-Re+2]}`,Pe<Re-1&&(Oe+="||");return Oe})(le,Se,he),Ee=(function(Re,Le){const Ne=Re.length;if(Ne===0)return"getA(), 0, 0, 0";if(Ne===1)return`getA(rc),
            rc + 1 >= ${Re[0]} ? 0. : getA(rc + 1),
            0, 0`;let Oe="";if(Ne>2)for(let Pe=0;Pe<Ne-2;++Pe)Oe+=`${Le[Pe]},`;return`getA(${Oe}r, c),
          rEdge ? 0. : getA(${Oe}rp1, c),
          cEdge ? 0. : getA(${Oe}r, cp1),
          rEdge || cEdge ? 0. : getA(${Oe}rp1, cp1)`})(ne,he),we=`
        void main() {
          ${ce} rc = getOutputCoords();

          if(${Me}) {
            ${W.output} = vec4(0);
          } else {
            ${pe}

            ${W.output} = vec4(${Ee});
          }
        }
      `;return Object.assign(Object.assign({},K),{hasMain:!0,output:{dims:Y.dims,type:Y.type,textureType:U.TextureType.packed},shaderSource:we})})(ee,Z)})},2827:(F,w,D)=>{Object.defineProperty(w,"__esModule",{value:!0}),w.unpackFromChannel=w.getChannels=w.getVecChannels=void 0;const O=D(9390);function U(G,q){return(0,O.getGlChannels)(q).map((K=>`${G}.${K}`))}w.getVecChannels=U,w.getChannels=function(G,q){return q===1?[G]:U(G,q)},w.unpackFromChannel=function(){return`
    float getChannel(vec4 frag, int dim) {
      int modCoord = imod(dim, 2);
      return modCoord == 0 ? frag.r : frag.g;
    }

    float getChannel(vec4 frag, vec2 innerDims) {
      vec2 modCoord = mod(innerDims, 2.);
      return modCoord.x == 0. ?
        (modCoord.y == 0. ? frag.r : frag.g) :
        (modCoord.y == 0. ? frag.b : frag.a);
    }
  `}},2870:(F,w,D)=>{Object.defineProperty(w,"__esModule",{value:!0}),w.parsePadAttributesV11=w.padV11=w.parsePadAttributesV2=w.padV2=void 0;const O=D(246),U=D(2517),G=D(5060),q=D(2039),K={name:"Pad",inputNames:["A"],inputTypes:[q.TextureType.unpacked]};w.padV2=(ce,he,pe)=>(ie(he),[ce.run(Object.assign(Object.assign({},K),{cacheHint:pe.cacheKey,get:()=>Z(ce,he[0],pe)}),he)]),w.parsePadAttributesV2=ce=>{const he=ce.attributes.getString("mode","constant"),pe=ce.attributes.getFloat("value",0),me=ce.attributes.getInts("pads");return(0,O.createAttributeWithCacheKey)({mode:he,value:pe,pads:me})},w.padV11=(ce,he,pe)=>{Y(he);const me=ee(ce,he,pe);return(0,w.padV2)(ce,[he[0]],me)},w.parsePadAttributesV11=ce=>ce.attributes.getString("mode","constant");const ee=(ce,he,pe)=>{if(!ce.session.isInitializer(he[1].dataId)||he.length>=3&&!ce.session.isInitializer(he[2].dataId))throw new Error("dynamic pad attributes are not allowed");const me=Array.from(he[1].integerData),be=he.length>=3?he[2].floatData[0]:0;return(0,O.createAttributeWithCacheKey)({mode:pe,pads:me,value:be})},Z=(ce,he,pe)=>{const me=U.ShapeUtil.padShape(he.dims.slice(),pe.pads),be=me.length,ge=`
      ${W(ce,he,pe)}
      float process(int[${be}] indices) {
          return padA(indices);
      }`;return{name:"Pad",inputNames:["A"],inputTypes:[q.TextureType.unpacked],output:{dims:me,type:he.type,textureType:q.TextureType.unpacked},shaderSource:ge}},ie=ce=>{if(!ce||ce.length!==1)throw new Error("Pad requires 1 input");if(ce[0].type!=="float32"&&ce[0].type!=="float64")throw new Error("Invalid input type.")},Y=ce=>{if(!ce||ce.length!==2&&ce.length!==3)throw new Error("Pad requires 2 or 3 inputs");if(ce[1].type!=="int32")throw new Error("Invalid input type.");if(ce.length>=3&&ce[2].type==="string")throw new Error("Invalid input type.")},W=(ce,he,pe)=>{const me=(0,G.getGlsl)(ce.session.backend.glContext.version),[be,ge]=ce.calculateTextureWidthAndHeight(he.dims,q.TextureType.unpacked),ve=U.ShapeUtil.computeStrides(he.dims);switch(pe.mode){case"constant":return ne(me,he.dims,ve,be,ge,pe.pads,pe.value);case"reflect":return se(me,he.dims,ve,be,ge,pe.pads);case"edge":return le(me,he.dims,ve,be,ge,pe.pads);default:throw new Error("Invalid mode")}},ne=(ce,he,pe,me,be,ge,ve)=>{const Se=he.length;let Me="";for(let Ee=Se-1;Ee>=0;--Ee)Me+=`
        k = m[${Ee}] - ${ge[Ee]};
        if (k < 0)  return constant;
        if (k >= ${he[Ee]}) return constant;
        offset += k * ${pe[Ee]};
        `;return`
      float padA(int m[${Se}]) {
        const float constant = float(${ve});
        int offset = 0;
        int k = 0;
        ${Me}
        vec2 coords = offsetToCoords(offset, ${me}, ${be});
        float value = getColorAsFloat(${ce.texture2D}(A, coords));
        return value;
      }
      `},se=(ce,he,pe,me,be,ge)=>{const ve=he.length;let Se="";for(let Me=ve-1;Me>=0;--Me)Se+=`
        k = m[${Me}] - ${ge[Me]};
        if (k < 0) { k = -k; }
        {
          const int _2n_1 = ${2*(he[Me]-1)};
          k = int( mod( float(k), float(_2n_1) ) ) ;
          if(k >= ${he[Me]}) { k = _2n_1 - k; }
        }
        offset += k * ${pe[Me]};
        `;return`
      float padA(int m[${ve}]) {
        int offset = 0;
        int k = 0;
        ${Se}
        vec2 coords = offsetToCoords(offset, ${me}, ${be});
        float value = getColorAsFloat(${ce.texture2D}(A, coords));
        return value;
      }
      `},le=(ce,he,pe,me,be,ge)=>{const ve=he.length;let Se="";for(let Me=ve-1;Me>=0;--Me)Se+=`
        k = m[${Me}] - ${ge[Me]};
        if (k < 0)  k = 0;
        if (k >= ${he[Me]}) k = ${he[Me]-1};
        offset += k * ${pe[Me]};
      `;return`
      float padA(int m[${ve}]) {
        int offset = 0;
        int k = 0;
        ${Se}
        vec2 coords = offsetToCoords(offset, ${me}, ${be});
        float value = getColorAsFloat(${ce.texture2D}(A, coords));
        return value;
      }
      `}},2143:(F,w,D)=>{Object.defineProperty(w,"__esModule",{value:!0}),w.globalMaxPool=w.parseMaxPoolAttributes=w.maxPool=w.parseGlobalAveragePoolAttributes=w.globalAveragePool=w.parseAveragePoolAttributes=w.averagePool=void 0;const O=D(246),U=D(2517),G=D(2039);w.averagePool=(le,ce,he)=>{Y(ce);const pe={name:"AveragePool",inputNames:["X"],inputTypes:[G.TextureType.unpacked],cacheHint:he.cacheKey};return[le.run(Object.assign(Object.assign({},pe),{get:()=>q(ce,pe,!1,he)}),ce)]},w.parseAveragePoolAttributes=le=>{const ce=le.attributes.getString("auto_pad","NOTSET"),he=le.attributes.getInt("ceil_mode",0),pe=le.attributes.getInt("count_include_pad",0)!==0,me=le.attributes.getInts("kernel_shape"),be=le.attributes.getInts("strides",[]),ge=le.attributes.getInts("pads",[]);if(he!==0)throw new Error("using ceil() in shape computation is not yet supported for AveragePool");return(0,O.createAttributeWithCacheKey)({autoPad:ce,ceilMode:he,countIncludePad:pe,kernelShape:me,strides:be,pads:ge})};const q=(le,ce,he,pe)=>{const[me,be]=ee(le,pe,he),ge=U.ShapeUtil.size(me.kernelShape);let ve="";me.countIncludePad?ve+=`value /= float(${ge});`:ve+=`value /= float(${ge} - pad);`;const Se=`
        ${W(le[0].dims,me,"value += _X(x);",ve,"0.0")}
      `;return Object.assign(Object.assign({},ce),{output:{dims:be,type:le[0].type,textureType:G.TextureType.unpacked},shaderSource:Se})};w.globalAveragePool=(le,ce,he)=>{Y(ce);const pe={name:"GlobalAveragePool",inputNames:["X"],inputTypes:[G.TextureType.unpacked],cacheHint:`${he.countIncludePad}`};return[le.run(Object.assign(Object.assign({},pe),{get:()=>q(ce,pe,!0,he)}),ce)]},w.parseGlobalAveragePoolAttributes=le=>{const ce=le.attributes.getInt("count_include_pad",0)!==0;return(0,O.createAttributeWithCacheKey)({autoPad:"",ceilMode:0,countIncludePad:ce,kernelShape:[],strides:[],pads:[]})},w.maxPool=(le,ce,he)=>{Y(ce);const pe={name:"MaxPool",inputNames:["X"],inputTypes:[G.TextureType.unpacked],cacheHint:he.cacheKey};return[le.run(Object.assign(Object.assign({},pe),{get:()=>K(ce,pe,!1,he)}),ce)]},w.parseMaxPoolAttributes=le=>{const ce=le.attributes.getString("auto_pad","NOTSET"),he=le.attributes.getInt("ceil_mode",0),pe=le.attributes.getInts("kernel_shape"),me=le.attributes.getInts("strides",[]),be=le.attributes.getInts("pads",[]),ge=le.attributes.getInt("storage_order",0),ve=le.attributes.getInts("dilations",[]);if(ge!==0)throw new Error("column major storage order is not yet supported for MaxPool");if(he!==0)throw new Error("using ceil() in shape computation is not yet supported for MaxPool");return(0,O.createAttributeWithCacheKey)({autoPad:ce,ceilMode:he,countIncludePad:!1,kernelShape:pe,strides:me,pads:be,storageOrder:ge,dilations:ve})};const K=(le,ce,he,pe)=>{const[me,be]=ee(le,pe,he),ge=`
      ${W(le[0].dims,me,`
      value = max(_X(x), value);
    `,"","-1e5")}
    `;return Object.assign(Object.assign({},ce),{output:{dims:be,type:le[0].type,textureType:G.TextureType.unpacked},shaderSource:ge})},ee=(le,ce,he)=>{const pe=le[0].dims.slice(),me=Object.hasOwnProperty.call(ce,"dilations"),be=ce.kernelShape.slice(),ge=ce.strides.slice(),ve=me?ce.dilations.slice():[],Se=ce.pads.slice();U.PoolConvUtil.adjustPoolAttributes(he,pe,be,ge,ve,Se);const Me=U.PoolConvUtil.computePoolOutputShape(he,pe,ge,ve,be,Se,ce.autoPad),Ee=Object.assign({},ce);return me?Object.assign(Ee,{kernelShape:be,strides:ge,pads:Se,dilations:ve,cacheKey:ce.cacheKey}):Object.assign(Ee,{kernelShape:be,strides:ge,pads:Se,cacheKey:ce.cacheKey}),[Ee,Me]},Z={autoPad:"",ceilMode:0,countIncludePad:!1,kernelShape:[],strides:[],pads:[],storageOrder:0,dilations:[],cacheKey:""},ie={name:"GlobalMaxPool",inputNames:["X"],inputTypes:[G.TextureType.unpacked]};w.globalMaxPool=(le,ce)=>(Y(ce),[le.run(Object.assign(Object.assign({},ie),{get:()=>K(ce,ie,!0,Z)}),ce)]);const Y=le=>{if(!le||le.length!==1)throw new Error("Pool ops requires 1 input.");if(le[0].type!=="float32"&&le[0].type!=="float64")throw new Error("Invalid input type.")},W=(le,ce,he,pe,me)=>{const be=le.length;if(ce.kernelShape.length<=2){const ge=ce.kernelShape[ce.kernelShape.length-1],ve=ce.strides[ce.strides.length-1],Se=ce.pads[ce.pads.length/2-1],Me=ce.pads[ce.pads.length-1],Ee=le[be-1];let we="",Re="",Le="";if(we=Se+Me!==0?`
          for (int i = 0; i < ${ge}; i++) {
            x[${be} - 1] = indices[${be} - 1] * ${ve} - ${Se} + i;
            if (x[${be} - 1] < 0 || x[${be} - 1] >= ${Ee}) {
              pad++;
              continue;
            }
            ${he}
          }`:`
          for (int i = 0; i < ${ge}; i++) {
            x[${be} - 1] = indices[${be} - 1] * ${ve} - ${Se} + i;
            ${he}
          }`,ce.kernelShape.length===2){const Ne=ce.kernelShape[ce.kernelShape.length-2],Oe=ce.strides[ce.strides.length-2],Pe=ce.pads[ce.pads.length/2-2],Ce=ce.pads[ce.pads.length-2],Be=le[be-2];Re=Pe+Ce!==0?`
            for (int j = 0; j < ${Ne}; j++) {
              x[${be} - 2] = indices[${be} - 2] * ${Oe} - ${Pe} + j;
              if (x[${be} - 2] < 0 || x[${be} - 2] >= ${Be}) {
                pad+= ${ge};
                continue;
              }
          `:`
            for (int j = 0; j < ${Ne}; j++) {
              x[${be} - 2] = indices[${be} - 2] * ${Oe} - ${Pe} + j;
            `,Le=`
          }
        `}return`
        float process(int indices[${be}]) {
          int x[${be}];
          copyVec(indices, x);

          float value = ${me};
          int pad = 0;
          ${Re}
          ${we}
          ${Le}
          ${pe}
          return value;
        }
      `}{const ge=U.ShapeUtil.size(ce.kernelShape),ve=U.ShapeUtil.computeStrides(ce.kernelShape),Se=ve.length,Me=ce.pads.length,Ee=se(Se),we=ne(le,"inputDims"),Re=ne(ce.pads,"pads"),Le=ne(ve,"kernelStrides"),Ne=ne(ce.strides,"strides");let Oe="";return Oe=ce.pads.reduce(((Pe,Ce)=>Pe+Ce))?`
            if (x[j] >= inputDims[j] || x[j] < 0) {
              pad++;
              isPad = true;
              break;
            }
          }
          if (!isPad) {
            ${he}
          }`:`
          }
          ${he}
        `,`
        ${Ee}
        float process(int indices[${be}]) {
          int x[${be}];
          copyVec(indices, x);
          int offset[${Se}];
          int pads[${Me}];
          int inputDims[${be}];
          int kernelStrides[${Se}];
          int strides[${Se}];
          ${Re}
          ${we}
          ${Ne}
          ${Le}

          float value = ${me};
          int pad = 0;
          bool isPad = false;
          for (int i = 0; i < ${ge}; i++) {
            offsetToIndices(i, kernelStrides, offset);
            isPad = false;
            for (int j = ${be} - ${Se}; j < ${be}; j++) {
              x[j] = indices[j] * strides[j - ${be} + ${Se}]
                + offset[j - ${be} + ${Se}] - pads[j - 2];
              ${Oe}
          }
          ${pe}

          return value;
        }
      `}},ne=(le,ce)=>{let he="";for(let pe=0;pe<le.length;pe++)he+=`
      ${ce}[${pe}] = ${le[pe]};
    `;return he},se=le=>`
  void offsetToIndices(int offset, int[${le}] strides, out int[${le}] indices) {
    if (${le} == 0) {
      return;
    }
    for (int i = 0; i < ${le} - 1; ++i) {
      indices[i] = offset / strides[i];
      offset -= indices[i] * strides[i];
    }
    indices[${le} - 1] = offset;
  }`},4939:(F,w,D)=>{Object.defineProperty(w,"__esModule",{value:!0}),w.reduceLogSumSquare=w.reduceLogSum=w.reduceProd=w.reduceMin=w.reduceMax=w.reduceMean=w.reduceSum=w.parseReduceAttributes=void 0;const O=D(246),U=D(782),G=D(2517),q=D(2039),K=(ie,Y,W,ne,se)=>{Z(Y);const le={name:ne,inputNames:["A"],inputTypes:[q.TextureType.unpacked]};return[ie.run(Object.assign(Object.assign({},le),{cacheHint:W.cacheKey,get:()=>ee(ie,Y,W,ne,se,le)}),Y)]};w.parseReduceAttributes=ie=>{const Y=ie.attributes.getInts("axes",[]),W=ie.attributes.getInt("keepdims",1)===1;return(0,O.createAttributeWithCacheKey)({axes:Y,keepDims:W})};const ee=(ie,Y,W,ne,se,le)=>{const ce=[],he=Y[0].dims.length||1,pe=[],me=G.ShapeUtil.normalizeAxes(W.axes,Y[0].dims.length),be=se(Y,me);let ge=be[1];for(let Se=0;Se<Y[0].dims.length;Se++)me.indexOf(Se)>=0||me.length===0?(W.keepDims&&ce.push(1),ge=`
          for(int j${Se} = 0; j${Se} < ${Y[0].dims[Se]}; j${Se}++) {
            inputIdx[${Se}] = j${Se};
            ${ge}
          }`):(pe.push(`inputIdx[${Se}] = outputIdx[${ce.length}];`),ce.push(Y[0].dims[Se]));const ve=`
      float process(int outputIdx[${ce.length||1}]) {
        float value;                 // final result
        int inputIdx[${he}];      // addressing input data
        ${pe.join(`
`)}
        ${be[0]}       // init ops for reduce max/min
        ${ge}
        ${be[2]}       // final computation for reduce mean
        return value;
      }`;return Object.assign(Object.assign({},le),{output:{dims:ce,type:Y[0].type,textureType:q.TextureType.unpacked},shaderSource:ve})},Z=ie=>{if(!ie||ie.length!==1)throw new Error("Reduce op requires 1 input.");if(U.NUMBER_TYPES.indexOf(ie[0].type)===-1)throw new Error("Invalid input type.")};w.reduceSum=(ie,Y,W)=>K(ie,Y,W,"ReduceSum",(()=>["value = 0.0;","value += _A(inputIdx);",""])),w.reduceMean=(ie,Y,W)=>K(ie,Y,W,"ReduceMean",((ne,se)=>{let le=1;for(let ce=0;ce<ne[0].dims.length;ce++)(se.indexOf(ce)>=0||se.length===0)&&(le*=ne[0].dims[ce]);return["value = 0.0;","value += _A(inputIdx);",`value /= ${le}.;`]})),w.reduceMax=(ie,Y,W)=>K(ie,Y,W,"ReduceMax",((ne,se)=>{const le=[];for(let ce=0;ce<ne[0].dims.length;ce++)(se.indexOf(ce)>=0||se.length===0)&&le.push(`inputIdx[${ce}] = 0;`);return[`${le.join(`
`)}
value = _A(inputIdx);`,"value = max(value, _A(inputIdx));",""]})),w.reduceMin=(ie,Y,W)=>K(ie,Y,W,"ReduceMin",((ne,se)=>{const le=[];for(let ce=0;ce<ne[0].dims.length;ce++)(se.indexOf(ce)>=0||se.length===0)&&le.push(`inputIdx[${ce}] = 0;`);return[`${le.join(`
`)}
value = _A(inputIdx);`,"value = min(value, _A(inputIdx));",""]})),w.reduceProd=(ie,Y,W)=>K(ie,Y,W,"ReduceProd",(()=>["value = 1.0;","value *= _A(inputIdx);",""])),w.reduceLogSum=(ie,Y,W)=>K(ie,Y,W,"ReduceLogSum",(()=>["value = 0.0;","value += _A(inputIdx);","value = log(value);"])),w.reduceLogSumSquare=(ie,Y,W)=>K(ie,Y,W,"ReduceLogSumSquare",(()=>["float t; value = 0.0;","t = _A(inputIdx); value += t * t;",""]))},7019:(F,w,D)=>{Object.defineProperty(w,"__esModule",{value:!0}),w.isReshapeCheap=w.processDims3D=w.createPackedReshape3DProgramInfoLoader=void 0;const O=D(2517),U=D(5060),G=D(2039),q=D(2827);w.createPackedReshape3DProgramInfoLoader=(K,ee,Z)=>{const ie=(Y=>({name:"Reshape (packed)",inputTypes:[G.TextureType.packed],inputNames:["A"],cacheHint:`${Y}`}))(Z);return Object.assign(Object.assign({},ie),{get:()=>((Y,W,ne,se)=>{const le=W.dims,ce=se;let he="";for(let be=0;be<4;be++){let ge="";switch(be){case 0:ge="outputCoords = rc;";break;case 1:ge="outputCoords = ivec3(rc.x, rc.y+1, rc.z);";break;case 2:ge="outputCoords = ivec3(rc.x, rc.y, rc.z+1);";break;case 3:ge="outputCoords = ivec3(rc.x, rc.y+1, rc.z+1);";break;default:throw new Error}he+=`
        ${ge}
        ${be>0?"if(outputCoords.y < rows && outputCoords.z < cols){":""}
          int flattenedIndex = getFlattenedIndex(outputCoords);

          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flattenedIndex);
          vec2 innerDims = vec2(float(inputRC.y),float(inputRC.z));

          result[${be}] = getChannel(getA(inputRC.x, inputRC.y, inputRC.z), innerDims);

        ${be>0?"}":""}
      `}const pe=(0,U.getGlsl)(Y.session.backend.glContext.version),me=`
      ${(function(be){const ge=O.ShapeUtil.computeStrides(be),ve=["b","r","c"],Se="index";return`
    ivec3 inputCoordsFromReshapedOutCoords(int index) {
      ${ge.map(((Me,Ee)=>`int ${ve[Ee]} = ${Se} / ${Me}; ${Ee===ge.length-1?`int ${ve[Ee+1]} = ${Se} - ${ve[Ee]} * ${Me}`:`index -= ${ve[Ee]} * ${Me}`};`)).join("")}
      return ivec3(b, r, c);
    }
  `})(le)}
      ${(function(be){const ge=O.ShapeUtil.computeStrides(be);return`
  int getFlattenedIndex(ivec3 coords) {
    // reverse y, z order
    return coords.x * ${ge[0]} + coords.z * ${ge[1]} + coords.y;
  }
`})(ce)}
      ${(0,q.unpackFromChannel)()}

      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0.0);

        ivec3 outputCoords;
        int rows = ${ce[2]};
        int cols = ${ce[1]};

        ${he}
        ${pe.output} = result;
      }
    `;return Object.assign(Object.assign({},ne),{output:{dims:ce,type:W.type,textureType:G.TextureType.packed},shaderSource:me,hasMain:!0})})(K,ee,ie,Z)})},w.processDims3D=function(K){if(K.length===0)return[1,1,1];let ee=1;for(let Z=0;Z<K.length-2;++Z)ee*=K[Z];return[ee,K.length>1?K[K.length-2]:1,K[K.length-1]]},w.isReshapeCheap=function(K,ee){let Z=!1;return Z=K.length===0||ee.length===0||(K.length<2||ee.length<2?K[K.length-1]===ee[ee.length-1]:K[K.length-1]===ee[ee.length-1]&&K[K.length-2]===ee[ee.length-2]),Z}},718:(F,w,D)=>{Object.defineProperty(w,"__esModule",{value:!0}),w.reshape=void 0;const O=D(2517);w.reshape=(U,G)=>{const q=O.ShapeUtil.calculateReshapedDims(G[0].dims,G[1].integerData);return U.session.pack?[U.reshapePacked(G[0],q)]:[U.reshapeUnpacked(G[0],q)]}},2268:(F,w,D)=>{Object.defineProperty(w,"__esModule",{value:!0}),w.parseResizeAttributesV11=w.parseResizeAttributesV10=w.resize=void 0;const O=D(5060),U=D(2039),G=D(9390),q=D(2827),K=D(9793),ee={name:"Resize",inputNames:["A"],inputTypes:[U.TextureType.packed]};w.resize=(ne,se,le)=>((0,K.validateInputs)(se,le),[ne.run(Object.assign(Object.assign({},ee),{cacheHint:le.cacheKey,get:()=>Z(ne,se,le)}),se)]),w.parseResizeAttributesV10=ne=>(0,K.parseUpsampleAttributes)(ne,10),w.parseResizeAttributesV11=ne=>(0,K.parseUpsampleAttributes)(ne,11);const Z=(ne,se,le)=>{const ce=(0,O.getGlsl)(ne.session.backend.glContext.version),[he,pe]=ie(se,le);if(he.every((Oe=>Oe===1))&&le.coordinateTransformMode!=="tf_crop_and_resize")return Object.assign(Object.assign({},ee),{output:{dims:pe,type:se[0].type,textureType:U.TextureType.packed},hasMain:!0,shaderSource:`void main() {
                    vec4 v = ${ce.texture2D}(X, TexCoords);
                    ${ce.output} = v;
                }`});const me=pe.length;if(me<2)throw new Error(`output dimension should be at least 2, but got ${me}`);const be=pe[me-2],ge=pe[me-1],ve=se[0].dims;if(me!==ve.length)throw new Error(`output dimension should match input ${ve.length}, but got ${me}`);const Se=ve[me-2],Me=ve[me-1],Ee=he[me-2],we=he[me-1];let Re="";if(le.mode!=="linear")throw new Error(`resize (packed) does not support mode: '${le.mode}'`);switch(le.coordinateTransformMode){case"asymmetric":Re=`
                    vec4 getSourceFracIndex(ivec4 coords) {
                        return vec4(coords) / scaleWHWH;
                    }
                `;break;case"half_pixel":Re=`
                    vec4 getSourceFracIndex(ivec4 coords) {
                        return (vec4(coords) + 0.5) / scaleWHWH - 0.5;
                    }
                `;break;case"pytorch_half_pixel":Re=`
                    vec4 getSourceFracIndex(ivec4 coords) {
                        vec4 fcoords = vec4(coords);
                        return vec4(
                            ${ge}.0 > 1.0 ? (fcoords.x + 0.5) / scaleWHWH.x - 0.5 : 0.0,
                            ${be}.0 > 1.0 ? (fcoords.y + 0.5) / scaleWHWH.y - 0.5 : 0.0,
                            ${ge}.0 > 1.0 ? (fcoords.z + 0.5) / scaleWHWH.z - 0.5 : 0.0,
                            ${be}.0 > 1.0 ? (fcoords.w + 0.5) / scaleWHWH.w - 0.5 : 0.0
                          );
                    }
                `;break;case"align_corners":Re=`
                    vec4 getSourceFracIndex(ivec4 coords) {
                        vec4 resized = vec4(${ge}.0 - 1.0, ${be}.0 - 1.0, ${ge}.0 - 1.0,
                            ${be}.0 - 1.0);
                        vec4 original = vec4(${Me}.0 - 1.0, ${Se}.0 - 1.0, ${Me}.0 - 1.0,
                            ${Se}.0 - 1.0);
                        vec4 new_scale = original / resized;
                        return vec4(coords) * new_scale;
                    }
                `;break;default:throw new Error(`resize (packed) does not support coordinateTransformMode:                                 '${le.coordinateTransformMode}'`)}const Le=(0,G.getCoordsDataType)(me),Ne=`
            const vec2 inputWH = vec2(${Se}.0, ${Me}.0);
            const vec4 scaleWHWH = vec4(float(${Ee}), float(${we}), float(${Ee}), float(${we}));
            ${(0,q.unpackFromChannel)()}
            ${Re}
            float getAValue(int x10, int r, int c, int d) {
                return getChannel(getA(x10, r, c, d), vec2(c, d));
            }
            void main() {
                ${Le} rc = getOutputCoords();

                int batch = rc[0];
                int depth = rc[1];

                // retrieve the 4 coordinates that is used in the 4 packed output values.
                ivec4 coords = ivec4(rc.wz, rc.w + 1, rc.z + 1);

                // calculate the source index in fraction
                vec4 sourceFrac = getSourceFracIndex(coords);

                // get the lower and upper bound of the 4 values that will be packed into one texel.
                ivec4 x00 = ivec4(max(sourceFrac.xy, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.xy)));
                ivec4 x01 = ivec4(max(sourceFrac.xw, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.xw)));
                ivec4 x10 = ivec4(max(sourceFrac.zy, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.zy)));
                ivec4 x11 = ivec4(max(sourceFrac.zw, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.zw)));

                bool hasNextRow = rc.w < ${be-1};
                bool hasNextCol = rc.z < ${ge-1};

                // pack x00, x01, x10, x11's top-left corner into one vec4 structure
                vec4 topLeft = vec4(
                    getAValue(batch, depth, x00.x, x00.y),
                    hasNextCol ? getAValue(batch, depth, x01.x, x01.y) : 0.0,
                    hasNextRow ? getAValue(batch, depth, x10.x, x10.y) : 0.0,
                    (hasNextRow && hasNextCol) ? getAValue(batch, depth, x11.x, x11.y) : 0.0);

                // pack x00, x01, x10, x11's top-right corner into one vec4 structure
                vec4 topRight = vec4(
                    getAValue(batch, depth, x00.x, x00.w),
                    hasNextCol ? getAValue(batch, depth, x01.x, x01.w) : 0.0,
                    hasNextRow ? getAValue(batch, depth, x10.x, x10.w) : 0.0,
                    (hasNextRow && hasNextCol) ? getAValue(batch, depth, x11.x, x11.w) : 0.0);

                // pack x00, x01, x10, x11's bottom-left corner into one vec4 structure
                vec4 bottomLeft = vec4(
                    getAValue(batch, depth, x00.z, x00.y),
                    hasNextCol ? getAValue(batch, depth, x01.z, x01.y) : 0.0,
                    hasNextRow ? getAValue(batch, depth, x10.z, x10.y) : 0.0,
                    (hasNextRow && hasNextCol) ? getAValue(batch, depth, x11.z, x11.y) : 0.0);

                // pack x00, x01, x10, x11's bottom-right corner into one vec4 structure
                vec4 bottomRight = vec4(
                    getAValue(batch, depth, x00.z, x00.w),
                    hasNextCol ? getAValue(batch, depth, x01.z, x01.w) : 0.0,
                    hasNextRow ? getAValue(batch, depth, x10.z, x10.w) : 0.0,
                    (hasNextRow && hasNextCol) ? getAValue(batch, depth, x11.z, x11.w) : 0.0);

                // calculate the interpolation fraction on u and v direction
                vec4 frac = vec4(sourceFrac) - floor(sourceFrac);
                vec4 clampFrac = clamp(frac, vec4(0.0), vec4(1.0));

                vec4 top = mix(topLeft, topRight, clampFrac.ywyw);
                vec4 bottom = mix(bottomLeft, bottomRight, clampFrac.ywyw);
                vec4 newValue = mix(top, bottom, clampFrac.xxzz);

                ${ce.output} = vec4(newValue);
            }
        `;return Object.assign(Object.assign({},ee),{output:{dims:pe,type:se[0].type,textureType:U.TextureType.packed},hasMain:!0,shaderSource:Ne})},ie=(ne,se)=>{const le=ne[0].dims;let ce,he=se.scales;if(he.length===0){const me=ne[se.scalesInputIdx];if(me&&me.size!==0){if(ne[se.sizesInputIdx])throw new Error("Only one of scales or sizes must be provided as input.");he=Y(me,se.mode,se.isResize)}else{const be=ne[se.sizesInputIdx];if(!be||be.size===0)throw new Error("Either scales or sizes MUST be provided as input.");ce=Array.from(be.integerData),he=W(ce,le,se.mode,se.isResize)}}else if(ne[se.sizesInputIdx])throw new Error("Only one of scales or sizes must be provided as input.");const pe=ce||le.map(((me,be)=>Math.floor(me*he[be])));return[he,pe]},Y=(ne,se,le)=>{const ce=Array.from(ne.floatData);return(0,K.scalesValidation)(ce,se,le),ce},W=(ne,se,le,ce)=>{const he=se.length,pe=new Array(he);for(let me=0,be=he;me<be;me++)if(se[me]===0){if(ne[me]!==0)throw new Error("Input dim is zero but required output dim is non-zero.");pe[me]=1}else pe[me]=ne[me]/se[me];return(0,K.scalesValidation)(pe,le,ce),pe}},8117:(F,w,D)=>{Object.defineProperty(w,"__esModule",{value:!0}),w.shape=void 0;const O=D(9162);w.shape=(G,q)=>(U(q),[new O.Tensor([q[0].dims.length],"int32",void 0,void 0,new Int32Array(q[0].dims))]);const U=G=>{if(!G||G.length!==1)throw new Error("Shape requires 1 input.")}},2278:(F,w,D)=>{Object.defineProperty(w,"__esModule",{value:!0}),w.sliceV10=w.parseSliceAttributes=w.slice=void 0;const O=D(246),U=D(782),G=D(2517),q=D(2039),K={name:"Slice",inputNames:["A"],inputTypes:[q.TextureType.unpacked]};w.slice=(W,ne,se)=>(Z(ne),[W.run(Object.assign(Object.assign({},K),{cacheHint:se.cacheKey,get:()=>ee(W,ne[0],se)}),ne)]),w.parseSliceAttributes=W=>{const ne=W.attributes.getInts("starts"),se=W.attributes.getInts("ends"),le=W.attributes.getInts("axes",[]);return(0,O.createAttributeWithCacheKey)({starts:ne,ends:se,axes:le})};const ee=(W,ne,se)=>{const le=se.axes.length===0?ne.dims.slice(0).map(((ve,Se)=>Se)):se.axes,ce=G.ShapeUtil.normalizeAxes(le,ne.dims.length),he=se.starts.map(((ve,Se)=>ve>ne.dims[ce[Se]]-1?ne.dims[ce[Se]]:G.ShapeUtil.normalizeAxis(ve,ne.dims[ce[Se]]))),pe=se.ends.map(((ve,Se)=>ve>ne.dims[ce[Se]]-1?ne.dims[ce[Se]]:G.ShapeUtil.normalizeAxis(ve,ne.dims[ce[Se]]))),me=ne.dims.slice(),be=[];for(let ve=0;ve<ce.length;ve++)me[ce[ve]]=pe[ve]-he[ve],he[ve]>0&&be.push(`outputIdx[${ce[ve]}] += ${he[ve]};`);const ge=`
      float process(int outputIdx[${me.length}]) {
        ${be.join(`
      `)}
        return _A(outputIdx);
      }`;return Object.assign(Object.assign({},K),{output:{dims:me,type:ne.type,textureType:q.TextureType.unpacked},shaderSource:ge})},Z=W=>{if(!W||W.length!==1)throw new Error("Slice requires 1 input.");if(U.NUMBER_TYPES.indexOf(W[0].type)===-1)throw new Error("Invalid input type.")};w.sliceV10=(W,ne)=>{Y(ne);const se=ie(W,ne);return[W.run(Object.assign(Object.assign({},K),{cacheHint:se.cacheKey,get:()=>ee(W,ne[0],se)}),[ne[0]])]};const ie=(W,ne)=>{if(!W.session.isInitializer(ne[1].dataId)||!W.session.isInitializer(ne[2].dataId)||ne.length>=4&&!W.session.isInitializer(ne[3].dataId)||ne.length>=5&&!W.session.isInitializer(ne[4].dataId))throw new Error("dynamic slice attributes are not allowed");if(ne.length>=5&&ne[4].integerData.some((he=>he!==1)))throw new Error("currently non-1 steps is not supported for Slice");const se=Array.from(ne[1].integerData),le=Array.from(ne[2].integerData),ce=ne.length>=4?Array.from(ne[3].integerData):[];return{starts:se,ends:le,axes:ce,cacheKey:`${ce};${se};${le}`}},Y=W=>{if(!W||W.length<3||W.length>5)throw new Error("Invalid input number.");if(W[1].type!=="int32"||W[1].dims.length!==1)throw new Error("Invalid input type.");if(W[2].type!=="int32"||W[2].dims.length!==1)throw new Error("Invalid input type.");if(W.length>=4&&(W[3].type!=="int32"||W[3].dims.length!==1))throw new Error("Invalid input type.");if(W.length>=5&&(W[4].type!=="int32"||W[4].dims.length!==1))throw new Error("Invalid input type.")}},5524:(F,w,D)=>{Object.defineProperty(w,"__esModule",{value:!0}),w.softmaxV13=w.parseSoftmaxAttributesV13=w.parseSoftmaxAttributes=w.softmax=void 0;const O=D(246),U=D(2517),G=D(5060),q=D(2039),K=D(3738),ee={name:"SoftmaxComputeMax",inputNames:["A"],inputTypes:[q.TextureType.unpacked]},Z={name:"SoftmaxComputeScale",inputNames:["A","Max"],inputTypes:[q.TextureType.unpacked,q.TextureType.unpacked]},ie={name:"SoftMax",inputNames:["A","Max","Norm"],inputTypes:[q.TextureType.unpacked,q.TextureType.unpacked,q.TextureType.unpacked]};w.softmax=(ce,he,pe)=>{le(he);const me=he[0].dims.slice(),be=U.ShapeUtil.normalizeAxis(pe.axis,me.length),ge=U.ShapeUtil.sizeToDimension(me,be),ve=U.ShapeUtil.sizeFromDimension(me,be);return Y(ce,he,pe,ge,ve)},w.parseSoftmaxAttributes=ce=>(0,O.createAttributeWithCacheKey)({axis:ce.attributes.getInt("axis",1)}),w.parseSoftmaxAttributesV13=ce=>(0,O.createAttributeWithCacheKey)({axis:ce.attributes.getInt("axis",-1)}),w.softmaxV13=(ce,he,pe)=>{le(he);const me=he[0].dims.slice(),be=U.ShapeUtil.normalizeAxis(pe.axis,me.length),ge=me.length,ve=be!==ge-1,Se=[];let Me,Ee=[],we=[];ve&&(Ee=Array.from({length:ge}).map(((Oe,Pe)=>Pe)),Ee[be]=ge-1,Ee[ge-1]=be,Ee.map((Oe=>Se.push(me[Oe]))),Me=(0,O.createAttributeWithCacheKey)({perm:Ee}),we=(0,K.transpose)(ce,he,Me));const Re=ve?U.ShapeUtil.sizeToDimension(Se,ge-1):U.ShapeUtil.sizeToDimension(me,ge-1),Le=ve?U.ShapeUtil.sizeFromDimension(Se,ge-1):U.ShapeUtil.sizeFromDimension(me,ge-1),Ne=Y(ce,ve?we:he,pe,Re,Le);return ve?(0,K.transpose)(ce,Ne,Me):Ne};const Y=(ce,he,pe,me,be)=>{const ge=W(ce,he[0],me,be,[me]),ve=ce.run(Object.assign(Object.assign({},ee),{cacheHint:pe.cacheKey,get:()=>ge}),he),Se=ne(ce,he[0],me,be,ge.output.dims,[me]),Me=ce.run(Object.assign(Object.assign({},Z),{cacheHint:pe.cacheKey,get:()=>Se}),[he[0],ve]),Ee=se(ce,he[0],me,be,ge.output.dims,Se.output.dims);return[ce.run(Object.assign(Object.assign({},ie),{cacheHint:pe.cacheKey,get:()=>Ee}),[he[0],ve,Me])]},W=(ce,he,pe,me,be)=>{const[ge,ve]=ce.calculateTextureWidthAndHeight(he.dims,q.TextureType.unpacked),Se=be.length;if(pe<1||me<1)throw new Error("Logical row count N and feature count D must be greater than or equal to 1");if(be.length!==1)throw new Error("Dimensionality of the output should be 1");if(be[0]!==pe)throw new Error("Shape of the output should be equal to logical row count");const Me=(0,G.getGlsl)(ce.session.backend.glContext.version),Ee=`
      float process(int[${Se}] indices) {
        int logical_row_start_offset = indices[0] * ${me};

        float max = getColorAsFloat(${Me.texture2D}(A, offsetToCoords(logical_row_start_offset, ${ge},
        ${ve} )));
        for(int i=1; i<${me}; ++i)
        {
          float current = getColorAsFloat(${Me.texture2D}(A, offsetToCoords(logical_row_start_offset + i,
            ${ge}, ${ve})));
          if(current > max)
          max = current;
        }

        return max;
      }`;return Object.assign(Object.assign({},ee),{output:{dims:be,type:he.type,textureType:q.TextureType.unpacked},shaderSource:Ee})},ne=(ce,he,pe,me,be,ge)=>{const[ve,Se]=ce.calculateTextureWidthAndHeight(he.dims,q.TextureType.unpacked),Me=ge.length;if(pe<1||me<1)throw new Error("Logical row count N and feature count D must be greater than or equal to 1");if(ge.length!==1)throw new Error("Dimensionality of the output should be 1");if(ge[0]!==pe)throw new Error("Shape of the output should be equal to logical row count");if(be.length!==1)throw new Error("Dimensionality of the intermediate results should be 1");if(be[0]!==pe)throw new Error("Shape of the intermediate results should be equal to logical row count");const Ee=`
      float process(int[${Me}] indices) {
        int logical_row_start_offset = indices[0] * ${me};

        float norm_factor = 0.0;
        float max = _Max(indices);
        for(int i=0; i<${me}; ++i)
        {
          norm_factor += exp(getColorAsFloat(${(0,G.getGlsl)(ce.session.backend.glContext.version).texture2D}(A, offsetToCoords(logical_row_start_offset + i,
            ${ve}, ${Se}))) - max);
        }

        return norm_factor;
      }`;return Object.assign(Object.assign({},Z),{output:{dims:ge,type:he.type,textureType:q.TextureType.unpacked},shaderSource:Ee})},se=(ce,he,pe,me,be,ge)=>{const[ve,Se]=ce.calculateTextureWidthAndHeight(he.dims,q.TextureType.unpacked),Me=he.dims.length;if(pe<1||me<1)throw new Error("Logical row count N and feature count D must be greater than or equal to 1");if(be.length!==1||ge.length!==1)throw new Error("Dimensionality of the intermediate results should be 1");if(be[0]!==pe||ge[0]!==pe)throw new Error("Shape of the intermediate results should be equal to logical row count");const Ee=`
      float process(int[${Me}] indices) {

      // get offset of current logical tensor index from the 2-D texture coordinates (TexCoords)
      int offset = coordsToOffset(TexCoords, ${ve}, ${Se});

      //determine the logical row for this index
      int logical_row_index[1];
      logical_row_index[0] = offset / ${me};

      float norm_factor = _Norm(logical_row_index);

      // avoid possible division by 0
      // if norm_facor is 0, all elements are zero
      // if so, return 0
      if(norm_factor == 0.0)
        return 0.0;

      return exp(_A(indices) - _Max(logical_row_index)) / norm_factor;
    }`;return Object.assign(Object.assign({},ie),{output:{dims:he.dims,type:he.type,textureType:q.TextureType.unpacked},shaderSource:Ee})},le=ce=>{if(!ce||ce.length!==1)throw new Error("Softmax requires 1 input.");if(ce[0].type!=="float32"&&ce[0].type!=="float64")throw new Error("Invalid input type")}},5975:(F,w,D)=>{Object.defineProperty(w,"__esModule",{value:!0}),w.parseSplitAttributes=w.split=void 0;const O=D(246),U=D(2517),G=D(2039),q={name:"Split",inputNames:["A"],inputTypes:[G.TextureType.unpacked]};w.split=(ie,Y,W)=>{Z(Y);const ne=U.ShapeUtil.normalizeAxis(W.axis,Y[0].dims.length),se=K(ie,Y,ne,W),le=[];for(let ce=0;ce<se;++ce)le.push(ie.run(Object.assign(Object.assign({},q),{cacheHint:`${W.cacheKey};${ce}`,get:()=>ee(ie,Y[0],W,ne,ce)}),Y));return le},w.parseSplitAttributes=ie=>{const Y=ie.attributes.getInt("axis",0),W=ie.attributes.getInts("split",[]),ne=ie.outputs.length;return(0,O.createAttributeWithCacheKey)({axis:Y,split:W,numOutputs:ne})};const K=(ie,Y,W,ne)=>{const[,se]=U.SplitUtil.splitShape(Y[0].dims,W,ne.split,ne.numOutputs);return se.length},ee=(ie,Y,W,ne,se)=>{const[le,ce]=U.SplitUtil.splitShape(Y.dims,ne,W.split,W.numOutputs),he=ce[se],pe=le[se],me=`
      float process(int indices[${pe.length}]) {
        indices[${ne}] += ${he};
        return _A(indices);
      }
    `;return Object.assign(Object.assign({},q),{cacheHint:`${W.cacheKey}:${se}`,output:{dims:pe,type:Y.type,textureType:G.TextureType.unpacked},shaderSource:me})},Z=ie=>{if(!ie||ie.length!==1)throw new Error("Split requires one input.");if(ie[0].type!=="int8"&&ie[0].type!=="uint8"&&ie[0].type!=="int16"&&ie[0].type!=="uint16"&&ie[0].type!=="int32"&&ie[0].type!=="uint32"&&ie[0].type!=="float32"&&ie[0].type!=="float64"&&ie[0].type!=="bool")throw new Error("Invalid input type.")}},3933:(F,w,D)=>{Object.defineProperty(w,"__esModule",{value:!0}),w.parseSqueezeAttributes=w.squeezeV13=w.squeeze=void 0;const O=D(2517);w.squeeze=(q,K,ee)=>{U(K);const Z=O.ShapeUtil.squeezeShape(K[0].dims,ee);return[q.reshapeUnpacked(K[0],Z)]},w.squeezeV13=(q,K)=>(G(K),(0,w.squeeze)(q,[K[0]],Array.from(K[1].integerData))),w.parseSqueezeAttributes=q=>q.attributes.getInts("axes");const U=q=>{if(!q||q.length!==1)throw new Error("Squeeze requires 1 input.");if(q[0].type==="string")throw new Error("invalid input tensor types.")},G=q=>{if(!q||q.length!==2)throw new Error("Squeeze requires 2 inputs.");if(q[1].type!=="int32")throw new Error("Invalid input type.")}},6558:(F,w,D)=>{Object.defineProperty(w,"__esModule",{value:!0}),w.sum=void 0;const O=D(5060),U=D(2039);w.sum=(K,ee)=>{q(ee);const Z={name:"Sum",inputNames:ee.map(((ie,Y)=>`X${Y}`)),inputTypes:new Array(ee.length).fill(U.TextureType.unpacked)};return[K.run(Object.assign(Object.assign({},Z),{get:()=>G(K,ee,Z)}),ee)]};const G=(K,ee,Z)=>{const ie=(0,O.getGlsl)(K.session.backend.glContext.version),Y=ee[0].dims.slice(),W=`
      void main() {
        vec4 result = ${ee.map(((ne,se)=>`${ie.texture2D}(X${se},TexCoords)`)).join(" + ")};
        ${ie.output} = result;
      }
    `;return Object.assign(Object.assign({},Z),{output:{dims:Y,type:ee[0].type,textureType:U.TextureType.unpacked},hasMain:!0,shaderSource:W})},q=K=>{if(!K||K.length===0)throw new Error("Sum requires inputs.");const ee=K[0].dims.length;for(let Z=1;Z<K.length;Z++){if(ee!==K[Z].dims.length)throw new Error("Input shapes are mismatched.");for(let ie=0;ie<ee;ie++)if(K[0].dims[ie]!==K[Z].dims[ie])throw new Error("Input shapes are not matched.")}if(K[0].type!=="float32"&&K[0].type!=="float64")throw new Error("Invalid input type.");for(let Z=1;Z<K.length;Z++)if(K[0].type!==K[Z].type)throw new Error("Input types are not matched.")}},5723:(F,w,D)=>{Object.defineProperty(w,"__esModule",{value:!0}),w.tile=void 0;const O=D(782),U=D(2039);w.tile=(K,ee)=>{q(ee);const Z={name:"Tile",inputNames:["A"],inputTypes:[U.TextureType.unpacked]};return[K.run(Object.assign(Object.assign({},Z),{get:()=>G(K,ee,Z)}),ee)]};const G=(K,ee,Z)=>{const ie=ee[0].dims.slice(),Y=new Array(ie.length),W=[];for(let le=0;le<ie.length;le++)Y[le]=ie[le]*ee[1].numberData[le],W.push(`inputIdx[${le}] = int(mod(float(outputIdx[${le}]), ${ie[le]}.));`);const ne=Y.length,se=`
      float process(int outputIdx[${ne}]) {
        int inputIdx[${ne}];
        ${W.join(`
`)}
        return _A(inputIdx);
      }
    `;return Object.assign(Object.assign({},Z),{output:{dims:Y,type:ee[0].type,textureType:U.TextureType.unpacked},shaderSource:se})},q=K=>{if(!K||K.length!==2)throw new Error("Tile requires 2 input.");if(K[1].dims.length!==1)throw new Error("The second input shape must 1 dimension.");if(K[1].dims[0]!==K[0].dims.length)throw new Error("Invalid input shape.");if(O.NUMBER_TYPES.indexOf(K[0].type)===-1)throw new Error("Invalid input type.");if(K[1].type!=="int32"&&K[1].type!=="int16")throw new Error("Invalid repeat type.")}},3738:(F,w,D)=>{Object.defineProperty(w,"__esModule",{value:!0}),w.parseTransposeAttributes=w.transpose=void 0;const O=D(246),U=D(2517),G=D(2039),q={name:"Transpose",inputNames:["A"],inputTypes:[G.TextureType.unpacked]};w.transpose=(W,ne,se)=>(Y(ne),[W.run(Object.assign(Object.assign({},q),{cacheHint:se.cacheKey,get:()=>K(W,ne[0],se.perm)}),ne)]),w.parseTransposeAttributes=W=>(0,O.createAttributeWithCacheKey)({perm:W.attributes.getInts("perm",[])});const K=(W,ne,se)=>{const le=ne.dims;se=ee(le,se);const ce=Z(le,se),he=le.length,pe=`
      ${ie("perm",se,he)}
      float process(int indices[${he}]) {
        int a[${he}];
        perm(a, indices);
        return _A(a);
      }`;return Object.assign(Object.assign({},q),{output:{dims:ce,type:ne.type,textureType:G.TextureType.unpacked},shaderSource:pe})},ee=(W,ne)=>(ne&&ne.length!==W.length&&(ne=[...W.keys()].reverse()),ne),Z=(W,ne)=>(ne=ee(W,ne),U.ShapeUtil.sortBasedOnPerm(W,ne)),ie=(W,ne,se)=>{const le=[];le.push(`void ${W}(out int a[${se}], int src[${se}]) {`);for(let ce=0;ce<se;++ce)le.push(`	a[${ne[ce]}]=src[${ce}];`);return le.push("	}"),le.join(`
`)},Y=W=>{if(!W||W.length!==1)throw new Error("Transpose requires 1 input.");if(W[0].type!=="float32"&&W[0].type!=="float64")throw new Error("input should be float tensor")}},8710:(F,w,D)=>{Object.defineProperty(w,"__esModule",{value:!0}),w.encodeAsUint8=void 0;const O=D(5060),U=D(2039);w.encodeAsUint8=(G,q)=>{const K=q.shape,ee=(0,O.getGlsl)(G.session.backend.glContext.version),Z=`
    const float FLOAT_MAX = 1.70141184e38;
    const float FLOAT_MIN = 1.17549435e-38;

    bool isNaN(float val) {
      return (val < 1.0 || 0.0 < val || val == 0.0) ? false : true;
    }

    highp vec4 encodeAsUint8(highp float v) {
      if (isNaN(v)) {
        return vec4(255, 255, 255, 255);
      }

      highp float av = abs(v);

      if(av < FLOAT_MIN) {
        return vec4(0.0, 0.0, 0.0, 0.0);
      } else if(v > FLOAT_MAX) {
        return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;
      } else if(v < -FLOAT_MAX) {
        return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;
      }

      highp vec4 c = vec4(0,0,0,0);

      highp float e = floor(log2(av));
      highp float m = exp2(fract(log2(av))) - 1.0;

      c[2] = floor(128.0 * m);
      m -= c[2] / 128.0;
      c[1] = floor(32768.0 * m);
      m -= c[1] / 32768.0;
      c[0] = floor(8388608.0 * m);

      highp float ebias = e + 127.0;
      c[3] = floor(ebias / 2.0);
      ebias -= c[3] * 2.0;
      c[2] += floor(ebias) * 128.0;

      c[3] += 128.0 * step(0.0, -v);

      return c / 255.0;
    }

    void main() {
      float value = ${ee.texture2D}(X,TexCoords).r;
      ${ee.output} = encodeAsUint8(value);
    }`,ie={name:"Uint8Encode",inputTypes:[U.TextureType.unpacked],inputNames:["X"],output:{dims:K,type:q.tensor.type,textureType:U.TextureType.downloadUint8AsFloat},shaderSource:Z,hasMain:!0};return G.executeProgram(ie,[q.tensor])}},4909:(F,w,D)=>{Object.defineProperty(w,"__esModule",{value:!0}),w.tanh=w.tan=w.sqrt=w.sin=w.sigmoid=w.relu=w.not=w.neg=w.log=w.parseLeakyReluAttributes=w.leakyRelu=w.identity=w.floor=w.exp=w.parseEluAttributes=w.elu=w.cos=w.ceil=w.clipV11=w.parseClipAttributes=w.clip=w.atan=w.asin=w.acos=w.abs=w.glslTanh=w.glslTan=w.glslSqrt=w.glslSigmoid=w.glslRelu=w.glslSin=w.glslNot=w.glslNeg=w.glslLog=w.glslLeakyRelu=w.glslIdentity=w.glslClip=w.glslFloor=w.glslExp=w.glslElu=w.glslCos=w.glslCeil=w.glslAtan=w.glslAsin=w.glslAcos=w.glslAbs=void 0;const O=D(246),U=D(2517),G=D(8520),q=D(5060),K=D(2039);function ee(){return Ne("abs")}function Z(){return Ne("acos")}function ie(){return Ne("asin")}function Y(){return Ne("atan")}function W(){return Ne("ceil")}function ne(){return Ne("cos")}function se(Ce){return{body:`
  const float alpha = float(${Ce});

  float elu_(float a) {
    return a >= 0.0 ? a: (exp(a) - 1.0) * alpha;
  }
  vec4 elu_(vec4 v) {
    return vec4(elu_(v.x), elu_(v.y), elu_(v.z), elu_(v.w));
  }
  `,name:"elu",type:G.FunctionType.ValueBased}}function le(){return Ne("exp")}function ce(){return Ne("floor")}function he(Ce,Be){const ze="clip";return{body:`
  const float min = float(${Ce});
  const float max = float(${Be});

  float ${ze}_(float a) {
    return clamp(a, min, max);
  }
  vec4 ${ze}_(vec4 v) {
    return clamp(v, min, max);
  }
  `,name:ze,type:G.FunctionType.ValueBased}}function pe(){const Ce="indentity";return{body:`
  float ${Ce}_(float a) {
    return a;
  }
  vec4 ${Ce}_(vec4 v) {
    return v;
  }
  `,name:Ce,type:G.FunctionType.ValueBased}}function me(Ce){const Be="leakyRelu";return{body:`
  const float alpha = float(${Ce});

  float ${Be}_(float a) {
    return a < 0.0 ? a * alpha : a;
  }
  vec4 ${Be}_(vec4 v) {
    return vec4(${Be}_(v.x), ${Be}_(v.y), ${Be}_(v.z), ${Be}_(v.w));
  }
  `,name:Be,type:G.FunctionType.ValueBased}}function be(){return Ne("log")}function ge(){return{body:`
  float neg_(float a) {
    return -a;
  }
  vec4 neg_(vec4 v) {
    return -v;
  }
  `,name:"neg",type:G.FunctionType.ValueBased}}function ve(){return{body:`
  float not_(float a) {
    return float( ! bool(a) );
  }
  bool not_(bool a) {
    return !a;
  }
  vec4 not_(vec4 v) {
    return vec4(!bool(v.x), !bool(v.y), !bool(v.z), !bool(v.w));
  }
  bvec4 not_(bvec4 v) {
    return bvec4(!v.x, !v.y, !v.z, !v.w);
  }
  `,name:"not",type:G.FunctionType.ValueBased}}function Se(){return Ne("sin")}function Me(){const Ce="relu";return{body:`
  float ${Ce}_(float a) {
    return max( a, 0.0 );
  }
  vec4 ${Ce}_(vec4 v) {
    return max( v, 0.0 );
  }
  `,name:Ce,type:G.FunctionType.ValueBased}}function Ee(){const Ce="sigmoid";return{body:`
  float ${Ce}_(float a) {
    return 1.0 / (1.0 + exp(-a));
  }
  vec4 ${Ce}_(vec4 v) {
    return 1.0 / (1.0 + exp(-v));
  }
  `,name:Ce,type:G.FunctionType.ValueBased}}function we(){return Ne("sqrt")}function Re(){return Ne("tan")}function Le(){const Ce="tanh";return{body:`
  float ${Ce}_(float a) {
    a = clamp(a, -10., 10.);
    a = exp(2.*a);
    return (a - 1.) / (a + 1.);
  }
  vec4 ${Ce}_(vec4 v) {
    v = clamp(v, -10., 10.);
    v = exp(2.*v);
    return (v - 1.) / (v + 1.);
  }
  `,name:Ce,type:G.FunctionType.ValueBased}}function Ne(Ce){return{body:`
  float ${Ce}_(float a) {
    return ${Ce}(a);
  }
  vec4 ${Ce}_(vec4 v) {
    return ${Ce}(v);
  }
  `,name:Ce,type:G.FunctionType.ValueBased}}w.glslAbs=ee,w.glslAcos=Z,w.glslAsin=ie,w.glslAtan=Y,w.glslCeil=W,w.glslCos=ne,w.glslElu=se,w.glslExp=le,w.glslFloor=ce,w.glslClip=he,w.glslIdentity=pe,w.glslLeakyRelu=me,w.glslLog=be,w.glslNeg=ge,w.glslNot=ve,w.glslSin=Se,w.glslRelu=Me,w.glslSigmoid=Ee,w.glslSqrt=we,w.glslTan=Re,w.glslTanh=Le;const Oe=(Ce,Be,ze,Xe)=>{const lt=Ce.session.pack?K.TextureType.packed:K.TextureType.unpacked,ke={name:ze.name,inputTypes:[lt],inputNames:["A"],cacheHint:Xe};return Object.assign(Object.assign({},ke),{get:()=>((rt,St,Lt,$t)=>{const mt=rt.session.pack?K.TextureType.packed:K.TextureType.unpacked,bt=(0,q.getGlsl)(rt.session.backend.glContext.version);return Object.assign(Object.assign({},St),{output:{dims:Lt.dims,type:Lt.type,textureType:mt},shaderSource:`
     ${$t.body}
     void main() {
       vec4 v = ${bt.texture2D}(A, TexCoords);
       v = ${$t.name}_(v);
       ${bt.output} = v;
     }
     `,hasMain:!0})})(Ce,ke,Be,ze)})};w.abs=(Ce,Be)=>[Ce.run(Oe(Ce,Be[0],ee()),Be)],w.acos=(Ce,Be)=>[Ce.run(Oe(Ce,Be[0],Z()),Be)],w.asin=(Ce,Be)=>[Ce.run(Oe(Ce,Be[0],ie()),Be)],w.atan=(Ce,Be)=>[Ce.run(Oe(Ce,Be[0],Y()),Be)],w.clip=(Ce,Be,ze)=>[Ce.run(Oe(Ce,Be[0],he(ze.min,ze.max),ze.cacheKey),Be)],w.parseClipAttributes=Ce=>(0,O.createAttributeWithCacheKey)({min:Ce.attributes.getFloat("min",U.MIN_CLIP),max:Ce.attributes.getFloat("max",U.MAX_CLIP)}),w.clipV11=(Ce,Be)=>{const ze=Pe(Ce,Be);return(0,w.clip)(Ce,[Be[0]],ze)};const Pe=(Ce,Be)=>{if(Be.length>=3&&(!Ce.session.isInitializer(Be[1].dataId)||!Ce.session.isInitializer(Be[2].dataId)))throw new Error("dynamic clip attributes are not allowed");const ze=Be.length>=3?Be[1].numberData[0]:U.MIN_CLIP,Xe=Be.length>=3?Be[2].numberData[0]:U.MAX_CLIP;return(0,O.createAttributeWithCacheKey)({min:ze,max:Xe})};w.ceil=(Ce,Be)=>[Ce.run(Oe(Ce,Be[0],W()),Be)],w.cos=(Ce,Be)=>[Ce.run(Oe(Ce,Be[0],ne()),Be)],w.elu=(Ce,Be,ze)=>[Ce.run(Oe(Ce,Be[0],se(ze.alpha),ze.cacheKey),Be)],w.parseEluAttributes=Ce=>(0,O.createAttributeWithCacheKey)({alpha:Ce.attributes.getFloat("alpha",1)}),w.exp=(Ce,Be)=>[Ce.run(Oe(Ce,Be[0],le()),Be)],w.floor=(Ce,Be)=>[Ce.run(Oe(Ce,Be[0],ce()),Be)],w.identity=(Ce,Be)=>[Ce.run(Oe(Ce,Be[0],pe()),Be)],w.leakyRelu=(Ce,Be,ze)=>[Ce.run(Oe(Ce,Be[0],me(ze.alpha),ze.cacheKey),Be)],w.parseLeakyReluAttributes=Ce=>(0,O.createAttributeWithCacheKey)({alpha:Ce.attributes.getFloat("alpha",.01)}),w.log=(Ce,Be)=>[Ce.run(Oe(Ce,Be[0],be()),Be)],w.neg=(Ce,Be)=>[Ce.run(Oe(Ce,Be[0],ge()),Be)],w.not=(Ce,Be)=>[Ce.run(Oe(Ce,Be[0],ve()),Be)],w.relu=(Ce,Be)=>[Ce.run(Oe(Ce,Be[0],Me()),Be)],w.sigmoid=(Ce,Be)=>[Ce.run(Oe(Ce,Be[0],Ee()),Be)],w.sin=(Ce,Be)=>[Ce.run(Oe(Ce,Be[0],Se()),Be)],w.sqrt=(Ce,Be)=>[Ce.run(Oe(Ce,Be[0],we()),Be)],w.tan=(Ce,Be)=>[Ce.run(Oe(Ce,Be[0],Re()),Be)],w.tanh=(Ce,Be)=>[Ce.run(Oe(Ce,Be[0],Le()),Be)]},5611:(F,w,D)=>{Object.defineProperty(w,"__esModule",{value:!0}),w.createUnpackProgramInfoLoader=w.createUnpackProgramInfo=void 0;const O=D(5060),U=D(2039),G=D(9390),q=D(2827),K={name:"unpack",inputNames:["A"],inputTypes:[U.TextureType.packed]};w.createUnpackProgramInfo=(ee,Z)=>{const ie=Z.dims.length,Y=(0,q.getChannels)("rc",ie),W=Y.slice(-2),ne=(0,G.getCoordsDataType)(ie),se=(0,q.unpackFromChannel)(),le=Z.dims.length===0?"":(function(pe,me){if(pe===1)return"rc";let be="";for(let ge=0;ge<pe;ge++)be+=me[ge],ge<pe-1&&(be+=",");return be})(ie,Y),ce=ie<=1?"rc":`vec2(${W.join(",")})`,he=`
    ${se}
    void main() {
      ${ne} rc = getOutputCoords();

       // Sample the texture with the coords to get the rgba channel value.
       vec4 packedInput = getA(${le});

       ${(0,O.getGlsl)(ee.session.backend.glContext.version).output} = vec4(getChannel(packedInput, ${ce}), 0, 0, 0);
     }
   `;return Object.assign(Object.assign({},K),{hasMain:!0,output:{dims:Z.dims,type:Z.type,textureType:U.TextureType.unpacked},shaderSource:he})},w.createUnpackProgramInfoLoader=(ee,Z)=>Object.assign(Object.assign({},K),{get:()=>(0,w.createUnpackProgramInfo)(ee,Z)})},8428:(F,w,D)=>{Object.defineProperty(w,"__esModule",{value:!0}),w.parseUnsqueezeAttributes=w.unsqueezeV13=w.unsqueeze=void 0;const O=D(2517);w.unsqueeze=(q,K,ee)=>{U(K);const Z=O.ShapeUtil.unsqueezeShape(K[0].dims,ee);return[q.reshapeUnpacked(K[0],Z)]},w.unsqueezeV13=(q,K)=>(G(K),(0,w.unsqueeze)(q,[K[0]],Array.from(K[1].integerData))),w.parseUnsqueezeAttributes=q=>q.attributes.getInts("axes");const U=q=>{if(!q||q.length!==1)throw new Error("Unsqueeze requires 1 input.");if(q[0].type==="string")throw new Error("invalid input tensor types.")},G=q=>{if(!q||q.length!==2)throw new Error("Unsqueeze requires 2 inputs.");if(q[1].type!=="int32")throw new Error("Invalid input type.")}},9793:(F,w,D)=>{Object.defineProperty(w,"__esModule",{value:!0}),w.scalesValidation=w.validateInputs=w.parseUpsampleAttributes=w.parseUpsampleAttributesV9=w.parseUpsampleAttributesV7=w.upsample=void 0;const O=D(246),U=D(5060),G=D(2039),q={name:"Upsample",inputNames:["X"],inputTypes:[G.TextureType.unpacked]};w.upsample=(ee,Z,ie)=>((0,w.validateInputs)(Z,ie),[ee.run(Object.assign(Object.assign({},q),{cacheHint:ie.cacheKey,get:()=>K(ee,Z,ie)}),Z)]),w.parseUpsampleAttributesV7=ee=>(0,w.parseUpsampleAttributes)(ee,7),w.parseUpsampleAttributesV9=ee=>(0,w.parseUpsampleAttributes)(ee,9),w.parseUpsampleAttributes=(ee,Z)=>{const ie=Z>=10,Y=ee.attributes.getString("mode","nearest");if(Y!=="nearest"&&Y!=="linear"&&(Z<11||Y!=="cubic"))throw new Error(`unrecognized mode: ${Y}`);let W=[];Z<9&&(W=ee.attributes.getFloats("scales"),(0,w.scalesValidation)(W,Y,ie));const ne=ee.attributes.getFloat("extrapolation_value",0),se=Z>10?ee.attributes.getString("coordinate_transformation_mode","half_pixel"):"asymmetric";if(["asymmetric","pytorch_half_pixel","tf_half_pixel_for_nn","align_corners","tf_crop_and_resize","half_pixel"].indexOf(se)===-1)throw new Error(`coordinate_transform_mode '${se}' is not supported`);const le=se==="tf_crop_and_resize",ce=le,he=Y==="nearest"&&Z>=11?ee.attributes.getString("nearest_mode","round_prefer_floor"):"";if(["round_prefer_floor","round_prefer_ceil","floor","ceil",""].indexOf(he)===-1)throw new Error(`nearest_mode '${he}' is not supported`);const pe=ee.attributes.getFloat("cubic_coeff_a",-.75),me=ee.attributes.getInt("exclude_outside",0)!==0;if(me&&Y!=="cubic")throw new Error("exclude_outside can be set to 1 only when mode is CUBIC.");const be=Z<11||Y==="nearest"&&se==="asymmetric"&&he==="floor";let ge=0,ve=0,Se=0;return Z>10?ee.inputs.length>2?(ge=1,ve=2,Se=3):(ve=1,Se=2):Z===9&&(ve=1),(0,O.createAttributeWithCacheKey)({opset:Z,isResize:ie,mode:Y,scales:W,extrapolationValue:ne,coordinateTransformMode:se,useExtrapolation:ce,needRoiInput:le,nearestMode:he,cubicCoefficientA:pe,excludeOutside:me,useNearest2xOptimization:be,roiInputIdx:ge,scalesInputIdx:ve,sizesInputIdx:Se})};const K=(ee,Z,ie)=>{const Y=(0,U.getGlsl)(ee.session.backend.glContext.version),[W,ne]=ee.calculateTextureWidthAndHeight(Z[0].dims,G.TextureType.unpacked),se=Z[0].dims.map(((Se,Me)=>Math.floor(Se*ie.scales[Me]))),[le,ce]=ee.calculateTextureWidthAndHeight(se,G.TextureType.unpacked),he=se.length,pe=new Array(he),me=new Array(he);let be=`
      int output_pitches[${he}];
      int input_pitches[${he}];
      `;for(let Se=he-1;Se>=0;Se--)pe[Se]=Se===he-1?1:pe[Se+1]*se[Se+1],me[Se]=Se===he-1?1:me[Se+1]*Z[0].dims[Se+1],be+=`
        output_pitches[${Se}] = ${pe[Se]};
        input_pitches[${Se}] = ${me[Se]};
        `;const ge=`
      float getInputFloat(int index) {
        vec2 coords = offsetToCoords(index, ${W}, ${ne});
        float value = getColorAsFloat(${Y.texture2D}(X, coords));
        return value;
      }
      `,ve=ie.mode==="nearest"?`
    ${ge}
    float process(int indices[${he}]) {
      int input_index = 0;
      int output_index = coordsToOffset(TexCoords, ${le}, ${ce});

      ${be}

      int d, m;
      for (int dim = 0; dim < ${he}; ++dim) {
        d = output_index / output_pitches[dim];
        m = output_index - d * output_pitches[dim];
        output_index = m;

        if (scales[dim] != 1 && d > 0) {
          int d2 = d / scales[dim];
          m = d - d2 * scales[dim];
          d = d2;
        }
        input_index += input_pitches[dim] * d;
      }

      return getInputFloat(input_index);
    }`:he===4?`
    ${ge}
    float process(int indices[4]) {
      int input_index = 0;
      int output_index = coordsToOffset(TexCoords, ${le}, ${ce});

      ${be}

      int m;
      int index_of_dim0, index_of_dim1, index_of_dim2, index_of_dim3;
      index_of_dim0 = output_index / output_pitches[0];
      m = output_index - index_of_dim0 * output_pitches[0];
      index_of_dim1 = m / output_pitches[1];
      m = m - index_of_dim1 * output_pitches[1];
      index_of_dim2 = m / output_pitches[2];
      m = m - index_of_dim2 * output_pitches[2];
      index_of_dim3 = m;

      int index_of_input_dim2, index_of_input_dim3, x_offset, y_offset;
      index_of_input_dim2 = index_of_dim2 / scales[2];
      y_offset = index_of_dim2 - index_of_input_dim2 * scales[2];
      index_of_input_dim3 = index_of_dim3 / scales[3];
      x_offset = index_of_dim3 - index_of_input_dim3 * scales[3];

      input_index = index_of_dim0 * input_pitches[0] +
            index_of_dim1 * input_pitches[1] +
            index_of_input_dim2 * input_pitches[2] +
            index_of_input_dim3;

      float x00 = getInputFloat(input_index);
      float x10, x01, x11;

      bool end_of_dim2 = false;
      if (index_of_input_dim2 == (${Z[0].dims[2]} - 1)) {
        // It's the end in dimension 2
        x01 = x00;
        end_of_dim2 = true;
      } else {
        x01 = getInputFloat(input_index + input_pitches[2]);
      }

      if (index_of_input_dim3 == (input_pitches[2] - 1)) {
        // It's the end in dimension 3
        x10 = x00;
        x11 = x01;
      }
      else {
        x10 = getInputFloat(input_index + 1);
        x11 = end_of_dim2 ? x10 : getInputFloat(input_index + input_pitches[2] + 1);
      }

      float y0 = x00 + float(y_offset) * (x01 - x00) / float(scales[2]);
      float y1 = x10 + float(y_offset) * (x11 - x10) / float(scales[2]);
      return y0 + float(x_offset) * (y1 - y0) / float(scales[3]);
    }`:`
    ${ge}
    float process(int indices[2]) {
      int input_index = 0;
      int output_index = coordsToOffset(TexCoords, ${le}, ${ce});

      ${be}

      int m;
      int index_of_dim0, index_of_dim1;
      index_of_dim0 = output_index / output_pitches[0];
      m = output_index - index_of_dim0 * output_pitches[0];
      index_of_dim1 = m;

      int index_of_input_dim0, index_of_input_dim1, x_offset, y_offset;
      index_of_input_dim0 = index_of_dim0 / scales[0];
      y_offset = index_of_dim0 - index_of_input_dim0 * scales[0];
      index_of_input_dim1 = index_of_dim1 / scales[1];
      x_offset = index_of_dim1 - index_of_input_dim1 * scales[1];

      input_index = index_of_input_dim0 * input_pitches[0] + index_of_input_dim1;

      float x00 = getInputFloat(input_index);
      float x10, x01, x11;

      bool end_of_dim0 = false;
      if (index_of_input_dim0 == (${Z[0].dims[0]} - 1)) {
        // It's the end in dimension 0
        x01 = x00;
        end_of_dim0 = true;
      } else {
        x01 = getInputFloat(input_index + input_pitches[0]);
      }

      if (index_of_input_dim1 == (input_pitches[0] - 1)) {
        // It's the end in dimension 1
        x10 = x00;
        x11 = x01;
      }
      else {
        x10 = getInputFloat(input_index + 1);
        x11 = end_of_dim0 ? x10 : getInputFloat(input_index + input_pitches[0] + 1);
      }

      float y0 = x00 + float(y_offset) * (x01 - x00) / float(scales[0]);
      float y1 = x10 + float(y_offset) * (x11 - x10) / float(scales[0]);
      return y0 + float(x_offset) * (y1 - y0) / float(scales[1]);
    }`;return Object.assign(Object.assign({},q),{output:{dims:se,type:Z[0].type,textureType:G.TextureType.unpacked},shaderSource:ve,variables:[{name:"scales",type:"int",arrayLength:ie.scales.length,data:ie.scales.map((Se=>Math.ceil(Se)))}]})};w.validateInputs=(ee,Z)=>{if(!ee||Z.opset<9&&ee.length!==1||Z.opset>=9&&Z.opset<11&&ee.length!==2||Z.opset>=11&&ee.length<2)throw new Error("invalid inputs.");if(Z.scales.length>0&&ee[0].dims.length!==Z.scales.length)throw new Error("Invalid input shape.");if(ee[0].type==="string")throw new Error("Invalid input tensor types.")},w.scalesValidation=(ee,Z,ie)=>{if(ie){for(const Y of ee)if(Y<=0)throw new Error("Scale value should be greater than 0.")}else for(const Y of ee)if(Y<1)throw new Error("Scale value should be greater than or equal to 1.");if(!(Z!=="linear"&&Z!=="cubic"||ee.length===2||ee.length===4&&ee[0]===1&&ee[1]===1))throw new Error(`'Linear' mode and 'Cubic' mode only support 2-D inputs ('Bilinear', 'Bicubic')         or 4-D inputs with the corresponding outermost 2 scale values being 1         in the ${ie?"Resize":"Upsample"} opeartor.`)}},1958:(F,w,D)=>{Object.defineProperty(w,"__esModule",{value:!0}),w.ProgramManager=void 0;const O=D(1670),U=D(6231),G=D(8879),q=D(5060);w.ProgramManager=class{constructor(K,ee,Z){this.profiler=K,this.glContext=ee,this.textureLayoutStrategy=Z,this.repo=new Map,this.attributesBound=!1}getArtifact(K){return this.repo.get(K)}setArtifact(K,ee){this.repo.set(K,ee)}run(K,ee,Z){var ie;this.profiler.event("op",`ProgramManager.run ${(ie=K.programInfo.name)!==null&&ie!==void 0?ie:"unknown kernel"}`,(()=>{var Y;const W=this.glContext.gl,ne=K.program;W.useProgram(ne);try{this.bindOutput(Z),this.attributesBound||this.bindAttributes(K.attribLocations),this.bindUniforms(K.uniformLocations,(Y=K.programInfo.variables)!==null&&Y!==void 0?Y:[],ee)}catch(se){throw U.Logger.error("ProgramManager",K.programInfo.shaderSource),se}this.profiler.event("backend","GlContext.draw()",(()=>{this.glContext.draw()}))}),this.glContext)}dispose(){this.vertexShader&&this.glContext.deleteShader(this.vertexShader),this.repo.forEach((K=>this.glContext.deleteProgram(K.program)))}build(K,ee,Z){return this.profiler.event("backend","ProgramManager.build",(()=>{const ie=new G.GlslPreprocessor(this.glContext,K,ee,Z),Y=ie.preprocess(),W=this.compile(Y);return{programInfo:K,program:W,uniformLocations:this.getUniformLocations(W,ie.context.programInfo.inputNames,ie.context.programInfo.variables),attribLocations:this.getAttribLocations(W)}}))}compile(K){if(!this.vertexShader){U.Logger.verbose("ProrgramManager","Compiling and caching Vertex shader for the first time");const ie=(0,q.getVertexShaderSource)(this.glContext.version);this.vertexShader=this.glContext.compileShader(ie,this.glContext.gl.VERTEX_SHADER)}O.env.debug&&U.Logger.verbose("ProrgramManager",`FragShader:
${K}
`);const ee=this.glContext.compileShader(K,this.glContext.gl.FRAGMENT_SHADER),Z=this.glContext.createProgram(this.vertexShader,ee);return this.glContext.deleteShader(ee),Z}bindOutput(K){const ee=K.width,Z=K.height;U.Logger.verbose("ProrgramManager",`Binding output texture to Framebuffer: w/h=${ee}/${Z}, shape=${K.shape}, type=${K.tensor.type}`),this.glContext.attachFramebuffer(K.texture,ee,Z)}bindAttributes(K){const ee=K.position,Z=K.textureCoord;this.glContext.setVertexAttributes(ee,Z),this.attributesBound=!0}bindUniforms(K,ee,Z){var ie;const Y=this.glContext.gl;let W=0;for(const{name:ne,type:se,location:le,arrayLength:ce}of K){const he=(ie=ee.find((pe=>pe.name===ne)))===null||ie===void 0?void 0:ie.data;if(se!=="sampler2D"&&!he)throw new Error(`variable '${ne}' does not have data defined in program info`);switch(se){case"sampler2D":this.bindTexture(Z[W],le,W),W++;break;case"float":ce?Y.uniform1fv(le,he):Y.uniform1f(le,he);break;case"int":ce?Y.uniform1iv(le,he):Y.uniform1i(le,he);break;default:throw new Error(`Uniform not implemented: ${se}`)}}}bindTexture(K,ee,Z){this.glContext.bindTextureToUniform(K.texture,Z,ee)}getAttribLocations(K){return{position:this.getAttribLocation(K,"position"),textureCoord:this.getAttribLocation(K,"textureCoord")}}getUniformLocations(K,ee,Z){const ie=[];if(ee)for(const Y of ee)ie.push({name:Y,type:"sampler2D",location:this.getUniformLocation(K,Y)});if(Z)for(const Y of Z)ie.push(Object.assign(Object.assign({},Y),{location:this.getUniformLocation(K,Y.name)}));return ie}getUniformLocation(K,ee){const Z=this.glContext.gl.getUniformLocation(K,ee);if(Z===null)throw new Error(`Uniform ${ee} not found.`);return Z}getAttribLocation(K,ee){return this.glContext.gl.getAttribLocation(K,ee)}}},6416:(F,w,D)=>{Object.defineProperty(w,"__esModule",{value:!0}),w.WebGLSessionHandler=void 0;const O=D(6231),U=D(1047),G=D(8316),q=D(1640),K=D(1958),ee=D(7859),Z=D(5702);w.WebGLSessionHandler=class{constructor(ie,Y){this.backend=ie,this.context=Y,this.layoutStrategy=new ee.PreferLogicalStrategy(ie.glContext.maxTextureSize),this.programManager=new K.ProgramManager(this.context.profiler,ie.glContext,this.layoutStrategy),this.textureManager=new Z.TextureManager(ie.glContext,this.layoutStrategy,this.context.profiler,{reuseTextures:ie.textureCacheMode==="full"}),this.packedTextureDataCache=new Map,this.unpackedTextureDataCache=new Map,this.pack=ie.pack,this.pack2unpackMap=new Map,this.unpack2packMap=new Map}createInferenceHandler(){return new G.WebGLInferenceHandler(this)}onGraphInitialized(ie){const Y=ie.getValues().filter((W=>W.from===-1&&W.tensor)).map((W=>W.tensor.dataId));this.initializers=new Set(Y)}isInitializer(ie){return!!this.initializers&&this.initializers.has(ie)}addInitializer(ie){this.initializers.add(ie)}getTextureData(ie,Y){return Y?this.packedTextureDataCache.get(ie):this.unpackedTextureDataCache.get(ie)}setTextureData(ie,Y,W=!1){O.Logger.verbose("WebGLSessionHandler","Storing Texture data in cache"),W?this.packedTextureDataCache.set(ie,Y):this.unpackedTextureDataCache.set(ie,Y)}dispose(){this.programManager.dispose(),this.textureManager.clearActiveTextures(),this.packedTextureDataCache.forEach((ie=>this.textureManager.releaseTexture(ie,!0))),this.packedTextureDataCache=new Map,this.unpackedTextureDataCache.forEach((ie=>this.textureManager.releaseTexture(ie,!0))),this.unpackedTextureDataCache=new Map}resolve(ie,Y,W){const ne=(0,U.resolveOperator)(ie,Y,q.WEBGL_OP_RESOLVE_RULES);return{impl:ne.opImpl,context:ne.opInit?ne.opInit(ie,W):ie}}}},7769:(F,w,D)=>{Object.defineProperty(w,"__esModule",{value:!0}),w.Uint8DataEncoder=w.RGBAFloatDataEncoder=w.RedFloat32DataEncoder=void 0;const O=D(6231);w.RedFloat32DataEncoder=class{constructor(U,G=1){if(G===1)this.internalFormat=U.R32F,this.format=U.RED,this.textureType=U.FLOAT,this.channelSize=G;else{if(G!==4)throw new Error(`Invalid number of channels: ${G}`);this.internalFormat=U.RGBA32F,this.format=U.RGBA,this.textureType=U.FLOAT,this.channelSize=G}}encode(U,G){let q,K;return U.constructor!==Float32Array&&(O.Logger.warning("Encoder","data was not of type Float32; creating new Float32Array"),K=new Float32Array(U)),G*this.channelSize>U.length?(O.Logger.warning("Encoder","Source data too small. Allocating larger array"),K=U,q=this.allocate(G*this.channelSize),K.forEach(((ee,Z)=>q[Z]=ee))):(K=U,q=K),q}allocate(U){return new Float32Array(4*U)}decode(U,G){return this.channelSize===1?U.filter(((q,K)=>K%4==0)).subarray(0,G):U.subarray(0,G)}},w.RGBAFloatDataEncoder=class{constructor(U,G=1,q){if(G!==1&&G!==4)throw new Error(`Invalid number of channels: ${G}`);this.internalFormat=U.RGBA,this.format=U.RGBA,this.channelSize=G,this.textureType=q||U.FLOAT}encode(U,G){let q=U;return this.channelSize===1&&(O.Logger.verbose("Encoder","Exploding into a larger array"),q=this.allocate(G),U.forEach(((K,ee)=>q[4*ee]=K))),q}allocate(U){return new Float32Array(4*U)}decode(U,G){return this.channelSize===1?U.filter(((q,K)=>K%4==0)).subarray(0,G):U.subarray(0,G)}},w.Uint8DataEncoder=class{constructor(U,G=1){if(this.channelSize=4,G===1)this.internalFormat=U.ALPHA,this.format=U.ALPHA,this.textureType=U.UNSIGNED_BYTE,this.channelSize=G;else{if(G!==4)throw new Error(`Invalid number of channels: ${G}`);this.internalFormat=U.RGBA,this.format=U.RGBA,this.textureType=U.UNSIGNED_BYTE,this.channelSize=G}}encode(U,G){return new Uint8Array(U.buffer,U.byteOffset,U.byteLength)}allocate(U){return new Uint8Array(U*this.channelSize)}decode(U,G){if(U instanceof Uint8Array)return U.subarray(0,G);throw new Error(`Invalid array type: ${U.constructor}`)}}},7859:(F,w,D)=>{Object.defineProperty(w,"__esModule",{value:!0}),w.getBatchDim=w.sizeToSquarishShape=w.getRowsCols=w.sizeFromShape=w.isInt=w.parseAxisParam=w.squeezeShape=w.PreferLogicalStrategy=w.AlwaysKeepOriginalSizeStrategy=void 0;const O=D(6231),U=D(2517);function G(ie,Y){const W=[],ne=[],se=Y!=null&&Array.isArray(Y)&&Y.length===0,le=Y==null||se?null:q(Y,ie).sort();let ce=0;for(let he=0;he<ie.length;++he){if(le!=null){if(le[ce]===he&&ie[he]!==1)throw new Error(`Can't squeeze axis ${he} since its dim '${ie[he]}' is not 1`);(le[ce]==null||le[ce]>he)&&ie[he]===1&&(W.push(ie[he]),ne.push(he)),le[ce]<=he&&ce++}ie[he]!==1&&(W.push(ie[he]),ne.push(he))}return{newShape:W,keptDims:ne}}function q(ie,Y){const W=Y.length;return ie=ie==null?Y.map(((ne,se)=>se)):[].concat(ie),(0,U.assert)(ie.every((ne=>ne>=-W&&ne<W)),(()=>`All values in axis param must be in range [-${W}, ${W}) but got axis ${ie}`)),(0,U.assert)(ie.every(K),(()=>`All values in axis param must be integers but got axis ${ie}`)),ie.map((ne=>ne<0?W+ne:ne))}function K(ie){return ie%1==0}function ee(ie){if(ie.length===0)return 1;let Y=ie[0];for(let W=1;W<ie.length;W++)Y*=ie[W];return Y}function Z(ie){const Y=Math.ceil(Math.sqrt(ie));return[Y,Math.ceil(ie/Y)]}w.AlwaysKeepOriginalSizeStrategy=class{constructor(ie){this.maxTextureSize=ie}computeTextureWH(ie,Y){if(ie.length===0)return[1,1];const W=this.maxTextureSize;if(Y&&Y.breakAxis!==void 0){const le=Y.breakAxis>=ie.length?1:ie.slice(Y.breakAxis).reduce(((he,pe)=>he*pe)),ce=Y.breakAxis<=0?1:ie.slice(0,Y.breakAxis).reduce(((he,pe)=>he*pe));if(!(le>W||ce>W))return[le,ce];O.Logger.verbose("TextureLayout",`Given width/height preferences were unattainable: shape:${ie}, breakAxis:${Y.breakAxis}`)}const ne=ie.reduce(((le,ce)=>le*ce));let se=Math.floor(Math.sqrt(ne));for(;se<W&&se<ne&&ne%se!=0;se++);if(se>=W||ne%se!=0)throw new Error(`The given dimensions are outside this GPU's boundaries: ${ie}`);return[se,ne/se]}},w.PreferLogicalStrategy=class{constructor(ie){this.maxTextureSize=ie}computeTextureWH(ie,Y){const W=this.computeTexture(ie,Y);return Y&&Y.isPacked&&(W[0]/=2,W[1]/=2),Y&&Y.reverseWH?[W[1],W[0]]:W}computeTexture(ie,Y){const W=Y&&Y.isPacked;if(ie.length===0)return W?[2,2]:[1,1];let ne=this.maxTextureSize;if(Y&&Y.breakAxis!==void 0){const ce=Y.breakAxis>=ie.length?1:ie.slice(Y.breakAxis).reduce(((pe,me)=>pe*me)),he=Y.breakAxis<=0?1:ie.slice(0,Y.breakAxis).reduce(((pe,me)=>pe*me));if(!(ce>ne||he>ne))return[ce,he];O.Logger.verbose("TextureLayout",`Given width/height preferences were unattainable: shape:${ie}, breakAxis:${Y.breakAxis}`)}let se=ie.slice(0);W&&(ne*=2,se=se.map(((ce,he)=>he>=se.length-2?se[he]%2==0?se[he]:se[he]+1:se[he])),se.length===1&&(se=[2,se[0]])),se.length!==2&&(se=G(se).newShape);const le=ee(se);return se.length<=1&&le<=ne?[1,le]:se.length===2&&se[0]<=ne&&se[1]<=ne?se:se.length===3&&se[0]*se[1]<=ne&&se[2]<=ne?[se[0]*se[1],se[2]]:se.length===3&&se[0]<=ne&&se[1]*se[2]<=ne?[se[0],se[1]*se[2]]:se.length===4&&se[0]*se[1]*se[2]<=ne&&se[3]<=ne?[se[0]*se[1]*se[2],se[3]]:se.length===4&&se[0]<=ne&&se[1]*se[2]*se[3]<=ne?[se[0],se[1]*se[2]*se[3]]:W?Z(le/4).map((ce=>2*ce)):Z(le)}},w.squeezeShape=G,w.parseAxisParam=q,w.isInt=K,w.sizeFromShape=ee,w.getRowsCols=function(ie){if(ie.length===0)throw Error("Cannot get rows and columns of an empty shape array.");return[ie.length>1?ie[ie.length-2]:1,ie[ie.length-1]]},w.sizeToSquarishShape=Z,w.getBatchDim=function(ie,Y=2){return ee(ie.slice(0,ie.length-Y))}},4057:(F,w,D)=>{Object.defineProperty(w,"__esModule",{value:!0}),w.createTextureLayoutFromShape=w.calculateTextureWidthAndHeight=w.createTextureLayoutFromTextureType=void 0;const O=D(2517),U=D(2039);w.createTextureLayoutFromTextureType=(G,q,K)=>{const ee=K===U.TextureType.unpacked||K===U.TextureType.unpackedReversed?1:4,Z=K===U.TextureType.packed,ie=K===U.TextureType.unpackedReversed||K===U.TextureType.packed,Y=K===U.TextureType.packedLastDimension?q.length-1:void 0,W=K===U.TextureType.packedLastDimension?q.map(((ne,se)=>se===q.length-1?4*ne:ne)):void 0;return(0,w.createTextureLayoutFromShape)(G,q,ee,W,{isPacked:Z,reverseWH:ie,breakAxis:Y})},w.calculateTextureWidthAndHeight=(G,q,K)=>{const ee=(0,w.createTextureLayoutFromTextureType)(G,q,K);return[ee.width,ee.height]},w.createTextureLayoutFromShape=(G,q,K=1,ee,Z)=>{const ie=!(!Z||!Z.isPacked),[Y,W]=G.computeTextureWH(ie&&ee||q,Z),ne=q.length;let se=q.slice(0);if(ne===0&&(se=[1]),K===1)ee=q;else if(ie){if(K!==4)throw new Error("a packed texture must be 4-channel");ee=q,ne>0&&(se[ne-1]=Math.ceil(se[ne-1]/2)),ne>1&&(se[ne-2]=Math.ceil(se[ne-2]/2))}else if(!ee)throw new Error("Unpacked shape is needed when using channels > 1");return{width:Y,height:W,channels:K,isPacked:ie,shape:se,strides:O.ShapeUtil.computeStrides(se),unpackedShape:ee,reversedWH:Z&&Z.reverseWH}}},5702:(F,w,D)=>{Object.defineProperty(w,"__esModule",{value:!0}),w.TextureManager=void 0;const O=D(6231);w.TextureManager=class{constructor(U,G,q,K){this.glContext=U,this.layoutStrategy=G,this.profiler=q,this.config=K,this.pendingRead=new Map,K.reuseTextures&&(this.inUseTextures=new Map,this.idleTextures=new Map,this.textureLookup=new Map)}createTextureFromLayout(U,G,q,K){const ee=this.toEncoderType(U),Z=this.glContext.getEncoder(ee,G.channels||1,K);if(G.isPacked&&K===1)throw new Error("not implemented");const ie=G.width,Y=G.height;let W,ne;if(this.config.reuseTextures){W=`${ie}x${Y}_${Z.format}_${Z.internalFormat}_${Z.textureType}`,ne=this.inUseTextures.get(W),ne||(ne=[],this.inUseTextures.set(W,ne));const le=this.idleTextures.get(W);if(le&&le.length>0){const ce=le.pop();return ne.push(ce),K===1&&this.glContext.updateTexture(ce,ie,Y,Z,this.toTextureData(U,q)),ce}}O.Logger.verbose("TextureManager",`Creating new texture of size ${G.width}x${G.height}`);const se=this.glContext.allocateTexture(ie,Y,Z,this.toTextureData(U,q));return this.config.reuseTextures&&(ne.push(se),this.textureLookup.set(se,W)),se}readTexture(U,G,q){return q||(q=1),this.profiler.event("backend","TextureManager.readTexture",(()=>{const K=U.shape.reduce(((Z,ie)=>Z*ie))*q,ee=this.glContext.readTexture(U.texture,U.width,U.height,K,this.toEncoderType(G),q);return this.toTensorData(G,ee)}))}async readTextureAsync(U,G,q){const K=U.tensor.dataId;if(q||(q=1),this.pendingRead.has(K)){const ee=this.pendingRead.get(K);return new Promise((Z=>ee?.push(Z)))}return this.profiler.event("backend","TextureManager.readTextureAsync",(async()=>{this.pendingRead.set(K,[]);const ee=U.shape.reduce(((W,ne)=>W*ne))*q;await this.glContext.createAndWaitForFence();const Z=this.glContext.readTexture(U.texture,U.width,U.height,ee,this.toEncoderType(G),q),ie=this.toTensorData(G,Z),Y=this.pendingRead.get(K);return this.pendingRead.delete(K),Y?.forEach((W=>W(ie))),ie}))}readUint8TextureAsFloat(U){return this.profiler.event("backend","TextureManager.readUint8TextureAsFloat",(()=>{const G=U.shape.reduce(((K,ee)=>K*ee)),q=this.glContext.readTexture(U.texture,U.width,U.height,4*G,"byte",4);return new Float32Array(q.buffer,q.byteOffset,G)}))}releaseTexture(U,G){let q;if(this.config.reuseTextures&&(q=this.textureLookup.get(U.texture),q)){G&&this.textureLookup.delete(q);const K=this.inUseTextures.get(q);if(K){const ee=K.indexOf(U.texture);if(ee!==-1){K.splice(ee,1);let Z=this.idleTextures.get(q);Z||(Z=[],this.idleTextures.set(q,Z)),Z.push(U.texture)}}}q&&!G||(O.Logger.verbose("TextureManager",`Deleting texture of size ${U.width}x${U.height}`),this.glContext.deleteTexture(U.texture))}toTensorData(U,G){switch(U){case"int16":return G instanceof Int16Array?G:Int16Array.from(G);case"int32":return G instanceof Int32Array?G:Int32Array.from(G);case"int8":return G instanceof Int8Array?G:Int8Array.from(G);case"uint16":return G instanceof Uint16Array?G:Uint16Array.from(G);case"uint32":return G instanceof Uint32Array?G:Uint32Array.from(G);case"uint8":case"bool":return G instanceof Uint8Array?G:Uint8Array.from(G);case"float32":return G instanceof Float32Array?G:Float32Array.from(G);case"float64":return G instanceof Float64Array?G:Float64Array.from(G);default:throw new Error(`TensorData type ${U} is not supported`)}}toTextureData(U,G){if(G)return G instanceof Float32Array?G:new Float32Array(G)}toEncoderType(U){return"float"}clearActiveTextures(){this.glContext.clearActiveTextures()}}},2039:(F,w)=>{var D;Object.defineProperty(w,"__esModule",{value:!0}),w.TextureType=void 0,(D=w.TextureType||(w.TextureType={}))[D.unpacked=0]="unpacked",D[D.unpackedReversed=1]="unpackedReversed",D[D.packed=2]="packed",D[D.downloadUint8AsFloat=3]="downloadUint8AsFloat",D[D.packedLastDimension=4]="packedLastDimension"},9390:(F,w,D)=>{Object.defineProperty(w,"__esModule",{value:!0}),w.getGlChannels=w.getCoordsDataType=w.getSqueezedParams=w.squeezeInputShape=w.generateShaderFuncNameFromInputSamplerNameAtOutCoords=w.generateShaderFuncNameFromInputSamplerName=w.repeatedTry=w.getPackedShape=void 0;const O=D(2517);w.getPackedShape=function(U){const G=U.length;return U.slice(0,G-1).concat(U[G-1]/4)},w.repeatedTry=async function(U,G=(K=>0),q){return new Promise(((K,ee)=>{let Z=0;const ie=()=>{if(U())return void K();Z++;const Y=G(Z);q!=null&&Z>=q?ee():setTimeout(ie,Y)};ie()}))},w.generateShaderFuncNameFromInputSamplerName=function(U){return(0,O.assert)(U!==void 0&&U.length!==0,(()=>"empty string found for sampler name")),"get"+U.charAt(0).toUpperCase()+U.slice(1)},w.generateShaderFuncNameFromInputSamplerNameAtOutCoords=function(U){return(0,O.assert)(U!==void 0&&U.length!==0,(()=>"empty string found for sampler name")),"get"+U.charAt(0).toUpperCase()+U.slice(1)+"AtOutCoords"},w.squeezeInputShape=function(U,G){let q=JSON.parse(JSON.stringify(U));return q=G,q},w.getSqueezedParams=function(U,G){return G.map((q=>U[q])).join(", ")},w.getCoordsDataType=function(U){if(U<=1)return"int";if(U===2)return"ivec2";if(U===3)return"ivec3";if(U===4)return"ivec4";if(U===5)return"ivec5";if(U===6)return"ivec6";throw Error(`GPU for rank ${U} is not yet supported`)},w.getGlChannels=function(U=6){return["x","y","z","w","u","v"].slice(0,U)}},7305:(F,w,D)=>{Object.defineProperty(w,"__esModule",{value:!0}),w.createNewWebGLContext=w.createWebGLContext=void 0;const O=D(6231),U=D(1713),G={};function q(K){const ee=(function(){if(typeof document>"u"){if(typeof OffscreenCanvas>"u")throw new TypeError("failed to create canvas: OffscreenCanvas is not supported");return new OffscreenCanvas(1,1)}const Y=document.createElement("canvas");return Y.width=1,Y.height=1,Y})();let Z;const ie={alpha:!1,depth:!1,antialias:!1,stencil:!1,preserveDrawingBuffer:!1,premultipliedAlpha:!1,failIfMajorPerformanceCaveat:!1};if((!K||K==="webgl2")&&(Z=ee.getContext("webgl2",ie),Z))try{return new U.WebGLContext(Z,2)}catch(Y){O.Logger.warning("GlContextFactory",`failed to create WebGLContext using contextId 'webgl2'. Error: ${Y}`)}if((!K||K==="webgl")&&(Z=ee.getContext("webgl",ie)||ee.getContext("experimental-webgl",ie),Z))try{return new U.WebGLContext(Z,1)}catch(Y){O.Logger.warning("GlContextFactory",`failed to create WebGLContext using contextId 'webgl' or 'experimental-webgl'. Error: ${Y}`)}throw new Error("WebGL is not supported")}w.createWebGLContext=function K(ee){let Z;ee&&ee!=="webgl2"||!("webgl2"in G)?ee&&ee!=="webgl"||!("webgl"in G)||(Z=G.webgl):Z=G.webgl2,Z=Z||q(ee),ee=ee||Z.version===1?"webgl":"webgl2";const ie=Z.gl;return G[ee]=Z,ie.isContextLost()?(delete G[ee],K(ee)):(ie.disable(ie.DEPTH_TEST),ie.disable(ie.STENCIL_TEST),ie.disable(ie.BLEND),ie.disable(ie.DITHER),ie.disable(ie.POLYGON_OFFSET_FILL),ie.disable(ie.SAMPLE_COVERAGE),ie.enable(ie.SCISSOR_TEST),ie.enable(ie.CULL_FACE),ie.cullFace(ie.BACK),Z)},w.createNewWebGLContext=q},1713:function(F,w,D){var O=this&&this.__createBinding||(Object.create?function(ie,Y,W,ne){ne===void 0&&(ne=W);var se=Object.getOwnPropertyDescriptor(Y,W);se&&!("get"in se?!Y.__esModule:se.writable||se.configurable)||(se={enumerable:!0,get:function(){return Y[W]}}),Object.defineProperty(ie,ne,se)}:function(ie,Y,W,ne){ne===void 0&&(ne=W),ie[ne]=Y[W]}),U=this&&this.__setModuleDefault||(Object.create?function(ie,Y){Object.defineProperty(ie,"default",{enumerable:!0,value:Y})}:function(ie,Y){ie.default=Y}),G=this&&this.__importStar||function(ie){if(ie&&ie.__esModule)return ie;var Y={};if(ie!=null)for(var W in ie)W!=="default"&&Object.prototype.hasOwnProperty.call(ie,W)&&O(Y,ie,W);return U(Y,ie),Y};Object.defineProperty(w,"__esModule",{value:!0}),w.WebGLContext=w.linearSearchLastTrue=void 0;const q=D(1670),K=G(D(7769)),ee=D(9390);function Z(ie){let Y=0;for(;Y<ie.length&&ie[Y]();++Y);return Y-1}w.linearSearchLastTrue=Z,w.WebGLContext=class{constructor(ie,Y){this.frameBufferBound=!1,this.itemsToPoll=[],this.gl=ie,this.version=Y,this.getExtensions(),this.vertexbuffer=this.createVertexbuffer(),this.framebuffer=this.createFramebuffer(),this.queryVitalParameters()}allocateTexture(ie,Y,W,ne){const se=this.gl,le=se.createTexture();se.bindTexture(se.TEXTURE_2D,le),se.texParameteri(se.TEXTURE_2D,se.TEXTURE_MIN_FILTER,se.NEAREST),se.texParameteri(se.TEXTURE_2D,se.TEXTURE_MAG_FILTER,se.NEAREST),se.texParameteri(se.TEXTURE_2D,se.TEXTURE_WRAP_S,se.CLAMP_TO_EDGE),se.texParameteri(se.TEXTURE_2D,se.TEXTURE_WRAP_T,se.CLAMP_TO_EDGE);const ce=ne?W.encode(ne,ie*Y):null;return se.texImage2D(se.TEXTURE_2D,0,W.internalFormat,ie,Y,0,W.format,W.textureType,ce),this.checkError(),le}updateTexture(ie,Y,W,ne,se){const le=this.gl;le.bindTexture(le.TEXTURE_2D,ie);const ce=ne.encode(se,Y*W);le.texSubImage2D(le.TEXTURE_2D,0,0,0,Y,W,ne.format,ne.textureType,ce),this.checkError()}attachFramebuffer(ie,Y,W){const ne=this.gl;ne.bindTexture(ne.TEXTURE_2D,ie),ne.bindFramebuffer(ne.FRAMEBUFFER,this.framebuffer),ne.framebufferTexture2D(ne.FRAMEBUFFER,ne.COLOR_ATTACHMENT0,ne.TEXTURE_2D,ie,0),this.checkError(),ne.viewport(0,0,Y,W),ne.scissor(0,0,Y,W)}readTexture(ie,Y,W,ne,se,le){const ce=this.gl;le||(le=1),this.frameBufferBound||this.attachFramebuffer(ie,Y,W);const he=this.getEncoder(se,le),pe=he.allocate(Y*W);return ce.bindTexture(ce.TEXTURE_2D,ie),ce.framebufferTexture2D(ce.FRAMEBUFFER,ce.COLOR_ATTACHMENT0,ce.TEXTURE_2D,ie,0),ce.readPixels(0,0,Y,W,ce.RGBA,he.textureType,pe),this.checkError(),he.decode(pe,ne)}isFramebufferReady(){return!0}getActiveTexture(){const ie=this.gl;return"TEXTURE"+(ie.getParameter(this.gl.ACTIVE_TEXTURE)-ie.TEXTURE0)}getTextureBinding(){return this.gl.getParameter(this.gl.TEXTURE_BINDING_2D)}getFramebufferBinding(){return this.gl.getParameter(this.gl.FRAMEBUFFER_BINDING)}setVertexAttributes(ie,Y){const W=this.gl;W.vertexAttribPointer(ie,3,W.FLOAT,!1,20,0),W.enableVertexAttribArray(ie),Y!==-1&&(W.vertexAttribPointer(Y,2,W.FLOAT,!1,20,12),W.enableVertexAttribArray(Y)),this.checkError()}createProgram(ie,Y){const W=this.gl,ne=W.createProgram();return W.attachShader(ne,ie),W.attachShader(ne,Y),W.linkProgram(ne),ne}compileShader(ie,Y){const W=this.gl,ne=W.createShader(Y);if(!ne)throw new Error(`createShader() returned null with type ${Y}`);if(W.shaderSource(ne,ie),W.compileShader(ne),W.getShaderParameter(ne,W.COMPILE_STATUS)===!1)throw new Error(`Failed to compile shader: ${W.getShaderInfoLog(ne)}
Shader source:
${ie}`);return ne}deleteShader(ie){this.gl.deleteShader(ie)}bindTextureToUniform(ie,Y,W){const ne=this.gl;ne.activeTexture(ne.TEXTURE0+Y),this.checkError(),ne.bindTexture(ne.TEXTURE_2D,ie),this.checkError(),ne.uniform1i(W,Y),this.checkError()}draw(){this.gl.drawArrays(this.gl.TRIANGLE_STRIP,0,4),this.checkError()}checkError(){if(q.env.debug){const ie=this.gl,Y=ie.getError();let W="";switch(Y){case ie.NO_ERROR:return;case ie.INVALID_ENUM:W="INVALID_ENUM";break;case ie.INVALID_VALUE:W="INVALID_VALUE";break;case ie.INVALID_OPERATION:W="INVALID_OPERATION";break;case ie.INVALID_FRAMEBUFFER_OPERATION:W="INVALID_FRAMEBUFFER_OPERATION";break;case ie.OUT_OF_MEMORY:W="OUT_OF_MEMORY";break;case ie.CONTEXT_LOST_WEBGL:W="CONTEXT_LOST_WEBGL";break;default:W=`Unknown WebGL Error: ${Y.toString(16)}`}throw new Error(W)}}deleteTexture(ie){this.gl.deleteTexture(ie)}deleteProgram(ie){this.gl.deleteProgram(ie)}getEncoder(ie,Y,W=0){if(this.version===2)return new K.RedFloat32DataEncoder(this.gl,Y);switch(ie){case"float":return W===1||this.isRenderFloat32Supported?new K.RGBAFloatDataEncoder(this.gl,Y):new K.RGBAFloatDataEncoder(this.gl,Y,this.textureHalfFloatExtension.HALF_FLOAT_OES);case"int":throw new Error("not implemented");case"byte":return new K.Uint8DataEncoder(this.gl,Y);default:throw new Error(`Invalid dataType: ${ie}`)}}clearActiveTextures(){const ie=this.gl;for(let Y=0;Y<this.maxTextureImageUnits;++Y)ie.activeTexture(ie.TEXTURE0+Y),ie.bindTexture(ie.TEXTURE_2D,null)}dispose(){if(this.disposed)return;const ie=this.gl;ie.bindFramebuffer(ie.FRAMEBUFFER,null),ie.deleteFramebuffer(this.framebuffer),ie.bindBuffer(ie.ARRAY_BUFFER,null),ie.deleteBuffer(this.vertexbuffer),ie.bindBuffer(ie.ELEMENT_ARRAY_BUFFER,null),ie.finish(),this.disposed=!0}createDefaultGeometry(){return new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0])}createVertexbuffer(){const ie=this.gl,Y=ie.createBuffer();if(!Y)throw new Error("createBuffer() returned null");const W=this.createDefaultGeometry();return ie.bindBuffer(ie.ARRAY_BUFFER,Y),ie.bufferData(ie.ARRAY_BUFFER,W,ie.STATIC_DRAW),this.checkError(),Y}createFramebuffer(){const ie=this.gl.createFramebuffer();if(!ie)throw new Error("createFramebuffer returned null");return ie}queryVitalParameters(){const ie=this.gl;if(this.isFloatTextureAttachableToFrameBuffer=this.checkFloatTextureAttachableToFrameBuffer(),this.isRenderFloat32Supported=this.checkRenderFloat32(),this.isFloat32DownloadSupported=this.checkFloat32Download(),this.version===1&&!this.textureHalfFloatExtension&&!this.isRenderFloat32Supported)throw new Error("both float32 and float16 TextureType are not supported");this.isBlendSupported=!this.isRenderFloat32Supported||this.checkFloat32Blend(),this.maxTextureSize=ie.getParameter(ie.MAX_TEXTURE_SIZE),this.maxTextureImageUnits=ie.getParameter(ie.MAX_TEXTURE_IMAGE_UNITS),this.version}getExtensions(){this.version===2?(this.colorBufferFloatExtension=this.gl.getExtension("EXT_color_buffer_float"),this.disjointTimerQueryWebgl2Extension=this.gl.getExtension("EXT_disjoint_timer_query_webgl2")):(this.textureFloatExtension=this.gl.getExtension("OES_texture_float"),this.textureHalfFloatExtension=this.gl.getExtension("OES_texture_half_float"))}checkFloatTextureAttachableToFrameBuffer(){const ie=this.gl,Y=ie.createTexture();ie.bindTexture(ie.TEXTURE_2D,Y);const W=this.version===2?ie.RGBA32F:ie.RGBA;ie.texImage2D(ie.TEXTURE_2D,0,W,1,1,0,ie.RGBA,ie.FLOAT,null);const ne=ie.createFramebuffer();ie.bindFramebuffer(ie.FRAMEBUFFER,ne),ie.framebufferTexture2D(ie.FRAMEBUFFER,ie.COLOR_ATTACHMENT0,ie.TEXTURE_2D,Y,0);const se=ie.checkFramebufferStatus(ie.FRAMEBUFFER)===ie.FRAMEBUFFER_COMPLETE;return ie.bindTexture(ie.TEXTURE_2D,null),ie.bindFramebuffer(ie.FRAMEBUFFER,null),ie.deleteTexture(Y),ie.deleteFramebuffer(ne),se}checkRenderFloat32(){if(this.version===2){if(!this.colorBufferFloatExtension)return!1}else if(!this.textureFloatExtension)return!1;return this.isFloatTextureAttachableToFrameBuffer}checkFloat32Download(){if(this.version===2){if(!this.colorBufferFloatExtension)return!1}else if(!this.textureFloatExtension||!this.gl.getExtension("WEBGL_color_buffer_float"))return!1;return this.isFloatTextureAttachableToFrameBuffer}checkFloat32Blend(){const ie=this.gl;let Y,W,ne,se,le;try{Y=ie.createTexture(),W=ie.createFramebuffer(),ie.bindTexture(ie.TEXTURE_2D,Y);const ce=this.version===2?ie.RGBA32F:ie.RGBA;return ie.texImage2D(ie.TEXTURE_2D,0,ce,1,1,0,ie.RGBA,ie.FLOAT,null),ie.bindFramebuffer(ie.FRAMEBUFFER,W),ie.framebufferTexture2D(ie.FRAMEBUFFER,ie.COLOR_ATTACHMENT0,ie.TEXTURE_2D,Y,0),ie.enable(ie.BLEND),ne=ie.createShader(ie.VERTEX_SHADER),!!ne&&(ie.shaderSource(ne,"void main(){}"),ie.compileShader(ne),se=ie.createShader(ie.FRAGMENT_SHADER),!!se&&(ie.shaderSource(se,"precision highp float;void main(){gl_FragColor=vec4(0.5);}"),ie.compileShader(se),le=ie.createProgram(),!!le&&(ie.attachShader(le,ne),ie.attachShader(le,se),ie.linkProgram(le),ie.useProgram(le),ie.drawArrays(ie.POINTS,0,1),ie.getError()===ie.NO_ERROR)))}finally{ie.disable(ie.BLEND),le&&ie.deleteProgram(le),ne&&ie.deleteShader(ne),se&&ie.deleteShader(se),W&&(ie.bindFramebuffer(ie.FRAMEBUFFER,null),ie.deleteFramebuffer(W)),Y&&(ie.bindTexture(ie.TEXTURE_2D,null),ie.deleteTexture(Y))}}beginTimer(){if(this.version===2&&this.disjointTimerQueryWebgl2Extension){const ie=this.gl,Y=this.disjointTimerQueryWebgl2Extension,W=ie.createQuery();return ie.beginQuery(Y.TIME_ELAPSED_EXT,W),W}throw new Error("WebGL1 profiling currently not supported.")}endTimer(){if(this.version!==2||!this.disjointTimerQueryWebgl2Extension)throw new Error("WebGL1 profiling currently not supported");{const ie=this.gl,Y=this.disjointTimerQueryWebgl2Extension;ie.endQuery(Y.TIME_ELAPSED_EXT)}}isTimerResultAvailable(ie){let Y=!1,W=!1;if(this.version!==2||!this.disjointTimerQueryWebgl2Extension)throw new Error("WebGL1 profiling currently not supported");{const ne=this.gl,se=this.disjointTimerQueryWebgl2Extension;Y=ne.getQueryParameter(ie,ne.QUERY_RESULT_AVAILABLE),W=ne.getParameter(se.GPU_DISJOINT_EXT)}return Y&&!W}getTimerResult(ie){let Y=0;if(this.version!==2)throw new Error("WebGL1 profiling currently not supported");{const W=this.gl;Y=W.getQueryParameter(ie,W.QUERY_RESULT),W.deleteQuery(ie)}return Y/1e6}async waitForQueryAndGetTime(ie){return await(0,ee.repeatedTry)((()=>this.isTimerResultAvailable(ie))),this.getTimerResult(ie)}async createAndWaitForFence(){const ie=this.createFence(this.gl);return this.pollFence(ie)}createFence(ie){let Y;const W=ie,ne=W.fenceSync(W.SYNC_GPU_COMMANDS_COMPLETE,0);return ie.flush(),Y=ne===null?()=>!0:()=>{const se=W.clientWaitSync(ne,0,0);return se===W.ALREADY_SIGNALED||se===W.CONDITION_SATISFIED},{query:ne,isFencePassed:Y}}async pollFence(ie){return new Promise((Y=>{this.addItemToPoll((()=>ie.isFencePassed()),(()=>Y()))}))}pollItems(){const ie=Z(this.itemsToPoll.map((Y=>Y.isDoneFn)));for(let Y=0;Y<=ie;++Y){const{resolveFn:W}=this.itemsToPoll[Y];W()}this.itemsToPoll=this.itemsToPoll.slice(ie+1)}async addItemToPoll(ie,Y){this.itemsToPoll.push({isDoneFn:ie,resolveFn:Y}),this.itemsToPoll.length>1||await(0,ee.repeatedTry)((()=>(this.pollItems(),this.itemsToPoll.length===0)))}}},1036:(F,w,D)=>{Object.defineProperty(w,"__esModule",{value:!0}),w.ExecutionPlan=void 0;const O=D(6231);class U{constructor(q,K){this.op=q,this.node=K}}w.ExecutionPlan=class{constructor(G,q,K){this.graph=G,this.profiler=K,this.initialize(q)}initialize(G){this.profiler.event("session","ExecutionPlan.initialize",(()=>{const q=this.graph.getNodes();if(q.length!==G.length)throw new Error("The size of nodes and OPs do not match.");this._ops=G.map(((K,ee)=>new U(K,q[ee]))),this.reset(),this._starter=[],this._ops.forEach(((K,ee)=>{let Z=!0;for(const ie of K.node.inputs)if(!this._values[ie]&&this.graph.getInputIndices().indexOf(ie)===-1){Z=!1;break}Z&&this._starter.push(ee)}))}))}reset(){this._values=this.graph.getValues().map((G=>G.tensor))}async execute(G,q){return this.profiler.event("session","ExecutionPlan.execute",(async()=>{this.reset();const K=G.createInferenceHandler(),ee=this.graph.getInputIndices();if(q.length!==ee.length)throw new Error(`number of input tensors don't match the number of inputs to the model: actual: ${q.length} expected: ${ee.length}`);q.forEach(((se,le)=>{const ce=ee[le];this._values[ce]=se}));const Z=this._starter.slice(0),ie=this.graph.getValues(),Y=this.graph.getNodes();let W=0;for(;W<Z.length;){const se=Z[W++],le=this._ops[se],ce=le.node.inputs.map((be=>this._values[be]));if(ce.indexOf(void 0)!==-1)throw new Error(`unresolved input detected: op: ${le.node}`);const he=ce;O.Logger.verbose("ExecPlan",`Runing op:${le.node.name} (${he.map(((be,ge)=>`'${le.node.inputs[ge]}': ${be.type}[${be.dims.join(",")}]`)).join(", ")})`);const pe=await this.profiler.event("node",le.node.name,(async()=>le.op.impl(K,he,le.op.context)));if(pe.length!==le.node.outputs.length)throw new Error("the size of output does not match model definition.");pe.forEach(((be,ge)=>{const ve=le.node.outputs[ge];if(this._values[ve])throw new Error(`output [${ve}] already has value: op:${le.node.name}`);this._values[ve]=be}));const me=new Set;pe.forEach(((be,ge)=>{const ve=le.node.outputs[ge];for(const Se of ie[ve].to){const Me=Y[Se];let Ee=!0;for(const we of Me.inputs)if(!this._values[we]){Ee=!1;break}Ee&&me.add(Se)}})),Z.push(...me)}const ne=[];for(let se=0;se<this.graph.getOutputIndices().length;se++){const le=this.graph.getOutputIndices()[se],ce=this._values[le];if(ce===void 0)throw new Error(`required output [${le}] does not have value`);le===0?await ce.getData():ce.data,ne.push(ce)}return O.Logger.verbose("ExecPlan","disposing of inferenceHandler"),K.dispose(),ne}))}}},7070:(F,w,D)=>{Object.defineProperty(w,"__esModule",{value:!0}),w.Graph=void 0;const O=D(1446),U=D(7778),G=D(9395),q=D(9162),K=D(2517);var ee=G.onnxruntime.experimental.fbs;w.Graph={from:(W,ne)=>new Y(W,ne)};class Z{constructor(ne){this._from=void 0,this._to=[],this.tensor=void 0,this.type=void 0,ne&&(this.type=K.ProtoUtil.tensorValueTypeFromProto(ne.type.tensorType))}get from(){return this._from}get to(){return this._to}}class ie{constructor(ne,se){ne instanceof O.onnx.NodeProto?(this.name=ne.name,this.opType=ne.opType,this.attributes=new U.Attribute(ne.attribute)):ne instanceof ee.Node&&(this.name=se??ne.name(),this.opType=ne.opType(),this.attributes=new U.Attribute(K.ProtoUtil.tensorAttributesFromORTFormat(ne))),this.inputs=[],this.outputs=[],this.executeNode=!0}}class Y{constructor(ne,se){if(!ne)throw new TypeError("graph is empty");this.buildGraph(ne),this.transformGraph(se),this.checkIsAcyclic()}getInputIndices(){return this._allInputIndices}getInputNames(){return this._allInputNames}getOutputIndices(){return this._allOutputIndices}getOutputNames(){return this._allOutputNames}getValues(){return this._allData}getNodes(){return this._nodes}buildGraph(ne){if(ne instanceof O.onnx.GraphProto)this.buildGraphFromOnnxFormat(ne);else{if(!(ne instanceof ee.Graph))throw new TypeError("Graph type is not supported.");this.buildGraphFromOrtFormat(ne)}}buildGraphFromOnnxFormat(ne){const se=new Map;this._allData=[],this._allInputIndices=[],this._allInputNames=[],this._allOutputIndices=[],this._allOutputNames=[],this._nodes=[];const le=new Map;if(!ne.input)throw new Error("missing information in graph: input");const ce=[];for(const he of ne.input){if(se.has(he.name))throw new Error(`duplicated input name: ${he.name}`);const pe=this._allData.push(new Z(he))-1;se.set(he.name,pe),ce.push(he.name)}if(!ne.initializer)throw new Error("missing information in graph: initializer");for(const he of ne.initializer){let pe=se.get(he.name);if(pe===void 0){const me=new Z;me.type={shape:{dims:K.ProtoUtil.tensorDimsFromProto(he.dims)},tensorType:K.ProtoUtil.tensorDataTypeFromProto(he.dataType)},pe=this._allData.push(me)-1,se.set(he.name,pe)}this._allData[pe]._from=-1,this._allData[pe].tensor=q.Tensor.fromProto(he)}for(let he=0;he<this._allData.length;he++)this._allData[he].tensor||(this._allInputIndices.push(he),this._allInputNames.push(ce[he]));if(!ne.output)throw new Error("missing information in graph: output");for(const he of ne.output){if(se.has(he.name))throw new Error(`duplicated output name: ${he.name}`);const pe=this._allData.push(new Z(he))-1;se.set(he.name,pe),this._allOutputIndices.push(pe),this._allOutputNames.push(he.name)}if(!ne.node)throw new Error("missing information in graph: node");for(const he of ne.node){if(!he.name)for(let me=0;;me++){const be=`unnamed_${he.opType}_${me}`;if(!le.has(be)){he.name=be;break}}if(le.has(he.name))throw new Error(`duplicated node name: ${he.name}`);const pe=this._nodes.push(new ie(he))-1;le.set(he.name,pe)}for(let he=0;he<this._nodes.length;he++){const pe=this._nodes[he],me=ne.node[he];if(!me.output)throw new Error(`missing output for node: ${me.name}`);for(const be of me.output){let ge=se.get(be);if(ge===void 0&&(ge=this._allData.push(new Z)-1,se.set(be,ge)),pe.outputs.push(ge),this._allData[ge]._from!==void 0)throw new Error(`multiple nodes output to one data value: ${ge}`);if(this._allData[ge]._from=he,me.opType==="Constant"){if(!me.attribute||me.attribute.length!==1||!me.attribute[0].t)throw new Error("missing attributes or missing tensor value in attributes for this Constant operator");if(!me.output||me.output.length!==1)throw new Error("missing output or incorrect number of outputs for this Constant operator");pe.outputs.pop(),pe.executeNode=!1,this._allData[ge]._from=-1,this._allData[ge].tensor=q.Tensor.fromProto(me.attribute[0].t)}}}for(let he=0;he<this._nodes.length;he++){const pe=this._nodes[he],me=ne.node[he];if(!me.input)throw new Error(`missing input for node: ${me.name}`);for(const be of me.input){const ge=se.get(be);if(ge===void 0){if(be===""&&me.input.length===3&&me.opType==="Resize")continue;throw new Error(`unrecognized input '${be}' for node: ${me.name}`)}pe.inputs.push(ge),this._allData[ge]._to.push(he)}}return!0}buildGraphFromOrtFormat(ne){var se,le,ce;const he=new Map;this._allData=[],this._allInputIndices=[],this._allInputNames=[],this._allOutputIndices=[],this._allOutputNames=[],this._nodes=[];const pe=new Map,me=[];for(let be=0;be<ne.inputsLength();be++){const ge=ne.inputs(be);if(he.has(ge))throw new Error(`duplicated input name: ${ge}`);for(let ve=0;ve<ne.nodeArgsLength();ve++)if(((se=ne.nodeArgs(ve))===null||se===void 0?void 0:se.name())===ge){const Se=new Z;if(((ce=(le=ne.nodeArgs(ve))===null||le===void 0?void 0:le.type())===null||ce===void 0?void 0:ce.valueType())!==ee.TypeInfoValue.tensor_type)throw new Error("Unexpected value type for the nodeArg.");const Me=ne.nodeArgs(ve).type().value(new ee.TensorTypeAndShape),Ee=K.ProtoUtil.tensorDataTypeFromProto(Me.elemType()),we=Me.shape(),Re=[];for(let Ne=0;Ne<we.dimLength();Ne++)Re.push(K.LongUtil.longToNumber(we.dim(Ne).value().dimValue()));Se.type={shape:{dims:Re},tensorType:Ee};const Le=this._allData.push(Se)-1;he.set(ge,Le),me.push(ge)}}for(let be=0;be<ne.initializersLength();be++){const ge=ne.initializers(be);let ve=he.get(ge.name());if(ve===void 0){const Se=new Z,Me=K.ProtoUtil.tensorDimsFromORTFormat(ge),Ee=K.ProtoUtil.tensorDataTypeFromProto(ge.dataType());Se.type={shape:{dims:Me},tensorType:Ee},ve=this._allData.push(Se)-1,he.set(ge.name(),ve)}this._allData[ve]._from=-1,this._allData[ve].tensor=q.Tensor.fromOrtTensor(ge)}for(let be=0;be<this._allData.length;be++)this._allData[be].tensor||(this._allInputIndices.push(be),this._allInputNames.push(me[be]));for(let be=0;be<ne.outputsLength();be++){const ge=ne.outputs(be);if(he.has(ge))throw new Error(`duplicated output name: ${ge}`);const ve=this._allData.push(new Z)-1;he.set(ge,ve),this._allOutputIndices.push(ve),this._allOutputNames.push(ge)}if(!ne.nodes)throw new Error("missing information in graph: node");for(let be=0;be<ne.nodesLength();be++){const ge=ne.nodes(be);let ve=ge.name();if(!ve)for(let Me=0;ve=`unnamed_${ge.opType()}_${Me}`,pe.has(ve);Me++);if(pe.has(ve))throw new Error(`duplicated node name: ${ve}`);const Se=this._nodes.push(new ie(ge,ve))-1;pe.set(ve,Se)}for(let be=0;be<this._nodes.length;be++){const ge=this._nodes[be],ve=ne.nodes(be);if(ve==null)throw new Error(`No node exists at index ${be}`);if(ve?.outputsLength()===0)throw new Error(`missing output for node: ${ve.name}`);for(let Se=0;Se<ve?.outputsLength();Se++){const Me=ve?.outputs(Se);let Ee=he.get(Me);if(Ee===void 0&&(Ee=this._allData.push(new Z)-1,he.set(Me,Ee)),ge.outputs.push(Ee),this._allData[Ee]._from!==void 0)throw new Error(`multiple nodes output to one data value: ${Ee}`);if(this._allData[Ee]._from=be,ve.opType()==="Constant"){if(ve.attributesLength()!==1||!ve.attributes(0).t())throw new Error("missing attributes or missing tensor value in attributes for this Constant operator");if(ve.outputsLength()!==1)throw new Error("missing output or incorrect number of outputs for this Constant operator");ge.outputs.pop(),ge.executeNode=!1,this._allData[Ee]._from=-1,this._allData[Ee].tensor=q.Tensor.fromOrtTensor(ve.attributes(0).t())}}}for(let be=0;be<this._nodes.length;be++){const ge=this._nodes[be],ve=ne.nodes(be);if(ve.inputsLength()===0)throw new Error(`missing input for node: ${ve.name}`);for(let Se=0;Se<ve.inputsLength();Se++){const Me=ve.inputs(Se),Ee=he.get(Me);if(Ee===void 0)throw new Error(`unrecognized input '${Me}' for node: ${ve.name()}`);ge.inputs.push(Ee),this._allData[Ee]._to.push(be)}}}checkIsAcyclic(){const ne=new Set;this._allInputIndices.forEach((ce=>{this._allData[ce]._to.forEach((he=>{ne.add(he)}))}));const se=Array.from(ne),le=new Array(this._nodes.length).fill("white");for(;se.length>0;){const ce=se.pop();le[ce]==="gray"?le[ce]="black":(se.push(ce),le[ce]="gray",this._nodes[ce].outputs.forEach((he=>{const pe=this._allData[he];if(pe.tensor!==void 0)throw new Error("node outputs should not be initialized");if(pe._from!==ce)throw new Error("from property of the Value object doesn't match index of Node being processed");pe._to.forEach((me=>{if(le[me]==="gray")throw new Error("model graph is cyclic");le[me]==="white"&&se.push(me)}))})))}}transformGraph(ne){this.removeAllIdentityNodes(),this.removeAllDropoutNodes(),this.fuseConvActivationNodes(),ne&&ne.transformGraph(this),this.finalizeGraph()}finalizeGraph(){let ne=0;for(let se=0;se<this._nodes.length;se++)this._nodes[se].executeNode?ne>0&&(this._nodes[se].inputs.forEach((le=>{const ce=this._allData[le]._to.indexOf(se+ne);ce!==-1&&(this._allData[le]._to[ce]=se)})),this._nodes[se].outputs.forEach((le=>{this._allData[le]._from&&this._allData[le]._from===se+ne&&(this._allData[le]._from=se)}))):(ne++,this._nodes[se].outputs.forEach((le=>{this._allData[le]._from=-2})),this._nodes.splice(se,1),se--);ne=0;for(let se=0;se<this._allData.length;se++)if(this._allData[se].from!==-2||this._allOutputIndices.indexOf(se+ne)!==-1){if(ne>0){let le=-1;this._allData[se].from!==void 0&&this._allData[se].from!==-1?(le=this._nodes[this._allData[se].from].outputs.indexOf(se+ne),le!==-1&&(this._nodes[this._allData[se].from].outputs[le]=se)):(le=this._allInputIndices.indexOf(se+ne),le!==-1&&(this._allInputIndices[le]=se)),this._allData[se].to.forEach((ce=>{le=this._nodes[ce].inputs.indexOf(se+ne),le!==-1&&(this._nodes[ce].inputs[le]=se)})),this._allData[se].to.length===0&&(le=this._allOutputIndices.indexOf(se+ne),le!==-1&&(this._allOutputIndices[le]=se))}}else ne++,this._allData.splice(se,1),se--}deleteNode(ne){const se=this._nodes[ne];if(se.outputs.length>1){for(let be=1;be<se.outputs.length;be++)if(this._allData[se.outputs[be]].to.length>0)throw new Error("Node deletion with more than one output connected to other nodes is not supported. ")}se.executeNode=!1;const le=se.inputs[0],ce=se.outputs[0],he=this._allData[ce].to,pe=this._allData[le].to.indexOf(ne);if(pe===-1)throw new Error("The Value object doesn't have the current Node in it's 'to' property ");this._allData[le].to.splice(pe,1),this._allData[ce]._to=[];const me=this._allOutputIndices.indexOf(ce);if(me!==-1&&(this._allOutputIndices[me]=le),he&&he.length>0)for(const be of he){const ge=this._nodes[be].inputs.indexOf(ce);if(ge===-1)throw new Error("The Node object doesn't have the output Value in it's 'inputs' property ");this._nodes[be].inputs[ge]=le,this._allData[le].to.push(be)}}removeAllDropoutNodes(){let ne=0;for(const se of this._nodes){if(se.opType==="Dropout"){if(se.inputs.length!==1)throw new Error("Dropout nodes should only contain one input. ");if(se.outputs.length!==1&&se.outputs.length!==2)throw new Error("Dropout nodes should contain either 1 or 2 output(s)");if(se.outputs.length===2&&this._allData[se.outputs[1]]._to.length!==0)throw new Error("Dropout nodes's second output should not be referenced by other nodes");this.deleteNode(ne)}ne++}}removeAllIdentityNodes(){let ne=0;for(const se of this._nodes)se.opType==="Identity"&&this.deleteNode(ne),ne++}isActivation(ne){switch(ne.opType){case"Relu":case"Sigmoid":case"Clip":return!0;default:return!1}}fuseConvActivationNodes(){for(const ne of this._nodes)if(ne.opType==="Conv"){const se=this._allData[ne.outputs[0]]._to;if(se.length===1&&this.isActivation(this._nodes[se[0]])){const le=this._nodes[se[0]];if(le.opType==="Clip")if(le.inputs.length===1)try{ne.attributes.set("activation_params","floats",[le.attributes.getFloat("min"),le.attributes.getFloat("max")])}catch{ne.attributes.set("activation_params","floats",[K.MIN_CLIP,K.MAX_CLIP])}else{if(!(le.inputs.length>=3&&this._allData[le.inputs[1]].tensor!==void 0&&this._allData[le.inputs[2]].tensor!==void 0))continue;ne.attributes.set("activation_params","floats",[this._allData[le.inputs[1]].tensor.floatData[0],this._allData[le.inputs[2]].tensor.floatData[0]])}ne.attributes.set("activation","string",le.opType),this.deleteNode(se[0])}}}}},6231:(F,w)=>{Object.defineProperty(w,"__esModule",{value:!0}),w.now=w.Profiler=w.Logger=void 0;const D={verbose:1e3,info:2e3,warning:4e3,error:5e3,fatal:6e3},O={none:new class{log(ie,Y,W){}},console:new class{log(ie,Y,W){console.log(`${this.color(ie)} ${W?"\x1B[35m"+W+"\x1B[0m ":""}${Y}`)}color(ie){switch(ie){case"verbose":return"\x1B[34;40mv\x1B[0m";case"info":return"\x1B[32mi\x1B[0m";case"warning":return"\x1B[30;43mw\x1B[0m";case"error":return"\x1B[31;40me\x1B[0m";case"fatal":return"\x1B[101mf\x1B[0m";default:throw new Error(`unsupported severity: ${ie}`)}}}},U={provider:"console",minimalSeverity:"warning",logDateTime:!0,logSourceLocation:!1};let G={"":U};function q(ie,Y,W,ne){if(Y===void 0)return se=ie,{verbose:q.verbose.bind(null,se),info:q.info.bind(null,se),warning:q.warning.bind(null,se),error:q.error.bind(null,se),fatal:q.fatal.bind(null,se)};if(W===void 0)K(ie,Y);else if(typeof W=="number"&&ne===void 0)K(ie,Y);else if(typeof W=="string"&&ne===void 0)K(ie,W,0,Y);else{if(typeof W!="string"||typeof ne!="number")throw new TypeError("input is valid");K(ie,W,0,Y)}var se}function K(ie,Y,W,ne){const se=G[ne||""]||G[""];D[ie]<D[se.minimalSeverity]||(se.logDateTime&&(Y=`${new Date().toISOString()}|${Y}`),se.logSourceLocation,O[se.provider].log(ie,Y,ne))}(function(ie){function Y(ne){G={},W("",ne||{})}function W(ne,se){if(ne==="*")Y(se);else{const le=G[ne]||U;G[ne]={provider:se.provider||le.provider,minimalSeverity:se.minimalSeverity||le.minimalSeverity,logDateTime:se.logDateTime===void 0?le.logDateTime:se.logDateTime,logSourceLocation:se.logSourceLocation===void 0?le.logSourceLocation:se.logSourceLocation}}}ie.verbose=function(ne,se){ie("verbose",ne,se)},ie.info=function(ne,se){ie("info",ne,se)},ie.warning=function(ne,se){ie("warning",ne,se)},ie.error=function(ne,se){ie("error",ne,se)},ie.fatal=function(ne,se){ie("fatal",ne,se)},ie.reset=Y,ie.set=W,ie.setWithEnv=function(ne){const se={};ne.logLevel&&(se.minimalSeverity=ne.logLevel),W("",se)}})(q||(q={})),w.Logger=q;class ee{constructor(Y,W,ne,se,le,ce){this.category=Y,this.name=W,this.startTime=ne,this.endCallback=se,this.timer=le,this.ctx=ce}end(){return this.endCallback(this)}async checkTimer(){if(this.ctx===void 0||this.timer===void 0)throw new Error("No webgl timer found");return this.ctx.endTimer(),this.ctx.waitForQueryAndGetTime(this.timer)}}class Z{constructor(Y,W,ne,se){this.category=Y,this.name=W,this.startTime=ne,this.endTime=se}}w.Profiler=class{static create(ie){return ie===void 0?new this:new this(ie.maxNumberEvents,ie.flushBatchSize,ie.flushIntervalInMilliseconds)}constructor(ie,Y,W){this._started=!1,this._flushPointer=0,this._started=!1,this._maxNumberEvents=ie===void 0?1e4:ie,this._flushBatchSize=Y===void 0?10:Y,this._flushIntervalInMilliseconds=W===void 0?5e3:W}start(){this._started=!0,this._timingEvents=[],this._flushTime=(0,w.now)(),this._flushPointer=0}stop(){for(this._started=!1;this._flushPointer<this._timingEvents.length;this._flushPointer++)this.logOneEvent(this._timingEvents[this._flushPointer])}event(ie,Y,W,ne){const se=this._started?this.begin(ie,Y,ne):void 0;let le=!1;const ce=W();if(ce&&typeof ce.then=="function")return le=!0,new Promise(((he,pe)=>{ce.then((async me=>{se&&await se.end(),he(me)}),(async me=>{se&&await se.end(),pe(me)}))}));if(!le&&se){const he=se.end();if(he&&typeof he.then=="function")return new Promise(((pe,me)=>{he.then((()=>{pe(ce)}),(be=>{me(be)}))}))}return ce}begin(ie,Y,W){if(!this._started)throw new Error("profiler is not started yet");if(W===void 0){const ne=(0,w.now)();return this.flush(ne),new ee(ie,Y,ne,(se=>this.endSync(se)))}{const ne=W.beginTimer();return new ee(ie,Y,0,(async se=>this.end(se)),ne,W)}}async end(ie){const Y=await ie.checkTimer();this._timingEvents.length<this._maxNumberEvents&&(this._timingEvents.push(new Z(ie.category,ie.name,ie.startTime,Y)),this.flush(Y))}endSync(ie){const Y=(0,w.now)();this._timingEvents.length<this._maxNumberEvents&&(this._timingEvents.push(new Z(ie.category,ie.name,ie.startTime,Y)),this.flush(Y))}logOneEvent(ie){w.Logger.verbose(`Profiler.${ie.category}`,`${(ie.endTime-ie.startTime).toFixed(2)}ms on event '${ie.name}' at ${ie.endTime.toFixed(2)}`)}flush(ie){if(this._timingEvents.length-this._flushPointer>=this._flushBatchSize||ie-this._flushTime>=this._flushIntervalInMilliseconds){for(const Y=this._flushPointer;this._flushPointer<Y+this._flushBatchSize&&this._flushPointer<this._timingEvents.length;this._flushPointer++)this.logOneEvent(this._timingEvents[this._flushPointer]);this._flushTime=(0,w.now)()}}get started(){return this._started}},w.now=typeof performance<"u"&&performance.now?()=>performance.now():Date.now},2644:(F,w,D)=>{Object.defineProperty(w,"__esModule",{value:!0}),w.Model=void 0;const O=D(5686),U=D(1446),G=D(7070),q=D(9395),K=D(2517);var ee=q.onnxruntime.experimental.fbs;w.Model=class{constructor(){}load(Z,ie,Y){if(!Y)try{return void this.loadFromOnnxFormat(Z,ie)}catch(W){if(Y!==void 0)throw W}this.loadFromOrtFormat(Z,ie)}loadFromOnnxFormat(Z,ie){const Y=U.onnx.ModelProto.decode(Z);if(K.LongUtil.longToNumber(Y.irVersion)<3)throw new Error("only support ONNX model with IR_VERSION>=3");this._opsets=Y.opsetImport.map((W=>({domain:W.domain,version:K.LongUtil.longToNumber(W.version)}))),this._graph=G.Graph.from(Y.graph,ie)}loadFromOrtFormat(Z,ie){const Y=new O.flatbuffers.ByteBuffer(Z),W=ee.InferenceSession.getRootAsInferenceSession(Y).model();if(K.LongUtil.longToNumber(W.irVersion())<3)throw new Error("only support ONNX model with IR_VERSION>=3");this._opsets=[];for(let ne=0;ne<W.opsetImportLength();ne++){const se=W.opsetImport(ne);this._opsets.push({domain:se?.domain(),version:K.LongUtil.longToNumber(se.version())})}this._graph=G.Graph.from(W.graph(),ie)}get graph(){return this._graph}get opsets(){return this._opsets}}},782:(F,w)=>{Object.defineProperty(w,"__esModule",{value:!0}),w.FLOAT_TYPES=w.INT_TYPES=w.NUMBER_TYPES=void 0,w.NUMBER_TYPES=["float32","float64","int32","int16","int8","uint16","uint32","uint8"],w.INT_TYPES=["int32","int16","int8","uint16","uint32","uint8"],w.FLOAT_TYPES=["float32","float64"]},1047:(F,w)=>{function D(O,U){if(U.endsWith("+")){const G=Number.parseInt(U.substring(0,U.length-1),10);return!isNaN(G)&&G<=O}if(U.split("-").length===2){const G=U.split("-"),q=Number.parseInt(G[0],10),K=Number.parseInt(G[1],10);return!isNaN(q)&&!isNaN(K)&&q<=O&&O<=K}return Number.parseInt(U,10)===O}Object.defineProperty(w,"__esModule",{value:!0}),w.resolveOperator=void 0,w.resolveOperator=function(O,U,G){for(const q of G){const K=q[0],ee=q[1],Z=q[2],ie=q[3],Y=q[4];if(O.opType===K){for(const W of U)if((W.domain===ee||W.domain==="ai.onnx"&&ee==="")&&D(W.version,Z))return{opImpl:ie,opInit:Y}}}throw new TypeError(`cannot resolve operator '${O.opType}' with opsets: ${U.map((q=>`${q.domain||"ai.onnx"} v${q.version}`)).join(", ")}`)}},9395:(F,w,D)=>{Object.defineProperty(w,"__esModule",{value:!0}),w.onnxruntime=void 0;const O=D(5686);var U,G;U=w.onnxruntime||(w.onnxruntime={}),(function(q){(function(K){K[K.UNDEFINED=0]="UNDEFINED",K[K.FLOAT=1]="FLOAT",K[K.INT=2]="INT",K[K.STRING=3]="STRING",K[K.TENSOR=4]="TENSOR",K[K.GRAPH=5]="GRAPH",K[K.FLOATS=6]="FLOATS",K[K.INTS=7]="INTS",K[K.STRINGS=8]="STRINGS",K[K.TENSORS=9]="TENSORS",K[K.GRAPHS=10]="GRAPHS",K[K.SPARSE_TENSOR=11]="SPARSE_TENSOR",K[K.SPARSE_TENSORS=12]="SPARSE_TENSORS"})(q.AttributeType||(q.AttributeType={}))})((G=U.experimental||(U.experimental={})).fbs||(G.fbs={})),(function(q){(function(K){(function(ee){(function(Z){Z[Z.UNKNOWN=0]="UNKNOWN",Z[Z.VALUE=1]="VALUE",Z[Z.PARAM=2]="PARAM"})(ee.DimensionValueType||(ee.DimensionValueType={}))})(K.fbs||(K.fbs={}))})(q.experimental||(q.experimental={}))})(w.onnxruntime||(w.onnxruntime={})),(function(q){(function(K){(function(ee){(function(Z){Z[Z.UNDEFINED=0]="UNDEFINED",Z[Z.FLOAT=1]="FLOAT",Z[Z.UINT8=2]="UINT8",Z[Z.INT8=3]="INT8",Z[Z.UINT16=4]="UINT16",Z[Z.INT16=5]="INT16",Z[Z.INT32=6]="INT32",Z[Z.INT64=7]="INT64",Z[Z.STRING=8]="STRING",Z[Z.BOOL=9]="BOOL",Z[Z.FLOAT16=10]="FLOAT16",Z[Z.DOUBLE=11]="DOUBLE",Z[Z.UINT32=12]="UINT32",Z[Z.UINT64=13]="UINT64",Z[Z.COMPLEX64=14]="COMPLEX64",Z[Z.COMPLEX128=15]="COMPLEX128",Z[Z.BFLOAT16=16]="BFLOAT16"})(ee.TensorDataType||(ee.TensorDataType={}))})(K.fbs||(K.fbs={}))})(q.experimental||(q.experimental={}))})(w.onnxruntime||(w.onnxruntime={})),(function(q){(function(K){(function(ee){(function(Z){Z[Z.Primitive=0]="Primitive",Z[Z.Fused=1]="Fused"})(ee.NodeType||(ee.NodeType={}))})(K.fbs||(K.fbs={}))})(q.experimental||(q.experimental={}))})(w.onnxruntime||(w.onnxruntime={})),(function(q){(function(K){(function(ee){(function(Z){Z[Z.NONE=0]="NONE",Z[Z.tensor_type=1]="tensor_type",Z[Z.sequence_type=2]="sequence_type",Z[Z.map_type=3]="map_type"})(ee.TypeInfoValue||(ee.TypeInfoValue={}))})(K.fbs||(K.fbs={}))})(q.experimental||(q.experimental={}))})(w.onnxruntime||(w.onnxruntime={})),(function(q){(function(K){(function(ee){class Z{constructor(){this.bb=null,this.bb_pos=0}__init(Y,W){return this.bb_pos=Y,this.bb=W,this}static getRootAsShape(Y,W){return(W||new Z).__init(Y.readInt32(Y.position())+Y.position(),Y)}static getSizePrefixedRootAsShape(Y,W){return Y.setPosition(Y.position()+O.flatbuffers.SIZE_PREFIX_LENGTH),(W||new Z).__init(Y.readInt32(Y.position())+Y.position(),Y)}dim(Y,W){let ne=this.bb.__offset(this.bb_pos,4);return ne?(W||new q.experimental.fbs.Dimension).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+ne)+4*Y),this.bb):null}dimLength(){let Y=this.bb.__offset(this.bb_pos,4);return Y?this.bb.__vector_len(this.bb_pos+Y):0}static startShape(Y){Y.startObject(1)}static addDim(Y,W){Y.addFieldOffset(0,W,0)}static createDimVector(Y,W){Y.startVector(4,W.length,4);for(let ne=W.length-1;ne>=0;ne--)Y.addOffset(W[ne]);return Y.endVector()}static startDimVector(Y,W){Y.startVector(4,W,4)}static endShape(Y){return Y.endObject()}static createShape(Y,W){return Z.startShape(Y),Z.addDim(Y,W),Z.endShape(Y)}}ee.Shape=Z})(K.fbs||(K.fbs={}))})(q.experimental||(q.experimental={}))})(w.onnxruntime||(w.onnxruntime={})),(function(q){(function(K){(function(ee){class Z{constructor(){this.bb=null,this.bb_pos=0}__init(Y,W){return this.bb_pos=Y,this.bb=W,this}static getRootAsDimension(Y,W){return(W||new Z).__init(Y.readInt32(Y.position())+Y.position(),Y)}static getSizePrefixedRootAsDimension(Y,W){return Y.setPosition(Y.position()+O.flatbuffers.SIZE_PREFIX_LENGTH),(W||new Z).__init(Y.readInt32(Y.position())+Y.position(),Y)}value(Y){let W=this.bb.__offset(this.bb_pos,4);return W?(Y||new q.experimental.fbs.DimensionValue).__init(this.bb.__indirect(this.bb_pos+W),this.bb):null}denotation(Y){let W=this.bb.__offset(this.bb_pos,6);return W?this.bb.__string(this.bb_pos+W,Y):null}static startDimension(Y){Y.startObject(2)}static addValue(Y,W){Y.addFieldOffset(0,W,0)}static addDenotation(Y,W){Y.addFieldOffset(1,W,0)}static endDimension(Y){return Y.endObject()}static createDimension(Y,W,ne){return Z.startDimension(Y),Z.addValue(Y,W),Z.addDenotation(Y,ne),Z.endDimension(Y)}}ee.Dimension=Z})(K.fbs||(K.fbs={}))})(q.experimental||(q.experimental={}))})(w.onnxruntime||(w.onnxruntime={})),(function(q){(function(K){(function(ee){class Z{constructor(){this.bb=null,this.bb_pos=0}__init(Y,W){return this.bb_pos=Y,this.bb=W,this}static getRootAsDimensionValue(Y,W){return(W||new Z).__init(Y.readInt32(Y.position())+Y.position(),Y)}static getSizePrefixedRootAsDimensionValue(Y,W){return Y.setPosition(Y.position()+O.flatbuffers.SIZE_PREFIX_LENGTH),(W||new Z).__init(Y.readInt32(Y.position())+Y.position(),Y)}dimType(){let Y=this.bb.__offset(this.bb_pos,4);return Y?this.bb.readInt8(this.bb_pos+Y):q.experimental.fbs.DimensionValueType.UNKNOWN}dimValue(){let Y=this.bb.__offset(this.bb_pos,6);return Y?this.bb.readInt64(this.bb_pos+Y):this.bb.createLong(0,0)}dimParam(Y){let W=this.bb.__offset(this.bb_pos,8);return W?this.bb.__string(this.bb_pos+W,Y):null}static startDimensionValue(Y){Y.startObject(3)}static addDimType(Y,W){Y.addFieldInt8(0,W,q.experimental.fbs.DimensionValueType.UNKNOWN)}static addDimValue(Y,W){Y.addFieldInt64(1,W,Y.createLong(0,0))}static addDimParam(Y,W){Y.addFieldOffset(2,W,0)}static endDimensionValue(Y){return Y.endObject()}static createDimensionValue(Y,W,ne,se){return Z.startDimensionValue(Y),Z.addDimType(Y,W),Z.addDimValue(Y,ne),Z.addDimParam(Y,se),Z.endDimensionValue(Y)}}ee.DimensionValue=Z})(K.fbs||(K.fbs={}))})(q.experimental||(q.experimental={}))})(w.onnxruntime||(w.onnxruntime={})),(function(q){(function(K){(function(ee){class Z{constructor(){this.bb=null,this.bb_pos=0}__init(Y,W){return this.bb_pos=Y,this.bb=W,this}static getRootAsTensorTypeAndShape(Y,W){return(W||new Z).__init(Y.readInt32(Y.position())+Y.position(),Y)}static getSizePrefixedRootAsTensorTypeAndShape(Y,W){return Y.setPosition(Y.position()+O.flatbuffers.SIZE_PREFIX_LENGTH),(W||new Z).__init(Y.readInt32(Y.position())+Y.position(),Y)}elemType(){let Y=this.bb.__offset(this.bb_pos,4);return Y?this.bb.readInt32(this.bb_pos+Y):q.experimental.fbs.TensorDataType.UNDEFINED}shape(Y){let W=this.bb.__offset(this.bb_pos,6);return W?(Y||new q.experimental.fbs.Shape).__init(this.bb.__indirect(this.bb_pos+W),this.bb):null}static startTensorTypeAndShape(Y){Y.startObject(2)}static addElemType(Y,W){Y.addFieldInt32(0,W,q.experimental.fbs.TensorDataType.UNDEFINED)}static addShape(Y,W){Y.addFieldOffset(1,W,0)}static endTensorTypeAndShape(Y){return Y.endObject()}static createTensorTypeAndShape(Y,W,ne){return Z.startTensorTypeAndShape(Y),Z.addElemType(Y,W),Z.addShape(Y,ne),Z.endTensorTypeAndShape(Y)}}ee.TensorTypeAndShape=Z})(K.fbs||(K.fbs={}))})(q.experimental||(q.experimental={}))})(w.onnxruntime||(w.onnxruntime={})),(function(q){(function(K){(function(ee){class Z{constructor(){this.bb=null,this.bb_pos=0}__init(Y,W){return this.bb_pos=Y,this.bb=W,this}static getRootAsMapType(Y,W){return(W||new Z).__init(Y.readInt32(Y.position())+Y.position(),Y)}static getSizePrefixedRootAsMapType(Y,W){return Y.setPosition(Y.position()+O.flatbuffers.SIZE_PREFIX_LENGTH),(W||new Z).__init(Y.readInt32(Y.position())+Y.position(),Y)}keyType(){let Y=this.bb.__offset(this.bb_pos,4);return Y?this.bb.readInt32(this.bb_pos+Y):q.experimental.fbs.TensorDataType.UNDEFINED}valueType(Y){let W=this.bb.__offset(this.bb_pos,6);return W?(Y||new q.experimental.fbs.TypeInfo).__init(this.bb.__indirect(this.bb_pos+W),this.bb):null}static startMapType(Y){Y.startObject(2)}static addKeyType(Y,W){Y.addFieldInt32(0,W,q.experimental.fbs.TensorDataType.UNDEFINED)}static addValueType(Y,W){Y.addFieldOffset(1,W,0)}static endMapType(Y){return Y.endObject()}static createMapType(Y,W,ne){return Z.startMapType(Y),Z.addKeyType(Y,W),Z.addValueType(Y,ne),Z.endMapType(Y)}}ee.MapType=Z})(K.fbs||(K.fbs={}))})(q.experimental||(q.experimental={}))})(w.onnxruntime||(w.onnxruntime={})),(function(q){(function(K){(function(ee){class Z{constructor(){this.bb=null,this.bb_pos=0}__init(Y,W){return this.bb_pos=Y,this.bb=W,this}static getRootAsSequenceType(Y,W){return(W||new Z).__init(Y.readInt32(Y.position())+Y.position(),Y)}static getSizePrefixedRootAsSequenceType(Y,W){return Y.setPosition(Y.position()+O.flatbuffers.SIZE_PREFIX_LENGTH),(W||new Z).__init(Y.readInt32(Y.position())+Y.position(),Y)}elemType(Y){let W=this.bb.__offset(this.bb_pos,4);return W?(Y||new q.experimental.fbs.TypeInfo).__init(this.bb.__indirect(this.bb_pos+W),this.bb):null}static startSequenceType(Y){Y.startObject(1)}static addElemType(Y,W){Y.addFieldOffset(0,W,0)}static endSequenceType(Y){return Y.endObject()}static createSequenceType(Y,W){return Z.startSequenceType(Y),Z.addElemType(Y,W),Z.endSequenceType(Y)}}ee.SequenceType=Z})(K.fbs||(K.fbs={}))})(q.experimental||(q.experimental={}))})(w.onnxruntime||(w.onnxruntime={})),(function(q){(function(K){(K.fbs||(K.fbs={})).EdgeEnd=class{constructor(){this.bb=null,this.bb_pos=0}__init(ee,Z){return this.bb_pos=ee,this.bb=Z,this}nodeIndex(){return this.bb.readUint32(this.bb_pos)}srcArgIndex(){return this.bb.readInt32(this.bb_pos+4)}dstArgIndex(){return this.bb.readInt32(this.bb_pos+8)}static createEdgeEnd(ee,Z,ie,Y){return ee.prep(4,12),ee.writeInt32(Y),ee.writeInt32(ie),ee.writeInt32(Z),ee.offset()}}})(q.experimental||(q.experimental={}))})(w.onnxruntime||(w.onnxruntime={})),(function(q){(function(K){(function(ee){class Z{constructor(){this.bb=null,this.bb_pos=0}__init(Y,W){return this.bb_pos=Y,this.bb=W,this}static getRootAsNodeEdge(Y,W){return(W||new Z).__init(Y.readInt32(Y.position())+Y.position(),Y)}static getSizePrefixedRootAsNodeEdge(Y,W){return Y.setPosition(Y.position()+O.flatbuffers.SIZE_PREFIX_LENGTH),(W||new Z).__init(Y.readInt32(Y.position())+Y.position(),Y)}nodeIndex(){let Y=this.bb.__offset(this.bb_pos,4);return Y?this.bb.readUint32(this.bb_pos+Y):0}inputEdges(Y,W){let ne=this.bb.__offset(this.bb_pos,6);return ne?(W||new q.experimental.fbs.EdgeEnd).__init(this.bb.__vector(this.bb_pos+ne)+12*Y,this.bb):null}inputEdgesLength(){let Y=this.bb.__offset(this.bb_pos,6);return Y?this.bb.__vector_len(this.bb_pos+Y):0}outputEdges(Y,W){let ne=this.bb.__offset(this.bb_pos,8);return ne?(W||new q.experimental.fbs.EdgeEnd).__init(this.bb.__vector(this.bb_pos+ne)+12*Y,this.bb):null}outputEdgesLength(){let Y=this.bb.__offset(this.bb_pos,8);return Y?this.bb.__vector_len(this.bb_pos+Y):0}static startNodeEdge(Y){Y.startObject(3)}static addNodeIndex(Y,W){Y.addFieldInt32(0,W,0)}static addInputEdges(Y,W){Y.addFieldOffset(1,W,0)}static startInputEdgesVector(Y,W){Y.startVector(12,W,4)}static addOutputEdges(Y,W){Y.addFieldOffset(2,W,0)}static startOutputEdgesVector(Y,W){Y.startVector(12,W,4)}static endNodeEdge(Y){return Y.endObject()}static createNodeEdge(Y,W,ne,se){return Z.startNodeEdge(Y),Z.addNodeIndex(Y,W),Z.addInputEdges(Y,ne),Z.addOutputEdges(Y,se),Z.endNodeEdge(Y)}}ee.NodeEdge=Z})(K.fbs||(K.fbs={}))})(q.experimental||(q.experimental={}))})(w.onnxruntime||(w.onnxruntime={})),(function(q){(function(K){(function(ee){class Z{constructor(){this.bb=null,this.bb_pos=0}__init(Y,W){return this.bb_pos=Y,this.bb=W,this}static getRootAsNode(Y,W){return(W||new Z).__init(Y.readInt32(Y.position())+Y.position(),Y)}static getSizePrefixedRootAsNode(Y,W){return Y.setPosition(Y.position()+O.flatbuffers.SIZE_PREFIX_LENGTH),(W||new Z).__init(Y.readInt32(Y.position())+Y.position(),Y)}name(Y){let W=this.bb.__offset(this.bb_pos,4);return W?this.bb.__string(this.bb_pos+W,Y):null}docString(Y){let W=this.bb.__offset(this.bb_pos,6);return W?this.bb.__string(this.bb_pos+W,Y):null}domain(Y){let W=this.bb.__offset(this.bb_pos,8);return W?this.bb.__string(this.bb_pos+W,Y):null}sinceVersion(){let Y=this.bb.__offset(this.bb_pos,10);return Y?this.bb.readInt32(this.bb_pos+Y):0}index(){let Y=this.bb.__offset(this.bb_pos,12);return Y?this.bb.readUint32(this.bb_pos+Y):0}opType(Y){let W=this.bb.__offset(this.bb_pos,14);return W?this.bb.__string(this.bb_pos+W,Y):null}type(){let Y=this.bb.__offset(this.bb_pos,16);return Y?this.bb.readInt32(this.bb_pos+Y):q.experimental.fbs.NodeType.Primitive}executionProviderType(Y){let W=this.bb.__offset(this.bb_pos,18);return W?this.bb.__string(this.bb_pos+W,Y):null}inputs(Y,W){let ne=this.bb.__offset(this.bb_pos,20);return ne?this.bb.__string(this.bb.__vector(this.bb_pos+ne)+4*Y,W):null}inputsLength(){let Y=this.bb.__offset(this.bb_pos,20);return Y?this.bb.__vector_len(this.bb_pos+Y):0}outputs(Y,W){let ne=this.bb.__offset(this.bb_pos,22);return ne?this.bb.__string(this.bb.__vector(this.bb_pos+ne)+4*Y,W):null}outputsLength(){let Y=this.bb.__offset(this.bb_pos,22);return Y?this.bb.__vector_len(this.bb_pos+Y):0}attributes(Y,W){let ne=this.bb.__offset(this.bb_pos,24);return ne?(W||new q.experimental.fbs.Attribute).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+ne)+4*Y),this.bb):null}attributesLength(){let Y=this.bb.__offset(this.bb_pos,24);return Y?this.bb.__vector_len(this.bb_pos+Y):0}inputArgCounts(Y){let W=this.bb.__offset(this.bb_pos,26);return W?this.bb.readInt32(this.bb.__vector(this.bb_pos+W)+4*Y):0}inputArgCountsLength(){let Y=this.bb.__offset(this.bb_pos,26);return Y?this.bb.__vector_len(this.bb_pos+Y):0}inputArgCountsArray(){let Y=this.bb.__offset(this.bb_pos,26);return Y?new Int32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+Y),this.bb.__vector_len(this.bb_pos+Y)):null}implicitInputs(Y,W){let ne=this.bb.__offset(this.bb_pos,28);return ne?this.bb.__string(this.bb.__vector(this.bb_pos+ne)+4*Y,W):null}implicitInputsLength(){let Y=this.bb.__offset(this.bb_pos,28);return Y?this.bb.__vector_len(this.bb_pos+Y):0}static startNode(Y){Y.startObject(13)}static addName(Y,W){Y.addFieldOffset(0,W,0)}static addDocString(Y,W){Y.addFieldOffset(1,W,0)}static addDomain(Y,W){Y.addFieldOffset(2,W,0)}static addSinceVersion(Y,W){Y.addFieldInt32(3,W,0)}static addIndex(Y,W){Y.addFieldInt32(4,W,0)}static addOpType(Y,W){Y.addFieldOffset(5,W,0)}static addType(Y,W){Y.addFieldInt32(6,W,q.experimental.fbs.NodeType.Primitive)}static addExecutionProviderType(Y,W){Y.addFieldOffset(7,W,0)}static addInputs(Y,W){Y.addFieldOffset(8,W,0)}static createInputsVector(Y,W){Y.startVector(4,W.length,4);for(let ne=W.length-1;ne>=0;ne--)Y.addOffset(W[ne]);return Y.endVector()}static startInputsVector(Y,W){Y.startVector(4,W,4)}static addOutputs(Y,W){Y.addFieldOffset(9,W,0)}static createOutputsVector(Y,W){Y.startVector(4,W.length,4);for(let ne=W.length-1;ne>=0;ne--)Y.addOffset(W[ne]);return Y.endVector()}static startOutputsVector(Y,W){Y.startVector(4,W,4)}static addAttributes(Y,W){Y.addFieldOffset(10,W,0)}static createAttributesVector(Y,W){Y.startVector(4,W.length,4);for(let ne=W.length-1;ne>=0;ne--)Y.addOffset(W[ne]);return Y.endVector()}static startAttributesVector(Y,W){Y.startVector(4,W,4)}static addInputArgCounts(Y,W){Y.addFieldOffset(11,W,0)}static createInputArgCountsVector(Y,W){Y.startVector(4,W.length,4);for(let ne=W.length-1;ne>=0;ne--)Y.addInt32(W[ne]);return Y.endVector()}static startInputArgCountsVector(Y,W){Y.startVector(4,W,4)}static addImplicitInputs(Y,W){Y.addFieldOffset(12,W,0)}static createImplicitInputsVector(Y,W){Y.startVector(4,W.length,4);for(let ne=W.length-1;ne>=0;ne--)Y.addOffset(W[ne]);return Y.endVector()}static startImplicitInputsVector(Y,W){Y.startVector(4,W,4)}static endNode(Y){return Y.endObject()}static createNode(Y,W,ne,se,le,ce,he,pe,me,be,ge,ve,Se,Me){return Z.startNode(Y),Z.addName(Y,W),Z.addDocString(Y,ne),Z.addDomain(Y,se),Z.addSinceVersion(Y,le),Z.addIndex(Y,ce),Z.addOpType(Y,he),Z.addType(Y,pe),Z.addExecutionProviderType(Y,me),Z.addInputs(Y,be),Z.addOutputs(Y,ge),Z.addAttributes(Y,ve),Z.addInputArgCounts(Y,Se),Z.addImplicitInputs(Y,Me),Z.endNode(Y)}}ee.Node=Z})(K.fbs||(K.fbs={}))})(q.experimental||(q.experimental={}))})(w.onnxruntime||(w.onnxruntime={})),(function(q){(function(K){(function(ee){class Z{constructor(){this.bb=null,this.bb_pos=0}__init(Y,W){return this.bb_pos=Y,this.bb=W,this}static getRootAsValueInfo(Y,W){return(W||new Z).__init(Y.readInt32(Y.position())+Y.position(),Y)}static getSizePrefixedRootAsValueInfo(Y,W){return Y.setPosition(Y.position()+O.flatbuffers.SIZE_PREFIX_LENGTH),(W||new Z).__init(Y.readInt32(Y.position())+Y.position(),Y)}name(Y){let W=this.bb.__offset(this.bb_pos,4);return W?this.bb.__string(this.bb_pos+W,Y):null}docString(Y){let W=this.bb.__offset(this.bb_pos,6);return W?this.bb.__string(this.bb_pos+W,Y):null}type(Y){let W=this.bb.__offset(this.bb_pos,8);return W?(Y||new q.experimental.fbs.TypeInfo).__init(this.bb.__indirect(this.bb_pos+W),this.bb):null}static startValueInfo(Y){Y.startObject(3)}static addName(Y,W){Y.addFieldOffset(0,W,0)}static addDocString(Y,W){Y.addFieldOffset(1,W,0)}static addType(Y,W){Y.addFieldOffset(2,W,0)}static endValueInfo(Y){return Y.endObject()}static createValueInfo(Y,W,ne,se){return Z.startValueInfo(Y),Z.addName(Y,W),Z.addDocString(Y,ne),Z.addType(Y,se),Z.endValueInfo(Y)}}ee.ValueInfo=Z})(K.fbs||(K.fbs={}))})(q.experimental||(q.experimental={}))})(w.onnxruntime||(w.onnxruntime={})),(function(q){(function(K){(function(ee){class Z{constructor(){this.bb=null,this.bb_pos=0}__init(Y,W){return this.bb_pos=Y,this.bb=W,this}static getRootAsTypeInfo(Y,W){return(W||new Z).__init(Y.readInt32(Y.position())+Y.position(),Y)}static getSizePrefixedRootAsTypeInfo(Y,W){return Y.setPosition(Y.position()+O.flatbuffers.SIZE_PREFIX_LENGTH),(W||new Z).__init(Y.readInt32(Y.position())+Y.position(),Y)}denotation(Y){let W=this.bb.__offset(this.bb_pos,4);return W?this.bb.__string(this.bb_pos+W,Y):null}valueType(){let Y=this.bb.__offset(this.bb_pos,6);return Y?this.bb.readUint8(this.bb_pos+Y):q.experimental.fbs.TypeInfoValue.NONE}value(Y){let W=this.bb.__offset(this.bb_pos,8);return W?this.bb.__union(Y,this.bb_pos+W):null}static startTypeInfo(Y){Y.startObject(3)}static addDenotation(Y,W){Y.addFieldOffset(0,W,0)}static addValueType(Y,W){Y.addFieldInt8(1,W,q.experimental.fbs.TypeInfoValue.NONE)}static addValue(Y,W){Y.addFieldOffset(2,W,0)}static endTypeInfo(Y){return Y.endObject()}static createTypeInfo(Y,W,ne,se){return Z.startTypeInfo(Y),Z.addDenotation(Y,W),Z.addValueType(Y,ne),Z.addValue(Y,se),Z.endTypeInfo(Y)}}ee.TypeInfo=Z})(K.fbs||(K.fbs={}))})(q.experimental||(q.experimental={}))})(w.onnxruntime||(w.onnxruntime={})),(function(q){(function(K){(function(ee){class Z{constructor(){this.bb=null,this.bb_pos=0}__init(Y,W){return this.bb_pos=Y,this.bb=W,this}static getRootAsOperatorSetId(Y,W){return(W||new Z).__init(Y.readInt32(Y.position())+Y.position(),Y)}static getSizePrefixedRootAsOperatorSetId(Y,W){return Y.setPosition(Y.position()+O.flatbuffers.SIZE_PREFIX_LENGTH),(W||new Z).__init(Y.readInt32(Y.position())+Y.position(),Y)}domain(Y){let W=this.bb.__offset(this.bb_pos,4);return W?this.bb.__string(this.bb_pos+W,Y):null}version(){let Y=this.bb.__offset(this.bb_pos,6);return Y?this.bb.readInt64(this.bb_pos+Y):this.bb.createLong(0,0)}static startOperatorSetId(Y){Y.startObject(2)}static addDomain(Y,W){Y.addFieldOffset(0,W,0)}static addVersion(Y,W){Y.addFieldInt64(1,W,Y.createLong(0,0))}static endOperatorSetId(Y){return Y.endObject()}static createOperatorSetId(Y,W,ne){return Z.startOperatorSetId(Y),Z.addDomain(Y,W),Z.addVersion(Y,ne),Z.endOperatorSetId(Y)}}ee.OperatorSetId=Z})(K.fbs||(K.fbs={}))})(q.experimental||(q.experimental={}))})(w.onnxruntime||(w.onnxruntime={})),(function(q){(function(K){(function(ee){class Z{constructor(){this.bb=null,this.bb_pos=0}__init(Y,W){return this.bb_pos=Y,this.bb=W,this}static getRootAsTensor(Y,W){return(W||new Z).__init(Y.readInt32(Y.position())+Y.position(),Y)}static getSizePrefixedRootAsTensor(Y,W){return Y.setPosition(Y.position()+O.flatbuffers.SIZE_PREFIX_LENGTH),(W||new Z).__init(Y.readInt32(Y.position())+Y.position(),Y)}name(Y){let W=this.bb.__offset(this.bb_pos,4);return W?this.bb.__string(this.bb_pos+W,Y):null}docString(Y){let W=this.bb.__offset(this.bb_pos,6);return W?this.bb.__string(this.bb_pos+W,Y):null}dims(Y){let W=this.bb.__offset(this.bb_pos,8);return W?this.bb.readInt64(this.bb.__vector(this.bb_pos+W)+8*Y):this.bb.createLong(0,0)}dimsLength(){let Y=this.bb.__offset(this.bb_pos,8);return Y?this.bb.__vector_len(this.bb_pos+Y):0}dataType(){let Y=this.bb.__offset(this.bb_pos,10);return Y?this.bb.readInt32(this.bb_pos+Y):q.experimental.fbs.TensorDataType.UNDEFINED}rawData(Y){let W=this.bb.__offset(this.bb_pos,12);return W?this.bb.readUint8(this.bb.__vector(this.bb_pos+W)+Y):0}rawDataLength(){let Y=this.bb.__offset(this.bb_pos,12);return Y?this.bb.__vector_len(this.bb_pos+Y):0}rawDataArray(){let Y=this.bb.__offset(this.bb_pos,12);return Y?new Uint8Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+Y),this.bb.__vector_len(this.bb_pos+Y)):null}stringData(Y,W){let ne=this.bb.__offset(this.bb_pos,14);return ne?this.bb.__string(this.bb.__vector(this.bb_pos+ne)+4*Y,W):null}stringDataLength(){let Y=this.bb.__offset(this.bb_pos,14);return Y?this.bb.__vector_len(this.bb_pos+Y):0}static startTensor(Y){Y.startObject(6)}static addName(Y,W){Y.addFieldOffset(0,W,0)}static addDocString(Y,W){Y.addFieldOffset(1,W,0)}static addDims(Y,W){Y.addFieldOffset(2,W,0)}static createDimsVector(Y,W){Y.startVector(8,W.length,8);for(let ne=W.length-1;ne>=0;ne--)Y.addInt64(W[ne]);return Y.endVector()}static startDimsVector(Y,W){Y.startVector(8,W,8)}static addDataType(Y,W){Y.addFieldInt32(3,W,q.experimental.fbs.TensorDataType.UNDEFINED)}static addRawData(Y,W){Y.addFieldOffset(4,W,0)}static createRawDataVector(Y,W){Y.startVector(1,W.length,1);for(let ne=W.length-1;ne>=0;ne--)Y.addInt8(W[ne]);return Y.endVector()}static startRawDataVector(Y,W){Y.startVector(1,W,1)}static addStringData(Y,W){Y.addFieldOffset(5,W,0)}static createStringDataVector(Y,W){Y.startVector(4,W.length,4);for(let ne=W.length-1;ne>=0;ne--)Y.addOffset(W[ne]);return Y.endVector()}static startStringDataVector(Y,W){Y.startVector(4,W,4)}static endTensor(Y){return Y.endObject()}static createTensor(Y,W,ne,se,le,ce,he){return Z.startTensor(Y),Z.addName(Y,W),Z.addDocString(Y,ne),Z.addDims(Y,se),Z.addDataType(Y,le),Z.addRawData(Y,ce),Z.addStringData(Y,he),Z.endTensor(Y)}}ee.Tensor=Z})(K.fbs||(K.fbs={}))})(q.experimental||(q.experimental={}))})(w.onnxruntime||(w.onnxruntime={})),(function(q){(function(K){(function(ee){class Z{constructor(){this.bb=null,this.bb_pos=0}__init(Y,W){return this.bb_pos=Y,this.bb=W,this}static getRootAsSparseTensor(Y,W){return(W||new Z).__init(Y.readInt32(Y.position())+Y.position(),Y)}static getSizePrefixedRootAsSparseTensor(Y,W){return Y.setPosition(Y.position()+O.flatbuffers.SIZE_PREFIX_LENGTH),(W||new Z).__init(Y.readInt32(Y.position())+Y.position(),Y)}values(Y){let W=this.bb.__offset(this.bb_pos,4);return W?(Y||new q.experimental.fbs.Tensor).__init(this.bb.__indirect(this.bb_pos+W),this.bb):null}indices(Y){let W=this.bb.__offset(this.bb_pos,6);return W?(Y||new q.experimental.fbs.Tensor).__init(this.bb.__indirect(this.bb_pos+W),this.bb):null}dims(Y){let W=this.bb.__offset(this.bb_pos,8);return W?this.bb.readInt64(this.bb.__vector(this.bb_pos+W)+8*Y):this.bb.createLong(0,0)}dimsLength(){let Y=this.bb.__offset(this.bb_pos,8);return Y?this.bb.__vector_len(this.bb_pos+Y):0}static startSparseTensor(Y){Y.startObject(3)}static addValues(Y,W){Y.addFieldOffset(0,W,0)}static addIndices(Y,W){Y.addFieldOffset(1,W,0)}static addDims(Y,W){Y.addFieldOffset(2,W,0)}static createDimsVector(Y,W){Y.startVector(8,W.length,8);for(let ne=W.length-1;ne>=0;ne--)Y.addInt64(W[ne]);return Y.endVector()}static startDimsVector(Y,W){Y.startVector(8,W,8)}static endSparseTensor(Y){return Y.endObject()}static createSparseTensor(Y,W,ne,se){return Z.startSparseTensor(Y),Z.addValues(Y,W),Z.addIndices(Y,ne),Z.addDims(Y,se),Z.endSparseTensor(Y)}}ee.SparseTensor=Z})(K.fbs||(K.fbs={}))})(q.experimental||(q.experimental={}))})(w.onnxruntime||(w.onnxruntime={})),(function(q){(function(K){(function(ee){class Z{constructor(){this.bb=null,this.bb_pos=0}__init(Y,W){return this.bb_pos=Y,this.bb=W,this}static getRootAsAttribute(Y,W){return(W||new Z).__init(Y.readInt32(Y.position())+Y.position(),Y)}static getSizePrefixedRootAsAttribute(Y,W){return Y.setPosition(Y.position()+O.flatbuffers.SIZE_PREFIX_LENGTH),(W||new Z).__init(Y.readInt32(Y.position())+Y.position(),Y)}name(Y){let W=this.bb.__offset(this.bb_pos,4);return W?this.bb.__string(this.bb_pos+W,Y):null}docString(Y){let W=this.bb.__offset(this.bb_pos,6);return W?this.bb.__string(this.bb_pos+W,Y):null}type(){let Y=this.bb.__offset(this.bb_pos,8);return Y?this.bb.readInt32(this.bb_pos+Y):q.experimental.fbs.AttributeType.UNDEFINED}f(){let Y=this.bb.__offset(this.bb_pos,10);return Y?this.bb.readFloat32(this.bb_pos+Y):0}i(){let Y=this.bb.__offset(this.bb_pos,12);return Y?this.bb.readInt64(this.bb_pos+Y):this.bb.createLong(0,0)}s(Y){let W=this.bb.__offset(this.bb_pos,14);return W?this.bb.__string(this.bb_pos+W,Y):null}t(Y){let W=this.bb.__offset(this.bb_pos,16);return W?(Y||new q.experimental.fbs.Tensor).__init(this.bb.__indirect(this.bb_pos+W),this.bb):null}g(Y){let W=this.bb.__offset(this.bb_pos,18);return W?(Y||new q.experimental.fbs.Graph).__init(this.bb.__indirect(this.bb_pos+W),this.bb):null}floats(Y){let W=this.bb.__offset(this.bb_pos,20);return W?this.bb.readFloat32(this.bb.__vector(this.bb_pos+W)+4*Y):0}floatsLength(){let Y=this.bb.__offset(this.bb_pos,20);return Y?this.bb.__vector_len(this.bb_pos+Y):0}floatsArray(){let Y=this.bb.__offset(this.bb_pos,20);return Y?new Float32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+Y),this.bb.__vector_len(this.bb_pos+Y)):null}ints(Y){let W=this.bb.__offset(this.bb_pos,22);return W?this.bb.readInt64(this.bb.__vector(this.bb_pos+W)+8*Y):this.bb.createLong(0,0)}intsLength(){let Y=this.bb.__offset(this.bb_pos,22);return Y?this.bb.__vector_len(this.bb_pos+Y):0}strings(Y,W){let ne=this.bb.__offset(this.bb_pos,24);return ne?this.bb.__string(this.bb.__vector(this.bb_pos+ne)+4*Y,W):null}stringsLength(){let Y=this.bb.__offset(this.bb_pos,24);return Y?this.bb.__vector_len(this.bb_pos+Y):0}tensors(Y,W){let ne=this.bb.__offset(this.bb_pos,26);return ne?(W||new q.experimental.fbs.Tensor).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+ne)+4*Y),this.bb):null}tensorsLength(){let Y=this.bb.__offset(this.bb_pos,26);return Y?this.bb.__vector_len(this.bb_pos+Y):0}graphs(Y,W){let ne=this.bb.__offset(this.bb_pos,28);return ne?(W||new q.experimental.fbs.Graph).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+ne)+4*Y),this.bb):null}graphsLength(){let Y=this.bb.__offset(this.bb_pos,28);return Y?this.bb.__vector_len(this.bb_pos+Y):0}static startAttribute(Y){Y.startObject(13)}static addName(Y,W){Y.addFieldOffset(0,W,0)}static addDocString(Y,W){Y.addFieldOffset(1,W,0)}static addType(Y,W){Y.addFieldInt32(2,W,q.experimental.fbs.AttributeType.UNDEFINED)}static addF(Y,W){Y.addFieldFloat32(3,W,0)}static addI(Y,W){Y.addFieldInt64(4,W,Y.createLong(0,0))}static addS(Y,W){Y.addFieldOffset(5,W,0)}static addT(Y,W){Y.addFieldOffset(6,W,0)}static addG(Y,W){Y.addFieldOffset(7,W,0)}static addFloats(Y,W){Y.addFieldOffset(8,W,0)}static createFloatsVector(Y,W){Y.startVector(4,W.length,4);for(let ne=W.length-1;ne>=0;ne--)Y.addFloat32(W[ne]);return Y.endVector()}static startFloatsVector(Y,W){Y.startVector(4,W,4)}static addInts(Y,W){Y.addFieldOffset(9,W,0)}static createIntsVector(Y,W){Y.startVector(8,W.length,8);for(let ne=W.length-1;ne>=0;ne--)Y.addInt64(W[ne]);return Y.endVector()}static startIntsVector(Y,W){Y.startVector(8,W,8)}static addStrings(Y,W){Y.addFieldOffset(10,W,0)}static createStringsVector(Y,W){Y.startVector(4,W.length,4);for(let ne=W.length-1;ne>=0;ne--)Y.addOffset(W[ne]);return Y.endVector()}static startStringsVector(Y,W){Y.startVector(4,W,4)}static addTensors(Y,W){Y.addFieldOffset(11,W,0)}static createTensorsVector(Y,W){Y.startVector(4,W.length,4);for(let ne=W.length-1;ne>=0;ne--)Y.addOffset(W[ne]);return Y.endVector()}static startTensorsVector(Y,W){Y.startVector(4,W,4)}static addGraphs(Y,W){Y.addFieldOffset(12,W,0)}static createGraphsVector(Y,W){Y.startVector(4,W.length,4);for(let ne=W.length-1;ne>=0;ne--)Y.addOffset(W[ne]);return Y.endVector()}static startGraphsVector(Y,W){Y.startVector(4,W,4)}static endAttribute(Y){return Y.endObject()}static createAttribute(Y,W,ne,se,le,ce,he,pe,me,be,ge,ve,Se,Me){return Z.startAttribute(Y),Z.addName(Y,W),Z.addDocString(Y,ne),Z.addType(Y,se),Z.addF(Y,le),Z.addI(Y,ce),Z.addS(Y,he),Z.addT(Y,pe),Z.addG(Y,me),Z.addFloats(Y,be),Z.addInts(Y,ge),Z.addStrings(Y,ve),Z.addTensors(Y,Se),Z.addGraphs(Y,Me),Z.endAttribute(Y)}}ee.Attribute=Z})(K.fbs||(K.fbs={}))})(q.experimental||(q.experimental={}))})(w.onnxruntime||(w.onnxruntime={})),(function(q){(function(K){(function(ee){class Z{constructor(){this.bb=null,this.bb_pos=0}__init(Y,W){return this.bb_pos=Y,this.bb=W,this}static getRootAsGraph(Y,W){return(W||new Z).__init(Y.readInt32(Y.position())+Y.position(),Y)}static getSizePrefixedRootAsGraph(Y,W){return Y.setPosition(Y.position()+O.flatbuffers.SIZE_PREFIX_LENGTH),(W||new Z).__init(Y.readInt32(Y.position())+Y.position(),Y)}initializers(Y,W){let ne=this.bb.__offset(this.bb_pos,4);return ne?(W||new q.experimental.fbs.Tensor).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+ne)+4*Y),this.bb):null}initializersLength(){let Y=this.bb.__offset(this.bb_pos,4);return Y?this.bb.__vector_len(this.bb_pos+Y):0}nodeArgs(Y,W){let ne=this.bb.__offset(this.bb_pos,6);return ne?(W||new q.experimental.fbs.ValueInfo).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+ne)+4*Y),this.bb):null}nodeArgsLength(){let Y=this.bb.__offset(this.bb_pos,6);return Y?this.bb.__vector_len(this.bb_pos+Y):0}nodes(Y,W){let ne=this.bb.__offset(this.bb_pos,8);return ne?(W||new q.experimental.fbs.Node).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+ne)+4*Y),this.bb):null}nodesLength(){let Y=this.bb.__offset(this.bb_pos,8);return Y?this.bb.__vector_len(this.bb_pos+Y):0}maxNodeIndex(){let Y=this.bb.__offset(this.bb_pos,10);return Y?this.bb.readUint32(this.bb_pos+Y):0}nodeEdges(Y,W){let ne=this.bb.__offset(this.bb_pos,12);return ne?(W||new q.experimental.fbs.NodeEdge).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+ne)+4*Y),this.bb):null}nodeEdgesLength(){let Y=this.bb.__offset(this.bb_pos,12);return Y?this.bb.__vector_len(this.bb_pos+Y):0}inputs(Y,W){let ne=this.bb.__offset(this.bb_pos,14);return ne?this.bb.__string(this.bb.__vector(this.bb_pos+ne)+4*Y,W):null}inputsLength(){let Y=this.bb.__offset(this.bb_pos,14);return Y?this.bb.__vector_len(this.bb_pos+Y):0}outputs(Y,W){let ne=this.bb.__offset(this.bb_pos,16);return ne?this.bb.__string(this.bb.__vector(this.bb_pos+ne)+4*Y,W):null}outputsLength(){let Y=this.bb.__offset(this.bb_pos,16);return Y?this.bb.__vector_len(this.bb_pos+Y):0}sparseInitializers(Y,W){let ne=this.bb.__offset(this.bb_pos,18);return ne?(W||new q.experimental.fbs.SparseTensor).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+ne)+4*Y),this.bb):null}sparseInitializersLength(){let Y=this.bb.__offset(this.bb_pos,18);return Y?this.bb.__vector_len(this.bb_pos+Y):0}static startGraph(Y){Y.startObject(8)}static addInitializers(Y,W){Y.addFieldOffset(0,W,0)}static createInitializersVector(Y,W){Y.startVector(4,W.length,4);for(let ne=W.length-1;ne>=0;ne--)Y.addOffset(W[ne]);return Y.endVector()}static startInitializersVector(Y,W){Y.startVector(4,W,4)}static addNodeArgs(Y,W){Y.addFieldOffset(1,W,0)}static createNodeArgsVector(Y,W){Y.startVector(4,W.length,4);for(let ne=W.length-1;ne>=0;ne--)Y.addOffset(W[ne]);return Y.endVector()}static startNodeArgsVector(Y,W){Y.startVector(4,W,4)}static addNodes(Y,W){Y.addFieldOffset(2,W,0)}static createNodesVector(Y,W){Y.startVector(4,W.length,4);for(let ne=W.length-1;ne>=0;ne--)Y.addOffset(W[ne]);return Y.endVector()}static startNodesVector(Y,W){Y.startVector(4,W,4)}static addMaxNodeIndex(Y,W){Y.addFieldInt32(3,W,0)}static addNodeEdges(Y,W){Y.addFieldOffset(4,W,0)}static createNodeEdgesVector(Y,W){Y.startVector(4,W.length,4);for(let ne=W.length-1;ne>=0;ne--)Y.addOffset(W[ne]);return Y.endVector()}static startNodeEdgesVector(Y,W){Y.startVector(4,W,4)}static addInputs(Y,W){Y.addFieldOffset(5,W,0)}static createInputsVector(Y,W){Y.startVector(4,W.length,4);for(let ne=W.length-1;ne>=0;ne--)Y.addOffset(W[ne]);return Y.endVector()}static startInputsVector(Y,W){Y.startVector(4,W,4)}static addOutputs(Y,W){Y.addFieldOffset(6,W,0)}static createOutputsVector(Y,W){Y.startVector(4,W.length,4);for(let ne=W.length-1;ne>=0;ne--)Y.addOffset(W[ne]);return Y.endVector()}static startOutputsVector(Y,W){Y.startVector(4,W,4)}static addSparseInitializers(Y,W){Y.addFieldOffset(7,W,0)}static createSparseInitializersVector(Y,W){Y.startVector(4,W.length,4);for(let ne=W.length-1;ne>=0;ne--)Y.addOffset(W[ne]);return Y.endVector()}static startSparseInitializersVector(Y,W){Y.startVector(4,W,4)}static endGraph(Y){return Y.endObject()}static createGraph(Y,W,ne,se,le,ce,he,pe,me){return Z.startGraph(Y),Z.addInitializers(Y,W),Z.addNodeArgs(Y,ne),Z.addNodes(Y,se),Z.addMaxNodeIndex(Y,le),Z.addNodeEdges(Y,ce),Z.addInputs(Y,he),Z.addOutputs(Y,pe),Z.addSparseInitializers(Y,me),Z.endGraph(Y)}}ee.Graph=Z})(K.fbs||(K.fbs={}))})(q.experimental||(q.experimental={}))})(w.onnxruntime||(w.onnxruntime={})),(function(q){(function(K){(function(ee){class Z{constructor(){this.bb=null,this.bb_pos=0}__init(Y,W){return this.bb_pos=Y,this.bb=W,this}static getRootAsModel(Y,W){return(W||new Z).__init(Y.readInt32(Y.position())+Y.position(),Y)}static getSizePrefixedRootAsModel(Y,W){return Y.setPosition(Y.position()+O.flatbuffers.SIZE_PREFIX_LENGTH),(W||new Z).__init(Y.readInt32(Y.position())+Y.position(),Y)}irVersion(){let Y=this.bb.__offset(this.bb_pos,4);return Y?this.bb.readInt64(this.bb_pos+Y):this.bb.createLong(0,0)}opsetImport(Y,W){let ne=this.bb.__offset(this.bb_pos,6);return ne?(W||new q.experimental.fbs.OperatorSetId).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+ne)+4*Y),this.bb):null}opsetImportLength(){let Y=this.bb.__offset(this.bb_pos,6);return Y?this.bb.__vector_len(this.bb_pos+Y):0}producerName(Y){let W=this.bb.__offset(this.bb_pos,8);return W?this.bb.__string(this.bb_pos+W,Y):null}producerVersion(Y){let W=this.bb.__offset(this.bb_pos,10);return W?this.bb.__string(this.bb_pos+W,Y):null}domain(Y){let W=this.bb.__offset(this.bb_pos,12);return W?this.bb.__string(this.bb_pos+W,Y):null}modelVersion(){let Y=this.bb.__offset(this.bb_pos,14);return Y?this.bb.readInt64(this.bb_pos+Y):this.bb.createLong(0,0)}docString(Y){let W=this.bb.__offset(this.bb_pos,16);return W?this.bb.__string(this.bb_pos+W,Y):null}graph(Y){let W=this.bb.__offset(this.bb_pos,18);return W?(Y||new q.experimental.fbs.Graph).__init(this.bb.__indirect(this.bb_pos+W),this.bb):null}graphDocString(Y){let W=this.bb.__offset(this.bb_pos,20);return W?this.bb.__string(this.bb_pos+W,Y):null}static startModel(Y){Y.startObject(9)}static addIrVersion(Y,W){Y.addFieldInt64(0,W,Y.createLong(0,0))}static addOpsetImport(Y,W){Y.addFieldOffset(1,W,0)}static createOpsetImportVector(Y,W){Y.startVector(4,W.length,4);for(let ne=W.length-1;ne>=0;ne--)Y.addOffset(W[ne]);return Y.endVector()}static startOpsetImportVector(Y,W){Y.startVector(4,W,4)}static addProducerName(Y,W){Y.addFieldOffset(2,W,0)}static addProducerVersion(Y,W){Y.addFieldOffset(3,W,0)}static addDomain(Y,W){Y.addFieldOffset(4,W,0)}static addModelVersion(Y,W){Y.addFieldInt64(5,W,Y.createLong(0,0))}static addDocString(Y,W){Y.addFieldOffset(6,W,0)}static addGraph(Y,W){Y.addFieldOffset(7,W,0)}static addGraphDocString(Y,W){Y.addFieldOffset(8,W,0)}static endModel(Y){return Y.endObject()}static createModel(Y,W,ne,se,le,ce,he,pe,me,be){return Z.startModel(Y),Z.addIrVersion(Y,W),Z.addOpsetImport(Y,ne),Z.addProducerName(Y,se),Z.addProducerVersion(Y,le),Z.addDomain(Y,ce),Z.addModelVersion(Y,he),Z.addDocString(Y,pe),Z.addGraph(Y,me),Z.addGraphDocString(Y,be),Z.endModel(Y)}}ee.Model=Z})(K.fbs||(K.fbs={}))})(q.experimental||(q.experimental={}))})(w.onnxruntime||(w.onnxruntime={})),(function(q){(function(K){(function(ee){class Z{constructor(){this.bb=null,this.bb_pos=0}__init(Y,W){return this.bb_pos=Y,this.bb=W,this}static getRootAsKernelCreateInfos(Y,W){return(W||new Z).__init(Y.readInt32(Y.position())+Y.position(),Y)}static getSizePrefixedRootAsKernelCreateInfos(Y,W){return Y.setPosition(Y.position()+O.flatbuffers.SIZE_PREFIX_LENGTH),(W||new Z).__init(Y.readInt32(Y.position())+Y.position(),Y)}nodeIndices(Y){let W=this.bb.__offset(this.bb_pos,4);return W?this.bb.readUint32(this.bb.__vector(this.bb_pos+W)+4*Y):0}nodeIndicesLength(){let Y=this.bb.__offset(this.bb_pos,4);return Y?this.bb.__vector_len(this.bb_pos+Y):0}nodeIndicesArray(){let Y=this.bb.__offset(this.bb_pos,4);return Y?new Uint32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+Y),this.bb.__vector_len(this.bb_pos+Y)):null}kernelDefHashes(Y){let W=this.bb.__offset(this.bb_pos,6);return W?this.bb.readUint64(this.bb.__vector(this.bb_pos+W)+8*Y):this.bb.createLong(0,0)}kernelDefHashesLength(){let Y=this.bb.__offset(this.bb_pos,6);return Y?this.bb.__vector_len(this.bb_pos+Y):0}static startKernelCreateInfos(Y){Y.startObject(2)}static addNodeIndices(Y,W){Y.addFieldOffset(0,W,0)}static createNodeIndicesVector(Y,W){Y.startVector(4,W.length,4);for(let ne=W.length-1;ne>=0;ne--)Y.addInt32(W[ne]);return Y.endVector()}static startNodeIndicesVector(Y,W){Y.startVector(4,W,4)}static addKernelDefHashes(Y,W){Y.addFieldOffset(1,W,0)}static createKernelDefHashesVector(Y,W){Y.startVector(8,W.length,8);for(let ne=W.length-1;ne>=0;ne--)Y.addInt64(W[ne]);return Y.endVector()}static startKernelDefHashesVector(Y,W){Y.startVector(8,W,8)}static endKernelCreateInfos(Y){return Y.endObject()}static createKernelCreateInfos(Y,W,ne){return Z.startKernelCreateInfos(Y),Z.addNodeIndices(Y,W),Z.addKernelDefHashes(Y,ne),Z.endKernelCreateInfos(Y)}}ee.KernelCreateInfos=Z})(K.fbs||(K.fbs={}))})(q.experimental||(q.experimental={}))})(w.onnxruntime||(w.onnxruntime={})),(function(q){(function(K){(function(ee){class Z{constructor(){this.bb=null,this.bb_pos=0}__init(Y,W){return this.bb_pos=Y,this.bb=W,this}static getRootAsSubGraphSessionState(Y,W){return(W||new Z).__init(Y.readInt32(Y.position())+Y.position(),Y)}static getSizePrefixedRootAsSubGraphSessionState(Y,W){return Y.setPosition(Y.position()+O.flatbuffers.SIZE_PREFIX_LENGTH),(W||new Z).__init(Y.readInt32(Y.position())+Y.position(),Y)}graphId(Y){let W=this.bb.__offset(this.bb_pos,4);return W?this.bb.__string(this.bb_pos+W,Y):null}sessionState(Y){let W=this.bb.__offset(this.bb_pos,6);return W?(Y||new q.experimental.fbs.SessionState).__init(this.bb.__indirect(this.bb_pos+W),this.bb):null}static startSubGraphSessionState(Y){Y.startObject(2)}static addGraphId(Y,W){Y.addFieldOffset(0,W,0)}static addSessionState(Y,W){Y.addFieldOffset(1,W,0)}static endSubGraphSessionState(Y){let W=Y.endObject();return Y.requiredField(W,4),W}static createSubGraphSessionState(Y,W,ne){return Z.startSubGraphSessionState(Y),Z.addGraphId(Y,W),Z.addSessionState(Y,ne),Z.endSubGraphSessionState(Y)}}ee.SubGraphSessionState=Z})(K.fbs||(K.fbs={}))})(q.experimental||(q.experimental={}))})(w.onnxruntime||(w.onnxruntime={})),(function(q){(function(K){(function(ee){class Z{constructor(){this.bb=null,this.bb_pos=0}__init(Y,W){return this.bb_pos=Y,this.bb=W,this}static getRootAsSessionState(Y,W){return(W||new Z).__init(Y.readInt32(Y.position())+Y.position(),Y)}static getSizePrefixedRootAsSessionState(Y,W){return Y.setPosition(Y.position()+O.flatbuffers.SIZE_PREFIX_LENGTH),(W||new Z).__init(Y.readInt32(Y.position())+Y.position(),Y)}kernels(Y){let W=this.bb.__offset(this.bb_pos,4);return W?(Y||new q.experimental.fbs.KernelCreateInfos).__init(this.bb.__indirect(this.bb_pos+W),this.bb):null}subGraphSessionStates(Y,W){let ne=this.bb.__offset(this.bb_pos,6);return ne?(W||new q.experimental.fbs.SubGraphSessionState).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+ne)+4*Y),this.bb):null}subGraphSessionStatesLength(){let Y=this.bb.__offset(this.bb_pos,6);return Y?this.bb.__vector_len(this.bb_pos+Y):0}static startSessionState(Y){Y.startObject(2)}static addKernels(Y,W){Y.addFieldOffset(0,W,0)}static addSubGraphSessionStates(Y,W){Y.addFieldOffset(1,W,0)}static createSubGraphSessionStatesVector(Y,W){Y.startVector(4,W.length,4);for(let ne=W.length-1;ne>=0;ne--)Y.addOffset(W[ne]);return Y.endVector()}static startSubGraphSessionStatesVector(Y,W){Y.startVector(4,W,4)}static endSessionState(Y){return Y.endObject()}static createSessionState(Y,W,ne){return Z.startSessionState(Y),Z.addKernels(Y,W),Z.addSubGraphSessionStates(Y,ne),Z.endSessionState(Y)}}ee.SessionState=Z})(K.fbs||(K.fbs={}))})(q.experimental||(q.experimental={}))})(w.onnxruntime||(w.onnxruntime={})),(function(q){(function(K){(function(ee){class Z{constructor(){this.bb=null,this.bb_pos=0}__init(Y,W){return this.bb_pos=Y,this.bb=W,this}static getRootAsInferenceSession(Y,W){return(W||new Z).__init(Y.readInt32(Y.position())+Y.position(),Y)}static getSizePrefixedRootAsInferenceSession(Y,W){return Y.setPosition(Y.position()+O.flatbuffers.SIZE_PREFIX_LENGTH),(W||new Z).__init(Y.readInt32(Y.position())+Y.position(),Y)}static bufferHasIdentifier(Y){return Y.__has_identifier("ORTM")}ortVersion(Y){let W=this.bb.__offset(this.bb_pos,4);return W?this.bb.__string(this.bb_pos+W,Y):null}model(Y){let W=this.bb.__offset(this.bb_pos,6);return W?(Y||new q.experimental.fbs.Model).__init(this.bb.__indirect(this.bb_pos+W),this.bb):null}sessionState(Y){let W=this.bb.__offset(this.bb_pos,8);return W?(Y||new q.experimental.fbs.SessionState).__init(this.bb.__indirect(this.bb_pos+W),this.bb):null}static startInferenceSession(Y){Y.startObject(3)}static addOrtVersion(Y,W){Y.addFieldOffset(0,W,0)}static addModel(Y,W){Y.addFieldOffset(1,W,0)}static addSessionState(Y,W){Y.addFieldOffset(2,W,0)}static endInferenceSession(Y){return Y.endObject()}static finishInferenceSessionBuffer(Y,W){Y.finish(W,"ORTM")}static finishSizePrefixedInferenceSessionBuffer(Y,W){Y.finish(W,"ORTM",!0)}static createInferenceSession(Y,W,ne,se){return Z.startInferenceSession(Y),Z.addOrtVersion(Y,W),Z.addModel(Y,ne),Z.addSessionState(Y,se),Z.endInferenceSession(Y)}}ee.InferenceSession=Z})(K.fbs||(K.fbs={}))})(q.experimental||(q.experimental={}))})(w.onnxruntime||(w.onnxruntime={}))},7448:(F,w,D)=>{Object.defineProperty(w,"__esModule",{value:!0}),w.OnnxjsSessionHandler=void 0;const O=D(1670),U=D(9162);w.OnnxjsSessionHandler=class{constructor(G){this.session=G,this.inputNames=this.session.inputNames,this.outputNames=this.session.outputNames}async dispose(){}async run(G,q,K){const ee=new Map;for(const Y in G)if(Object.hasOwnProperty.call(G,Y)){const W=G[Y];ee.set(Y,new U.Tensor(W.dims,W.type,void 0,void 0,W.data))}const Z=await this.session.run(ee),ie={};return Z.forEach(((Y,W)=>{ie[W]=new O.Tensor(Y.type,Y.data,Y.dims)})),ie}startProfiling(){this.session.startProfiling()}endProfiling(){this.session.endProfiling()}}},6919:(F,w,D)=>{Object.defineProperty(w,"__esModule",{value:!0}),w.Session=void 0;const O=D(7067),U=D(1296),G=D(7091),q=D(1036),K=D(6231),ee=D(2644);w.Session=class{constructor(Z={}){this._initialized=!1,this.backendHint=Z.backendHint,this.profiler=K.Profiler.create(Z.profiler),this.context={profiler:this.profiler,graphInputTypes:[],graphInputDims:[]}}get inputNames(){return this._model.graph.getInputNames()}get outputNames(){return this._model.graph.getOutputNames()}startProfiling(){this.profiler.start()}endProfiling(){this.profiler.stop()}async loadModel(Z,ie,Y){await this.profiler.event("session","Session.loadModel",(async()=>{const W=await(0,G.resolveBackend)(this.backendHint);if(this.sessionHandler=W.createSessionHandler(this.context),this._model=new ee.Model,typeof Z=="string"){const ne=Z.endsWith(".ort");if(typeof fetch>"u"){const se=await(0,U.promisify)(O.readFile)(Z);this.initialize(se,ne)}else{const se=await fetch(Z),le=await se.arrayBuffer();this.initialize(new Uint8Array(le),ne)}}else if(ArrayBuffer.isView(Z))this.initialize(Z);else{const ne=new Uint8Array(Z,ie||0,Y||Z.byteLength);this.initialize(ne)}}))}initialize(Z,ie){if(this._initialized)throw new Error("already initialized");this.profiler.event("session","Session.initialize",(()=>{const Y=this.sessionHandler.transformGraph?this.sessionHandler:void 0;this._model.load(Z,Y,ie),this.sessionHandler.onGraphInitialized&&this.sessionHandler.onGraphInitialized(this._model.graph),this.initializeOps(this._model.graph),this._executionPlan=new q.ExecutionPlan(this._model.graph,this._ops,this.profiler)})),this._initialized=!0}async run(Z){if(!this._initialized)throw new Error("session not initialized yet");return this.profiler.event("session","Session.run",(async()=>{const ie=this.normalizeAndValidateInputs(Z),Y=await this._executionPlan.execute(this.sessionHandler,ie);return this.createOutput(Y)}))}normalizeAndValidateInputs(Z){const ie=this._model.graph.getInputNames();if(Array.isArray(Z)){if(Z.length!==ie.length)throw new Error(`incorrect input array length: expected ${ie.length} but got ${Z.length}`)}else{if(Z.size!==ie.length)throw new Error(`incorrect input map size: expected ${ie.length} but got ${Z.size}`);const Y=new Array(Z.size);let W=0;for(let ne=0;ne<ie.length;++ne){const se=Z.get(ie[ne]);if(!se)throw new Error(`missing input tensor for: '${name}'`);Y[W++]=se}Z=Y}if(this.context.graphInputTypes&&this.context.graphInputTypes.length!==0&&this.context.graphInputDims&&this.context.graphInputDims.length!==0)this.validateInputTensorDims(this.context.graphInputDims,Z,!1);else{const Y=this._model.graph.getInputIndices(),W=this._model.graph.getValues(),ne=new Array(Y.length);for(let se=0;se<Y.length;++se){const le=W[Y[se]];ne[se]=le.type.shape.dims,this.context.graphInputTypes.push(le.type.tensorType),this.context.graphInputDims.push(Z[se].dims)}this.validateInputTensorDims(ne,Z,!0)}return this.validateInputTensorTypes(this.context.graphInputTypes,Z),Z}validateInputTensorTypes(Z,ie){for(let Y=0;Y<ie.length;Y++){const W=Z[Y],ne=ie[Y].type;if(W!==ne)throw new Error(`input tensor[${Y}] check failed: expected type '${W}' but got ${ne}`)}}validateInputTensorDims(Z,ie,Y){for(let W=0;W<ie.length;W++){const ne=Z[W],se=ie[W].dims;if(!this.compareTensorDims(ne,se,Y))throw new Error(`input tensor[${W}] check failed: expected shape '[${ne.join(",")}]' but got [${se.join(",")}]`)}}compareTensorDims(Z,ie,Y){if(Z.length!==ie.length)return!1;for(let W=0;W<Z.length;++W)if(Z[W]!==ie[W]&&(!Y||Z[W]!==0))return!1;return!0}createOutput(Z){const ie=this._model.graph.getOutputNames();if(Z.length!==ie.length)throw new Error("expected number of outputs do not match number of generated outputs");const Y=new Map;for(let W=0;W<ie.length;++W)Y.set(ie[W],Z[W]);return Y}initializeOps(Z){const ie=Z.getNodes();this._ops=new Array(ie.length);for(let Y=0;Y<ie.length;Y++)this._ops[Y]=this.sessionHandler.resolve(ie[Y],this._model.opsets,Z)}}},9162:function(F,w,D){var O=this&&this.__importDefault||function(le){return le&&le.__esModule?le:{default:le}};Object.defineProperty(w,"__esModule",{value:!0}),w.Tensor=void 0;const U=D(3442),G=O(D(3720)),q=D(1446),K=D(9395),ee=D(2517);var Z=K.onnxruntime.experimental.fbs;class ie{get data(){if(this.cache===void 0){const ce=this.dataProvider(this.dataId);if(ce.length!==this.size)throw new Error("Length of data provided by the Data Provider is inconsistent with the dims of this Tensor.");this.cache=ce}return this.cache}get stringData(){if(this.type!=="string")throw new TypeError("data type is not string");return this.data}get integerData(){switch(this.type){case"uint8":case"int8":case"uint16":case"int16":case"int32":case"uint32":case"bool":return this.data;default:throw new TypeError("data type is not integer (uint8, int8, uint16, int16, int32, uint32, bool)")}}get floatData(){switch(this.type){case"float32":case"float64":return this.data;default:throw new TypeError("data type is not float (float32, float64)")}}get numberData(){if(this.type!=="string")return this.data;throw new TypeError("type cannot be non-number (string)")}get(ce){return this.data[ee.ShapeUtil.indicesToOffset(ce,this.strides)]}set(ce,he){this.data[ee.ShapeUtil.indicesToOffset(ce,this.strides)]=he}async getData(){return this.cache===void 0&&(this.cache=await this.asyncDataProvider(this.dataId)),this.cache}get strides(){return this._strides||(this._strides=ee.ShapeUtil.computeStrides(this.dims)),this._strides}constructor(ce,he,pe,me,be,ge=U.Guid.create()){this.dims=ce,this.type=he,this.dataProvider=pe,this.asyncDataProvider=me,this.cache=be,this.dataId=ge,this.size=ee.ShapeUtil.validateDimsAndCalcSize(ce);const ve=this.size,Se=pe===void 0&&me===void 0&&be===void 0;if(be!==void 0&&be.length!==ve)throw new RangeError("Input dims doesn't match data length.");if(he==="string"){if(!(be===void 0||Array.isArray(be)&&be.every((Me=>typeof Me=="string"))))throw new TypeError("cache should be a string array");Se&&(this.cache=new Array(ve))}else{if(be!==void 0){const Me=W(he);if(!(be instanceof Me))throw new TypeError(`cache should be type ${Me.name}`)}if(Se){const Me=new ArrayBuffer(ve*(function(Ee){switch(Ee){case"bool":case"int8":case"uint8":return 1;case"int16":case"uint16":return 2;case"int32":case"uint32":case"float32":return 4;case"float64":return 8;default:throw new Error(`cannot calculate sizeof() on type ${Ee}`)}})(he));this.cache=(function(Ee,we){return new(W(we))(Ee)})(Me,he)}}}static fromProto(ce){if(!ce)throw new Error("cannot construct Value from an empty tensor");const he=ee.ProtoUtil.tensorDataTypeFromProto(ce.dataType),pe=ee.ProtoUtil.tensorDimsFromProto(ce.dims),me=new ie(pe,he);if(he==="string")ce.stringData.forEach(((be,ge)=>{me.data[ge]=(0,ee.decodeUtf8String)(be)}));else if(ce.rawData&&typeof ce.rawData.byteLength=="number"&&ce.rawData.byteLength>0){const be=me.data,ge=new DataView(ce.rawData.buffer,ce.rawData.byteOffset,ce.rawData.byteLength),ve=Y(ce.dataType),Se=ce.rawData.byteLength/ve;if(ce.rawData.byteLength%ve!=0)throw new Error("invalid buffer length");if(be.length!==Se)throw new Error("buffer length mismatch");for(let Me=0;Me<Se;Me++){const Ee=se(ge,ce.dataType,Me*ve);be[Me]=Ee}}else{let be;switch(ce.dataType){case q.onnx.TensorProto.DataType.FLOAT:be=ce.floatData;break;case q.onnx.TensorProto.DataType.INT32:case q.onnx.TensorProto.DataType.INT16:case q.onnx.TensorProto.DataType.UINT16:case q.onnx.TensorProto.DataType.INT8:case q.onnx.TensorProto.DataType.UINT8:case q.onnx.TensorProto.DataType.BOOL:be=ce.int32Data;break;case q.onnx.TensorProto.DataType.INT64:be=ce.int64Data;break;case q.onnx.TensorProto.DataType.DOUBLE:be=ce.doubleData;break;case q.onnx.TensorProto.DataType.UINT32:case q.onnx.TensorProto.DataType.UINT64:be=ce.uint64Data;break;default:throw new Error("unspecific error")}if(be==null)throw new Error("failed to populate data from a tensorproto value");const ge=me.data;if(ge.length!==be.length)throw new Error("array length mismatch");for(let ve=0;ve<be.length;ve++){const Se=be[ve];G.default.isLong(Se)?ge[ve]=ne(Se,ce.dataType):ge[ve]=Se}}return me}static fromData(ce,he,pe){return new ie(he,pe,void 0,void 0,ce)}static fromOrtTensor(ce){if(!ce)throw new Error("cannot construct Value from an empty tensor");const he=ee.ProtoUtil.tensorDimsFromORTFormat(ce),pe=ee.ProtoUtil.tensorDataTypeFromProto(ce.dataType()),me=new ie(he,pe);if(pe==="string")for(let be=0;be<ce.stringDataLength();be++)me.data[be]=ce.stringData(be);else if(ce.rawDataArray()&&typeof ce.rawDataLength()=="number"&&ce.rawDataLength()>0){const be=me.data,ge=new DataView(ce.rawDataArray().buffer,ce.rawDataArray().byteOffset,ce.rawDataLength()),ve=Y(ce.dataType()),Se=ce.rawDataLength()/ve;if(ce.rawDataLength()%ve!=0)throw new Error("invalid buffer length");if(be.length!==Se)throw new Error("buffer length mismatch");for(let Me=0;Me<Se;Me++){const Ee=se(ge,ce.dataType(),Me*ve);be[Me]=Ee}}return me}}function Y(le){switch(le){case q.onnx.TensorProto.DataType.UINT8:case q.onnx.TensorProto.DataType.INT8:case q.onnx.TensorProto.DataType.BOOL:return 1;case q.onnx.TensorProto.DataType.UINT16:case q.onnx.TensorProto.DataType.INT16:return 2;case q.onnx.TensorProto.DataType.FLOAT:case q.onnx.TensorProto.DataType.INT32:case q.onnx.TensorProto.DataType.UINT32:return 4;case q.onnx.TensorProto.DataType.INT64:case q.onnx.TensorProto.DataType.DOUBLE:case q.onnx.TensorProto.DataType.UINT64:return 8;default:throw new Error(`cannot calculate sizeof() on type ${q.onnx.TensorProto.DataType[le]}`)}}function W(le){switch(le){case"bool":case"uint8":return Uint8Array;case"int8":return Int8Array;case"int16":return Int16Array;case"uint16":return Uint16Array;case"int32":return Int32Array;case"uint32":return Uint32Array;case"float32":return Float32Array;case"float64":return Float64Array;default:throw new Error("unspecified error")}}function ne(le,ce){if(ce===q.onnx.TensorProto.DataType.INT64||ce===Z.TensorDataType.INT64){if(le.greaterThanOrEqual(2147483648)||le.lessThan(-2147483648))throw new TypeError("int64 is not supported")}else{if(ce!==q.onnx.TensorProto.DataType.UINT32&&ce!==Z.TensorDataType.UINT32&&ce!==q.onnx.TensorProto.DataType.UINT64&&ce!==Z.TensorDataType.UINT64)throw new TypeError(`not a LONG type: ${q.onnx.TensorProto.DataType[ce]}`);if(le.greaterThanOrEqual(4294967296)||le.lessThan(0))throw new TypeError("uint64 is not supported")}return le.toNumber()}function se(le,ce,he){switch(ce){case q.onnx.TensorProto.DataType.BOOL:case q.onnx.TensorProto.DataType.UINT8:return le.getUint8(he);case q.onnx.TensorProto.DataType.INT8:return le.getInt8(he);case q.onnx.TensorProto.DataType.UINT16:return le.getUint16(he,!0);case q.onnx.TensorProto.DataType.INT16:return le.getInt16(he,!0);case q.onnx.TensorProto.DataType.FLOAT:return le.getFloat32(he,!0);case q.onnx.TensorProto.DataType.INT32:return le.getInt32(he,!0);case q.onnx.TensorProto.DataType.UINT32:return le.getUint32(he,!0);case q.onnx.TensorProto.DataType.INT64:return ne(G.default.fromBits(le.getUint32(he,!0),le.getUint32(he+4,!0),!1),ce);case q.onnx.TensorProto.DataType.DOUBLE:return le.getFloat64(he,!0);case q.onnx.TensorProto.DataType.UINT64:return ne(G.default.fromBits(le.getUint32(he,!0),le.getUint32(he+4,!0),!0),ce);default:throw new Error(`cannot read from DataView for type ${q.onnx.TensorProto.DataType[ce]}`)}}w.Tensor=ie},2517:function(F,w,D){var O=this&&this.__importDefault||function(ce){return ce&&ce.__esModule?ce:{default:ce}};Object.defineProperty(w,"__esModule",{value:!0}),w.decodeUtf8String=w.MAX_CLIP=w.MIN_CLIP=w.PoolConvUtil=w.ReduceUtil=w.SplitUtil=w.MathUtil=w.ShapeUtil=w.LongUtil=w.ProtoUtil=w.GemmUtil=w.arrayCopyHelper=w.BroadcastUtil=w.MatMulUtil=w.ArrayUtil=w.assert=w.checkInputsShape=void 0;const U=D(5686),G=O(D(3720)),q=D(1446),K=D(9162);w.checkInputsShape=function(ce,...he){if(!ce||ce.length!==he.length)return!1;for(let pe=0;pe<ce.length;pe++)if(!ce[pe].dims||ce[pe].dims.length!==he[pe])return!1;return!0},w.assert=function(ce,he){if(!ce)throw new Error(typeof he=="string"?he:he())},w.ArrayUtil=class{static arraysEqual(ce,he){if(ce.length!==he.length)return!1;for(let pe=0;pe<ce.length;pe++)if(ce[pe]!==he[pe])return!1;return!0}};class ee{static preprocessInputShapes(he,pe){return[he.length===1?[1,he[0]]:he,pe.length===1?[pe[0],1]:pe]}static postprocessOutputShape(he,pe,me){pe===1&&he.splice(he.length-2,1),me===1&&he.pop()}static calcMatMulShape(he,pe){return he[1]!==pe[0]?void 0:[he[0],pe[1]]}}w.MatMulUtil=ee;class Z{static calcShape(he,pe,me=!1){const be=he.length,ge=pe.length;if(be===0)return pe;if(ge===0)return he;const ve=Math.max(he.length,pe.length),Se=new Array(ve);if(me){if(be<2||ge<2)return;const Me=ee.calcMatMulShape([he[be-2],he[be-1]],[pe[ge-2],pe[ge-1]]);if(Me===void 0)return;[Se[ve-2],Se[ve-1]]=Me}for(let Me=me?3:1;Me<=ve;Me++){const Ee=be-Me<0?1:he[be-Me],we=ge-Me<0?1:pe[ge-Me];if(Ee!==we&&Ee>1&&we>1)return;Se[ve-Me]=Math.max(Ee,we)}return Se}static index(he,pe){const me=new Array(pe.length);return Z.fillIndex(he,pe,me),me}static fillIndex(he,pe,me){const be=he.length-pe.length;for(let ge=0;ge<pe.length;ge++)me[ge]=he[be+ge]%pe[ge]}static calc(he,pe,me,be,ge){const ve=Z.calcShape(he.dims,pe.dims);if(ve){if(be&&!W.areEqual(ve,he.dims))return;const Se=W.size(ve),Me=be?he:new K.Tensor(ve,ge||he.type);if(ve.length===0)Me.set([],me(he.get([]),pe.get([])));else{const Ee=new Array(ve.length),we=new Array(he.dims.length),Re=new Array(pe.dims.length);let Le,Ne=0,Oe=0,Pe=!1,Ce=!1;he.dims.length===0&&(Ne=he.get([]),Pe=!0),pe.dims.length===0&&(Oe=pe.get([]),Ce=!0);for(let Be=0;Be<Se;Be++){Le=Be;for(let ze=ve.length-1;ze>=0;ze--)Ee[ze]=Le%ve[ze],Le=Math.floor(Le/ve[ze]);Pe||(Z.fillIndex(Ee,he.dims,we),Ne=he.get(we)),Ce||(Z.fillIndex(Ee,pe.dims,Re),Oe=pe.get(Re)),Me.set(Ee,me(Ne,Oe))}}return Me}}static isValidBroadcast(he,pe){const me=he.length,be=pe.length;if(me>be)return!1;for(let ge=1;ge<=me;ge++)if(he[me-ge]!==1&&he[me-ge]!==pe[be-ge])return!1;return!0}static getBroadcastDims(he,pe){const me=he.length,be=[];for(let ge=0;ge<me;ge++){const ve=me-1-ge,Se=he[ve]||1;(pe[pe.length-1-ge]||1)>1&&Se===1&&be.unshift(ve)}return be}}w.BroadcastUtil=Z,w.arrayCopyHelper=function(ce,he,pe,me,be){if(me<0||me>=he.length)throw new Error("sourceIndex out of bounds");if(pe<0||pe>=ce.length)throw new Error("targetIndex out of bounds");if(me+be>he.length)throw new Error("source indices to be copied are outside bounds");if(pe+be>ce.length)throw new Error("target array is too small to hold result");for(let ge=0;ge<be;ge++)ce[pe+ge]=he[me+ge]},w.GemmUtil=class{static getShapeOfGemmResult(ce,he,pe,me,be){if(ce.length!==2||pe.length!==2)throw new Error("shape need to be of size 2");let ge,ve,Se;he?(ge=ce[1],ve=ce[0]):(ge=ce[0],ve=ce[1]);let Me=-1;if(me?(Se=pe[0],Me=1):(Se=pe[1],Me=0),pe[Me]!==ve)throw new Error("dimension mismatch");if(ge<=0||Se<=0||ve<=0)throw new Error("invalid shape specified");if(be&&!Z.isValidBroadcast(be,[ge,Se]))throw new Error("gemm: invalid bias shape for broadcast");return[ge,Se,ve]}};class ie{static tensorDataTypeFromProto(he){switch(he){case q.onnx.TensorProto.DataType.INT8:return"int8";case q.onnx.TensorProto.DataType.UINT8:return"uint8";case q.onnx.TensorProto.DataType.BOOL:return"bool";case q.onnx.TensorProto.DataType.INT16:return"int16";case q.onnx.TensorProto.DataType.UINT16:return"uint16";case q.onnx.TensorProto.DataType.INT32:return"int32";case q.onnx.TensorProto.DataType.UINT32:return"uint32";case q.onnx.TensorProto.DataType.FLOAT:return"float32";case q.onnx.TensorProto.DataType.DOUBLE:return"float64";case q.onnx.TensorProto.DataType.STRING:return"string";case q.onnx.TensorProto.DataType.INT64:return"int32";case q.onnx.TensorProto.DataType.UINT64:return"uint32";default:throw new Error(`unsupported data type: ${q.onnx.TensorProto.DataType[he]}`)}}static tensorDataTypeStringToEnum(he){switch(he){case"int8":return q.onnx.TensorProto.DataType.INT8;case"uint8":return q.onnx.TensorProto.DataType.UINT8;case"bool":return q.onnx.TensorProto.DataType.BOOL;case"int16":return q.onnx.TensorProto.DataType.INT16;case"uint16":return q.onnx.TensorProto.DataType.UINT16;case"int32":return q.onnx.TensorProto.DataType.INT32;case"uint32":return q.onnx.TensorProto.DataType.UINT32;case"float32":return q.onnx.TensorProto.DataType.FLOAT;case"float64":return q.onnx.TensorProto.DataType.DOUBLE;case"string":return q.onnx.TensorProto.DataType.STRING;case"int64":return q.onnx.TensorProto.DataType.INT64;case"uint64":return q.onnx.TensorProto.DataType.UINT64;default:throw new Error(`unsupported data type: ${he}`)}}static tensorDimsFromProto(he){return he.map((pe=>G.default.isLong(pe)?pe.toNumber():pe))}static tensorValueTypeFromProto(he){return{tensorType:ie.tensorDataTypeFromProto(he.elemType),shape:{dims:ie.tensorDimsFromProto(he.shape.dim.map((pe=>pe.dimValue)))}}}static tensorDimsFromORTFormat(he){const pe=[];for(let me=0;me<he.dimsLength();me++)pe.push(Y.longToNumber(he.dims(me)));return pe}static tensorAttributesFromORTFormat(he){const pe=[];for(let me=0;me<he.attributesLength();me++)pe.push(he.attributes(me));return pe}}w.ProtoUtil=ie;class Y{static longToNumber(he,pe){return G.default.isLong(he)?he.toNumber():he instanceof U.flatbuffers.Long?G.default.fromValue({low:he.low,high:he.high,unsigned:pe!=null&&pe}).toNumber():he}static isLong(he){return G.default.isLong(he)||he instanceof U.flatbuffers.Long}}w.LongUtil=Y;class W{static size(he){return W.getSizeFromDimensionRange(he,0,he.length)}static sizeFromDimension(he,pe){if(pe<0||pe>he.length)throw new Error(`invalid dimension of ${pe} for sizeFromDimension as Tensor has ${he.length} dimensions.`);return W.getSizeFromDimensionRange(he,pe,he.length)}static sizeToDimension(he,pe){if(pe<0||pe>he.length)throw new Error(`invalid dimension of ${pe} for sizeToDimension as Tensor has ${he.length} dimensions.`);return W.getSizeFromDimensionRange(he,0,pe)}static getSizeFromDimensionRange(he,pe,me){let be=1;for(let ge=pe;ge<me;ge++){if(he[ge]<=0)throw new Error("cannot get valid size from specified dimension range. Most likely the range contains 0 or negative values in them.");be*=he[ge]}return be}static computeStrides(he){const pe=he.length;if(pe===0)return[];if(pe===1)return[1];const me=new Array(pe);me[pe-1]=1,me[pe-2]=he[pe-1];for(let be=pe-3;be>=0;--be)me[be]=me[be+1]*he[be+1];return me}static transpose(he){return he.slice().reverse()}static indicesToOffset(he,pe,me){me===void 0&&(me=he.length);let be=0;for(let ge=0;ge<me;++ge)be+=pe[ge]*he[ge];return be}static offsetToIndices(he,pe){const me=pe.length;if(me===0)return[];if(me===1)return[he*pe[0]];const be=new Array(pe.length);for(let ge=0;ge<be.length-1;++ge)be[ge]=Math.floor(he/pe[ge]),he-=be[ge]*pe[ge];return be[be.length-1]=he,be}static normalizeAxis(he,pe){if(he<-pe&&he>=pe)throw new Error("unsupported axis for this operation.");return he<0?he+pe:he}static normalizeAxes(he,pe){return he.map((me=>this.normalizeAxis(me,pe)))}static incrementIndex(he,pe,me){if(pe.length===0||he.length===0)throw new Error("Index incrementing unsupported for scalar Tensor");if(me===void 0)me=pe.length;else if(me<=0||me>pe.length)throw new Error("Incorrect axis to increment on");for(let be=me-1;be>=0&&(he[be]++,!(he[be]<pe[be]));--be)he[be]=0}static calculateReshapedDims(he,pe){if(pe.length===0){if(he.length===0||W.size(he)===1)return[];throw new Error("cannot reshape to a scalar Tensor")}const me=pe.length,be=new Array(me);let ge=-1,ve=1;for(let Me=0;Me<me;Me++){if(pe[Me]<-1)throw new Error("a dimension in shape hints cannot be less than -1");if(pe[Me]===-1){if(ge!==-1)throw new Error("at most one dimension in shape hints can be -1");ge=Me}else{if(pe[Me]===0){if(Me>=he.length)throw new Error("the dimension with value zero exceeds the dimension size of the input tensor");be[Me]=he[Me]}else be[Me]=pe[Me];ve*=be[Me]}}const Se=W.size(he);if(ge!==-1){if(Se%ve!=0)throw new Error(`the input tensor cannot be reshaped to the requested shape. Input shape: [${he}] Output shape: [${pe}]`);be[ge]=Se/ve}else if(ve!==Se)throw new Error("reshapedDims and originalDims don't have matching sizes");return be}static sortBasedOnPerm(he,pe){return pe?pe.map((me=>he[me])):he.slice().reverse()}static padShape(he,pe){const me=he.length;return he.map(((be,ge)=>be+pe[ge]+pe[ge+me]))}static areEqual(he,pe){return he.length===pe.length&&he.every(((me,be)=>me===pe[be]))}static validateDimsAndCalcSize(he){if(he.length>6)throw new TypeError("Only rank 0 to 6 is supported for tensor shape.");let pe=1;for(const me of he){if(!Number.isInteger(me))throw new TypeError(`Invalid shape: ${me} is not an integer`);if(me<0||me>2147483647)throw new TypeError(`Invalid shape: length ${me} is not allowed`);pe*=me}return pe}static flattenShape(he,pe){pe<0&&(pe+=he.length);const me=he.reduce(((ge,ve)=>ge*ve),1),be=he.slice(pe).reduce(((ge,ve)=>ge*ve),1);return[me/be,be]}static squeezeShape(he,pe){const me=new Array;pe=W.normalizeAxes(pe,he.length);for(let be=0;be<he.length;be++){const ge=pe.indexOf(be)>=0;if(ge&&he[be]!==1)throw new Error("squeeze an axis of size different than 1");(pe.length===0&&he[be]>1||pe.length>0&&!ge)&&me.push(he[be])}return me}static unsqueezeShape(he,pe){const me=new Array(he.length+pe.length);me.fill(0);for(let ge=0;ge<pe.length;ge++){const ve=W.normalizeAxis(pe[ge],me.length);if(ve>=me.length)throw new Error("'axes' has an out of range axis");if(me[ve]!==0)throw new Error("'axes' has a duplicate axis");me[ve]=1}let be=0;for(let ge=0;ge<me.length;ge++)me[ge]===0&&(me[ge]=he[be++]);if(be!==he.length)throw new Error("the unsqueezed dimension could not be established");return me}}w.ShapeUtil=W,w.MathUtil=class{static sqr(ce,he,pe,me,be){if(me<0||me>=he.length)throw new Error("sourceIndex out of bounds");if(pe<0||pe>=ce.length)throw new Error("targetIndex out of bounds");if(me+be>he.length)throw new Error("source indices to be copied are outside bounds");if(pe+be>ce.length)throw new Error("target array is too small to hold result");for(let ge=0;ge<be;ge++)ce[pe+ge]+=Math.pow(he[me+ge],2)}static axpy(ce,he,pe,me,be,ge){if(me<0||me>=he.length)throw new Error("sourceIndex out of bounds");if(pe<0||pe>=ce.length)throw new Error("targetIndex out of bounds");if(me+be>he.length)throw new Error("source indices to be copied are outside bounds");if(pe+be>ce.length)throw new Error("target array is too small to hold result");for(let ve=0;ve<be;ve++)ce[pe+ve]+=ge*he[me+ve]}static powx(ce,he,pe,me,be,ge){if(me<0||me>=he.length)throw new Error("sourceIndex out of bounds");if(pe<0||pe>=ce.length)throw new Error("targetIndex out of bounds");if(me+be>he.length)throw new Error("source indices to be copied are outside bounds");if(pe+be>ce.length)throw new Error("target array is too small to hold result");for(let ve=0;ve<be;ve++)ce[pe+ve]=Math.pow(he[me+ve],ge)}static mul(ce,he,pe,me,be){if(me<0||me>=he.length)throw new Error("sourceIndex out of bounds");if(pe<0||pe>=ce.length)throw new Error("targetIndex out of bounds");if(me+be>he.length)throw new Error("source indices to be copied are outside bounds");if(pe+be>ce.length)throw new Error("target array is too small to hold result");for(let ge=0;ge<be;ge++)ce[pe+ge]=he[me+ge]*ce[pe+ge]}};class ne{static splitShape(he,pe,me,be){if(me.length===0){if(!be)throw new Error("need to know number of outputs when the 'split' attribute is not specified");ne.determineSplit(he[pe],be,me)}const ge=[],ve=[0];for(let Se=0;Se<me.length;++Se){Se!==0&&ve.push(ve[Se-1]+me[Se-1]);const Me=he.slice();Me[pe]=me[Se],ge.push(Me)}return[ge,ve]}static determineSplit(he,pe,me){if(he%pe!=0)throw new Error("cannot split tensor to equal sized parts");for(let be=0;be<pe;++be)me.push(he/pe)}}w.SplitUtil=ne;class se{static calcReduce(he,pe,me,be,ge){const ve=he.dims.slice(0);pe.length===0&&ve.forEach(((Ne,Oe)=>pe.push(Oe)));const Se=se.calcReduceShape(ve,pe,!0),Me=W.size(Se),Ee=new K.Tensor(Se,he.type),we=W.computeStrides(Se),Re=W.computeStrides(ve),Le=new Array(ve.length);for(let Ne=0;Ne<Me;Ne++){const Oe=W.offsetToIndices(Ne,we);Z.fillIndex(Oe,ve,Le),Ee.set(Oe,se.calcReduceByAxis(he.numberData,pe,ve,0,W.indicesToOffset(Le,Re),be,ge))}return me?Ee:new K.Tensor(se.calcReduceShape(ve,pe,me),Ee.type,void 0,void 0,Ee.data,Ee.dataId)}static calcReduceByAxis(he,pe,me,be,ge,ve,Se){let Me=0;if(be>=pe.length)return ve(he[ge]);const Ee=pe[be],we=Ee>=me.length?1:W.size(me.slice(Ee+1));for(let Re=0;Re<me[Ee];Re++)Me=Re===0?se.calcReduceByAxis(he,pe,me,be+1,ge,ve,Se):Se(Me,se.calcReduceByAxis(he,pe,me,be+1,ge,ve,Se)),ge+=we;return Me}static calcReduceShape(he,pe,me){const be=he.slice();for(let ge=0;ge<pe.length;ge++)be[pe[ge]]=me?1:0;return be.filter((ge=>ge!==0))}}w.ReduceUtil=se;class le{static adjustPoolAttributes(he,pe,me,be,ge,ve){if(!he&&me.length!==pe.length-2)throw new Error("length of specified kernel shapes should be 2 less than length of input dimensions");if(he)for(let Se=0;Se<pe.length-2;Se++)Se>=me.length?me.push(pe[Se+2]):me[Se]=pe[Se+2];for(let Se=0;Se<me.length;Se++)if(Se<be.length){if(be[Se]<0)throw new Error("strides should be greater than or equal to 1")}else be.push(1);for(let Se=0;Se<me.length;Se++)if(Se<ge.length){if(ge[Se]<0)throw new Error("dilations should be greater than or equal to 1")}else ge.push(1);for(let Se=0;Se<2*me.length;Se++)if(Se<ve.length){if(ve[Se]<0)throw new Error("pad should be greater than or equal to 1")}else ve.push(0);for(let Se=0;Se<me.length;Se++){if(me[Se]<=0)throw new Error("kernel shapes need to be greater than 0");if(ve[Se]>=me[Se]||ve[Se+me.length]>=me[Se])throw new Error("pads should be smaller than kernel")}}static adjustPadsBasedOnAutoPad(he,pe,me,be,ge,ve){if(ve){if(ge.length!==2*(he.length-2))throw new Error("length of pads should be twice the length of data dimensions");if(pe.length!==he.length-2)throw new Error("length of strides should be the length of data dimensions");if(be.length!==he.length-2)throw new Error("length of kernel shapes should be the length of data dimensions");for(let Se=0;Se<he.length-2;Se++)le.adjustPadAndReturnShape(he[Se+2],pe[Se],me[Se],be[Se],ge,Se,Se+he.length-2,ve)}}static computePoolOutputShape(he,pe,me,be,ge,ve,Se){if(pe.length<=0)throw new Error("input shape must be of size greater than 0");const Me=[pe[0],pe[1]];return le.computeShapeHelper(he,pe,Me,me,be,ge,ve,Se),Me}static computeConvOutputShape(he,pe,me,be,ge,ve,Se){if(he.length<=0||pe.length<=0)throw new Error("invalid input tensor dims or invalid filter tensor dims");const Me=[he[0],pe[0]];return le.computeShapeHelper(!1,he,Me,me,be,ge,ve,Se),Me}static computeShapeHelper(he,pe,me,be,ge,ve,Se,Me){if(he)for(let Ee=0;Ee<pe.length-2;Ee++)me.push(1);else for(let Ee=0;Ee<pe.length-2;Ee++)me.push(le.adjustPadAndReturnShape(pe[Ee+2],be[Ee],ge[Ee],ve[Ee],Se,Ee,Ee+pe.length-2,Me))}static adjustPadAndReturnShape(he,pe,me,be,ge,ve,Se,Me){const Ee=me*(be-1)+1;if(!Me||Me==="NOTSET")return Math.floor((he+ge[ve]+ge[Se]-Ee)/pe+1);switch(Me){case"VALID":return ge[ve]=0,ge[Se]=0,Math.floor((he-Ee)/pe+1);case"SAME_LOWER":case"SAME_UPPER":if(me!==1)throw new Error("Dilation not supported for SAME_UPPER or SAME_LOWER");{const we=((he+pe-1)/pe-1)*pe+be-he;return ge[ve]=Math.floor(Me==="SAME_LOWER"?(we+1)/2:we/2),ge[Se]=we-ge[ve],Math.floor((he+we-be)/pe+1)}default:throw new Error("Unsupported AutoPad type")}}}w.PoolConvUtil=le,w.MIN_CLIP=-34028234663852886e22,w.MAX_CLIP=34028234663852886e22,w.decodeUtf8String=function(ce){return new TextDecoder().decode(ce)}},7967:(F,w)=>{Object.defineProperty(w,"__esModule",{value:!0}),w.iterateExtraOptions=void 0,w.iterateExtraOptions=(D,O,U,G)=>{if(typeof D=="object"&&D!==null){if(U.has(D))throw new Error("Circular reference in options");U.add(D)}Object.entries(D).forEach((([q,K])=>{const ee=O?O+q:q;if(typeof K=="object")(0,w.iterateExtraOptions)(K,ee+".",U,G);else if(typeof K=="string"||typeof K=="number")G(ee,K.toString());else{if(typeof K!="boolean")throw new Error("Can't handle extra config type: "+typeof K);G(ee,K?"1":"0")}}))}},2157:function(F,w,D){var O,U=this&&this.__createBinding||(Object.create?function(we,Re,Le,Ne){Ne===void 0&&(Ne=Le);var Oe=Object.getOwnPropertyDescriptor(Re,Le);Oe&&!("get"in Oe?!Re.__esModule:Oe.writable||Oe.configurable)||(Oe={enumerable:!0,get:function(){return Re[Le]}}),Object.defineProperty(we,Ne,Oe)}:function(we,Re,Le,Ne){Ne===void 0&&(Ne=Le),we[Ne]=Re[Le]}),G=this&&this.__setModuleDefault||(Object.create?function(we,Re){Object.defineProperty(we,"default",{enumerable:!0,value:Re})}:function(we,Re){we.default=Re}),q=this&&this.__importStar||function(we){if(we&&we.__esModule)return we;var Re={};if(we!=null)for(var Le in we)Le!=="default"&&Object.prototype.hasOwnProperty.call(we,Le)&&U(Re,we,Le);return G(Re,we),Re};Object.defineProperty(w,"__esModule",{value:!0}),w.endProfiling=w.run=w.releaseSession=w.createSession=w.createSessionFinalize=w.createSessionAllocate=w.initOrt=w.initWasm=void 0;const K=D(1670),ee=q(D(349)),Z=D(6361),ie=()=>!!K.env.wasm.proxy&&typeof document<"u";let Y,W,ne,se=!1,le=!1,ce=!1;const he=[],pe=[],me=[],be=[],ge=[],ve=[],Se=()=>{if(se||!le||ce||!Y)throw new Error("worker not ready")},Me=we=>{switch(we.data.type){case"init-wasm":se=!1,we.data.err?(ce=!0,W[1](we.data.err)):(le=!0,W[0]());break;case"init-ort":we.data.err?ne[1](we.data.err):ne[0]();break;case"create_allocate":we.data.err?he.shift()[1](we.data.err):he.shift()[0](we.data.out);break;case"create_finalize":we.data.err?pe.shift()[1](we.data.err):pe.shift()[0](we.data.out);break;case"create":we.data.err?me.shift()[1](we.data.err):me.shift()[0](we.data.out);break;case"release":we.data.err?be.shift()[1](we.data.err):be.shift()[0]();break;case"run":we.data.err?ge.shift()[1](we.data.err):ge.shift()[0](we.data.out);break;case"end-profiling":we.data.err?ve.shift()[1](we.data.err):ve.shift()[0]()}},Ee=typeof document<"u"?(O=document?.currentScript)===null||O===void 0?void 0:O.src:void 0;w.initWasm=async()=>{if(ie()){if(le)return;if(se)throw new Error("multiple calls to 'initWasm()' detected.");if(ce)throw new Error("previous call to 'initWasm()' failed.");return se=!0,K.env.wasm.wasmPaths===void 0&&Ee&&Ee.indexOf("blob:")!==0&&(K.env.wasm.wasmPaths=Ee.substr(0,+Ee.lastIndexOf("/")+1)),new Promise(((we,Re)=>{Y?.terminate(),Y=D(9710).Z(),Y.onmessage=Me,W=[we,Re];const Le={type:"init-wasm",in:K.env.wasm};Y.postMessage(Le)}))}return(0,Z.initializeWebAssembly)(K.env.wasm)},w.initOrt=async(we,Re)=>{if(ie())return Se(),new Promise(((Le,Ne)=>{ne=[Le,Ne];const Oe={type:"init-ort",in:{numThreads:we,loggingLevel:Re}};Y.postMessage(Oe)}));ee.initOrt(we,Re)},w.createSessionAllocate=async we=>ie()?(Se(),new Promise(((Re,Le)=>{he.push([Re,Le]);const Ne={type:"create_allocate",in:{model:we}};Y.postMessage(Ne,[we.buffer])}))):ee.createSessionAllocate(we),w.createSessionFinalize=async(we,Re)=>ie()?(Se(),new Promise(((Le,Ne)=>{pe.push([Le,Ne]);const Oe={type:"create_finalize",in:{modeldata:we,options:Re}};Y.postMessage(Oe)}))):ee.createSessionFinalize(we,Re),w.createSession=async(we,Re)=>ie()?(Se(),new Promise(((Le,Ne)=>{me.push([Le,Ne]);const Oe={type:"create",in:{model:we,options:Re}};Y.postMessage(Oe,[we.buffer])}))):ee.createSession(we,Re),w.releaseSession=async we=>{if(ie())return Se(),new Promise(((Re,Le)=>{be.push([Re,Le]);const Ne={type:"release",in:we};Y.postMessage(Ne)}));ee.releaseSession(we)},w.run=async(we,Re,Le,Ne,Oe)=>ie()?(Se(),new Promise(((Pe,Ce)=>{ge.push([Pe,Ce]);const Be={type:"run",in:{sessionId:we,inputIndices:Re,inputs:Le,outputIndices:Ne,options:Oe}};Y.postMessage(Be,ee.extractTransferableBuffers(Le))}))):ee.run(we,Re,Le,Ne,Oe),w.endProfiling=async we=>{if(ie())return Se(),new Promise(((Re,Le)=>{ve.push([Re,Le]);const Ne={type:"end-profiling",in:we};Y.postMessage(Ne)}));ee.endProfiling(we)}},586:(F,w,D)=>{Object.defineProperty(w,"__esModule",{value:!0}),w.setRunOptions=void 0;const O=D(7967),U=D(4983),G=D(6361);w.setRunOptions=q=>{const K=(0,G.getInstance)();let ee=0;const Z=[],ie=q||{};try{if(q?.logSeverityLevel===void 0)ie.logSeverityLevel=2;else if(typeof q.logSeverityLevel!="number"||!Number.isInteger(q.logSeverityLevel)||q.logSeverityLevel<0||q.logSeverityLevel>4)throw new Error(`log serverity level is not valid: ${q.logSeverityLevel}`);if(q?.logVerbosityLevel===void 0)ie.logVerbosityLevel=0;else if(typeof q.logVerbosityLevel!="number"||!Number.isInteger(q.logVerbosityLevel))throw new Error(`log verbosity level is not valid: ${q.logVerbosityLevel}`);q?.terminate===void 0&&(ie.terminate=!1);let Y=0;if(q?.tag!==void 0&&(Y=(0,U.allocWasmString)(q.tag,Z)),ee=K._OrtCreateRunOptions(ie.logSeverityLevel,ie.logVerbosityLevel,!!ie.terminate,Y),ee===0)throw new Error("Can't create run options");return q?.extra!==void 0&&(0,O.iterateExtraOptions)(q.extra,"",new WeakSet,((W,ne)=>{const se=(0,U.allocWasmString)(W,Z),le=(0,U.allocWasmString)(ne,Z);if(K._OrtAddRunConfigEntry(ee,se,le)!==0)throw new Error(`Can't set a run config entry: ${W} - ${ne}`)})),[ee,Z]}catch(Y){throw ee!==0&&K._OrtReleaseRunOptions(ee),Z.forEach(K._free),Y}}},2306:(F,w,D)=>{Object.defineProperty(w,"__esModule",{value:!0}),w.OnnxruntimeWebAssemblySessionHandler=void 0;const O=D(2806),U=D(1670),G=D(2850),q=D(2157);let K;w.OnnxruntimeWebAssemblySessionHandler=class{async createSessionAllocate(ee){const Z=await fetch(ee),ie=await Z.arrayBuffer();return(0,q.createSessionAllocate)(new Uint8Array(ie))}async loadModel(ee,Z){if(K||(await(0,q.initOrt)(U.env.wasm.numThreads,(ie=>{switch(ie){case"verbose":return 0;case"info":return 1;case"warning":return 2;case"error":return 3;case"fatal":return 4;default:throw new Error(`unsupported logging level: ${ie}`)}})(U.env.logLevel)),K=!0),typeof ee=="string")if(typeof fetch>"u"){const ie=await(0,G.promisify)(O.readFile)(ee);[this.sessionId,this.inputNames,this.outputNames]=await(0,q.createSession)(ie,Z)}else{const ie=await this.createSessionAllocate(ee);[this.sessionId,this.inputNames,this.outputNames]=await(0,q.createSessionFinalize)(ie,Z)}else[this.sessionId,this.inputNames,this.outputNames]=await(0,q.createSession)(ee,Z)}async dispose(){return(0,q.releaseSession)(this.sessionId)}async run(ee,Z,ie){const Y=[],W=[];Object.entries(ee).forEach((ce=>{const he=ce[0],pe=ce[1],me=this.inputNames.indexOf(he);if(me===-1)throw new Error(`invalid input '${he}'`);Y.push(pe),W.push(me)}));const ne=[];Object.entries(Z).forEach((ce=>{const he=ce[0],pe=this.outputNames.indexOf(he);if(pe===-1)throw new Error(`invalid output '${he}'`);ne.push(pe)}));const se=await(0,q.run)(this.sessionId,W,Y.map((ce=>[ce.type,ce.dims,ce.data])),ne,ie),le={};for(let ce=0;ce<se.length;ce++)le[this.outputNames[ne[ce]]]=new U.Tensor(se[ce][0],se[ce][2],se[ce][1]);return le}startProfiling(){}endProfiling(){(0,q.endProfiling)(this.sessionId)}}},4919:(F,w,D)=>{Object.defineProperty(w,"__esModule",{value:!0}),w.setSessionOptions=void 0;const O=D(7967),U=D(4983),G=D(6361);w.setSessionOptions=q=>{const K=(0,G.getInstance)();let ee=0;const Z=[],ie=q||{};(Y=>{Y.extra||(Y.extra={}),Y.extra.session||(Y.extra.session={});const W=Y.extra.session;W.use_ort_model_bytes_directly||(W.use_ort_model_bytes_directly="1")})(ie);try{q?.graphOptimizationLevel===void 0&&(ie.graphOptimizationLevel="all");const Y=(se=>{switch(se){case"disabled":return 0;case"basic":return 1;case"extended":return 2;case"all":return 99;default:throw new Error(`unsupported graph optimization level: ${se}`)}})(ie.graphOptimizationLevel);q?.enableCpuMemArena===void 0&&(ie.enableCpuMemArena=!0),q?.enableMemPattern===void 0&&(ie.enableMemPattern=!0),q?.executionMode===void 0&&(ie.executionMode="sequential");const W=(se=>{switch(se){case"sequential":return 0;case"parallel":return 1;default:throw new Error(`unsupported execution mode: ${se}`)}})(ie.executionMode);let ne=0;if(q?.logId!==void 0&&(ne=(0,U.allocWasmString)(q.logId,Z)),q?.logSeverityLevel===void 0)ie.logSeverityLevel=2;else if(typeof q.logSeverityLevel!="number"||!Number.isInteger(q.logSeverityLevel)||q.logSeverityLevel<0||q.logSeverityLevel>4)throw new Error(`log serverity level is not valid: ${q.logSeverityLevel}`);if(q?.logVerbosityLevel===void 0)ie.logVerbosityLevel=0;else if(typeof q.logVerbosityLevel!="number"||!Number.isInteger(q.logVerbosityLevel))throw new Error(`log verbosity level is not valid: ${q.logVerbosityLevel}`);if(q?.enableProfiling===void 0&&(ie.enableProfiling=!1),ee=K._OrtCreateSessionOptions(Y,!!ie.enableCpuMemArena,!!ie.enableMemPattern,W,!!ie.enableProfiling,0,ne,ie.logSeverityLevel,ie.logVerbosityLevel),ee===0)throw new Error("Can't create session options");return q?.executionProviders&&((se,le,ce)=>{for(const he of le){let pe=typeof he=="string"?he:he.name;switch(pe){case"xnnpack":pe="XNNPACK";break;case"wasm":case"cpu":continue;default:throw new Error(`not supported EP: ${pe}`)}const me=(0,U.allocWasmString)(pe,ce);if((0,G.getInstance)()._OrtAppendExecutionProvider(se,me)!==0)throw new Error(`Can't append execution provider: ${pe}`)}})(ee,q.executionProviders,Z),q?.extra!==void 0&&(0,O.iterateExtraOptions)(q.extra,"",new WeakSet,((se,le)=>{const ce=(0,U.allocWasmString)(se,Z),he=(0,U.allocWasmString)(le,Z);if(K._OrtAddSessionConfigEntry(ee,ce,he)!==0)throw new Error(`Can't set a session config entry: ${se} - ${le}`)})),[ee,Z]}catch(Y){throw ee!==0&&K._OrtReleaseSessionOptions(ee),Z.forEach(K._free),Y}}},4983:(F,w,D)=>{Object.defineProperty(w,"__esModule",{value:!0}),w.allocWasmString=void 0;const O=D(6361);w.allocWasmString=(U,G)=>{const q=(0,O.getInstance)(),K=q.lengthBytesUTF8(U)+1,ee=q._malloc(K);return q.stringToUTF8(U,ee,K),G.push(ee),ee}},349:(F,w,D)=>{Object.defineProperty(w,"__esModule",{value:!0}),w.extractTransferableBuffers=w.endProfiling=w.run=w.releaseSession=w.createSession=w.createSessionFinalize=w.createSessionAllocate=w.initOrt=void 0;const O=D(586),U=D(4919),G=D(4983),q=D(6361);w.initOrt=(Y,W)=>{const ne=(0,q.getInstance)()._OrtInit(Y,W);if(ne!==0)throw new Error(`Can't initialize onnxruntime. error code = ${ne}`)};const K=new Map;w.createSessionAllocate=Y=>{const W=(0,q.getInstance)(),ne=W._malloc(Y.byteLength);return W.HEAPU8.set(Y,ne),[ne,Y.byteLength]},w.createSessionFinalize=(Y,W)=>{const ne=(0,q.getInstance)();let se=0,le=0,ce=[];try{if([le,ce]=(0,U.setSessionOptions)(W),se=ne._OrtCreateSession(Y[0],Y[1],le),se===0)throw new Error("Can't create a session")}finally{ne._free(Y[0]),ne._OrtReleaseSessionOptions(le),ce.forEach(ne._free)}const he=ne._OrtGetInputCount(se),pe=ne._OrtGetOutputCount(se),me=[],be=[],ge=[],ve=[];for(let Se=0;Se<he;Se++){const Me=ne._OrtGetInputName(se,Se);if(Me===0)throw new Error("Can't get an input name");be.push(Me),me.push(ne.UTF8ToString(Me))}for(let Se=0;Se<pe;Se++){const Me=ne._OrtGetOutputName(se,Se);if(Me===0)throw new Error("Can't get an output name");ve.push(Me),ge.push(ne.UTF8ToString(Me))}return K.set(se,[se,be,ve]),[se,me,ge]},w.createSession=(Y,W)=>{const ne=(0,w.createSessionAllocate)(Y);return(0,w.createSessionFinalize)(ne,W)},w.releaseSession=Y=>{const W=(0,q.getInstance)(),ne=K.get(Y);if(!ne)throw new Error("invalid session id");const se=ne[0],le=ne[1],ce=ne[2];le.forEach(W._OrtFree),ce.forEach(W._OrtFree),W._OrtReleaseSession(se),K.delete(Y)};const ee=Y=>{switch(Y){case"int8":return 3;case"uint8":return 2;case"bool":return 9;case"int16":return 5;case"uint16":return 4;case"int32":return 6;case"uint32":return 12;case"float32":return 1;case"float64":return 11;case"string":return 8;case"int64":return 7;case"uint64":return 13;default:throw new Error(`unsupported data type: ${Y}`)}},Z=Y=>{switch(Y){case 3:return"int8";case 2:return"uint8";case 9:return"bool";case 5:return"int16";case 4:return"uint16";case 6:return"int32";case 12:return"uint32";case 1:return"float32";case 11:return"float64";case 8:return"string";case 7:return"int64";case 13:return"uint64";default:throw new Error(`unsupported data type: ${Y}`)}},ie=Y=>{switch(Y){case"float32":return Float32Array;case"uint8":case"bool":return Uint8Array;case"int8":return Int8Array;case"uint16":return Uint16Array;case"int16":return Int16Array;case"int32":return Int32Array;case"float64":return Float64Array;case"uint32":return Uint32Array;case"int64":return BigInt64Array;case"uint64":return BigUint64Array;default:throw new Error(`unsupported type: ${Y}`)}};w.run=(Y,W,ne,se,le)=>{const ce=(0,q.getInstance)(),he=K.get(Y);if(!he)throw new Error("invalid session id");const pe=he[0],me=he[1],be=he[2],ge=W.length,ve=se.length;let Se=0,Me=[];const Ee=[],we=[];try{[Se,Me]=(0,O.setRunOptions)(le);for(let Ce=0;Ce<ge;Ce++){const Be=ne[Ce][0],ze=ne[Ce][1],Xe=ne[Ce][2];let lt,ke;if(Array.isArray(Xe)){ke=4*Xe.length,lt=ce._malloc(ke),we.push(lt);let Lt=lt/4;for(let $t=0;$t<Xe.length;$t++){if(typeof Xe[$t]!="string")throw new TypeError(`tensor data at index ${$t} is not a string`);ce.HEAPU32[Lt++]=(0,G.allocWasmString)(Xe[$t],we)}}else ke=Xe.byteLength,lt=ce._malloc(ke),we.push(lt),ce.HEAPU8.set(new Uint8Array(Xe.buffer,Xe.byteOffset,ke),lt);const rt=ce.stackSave(),St=ce.stackAlloc(4*ze.length);try{let Lt=St/4;ze.forEach((mt=>ce.HEAP32[Lt++]=mt));const $t=ce._OrtCreateTensor(ee(Be),lt,ke,St,ze.length);if($t===0)throw new Error("Can't create a tensor");Ee.push($t)}finally{ce.stackRestore(rt)}}const Re=ce.stackSave(),Le=ce.stackAlloc(4*ge),Ne=ce.stackAlloc(4*ge),Oe=ce.stackAlloc(4*ve),Pe=ce.stackAlloc(4*ve);try{let Ce=Le/4,Be=Ne/4,ze=Oe/4,Xe=Pe/4;for(let rt=0;rt<ge;rt++)ce.HEAPU32[Ce++]=Ee[rt],ce.HEAPU32[Be++]=me[W[rt]];for(let rt=0;rt<ve;rt++)ce.HEAPU32[ze++]=0,ce.HEAPU32[Xe++]=be[se[rt]];let lt=ce._OrtRun(pe,Ne,Le,ge,Pe,ve,Oe,Se);const ke=[];if(lt===0)for(let rt=0;rt<ve;rt++){const St=ce.HEAPU32[Oe/4+rt],Lt=ce.stackSave(),$t=ce.stackAlloc(16);let mt,bt=0;try{if(lt=ce._OrtGetTensorData(St,$t,$t+4,$t+8,$t+12),lt!==0)throw new Error(`Can't access output tensor data. error code = ${lt}`);let Xt=$t/4;const hn=ce.HEAPU32[Xt++];bt=ce.HEAPU32[Xt++];const Jt=ce.HEAPU32[Xt++],Mn=ce.HEAPU32[Xt++],Zn=[];for(let In=0;In<Mn;In++)Zn.push(ce.HEAPU32[Jt/4+In]);ce._OrtFree(Jt);const vn=Zn.length===0?1:Zn.reduce(((In,st)=>In*st));if(mt=Z(hn),mt==="string"){const In=[];let st=bt/4;for(let Gn=0;Gn<vn;Gn++){const qn=ce.HEAPU32[st++],ai=Gn===vn-1?void 0:ce.HEAPU32[st]-qn;In.push(ce.UTF8ToString(qn,ai))}ke.push([mt,Zn,In])}else{const In=new(ie(mt))(vn);new Uint8Array(In.buffer,In.byteOffset,In.byteLength).set(ce.HEAPU8.subarray(bt,bt+In.byteLength)),ke.push([mt,Zn,In])}}finally{ce.stackRestore(Lt),mt==="string"&&bt&&ce._free(bt),ce._OrtReleaseTensor(St)}}if(lt===0)return ke;throw new Error(`failed to call OrtRun(). error code = ${lt}.`)}finally{ce.stackRestore(Re)}}finally{Ee.forEach(ce._OrtReleaseTensor),we.forEach(ce._free),ce._OrtReleaseRunOptions(Se),Me.forEach(ce._free)}},w.endProfiling=Y=>{const W=(0,q.getInstance)(),ne=K.get(Y);if(!ne)throw new Error("invalid session id");const se=ne[0],le=W._OrtEndProfiling(se);if(le===0)throw new Error("Can't get an profile file name");W._OrtFree(le)},w.extractTransferableBuffers=Y=>{const W=[];for(const ne of Y){const se=ne[2];!Array.isArray(se)&&se.buffer&&W.push(se.buffer)}return W}},6361:function(F,w,D){var O=this&&this.__createBinding||(Object.create?function(le,ce,he,pe){pe===void 0&&(pe=he);var me=Object.getOwnPropertyDescriptor(ce,he);me&&!("get"in me?!ce.__esModule:me.writable||me.configurable)||(me={enumerable:!0,get:function(){return ce[he]}}),Object.defineProperty(le,pe,me)}:function(le,ce,he,pe){pe===void 0&&(pe=he),le[pe]=ce[he]}),U=this&&this.__setModuleDefault||(Object.create?function(le,ce){Object.defineProperty(le,"default",{enumerable:!0,value:ce})}:function(le,ce){le.default=ce}),G=this&&this.__importStar||function(le){if(le&&le.__esModule)return le;var ce={};if(le!=null)for(var he in le)he!=="default"&&Object.prototype.hasOwnProperty.call(le,he)&&O(ce,le,he);return U(ce,le),ce},q=this&&this.__importDefault||function(le){return le&&le.__esModule?le:{default:le}};Object.defineProperty(w,"__esModule",{value:!0}),w.dispose=w.getInstance=w.initializeWebAssembly=void 0;const K=G(D(6449)),ee=q(D(932)),Z=D(3474);let ie,Y=!1,W=!1,ne=!1;const se=(le,ce)=>ce?le?"ort-wasm-simd-threaded.wasm":"ort-wasm-threaded.wasm":le?"ort-wasm-simd.wasm":"ort-wasm.wasm";w.initializeWebAssembly=async le=>{if(Y)return Promise.resolve();if(W)throw new Error("multiple calls to 'initializeWebAssembly()' detected.");if(ne)throw new Error("previous call to 'initializeWebAssembly()' failed.");W=!0;const ce=le.initTimeout,he=le.numThreads,pe=le.simd,me=he>1&&(()=>{try{return typeof SharedArrayBuffer<"u"&&(typeof MessageChannel<"u"&&new MessageChannel().port1.postMessage(new SharedArrayBuffer(1)),WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,5,4,1,3,1,1,10,11,1,9,0,65,0,254,16,2,0,26,11])))}catch{return!1}})(),be=pe&&(()=>{try{return WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,30,1,28,0,65,0,253,15,253,12,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,253,186,1,26,11]))}catch{return!1}})(),ge=typeof le.wasmPaths=="string"?le.wasmPaths:void 0,ve=se(!1,me),Se=se(be,me),Me=typeof le.wasmPaths=="object"?le.wasmPaths[Se]:void 0;let Ee=!1;const we=[];if(ce>0&&we.push(new Promise((Re=>{setTimeout((()=>{Ee=!0,Re()}),ce)}))),we.push(new Promise(((Re,Le)=>{const Ne=me?Z:ee.default,Oe={locateFile:(Pe,Ce)=>me&&Pe.endsWith(".worker.js")&&typeof Blob<"u"?URL.createObjectURL(new Blob([D(4154)],{type:"text/javascript"})):Pe===ve?Me??(ge??Ce)+Se:Ce+Pe};if(me)if(typeof Blob>"u")Oe.mainScriptUrlOrBlob=K.join("/","ort-wasm-threaded.js");else{const Pe=`var ortWasmThreaded=(function(){var _scriptDir;return ${Ne.toString()}})();`;Oe.mainScriptUrlOrBlob=new Blob([Pe],{type:"text/javascript"})}Ne(Oe).then((Pe=>{W=!1,Y=!0,ie=Pe,Re()}),(Pe=>{W=!1,ne=!0,Le(Pe)}))}))),await Promise.race(we),Ee)throw new Error(`WebAssembly backend initializing failed due to timeout: ${ce}ms`)},w.getInstance=()=>{if(Y&&ie)return ie;throw new Error("WebAssembly is not initialized yet.")},w.dispose=()=>{var le;!Y||W||ne||(W=!0,(le=ie.PThread)===null||le===void 0||le.terminateAllThreads(),ie=void 0,W=!1,Y=!1,ne=!0)}},9710:(F,w,D)=>{D.d(w,{Z:()=>G});var O=D(477),U=D.n(O);function G(){return U()('/*!\n* ONNX Runtime Web v1.14.0\n* Copyright (c) Microsoft Corporation. All rights reserved.\n* Licensed under the MIT License.\n*/\n(()=>{var t={474:(t,e,n)=>{var _scriptDir,r=(_scriptDir=(_scriptDir="undefined"!=typeof document&&document.currentScript?document.currentScript.src:void 0)||"/index.js",function(t){function e(){return j.buffer!=D&&N(j.buffer),P}function r(){return j.buffer!=D&&N(j.buffer),U}function a(){return j.buffer!=D&&N(j.buffer),F}function i(){return j.buffer!=D&&N(j.buffer),I}function o(){return j.buffer!=D&&N(j.buffer),W}var u,c,s;t=t||{},u||(u=void 0!==t?t:{}),u.ready=new Promise((function(t,e){c=t,s=e}));var l,f,p,h,d,y,b=Object.assign({},u),m="./this.program",g=(t,e)=>{throw e},v="object"==typeof window,w="function"==typeof importScripts,_="object"==typeof process&&"object"==typeof process.versions&&"string"==typeof process.versions.node,O=u.ENVIRONMENT_IS_PTHREAD||!1,A="";function S(t){return u.locateFile?u.locateFile(t,A):A+t}if(_){let e;A=w?n(908).dirname(A)+"/":"//",y=()=>{d||(h=n(384),d=n(908))},l=function(t,e){return y(),t=d.normalize(t),h.readFileSync(t,e?void 0:"utf8")},p=t=>((t=l(t,!0)).buffer||(t=new Uint8Array(t)),t),f=(t,e,n)=>{y(),t=d.normalize(t),h.readFile(t,(function(t,r){t?n(t):e(r.buffer)}))},1<process.argv.length&&(m=process.argv[1].replace(/\\\\/g,"/")),process.argv.slice(2),process.on("uncaughtException",(function(t){if(!(t instanceof ct))throw t})),process.on("unhandledRejection",(function(t){throw t})),g=(t,e)=>{if(Q())throw process.exitCode=t,e;e instanceof ct||x("exiting due to exception: "+e),process.exit(t)},u.inspect=function(){return"[Emscripten Module object]"};try{e=n(925)}catch(t){throw console.error(\'The "worker_threads" module is not supported in this node.js build - perhaps a newer version is needed?\'),t}n.g.Worker=e.Worker}else(v||w)&&(w?A=self.location.href:"undefined"!=typeof document&&document.currentScript&&(A=document.currentScript.src),_scriptDir&&(A=_scriptDir),A=0!==A.indexOf("blob:")?A.substr(0,A.replace(/[?#].*/,"").lastIndexOf("/")+1):"",_||(l=t=>{var e=new XMLHttpRequest;return e.open("GET",t,!1),e.send(null),e.responseText},w&&(p=t=>{var e=new XMLHttpRequest;return e.open("GET",t,!1),e.responseType="arraybuffer",e.send(null),new Uint8Array(e.response)}),f=(t,e,n)=>{var r=new XMLHttpRequest;r.open("GET",t,!0),r.responseType="arraybuffer",r.onload=()=>{200==r.status||0==r.status&&r.response?e(r.response):n()},r.onerror=n,r.send(null)}));_&&"undefined"==typeof performance&&(n.g.performance=n(953).performance);var T=console.log.bind(console),E=console.warn.bind(console);_&&(y(),T=t=>h.writeSync(1,t+"\\n"),E=t=>h.writeSync(2,t+"\\n"));var M,C=u.print||T,x=u.printErr||E;Object.assign(u,b),b=null,u.thisProgram&&(m=u.thisProgram),u.quit&&(g=u.quit),u.wasmBinary&&(M=u.wasmBinary);var R=u.noExitRuntime||!1;"object"!=typeof WebAssembly&&at("no native wasm support detected");var j,k,D,P,U,F,I,W,H=!1,L="undefined"!=typeof TextDecoder?new TextDecoder("utf8"):void 0;function z(t,e,n){var r=(e>>>=0)+n;for(n=e;t[n]&&!(n>=r);)++n;if(16<n-e&&t.buffer&&L)return L.decode(t.buffer instanceof SharedArrayBuffer?t.slice(e,n):t.subarray(e,n));for(r="";e<n;){var a=t[e++];if(128&a){var i=63&t[e++];if(192==(224&a))r+=String.fromCharCode((31&a)<<6|i);else{var o=63&t[e++];65536>(a=224==(240&a)?(15&a)<<12|i<<6|o:(7&a)<<18|i<<12|o<<6|63&t[e++])?r+=String.fromCharCode(a):(a-=65536,r+=String.fromCharCode(55296|a>>10,56320|1023&a))}}else r+=String.fromCharCode(a)}return r}function Y(t,e){return(t>>>=0)?z(r(),t,e):""}function B(t,e,n,r){if(!(0<r))return 0;var a=n>>>=0;r=n+r-1;for(var i=0;i<t.length;++i){var o=t.charCodeAt(i);if(55296<=o&&57343>=o&&(o=65536+((1023&o)<<10)|1023&t.charCodeAt(++i)),127>=o){if(n>=r)break;e[n++>>>0]=o}else{if(2047>=o){if(n+1>=r)break;e[n++>>>0]=192|o>>6}else{if(65535>=o){if(n+2>=r)break;e[n++>>>0]=224|o>>12}else{if(n+3>=r)break;e[n++>>>0]=240|o>>18,e[n++>>>0]=128|o>>12&63}e[n++>>>0]=128|o>>6&63}e[n++>>>0]=128|63&o}}return e[n>>>0]=0,n-a}function G(t){for(var e=0,n=0;n<t.length;++n){var r=t.charCodeAt(n);127>=r?e++:2047>=r?e+=2:55296<=r&&57343>=r?(e+=4,++n):e+=3}return e}function N(t){D=t,u.HEAP8=P=new Int8Array(t),u.HEAP16=new Int16Array(t),u.HEAP32=F=new Int32Array(t),u.HEAPU8=U=new Uint8Array(t),u.HEAPU16=new Uint16Array(t),u.HEAPU32=I=new Uint32Array(t),u.HEAPF32=new Float32Array(t),u.HEAPF64=W=new Float64Array(t)}O&&(D=u.buffer);var V=u.INITIAL_MEMORY||16777216;if(O)j=u.wasmMemory,D=u.buffer;else if(u.wasmMemory)j=u.wasmMemory;else if(!((j=new WebAssembly.Memory({initial:V/65536,maximum:65536,shared:!0})).buffer instanceof SharedArrayBuffer))throw x("requested a shared WebAssembly.Memory but the returned buffer is not a SharedArrayBuffer, indicating that while the browser has SharedArrayBuffer it does not have WebAssembly threads support - you may need to set a flag"),_&&console.log("(on node you may need: --experimental-wasm-threads --experimental-wasm-bulk-memory and also use a recent version)"),Error("bad memory");j&&(D=j.buffer),V=D.byteLength,N(D);var $,q=[],X=[],J=[],Z=[];function Q(){return R||!1}function K(){var t=u.preRun.shift();q.unshift(t)}var tt,et=0,nt=null,rt=null;function at(t){throw O?postMessage({cmd:"onAbort",arg:t}):u.onAbort&&u.onAbort(t),x(t="Aborted("+t+")"),H=!0,t=new WebAssembly.RuntimeError(t+". Build with -sASSERTIONS for more info."),s(t),t}function it(){return tt.startsWith("data:application/octet-stream;base64,")}function ot(){var t=tt;try{if(t==tt&&M)return new Uint8Array(M);if(p)return p(t);throw"both async and sync fetching of the wasm failed"}catch(t){at(t)}}tt="ort-wasm-threaded.wasm",it()||(tt=S(tt));var ut={};function ct(t){this.name="ExitStatus",this.message="Program terminated with exit("+t+")",this.status=t}function st(t){(t=ht.Vb[t])||at(),ht.mc(t)}function lt(t){var e=ht.Cc();if(!e)return 6;ht.ac.push(e),ht.Vb[t.Ub]=e,e.Ub=t.Ub;var n={cmd:"run",start_routine:t.Ic,arg:t.zc,pthread_ptr:t.Ub};return e.$b=()=>{n.time=performance.now(),e.postMessage(n,t.Nc)},e.loaded&&(e.$b(),delete e.$b),0}function ft(t){if(O)return $t(1,1,t);Q()||(ht.oc(),u.onExit&&u.onExit(t),H=!0),g(t,new ct(t))}function pt(t,e){if(!e&&O)throw bt(t),"unwind";Q()||O||(me(),dt(J),be(0),re[1].length&&ae(1,10),re[2].length&&ae(2,10),ht.oc()),ft(t)}var ht={Yb:[],ac:[],qc:[],Vb:{},fc:function(){O&&ht.Ec()},Pc:function(){},Ec:function(){ht.receiveObjectTransfer=ht.Gc,ht.threadInitTLS=ht.pc,ht.setExitStatus=ht.nc,R=!1},nc:function(){},oc:function(){for(var t of Object.values(ht.Vb))ht.mc(t);for(t of ht.Yb)t.terminate();ht.Yb=[]},mc:function(t){var e=t.Ub;delete ht.Vb[e],ht.Yb.push(t),ht.ac.splice(ht.ac.indexOf(t),1),t.Ub=0,Oe(e)},Gc:function(){},pc:function(){ht.qc.forEach((t=>t()))},Fc:function(t,e){t.onmessage=n=>{var r=(n=n.data).cmd;if(t.Ub&&(ht.Bc=t.Ub),n.targetThread&&n.targetThread!=he()){var a=ht.Vb[n.Qc];a?a.postMessage(n,n.transferList):x(\'Internal error! Worker sent a message "\'+r+\'" to target pthread \'+n.targetThread+", but that thread no longer exists!")}else"processProxyingQueue"===r?zt(n.queue):"spawnThread"===r?lt(n):"cleanupThread"===r?st(n.thread):"killThread"===r?(n=n.thread,r=ht.Vb[n],delete ht.Vb[n],r.terminate(),Oe(n),ht.ac.splice(ht.ac.indexOf(r),1),r.Ub=0):"cancelThread"===r?ht.Vb[n.thread].postMessage({cmd:"cancel"}):"loaded"===r?(t.loaded=!0,e&&e(t),t.$b&&(t.$b(),delete t.$b)):"print"===r?C("Thread "+n.threadId+": "+n.text):"printErr"===r?x("Thread "+n.threadId+": "+n.text):"alert"===r?alert("Thread "+n.threadId+": "+n.text):"setimmediate"===n.target?t.postMessage(n):"onAbort"===r?u.onAbort&&u.onAbort(n.arg):r&&x("worker sent an unknown command "+r);ht.Bc=void 0},t.onerror=t=>{throw x("worker sent an error! "+t.filename+":"+t.lineno+": "+t.message),t},_&&(t.on("message",(function(e){t.onmessage({data:e})})),t.on("error",(function(e){t.onerror(e)})),t.on("detachedExit",(function(){}))),t.postMessage({cmd:"load",urlOrBlob:u.mainScriptUrlOrBlob||_scriptDir,wasmMemory:j,wasmModule:k})},yc:function(){var t=S("ort-wasm-threaded.worker.js");ht.Yb.push(new Worker(t))},Cc:function(){return 0==ht.Yb.length&&(ht.yc(),ht.Fc(ht.Yb[0])),ht.Yb.pop()}};function dt(t){for(;0<t.length;)t.shift()(u)}function yt(t){var e=Ee();return t=t(),Me(e),t}function bt(t){if(O)return $t(2,0,t);try{pt(t)}catch(t){t instanceof ct||"unwind"==t||g(1,t)}}u.PThread=ht,u.establishStackSpace=function(){var t=he(),e=a()[t+44>>2>>>0];t=a()[t+48>>2>>>0],Te(e,e-t),Me(e)};var mt=[];function gt(t){var e=mt[t];return e||(t>=mt.length&&(mt.length=t+1),mt[t]=e=$.get(t)),e}u.invokeEntryPoint=function(t,e){t=gt(t)(e),Q()?ht.nc(t):Ae(t)};var vt,wt,_t=[],Ot=0,At=0;function St(t){this.Zb=t,this.Sb=t-24,this.xc=function(t){i()[this.Sb+4>>2>>>0]=t},this.bc=function(){return i()[this.Sb+4>>2>>>0]},this.wc=function(t){i()[this.Sb+8>>2>>>0]=t},this.Dc=function(){return i()[this.Sb+8>>2>>>0]},this.rc=function(){a()[this.Sb>>2>>>0]=0},this.hc=function(t){t=t?1:0,e()[this.Sb+12>>0>>>0]=t},this.uc=function(){return 0!=e()[this.Sb+12>>0>>>0]},this.ic=function(t){t=t?1:0,e()[this.Sb+13>>0>>>0]=t},this.kc=function(){return 0!=e()[this.Sb+13>>0>>>0]},this.fc=function(t,e){this.cc(0),this.xc(t),this.wc(e),this.rc(),this.hc(!1),this.ic(!1)},this.sc=function(){Atomics.add(a(),this.Sb>>2,1)},this.Hc=function(){return 1===Atomics.sub(a(),this.Sb>>2,1)},this.cc=function(t){i()[this.Sb+16>>2>>>0]=t},this.tc=function(){return i()[this.Sb+16>>2>>>0]},this.vc=function(){if(Re(this.bc()))return i()[this.Zb>>2>>>0];var t=this.tc();return 0!==t?t:this.Zb}}function Tt(t){return ye(new St(t).Sb)}function Et(t,e,n,r){return O?$t(3,1,t,e,n,r):Mt(t,e,n,r)}function Mt(t,e,n,r){if("undefined"==typeof SharedArrayBuffer)return x("Current environment does not support SharedArrayBuffer, pthreads are not available!"),6;var a=[];return O&&0===a.length?Et(t,e,n,r):(t={Ic:n,Ub:t,zc:r,Nc:a},O?(t.Oc="spawnThread",postMessage(t,a),0):lt(t))}function Ct(t,e,n){return O?$t(4,1,t,e,n):0}function xt(t,e){if(O)return $t(5,1,t,e)}function Rt(t,e){if(O)return $t(6,1,t,e)}function jt(t,e,n){if(O)return $t(7,1,t,e,n)}function kt(t,e,n){return O?$t(8,1,t,e,n):0}function Dt(t,e){if(O)return $t(9,1,t,e)}function Pt(t,e,n){if(O)return $t(10,1,t,e,n)}function Ut(t,e,n,r){if(O)return $t(11,1,t,e,n,r)}function Ft(t,e,n,r){if(O)return $t(12,1,t,e,n,r)}function It(t,e,n,r){if(O)return $t(13,1,t,e,n,r)}function Wt(t){if(O)return $t(14,1,t)}function Ht(t,e){if(O)return $t(15,1,t,e)}function Lt(t,e,n){if(O)return $t(16,1,t,e,n)}function zt(t){Atomics.store(a(),t>>2,1),he()&&_e(t),Atomics.compareExchange(a(),t>>2,1,0)}function Yt(t){return i()[t>>>2]+4294967296*a()[t+4>>>2]}function Bt(t,e,n,r,a,i){return O?$t(17,1,t,e,n,r,a,i):-52}function Gt(t,e,n,r,a,i){if(O)return $t(18,1,t,e,n,r,a,i)}function Nt(t){var n=G(t)+1,r=de(n);return r&&B(t,e(),r,n),r}function Vt(t,e,n){function r(t){return(t=t.toTimeString().match(/\\(([A-Za-z ]+)\\)$/))?t[1]:"GMT"}if(O)return $t(19,1,t,e,n);var o=(new Date).getFullYear(),u=new Date(o,0,1),c=new Date(o,6,1);o=u.getTimezoneOffset();var s=c.getTimezoneOffset(),l=Math.max(o,s);a()[t>>2>>>0]=60*l,a()[e>>2>>>0]=Number(o!=s),t=r(u),e=r(c),t=Nt(t),e=Nt(e),s<o?(i()[n>>2>>>0]=t,i()[n+4>>2>>>0]=e):(i()[n>>2>>>0]=e,i()[n+4>>2>>>0]=t)}function $t(t,e){var n=arguments.length-2,r=arguments;return yt((()=>{for(var a=Ce(8*n),i=a>>3,u=0;u<n;u++){var c=r[2+u];o()[i+u>>>0]=c}return we(t,n,a,e)}))}u.executeNotifiedProxyingQueue=zt,wt=_?()=>{var t=process.hrtime();return 1e3*t[0]+t[1]/1e6}:O?()=>performance.now()-u.__performance_now_clock_drift:()=>performance.now();var qt,Xt=[],Jt={};function Zt(){if(!qt){var t,e={USER:"web_user",LOGNAME:"web_user",PATH:"/",PWD:"/",HOME:"/home/web_user",LANG:("object"==typeof navigator&&navigator.languages&&navigator.languages[0]||"C").replace("-","_")+".UTF-8",_:m||"./this.program"};for(t in Jt)void 0===Jt[t]?delete e[t]:e[t]=Jt[t];var n=[];for(t in e)n.push(t+"="+e[t]);qt=n}return qt}function Qt(t,n){if(O)return $t(20,1,t,n);var r=0;return Zt().forEach((function(a,o){var u=n+r;for(o=i()[t+4*o>>2>>>0]=u,u=0;u<a.length;++u)e()[o++>>0>>>0]=a.charCodeAt(u);e()[o>>0>>>0]=0,r+=a.length+1})),0}function Kt(t,e){if(O)return $t(21,1,t,e);var n=Zt();i()[t>>2>>>0]=n.length;var r=0;return n.forEach((function(t){r+=t.length+1})),i()[e>>2>>>0]=r,0}function te(t){return O?$t(22,1,t):52}function ee(t,e,n,r){return O?$t(23,1,t,e,n,r):52}function ne(t,e,n,r,a){return O?$t(24,1,t,e,n,r,a):70}var re=[null,[],[]];function ae(t,e){var n=re[t];0===e||10===e?((1===t?C:x)(z(n,0)),n.length=0):n.push(e)}function ie(t,e,n,a){if(O)return $t(25,1,t,e,n,a);for(var o=0,u=0;u<n;u++){var c=i()[e>>2>>>0],s=i()[e+4>>2>>>0];e+=8;for(var l=0;l<s;l++)ae(t,r()[c+l>>>0]);o+=s}return i()[a>>2>>>0]=o,0}var oe=0;function ue(t){return 0==t%4&&(0!=t%100||0==t%400)}var ce=[31,29,31,30,31,30,31,31,30,31,30,31],se=[31,28,31,30,31,30,31,31,30,31,30,31];function le(t,n,r,i){function o(t,e,n){for(t="number"==typeof t?t.toString():t||"";t.length<e;)t=n[0]+t;return t}function u(t,e){return o(t,e,"0")}function c(t,e){function n(t){return 0>t?-1:0<t?1:0}var r;return 0===(r=n(t.getFullYear()-e.getFullYear()))&&0===(r=n(t.getMonth()-e.getMonth()))&&(r=n(t.getDate()-e.getDate())),r}function s(t){switch(t.getDay()){case 0:return new Date(t.getFullYear()-1,11,29);case 1:return t;case 2:return new Date(t.getFullYear(),0,3);case 3:return new Date(t.getFullYear(),0,2);case 4:return new Date(t.getFullYear(),0,1);case 5:return new Date(t.getFullYear()-1,11,31);case 6:return new Date(t.getFullYear()-1,11,30)}}function l(t){var e=t.Wb;for(t=new Date(new Date(t.Xb+1900,0,1).getTime());0<e;){var n=t.getMonth(),r=(ue(t.getFullYear())?ce:se)[n];if(!(e>r-t.getDate())){t.setDate(t.getDate()+e);break}e-=r-t.getDate()+1,t.setDate(1),11>n?t.setMonth(n+1):(t.setMonth(0),t.setFullYear(t.getFullYear()+1))}return n=new Date(t.getFullYear()+1,0,4),e=s(new Date(t.getFullYear(),0,4)),n=s(n),0>=c(e,t)?0>=c(n,t)?t.getFullYear()+1:t.getFullYear():t.getFullYear()-1}var f=a()[i+40>>2>>>0];for(var p in i={Lc:a()[i>>2>>>0],Kc:a()[i+4>>2>>>0],dc:a()[i+8>>2>>>0],jc:a()[i+12>>2>>>0],ec:a()[i+16>>2>>>0],Xb:a()[i+20>>2>>>0],Tb:a()[i+24>>2>>>0],Wb:a()[i+28>>2>>>0],Rc:a()[i+32>>2>>>0],Jc:a()[i+36>>2>>>0],Mc:f?Y(f):""},r=Y(r),f={"%c":"%a %b %d %H:%M:%S %Y","%D":"%m/%d/%y","%F":"%Y-%m-%d","%h":"%b","%r":"%I:%M:%S %p","%R":"%H:%M","%T":"%H:%M:%S","%x":"%m/%d/%y","%X":"%H:%M:%S","%Ec":"%c","%EC":"%C","%Ex":"%m/%d/%y","%EX":"%H:%M:%S","%Ey":"%y","%EY":"%Y","%Od":"%d","%Oe":"%e","%OH":"%H","%OI":"%I","%Om":"%m","%OM":"%M","%OS":"%S","%Ou":"%u","%OU":"%U","%OV":"%V","%Ow":"%w","%OW":"%W","%Oy":"%y"})r=r.replace(new RegExp(p,"g"),f[p]);var h="Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),d="January February March April May June July August September October November December".split(" ");for(p in f={"%a":function(t){return h[t.Tb].substring(0,3)},"%A":function(t){return h[t.Tb]},"%b":function(t){return d[t.ec].substring(0,3)},"%B":function(t){return d[t.ec]},"%C":function(t){return u((t.Xb+1900)/100|0,2)},"%d":function(t){return u(t.jc,2)},"%e":function(t){return o(t.jc,2," ")},"%g":function(t){return l(t).toString().substring(2)},"%G":function(t){return l(t)},"%H":function(t){return u(t.dc,2)},"%I":function(t){return 0==(t=t.dc)?t=12:12<t&&(t-=12),u(t,2)},"%j":function(t){for(var e=0,n=0;n<=t.ec-1;e+=(ue(t.Xb+1900)?ce:se)[n++]);return u(t.jc+e,3)},"%m":function(t){return u(t.ec+1,2)},"%M":function(t){return u(t.Kc,2)},"%n":function(){return"\\n"},"%p":function(t){return 0<=t.dc&&12>t.dc?"AM":"PM"},"%S":function(t){return u(t.Lc,2)},"%t":function(){return"\\t"},"%u":function(t){return t.Tb||7},"%U":function(t){return u(Math.floor((t.Wb+7-t.Tb)/7),2)},"%V":function(t){var e=Math.floor((t.Wb+7-(t.Tb+6)%7)/7);if(2>=(t.Tb+371-t.Wb-2)%7&&e++,e)53==e&&(4==(n=(t.Tb+371-t.Wb)%7)||3==n&&ue(t.Xb)||(e=1));else{e=52;var n=(t.Tb+7-t.Wb-1)%7;(4==n||5==n&&ue(t.Xb%400-1))&&e++}return u(e,2)},"%w":function(t){return t.Tb},"%W":function(t){return u(Math.floor((t.Wb+7-(t.Tb+6)%7)/7),2)},"%y":function(t){return(t.Xb+1900).toString().substring(2)},"%Y":function(t){return t.Xb+1900},"%z":function(t){var e=0<=(t=t.Jc);return t=Math.abs(t)/60,(e?"+":"-")+String("0000"+(t/60*100+t%60)).slice(-4)},"%Z":function(t){return t.Mc},"%%":function(){return"%"}},r=r.replace(/%%/g,"\\0\\0"),f)r.includes(p)&&(r=r.replace(new RegExp(p,"g"),f[p](i)));return p=function(t){var e=Array(G(t)+1);return B(t,e,0,e.length),e}(r=r.replace(/\\0\\0/g,"%")),p.length>n?0:(function(t,n){e().set(t,n>>>0)}(p,t),p.length-1)}ht.fc();var fe=[null,ft,bt,Et,Ct,xt,Rt,jt,kt,Dt,Pt,Ut,Ft,It,Wt,Ht,Lt,Bt,Gt,Vt,Qt,Kt,te,ee,ne,ie],pe={b:function(t){return de(t+24)+24},n:function(t){return(t=new St(t)).uc()||(t.hc(!0),Ot--),t.ic(!1),_t.push(t),t.sc(),t.vc()},ma:function(t){throw x("Unexpected exception thrown, this is not properly supported - aborting"),H=!0,t},x:function(){Se(0);var t=_t.pop();if(t.Hc()&&!t.kc()){var e=t.Dc();e&&gt(e)(t.Zb),Tt(t.Zb)}At=0},e:function(){var t=At;if(!t)return oe=0;var e=new St(t);e.cc(t);var n=e.bc();if(!n)return oe=0,t;for(var r=Array.prototype.slice.call(arguments),a=0;a<r.length;a++){var i=r[a];if(0===i||i===n)break;if(xe(i,n,e.Sb+16))return oe=i,t}return oe=n,t},l:function(){var t=At;if(!t)return oe=0;var e=new St(t);e.cc(t);var n=e.bc();if(!n)return oe=0,t;for(var r=Array.prototype.slice.call(arguments),a=0;a<r.length;a++){var i=r[a];if(0===i||i===n)break;if(xe(i,n,e.Sb+16))return oe=i,t}return oe=n,t},h:function(){var t=At;if(!t)return oe=0;var e=new St(t);e.cc(t);var n=e.bc();if(!n)return oe=0,t;for(var r=Array.prototype.slice.call(arguments),a=0;a<r.length;a++){var i=r[a];if(0===i||i===n)break;if(xe(i,n,e.Sb+16))return oe=i,t}return oe=n,t},t:Tt,M:function(){var t=_t.pop();t||at("no exception to throw");var e=t.Zb;throw t.kc()||(_t.push(t),t.ic(!0),t.hc(!1),Ot++),At=e,e},c:function(t,e,n){throw new St(t).fc(e,n),At=t,Ot++,t},pa:function(){return Ot},Fa:function(t){ge(t,!w,1,!v),ht.pc()},T:function(t){O?postMessage({cmd:"cleanupThread",thread:t}):st(t)},xa:Mt,j:function(t){throw At||(At=t),t},H:Ct,Ma:xt,ua:Rt,wa:jt,oa:kt,Ka:Dt,Ca:Pt,Ja:Ut,V:Ft,va:It,sa:Wt,La:Ht,ta:Lt,Ta:function(){},X:function(){at("To use dlopen, you need enable dynamic linking, see https://github.com/emscripten-core/emscripten/wiki/Linking")},Ua:function(){at("To use dlopen, you need enable dynamic linking, see https://github.com/emscripten-core/emscripten/wiki/Linking")},W:function(){return Date.now()},ya:function(){return 2097152},Oa:function(){return!0},za:function(t,e,n,r){if(t==e)setTimeout((()=>zt(r)));else if(O)postMessage({targetThread:t,cmd:"processProxyingQueue",queue:r});else{if(!(t=ht.Vb[t]))return;t.postMessage({cmd:"processProxyingQueue",queue:r})}return 1},Ea:function(){return-1},Pa:function(t,e){t=new Date(1e3*Yt(t)),a()[e>>2>>>0]=t.getUTCSeconds(),a()[e+4>>2>>>0]=t.getUTCMinutes(),a()[e+8>>2>>>0]=t.getUTCHours(),a()[e+12>>2>>>0]=t.getUTCDate(),a()[e+16>>2>>>0]=t.getUTCMonth(),a()[e+20>>2>>>0]=t.getUTCFullYear()-1900,a()[e+24>>2>>>0]=t.getUTCDay(),t=(t.getTime()-Date.UTC(t.getUTCFullYear(),0,1,0,0,0,0))/864e5|0,a()[e+28>>2>>>0]=t},Qa:function(t,e){t=new Date(1e3*Yt(t)),a()[e>>2>>>0]=t.getSeconds(),a()[e+4>>2>>>0]=t.getMinutes(),a()[e+8>>2>>>0]=t.getHours(),a()[e+12>>2>>>0]=t.getDate(),a()[e+16>>2>>>0]=t.getMonth(),a()[e+20>>2>>>0]=t.getFullYear()-1900,a()[e+24>>2>>>0]=t.getDay();var n=new Date(t.getFullYear(),0,1),r=(t.getTime()-n.getTime())/864e5|0;a()[e+28>>2>>>0]=r,a()[e+36>>2>>>0]=-60*t.getTimezoneOffset(),r=new Date(t.getFullYear(),6,1).getTimezoneOffset(),t=0|(r!=(n=n.getTimezoneOffset())&&t.getTimezoneOffset()==Math.min(n,r)),a()[e+32>>2>>>0]=t},Ra:function(t){var e=new Date(a()[t+20>>2>>>0]+1900,a()[t+16>>2>>>0],a()[t+12>>2>>>0],a()[t+8>>2>>>0],a()[t+4>>2>>>0],a()[t>>2>>>0],0),n=a()[t+32>>2>>>0],r=e.getTimezoneOffset(),i=new Date(e.getFullYear(),0,1),o=new Date(e.getFullYear(),6,1).getTimezoneOffset(),u=i.getTimezoneOffset(),c=Math.min(u,o);return 0>n?a()[t+32>>2>>>0]=Number(o!=u&&c==r):0<n!=(c==r)&&(o=Math.max(u,o),e.setTime(e.getTime()+6e4*((0<n?c:o)-r))),a()[t+24>>2>>>0]=e.getDay(),n=(e.getTime()-i.getTime())/864e5|0,a()[t+28>>2>>>0]=n,a()[t>>2>>>0]=e.getSeconds(),a()[t+4>>2>>>0]=e.getMinutes(),a()[t+8>>2>>>0]=e.getHours(),a()[t+12>>2>>>0]=e.getDate(),a()[t+16>>2>>>0]=e.getMonth(),e.getTime()/1e3|0},Aa:Bt,Ba:Gt,Sa:function t(e,n,r){t.Ac||(t.Ac=!0,Vt(e,n,r))},y:function(){at("")},U:function(){if(!_&&!w){var t="Blocking on the main thread is very dangerous, see https://emscripten.org/docs/porting/pthreads.html#blocking-on-the-main-browser-thread";vt||(vt={}),vt[t]||(vt[t]=1,_&&(t="warning: "+t),x(t))}},ra:function(){return 4294901760},B:wt,Ia:function(t,e,n){r().copyWithin(t>>>0,e>>>0,e+n>>>0)},F:function(){return _?n(993).cpus().length:navigator.hardwareConcurrency},Da:function(t,e,n){Xt.length=e,n>>=3;for(var r=0;r<e;r++)Xt[r]=o()[n+r>>>0];return(0>t?ut[-t-1]:fe[t]).apply(null,Xt)},qa:function(t){var e=r().length;if((t>>>=0)<=e||4294901760<t)return!1;for(var n=1;4>=n;n*=2){var a=e*(1+.2/n);a=Math.min(a,t+100663296);var i=Math;a=Math.max(t,a),i=i.min.call(i,4294901760,a+(65536-a%65536)%65536);t:{try{j.grow(i-D.byteLength+65535>>>16),N(j.buffer);var o=1;break t}catch(t){}o=void 0}if(o)return!0}return!1},Na:function(){throw"unwind"},Ga:Qt,Ha:Kt,J:pt,I:te,S:ee,ga:ne,R:ie,d:function(){return oe},na:function t(r,a){t.lc||(t.lc=function(){if("object"==typeof crypto&&"function"==typeof crypto.getRandomValues){var t=new Uint8Array(1);return()=>(crypto.getRandomValues(t),t[0])}if(_)try{var e=n(Object(function(){var t=new Error("Cannot find module \'crypto\'");throw t.code="MODULE_NOT_FOUND",t}()));return()=>e.randomBytes(1)[0]}catch(t){}return()=>at("randomDevice")}());for(var i=0;i<a;i++)e()[r+i>>0>>>0]=t.lc();return 0},ia:function(t,e,n){var r=Ee();try{return gt(t)(e,n)}catch(t){if(Me(r),t!==t+0)throw t;Se(1,0)}},ja:function(t,e,n){var r=Ee();try{return gt(t)(e,n)}catch(t){if(Me(r),t!==t+0)throw t;Se(1,0)}},K:function(t){var e=Ee();try{return gt(t)()}catch(t){if(Me(e),t!==t+0)throw t;Se(1,0)}},f:function(t,e){var n=Ee();try{return gt(t)(e)}catch(t){if(Me(n),t!==t+0)throw t;Se(1,0)}},P:function(t,e,n){var r=Ee();try{return gt(t)(e,n)}catch(t){if(Me(r),t!==t+0)throw t;Se(1,0)}},Q:function(t,e,n){var r=Ee();try{return gt(t)(e,n)}catch(t){if(Me(r),t!==t+0)throw t;Se(1,0)}},k:function(t,e,n){var r=Ee();try{return gt(t)(e,n)}catch(t){if(Me(r),t!==t+0)throw t;Se(1,0)}},p:function(t,e,n,r){var a=Ee();try{return gt(t)(e,n,r)}catch(t){if(Me(a),t!==t+0)throw t;Se(1,0)}},q:function(t,e,n,r,a){var i=Ee();try{return gt(t)(e,n,r,a)}catch(t){if(Me(i),t!==t+0)throw t;Se(1,0)}},N:function(t,e,n,r,a,i){var o=Ee();try{return gt(t)(e,n,r,a,i)}catch(t){if(Me(o),t!==t+0)throw t;Se(1,0)}},s:function(t,e,n,r,a,i){var o=Ee();try{return gt(t)(e,n,r,a,i)}catch(t){if(Me(o),t!==t+0)throw t;Se(1,0)}},w:function(t,e,n,r,a,i,o){var u=Ee();try{return gt(t)(e,n,r,a,i,o)}catch(t){if(Me(u),t!==t+0)throw t;Se(1,0)}},L:function(t,e,n,r,a,i,o,u){var c=Ee();try{return gt(t)(e,n,r,a,i,o,u)}catch(t){if(Me(c),t!==t+0)throw t;Se(1,0)}},E:function(t,e,n,r,a,i,o,u,c,s,l,f){var p=Ee();try{return gt(t)(e,n,r,a,i,o,u,c,s,l,f)}catch(t){if(Me(p),t!==t+0)throw t;Se(1,0)}},aa:function(t,e,n,r,a,i,o,u){var c=Ee();try{return He(t,e,n,r,a,i,o,u)}catch(t){if(Me(c),t!==t+0)throw t;Se(1,0)}},_:function(t,e,n,r,a,i,o){var u=Ee();try{return ke(t,e,n,r,a,i,o)}catch(t){if(Me(u),t!==t+0)throw t;Se(1,0)}},Z:function(t,e,n,r,a){var i=Ee();try{return Le(t,e,n,r,a)}catch(t){if(Me(i),t!==t+0)throw t;Se(1,0)}},ca:function(t,e,n,r){var a=Ee();try{return Ie(t,e,n,r)}catch(t){if(Me(a),t!==t+0)throw t;Se(1,0)}},$:function(t){var e=Ee();try{return je(t)}catch(t){if(Me(e),t!==t+0)throw t;Se(1,0)}},ba:function(t,e){var n=Ee();try{return We(t,e)}catch(t){if(Me(n),t!==t+0)throw t;Se(1,0)}},Y:function(t,e,n){var r=Ee();try{return De(t,e,n)}catch(t){if(Me(r),t!==t+0)throw t;Se(1,0)}},g:function(t){var e=Ee();try{gt(t)()}catch(t){if(Me(e),t!==t+0)throw t;Se(1,0)}},r:function(t,e){var n=Ee();try{gt(t)(e)}catch(t){if(Me(n),t!==t+0)throw t;Se(1,0)}},i:function(t,e,n){var r=Ee();try{gt(t)(e,n)}catch(t){if(Me(r),t!==t+0)throw t;Se(1,0)}},ha:function(t,e,n,r){var a=Ee();try{gt(t)(e,n,r)}catch(t){if(Me(a),t!==t+0)throw t;Se(1,0)}},m:function(t,e,n,r){var a=Ee();try{gt(t)(e,n,r)}catch(t){if(Me(a),t!==t+0)throw t;Se(1,0)}},v:function(t,e,n,r,a){var i=Ee();try{gt(t)(e,n,r,a)}catch(t){if(Me(i),t!==t+0)throw t;Se(1,0)}},u:function(t,e,n,r,a,i){var o=Ee();try{gt(t)(e,n,r,a,i)}catch(t){if(Me(o),t!==t+0)throw t;Se(1,0)}},O:function(t,e,n,r,a,i,o){var u=Ee();try{gt(t)(e,n,r,a,i,o)}catch(t){if(Me(u),t!==t+0)throw t;Se(1,0)}},A:function(t,e,n,r,a,i,o,u){var c=Ee();try{gt(t)(e,n,r,a,i,o,u)}catch(t){if(Me(c),t!==t+0)throw t;Se(1,0)}},ka:function(t,e,n,r,a,i,o,u,c){var s=Ee();try{gt(t)(e,n,r,a,i,o,u,c)}catch(t){if(Me(s),t!==t+0)throw t;Se(1,0)}},C:function(t,e,n,r,a,i,o,u,c,s,l){var f=Ee();try{gt(t)(e,n,r,a,i,o,u,c,s,l)}catch(t){if(Me(f),t!==t+0)throw t;Se(1,0)}},D:function(t,e,n,r,a,i,o,u,c,s,l,f,p,h,d,y){var b=Ee();try{gt(t)(e,n,r,a,i,o,u,c,s,l,f,p,h,d,y)}catch(t){if(Me(b),t!==t+0)throw t;Se(1,0)}},fa:function(t,e,n,r,a,i,o,u){var c=Ee();try{Pe(t,e,n,r,a,i,o,u)}catch(t){if(Me(c),t!==t+0)throw t;Se(1,0)}},da:function(t,e,n,r,a,i,o,u,c,s,l,f){var p=Ee();try{Fe(t,e,n,r,a,i,o,u,c,s,l,f)}catch(t){if(Me(p),t!==t+0)throw t;Se(1,0)}},ea:function(t,e,n,r,a,i){var o=Ee();try{Ue(t,e,n,r,a,i)}catch(t){if(Me(o),t!==t+0)throw t;Se(1,0)}},o:function(t){return t},a:j||u.wasmMemory,G:function(t){oe=t},la:le,z:function(t,e,n,r){return le(t,e,n,r)}};!function(){function t(t,e){u.asm=t.exports,ht.qc.push(u.asm.sb),$=u.asm.ub,X.unshift(u.asm.Va),k=e,O||(et--,u.monitorRunDependencies&&u.monitorRunDependencies(et),0==et&&(null!==nt&&(clearInterval(nt),nt=null),rt&&(t=rt,rt=null,t())))}function e(e){t(e.instance,e.module)}function n(t){return function(){if(!M&&(v||w)){if("function"==typeof fetch&&!tt.startsWith("file://"))return fetch(tt,{credentials:"same-origin"}).then((function(t){if(!t.ok)throw"failed to load wasm binary file at \'"+tt+"\'";return t.arrayBuffer()})).catch((function(){return ot()}));if(f)return new Promise((function(t,e){f(tt,(function(e){t(new Uint8Array(e))}),e)}))}return Promise.resolve().then((function(){return ot()}))}().then((function(t){return WebAssembly.instantiate(t,r)})).then((function(t){return t})).then(t,(function(t){x("failed to asynchronously prepare wasm: "+t),at(t)}))}var r={a:pe};if(O||(et++,u.monitorRunDependencies&&u.monitorRunDependencies(et)),u.instantiateWasm)try{return u.instantiateWasm(r,t)}catch(t){return x("Module.instantiateWasm callback failed with error: "+t),!1}(M||"function"!=typeof WebAssembly.instantiateStreaming||it()||tt.startsWith("file://")||_||"function"!=typeof fetch?n(e):fetch(tt,{credentials:"same-origin"}).then((function(t){return WebAssembly.instantiateStreaming(t,r).then(e,(function(t){return x("wasm streaming compile failed: "+t),x("falling back to ArrayBuffer instantiation"),n(e)}))}))).catch(s)}(),u.___wasm_call_ctors=function(){return(u.___wasm_call_ctors=u.asm.Va).apply(null,arguments)},u._OrtInit=function(){return(u._OrtInit=u.asm.Wa).apply(null,arguments)},u._OrtCreateSessionOptions=function(){return(u._OrtCreateSessionOptions=u.asm.Xa).apply(null,arguments)},u._OrtAppendExecutionProvider=function(){return(u._OrtAppendExecutionProvider=u.asm.Ya).apply(null,arguments)},u._OrtAddSessionConfigEntry=function(){return(u._OrtAddSessionConfigEntry=u.asm.Za).apply(null,arguments)},u._OrtReleaseSessionOptions=function(){return(u._OrtReleaseSessionOptions=u.asm._a).apply(null,arguments)},u._OrtCreateSession=function(){return(u._OrtCreateSession=u.asm.$a).apply(null,arguments)},u._OrtReleaseSession=function(){return(u._OrtReleaseSession=u.asm.ab).apply(null,arguments)},u._OrtGetInputCount=function(){return(u._OrtGetInputCount=u.asm.bb).apply(null,arguments)},u._OrtGetOutputCount=function(){return(u._OrtGetOutputCount=u.asm.cb).apply(null,arguments)},u._OrtGetInputName=function(){return(u._OrtGetInputName=u.asm.db).apply(null,arguments)},u._OrtGetOutputName=function(){return(u._OrtGetOutputName=u.asm.eb).apply(null,arguments)},u._OrtFree=function(){return(u._OrtFree=u.asm.fb).apply(null,arguments)},u._OrtCreateTensor=function(){return(u._OrtCreateTensor=u.asm.gb).apply(null,arguments)},u._OrtGetTensorData=function(){return(u._OrtGetTensorData=u.asm.hb).apply(null,arguments)},u._OrtReleaseTensor=function(){return(u._OrtReleaseTensor=u.asm.ib).apply(null,arguments)},u._OrtCreateRunOptions=function(){return(u._OrtCreateRunOptions=u.asm.jb).apply(null,arguments)},u._OrtAddRunConfigEntry=function(){return(u._OrtAddRunConfigEntry=u.asm.kb).apply(null,arguments)},u._OrtReleaseRunOptions=function(){return(u._OrtReleaseRunOptions=u.asm.lb).apply(null,arguments)},u._OrtRun=function(){return(u._OrtRun=u.asm.mb).apply(null,arguments)},u._OrtEndProfiling=function(){return(u._OrtEndProfiling=u.asm.nb).apply(null,arguments)};var he=u._pthread_self=function(){return(he=u._pthread_self=u.asm.ob).apply(null,arguments)},de=u._malloc=function(){return(de=u._malloc=u.asm.pb).apply(null,arguments)},ye=u._free=function(){return(ye=u._free=u.asm.qb).apply(null,arguments)},be=u._fflush=function(){return(be=u._fflush=u.asm.rb).apply(null,arguments)};u.__emscripten_tls_init=function(){return(u.__emscripten_tls_init=u.asm.sb).apply(null,arguments)};var me=u.___funcs_on_exit=function(){return(me=u.___funcs_on_exit=u.asm.tb).apply(null,arguments)},ge=u.__emscripten_thread_init=function(){return(ge=u.__emscripten_thread_init=u.asm.vb).apply(null,arguments)};u.__emscripten_thread_crashed=function(){return(u.__emscripten_thread_crashed=u.asm.wb).apply(null,arguments)};var ve,we=u._emscripten_run_in_main_runtime_thread_js=function(){return(we=u._emscripten_run_in_main_runtime_thread_js=u.asm.xb).apply(null,arguments)},_e=u.__emscripten_proxy_execute_task_queue=function(){return(_e=u.__emscripten_proxy_execute_task_queue=u.asm.yb).apply(null,arguments)},Oe=u.__emscripten_thread_free_data=function(){return(Oe=u.__emscripten_thread_free_data=u.asm.zb).apply(null,arguments)},Ae=u.__emscripten_thread_exit=function(){return(Ae=u.__emscripten_thread_exit=u.asm.Ab).apply(null,arguments)},Se=u._setThrew=function(){return(Se=u._setThrew=u.asm.Bb).apply(null,arguments)},Te=u._emscripten_stack_set_limits=function(){return(Te=u._emscripten_stack_set_limits=u.asm.Cb).apply(null,arguments)},Ee=u.stackSave=function(){return(Ee=u.stackSave=u.asm.Db).apply(null,arguments)},Me=u.stackRestore=function(){return(Me=u.stackRestore=u.asm.Eb).apply(null,arguments)},Ce=u.stackAlloc=function(){return(Ce=u.stackAlloc=u.asm.Fb).apply(null,arguments)},xe=u.___cxa_can_catch=function(){return(xe=u.___cxa_can_catch=u.asm.Gb).apply(null,arguments)},Re=u.___cxa_is_pointer_type=function(){return(Re=u.___cxa_is_pointer_type=u.asm.Hb).apply(null,arguments)},je=u.dynCall_j=function(){return(je=u.dynCall_j=u.asm.Ib).apply(null,arguments)},ke=u.dynCall_iiiiij=function(){return(ke=u.dynCall_iiiiij=u.asm.Jb).apply(null,arguments)},De=u.dynCall_jii=function(){return(De=u.dynCall_jii=u.asm.Kb).apply(null,arguments)},Pe=u.dynCall_viiiiij=function(){return(Pe=u.dynCall_viiiiij=u.asm.Lb).apply(null,arguments)},Ue=u.dynCall_vjji=function(){return(Ue=u.dynCall_vjji=u.asm.Mb).apply(null,arguments)},Fe=u.dynCall_viiijjjii=function(){return(Fe=u.dynCall_viiijjjii=u.asm.Nb).apply(null,arguments)},Ie=u.dynCall_iij=function(){return(Ie=u.dynCall_iij=u.asm.Ob).apply(null,arguments)},We=u.dynCall_ji=function(){return(We=u.dynCall_ji=u.asm.Pb).apply(null,arguments)},He=u.dynCall_iiiiiij=function(){return(He=u.dynCall_iiiiiij=u.asm.Qb).apply(null,arguments)},Le=u.dynCall_iiij=function(){return(Le=u.dynCall_iiij=u.asm.Rb).apply(null,arguments)};function ze(){function t(){if(!ve&&(ve=!0,u.calledRun=!0,!H)&&(O||dt(X),c(u),u.onRuntimeInitialized&&u.onRuntimeInitialized(),!O)){if(u.postRun)for("function"==typeof u.postRun&&(u.postRun=[u.postRun]);u.postRun.length;){var t=u.postRun.shift();Z.unshift(t)}dt(Z)}}if(!(0<et))if(O)c(u),O||dt(X),postMessage({cmd:"loaded"});else{if(u.preRun)for("function"==typeof u.preRun&&(u.preRun=[u.preRun]);u.preRun.length;)K();dt(q),0<et||(u.setStatus?(u.setStatus("Running..."),setTimeout((function(){setTimeout((function(){u.setStatus("")}),1),t()}),1)):t())}}if(u.UTF8ToString=Y,u.stringToUTF8=function(t,e,n){return B(t,r(),e,n)},u.lengthBytesUTF8=G,u.keepRuntimeAlive=Q,u.wasmMemory=j,u.stackSave=Ee,u.stackRestore=Me,u.stackAlloc=Ce,u.ExitStatus=ct,u.PThread=ht,rt=function t(){ve||ze(),ve||(rt=t)},u.preInit)for("function"==typeof u.preInit&&(u.preInit=[u.preInit]);0<u.preInit.length;)u.preInit.pop()();return ze(),t.ready});t.exports=r},932:(t,e,n)=>{var _scriptDir,r=(_scriptDir=(_scriptDir="undefined"!=typeof document&&document.currentScript?document.currentScript.src:void 0)||"/index.js",function(t){var e,r,a;t=t||{},e||(e=void 0!==t?t:{}),e.ready=new Promise((function(t,e){r=t,a=e}));var i,o,u,c,s,l,f=Object.assign({},e),p="./this.program",h=(t,e)=>{throw e},d="object"==typeof window,y="function"==typeof importScripts,b="object"==typeof process&&"object"==typeof process.versions&&"string"==typeof process.versions.node,m="";b?(m=y?n(908).dirname(m)+"/":"//",l=()=>{s||(c=n(384),s=n(908))},i=function(t,e){return l(),t=s.normalize(t),c.readFileSync(t,e?void 0:"utf8")},u=t=>((t=i(t,!0)).buffer||(t=new Uint8Array(t)),t),o=(t,e,n)=>{l(),t=s.normalize(t),c.readFile(t,(function(t,r){t?n(t):e(r.buffer)}))},1<process.argv.length&&(p=process.argv[1].replace(/\\\\/g,"/")),process.argv.slice(2),process.on("uncaughtException",(function(t){if(!(t instanceof J))throw t})),process.on("unhandledRejection",(function(t){throw t})),h=(t,e)=>{if(_||0<L)throw process.exitCode=t,e;e instanceof J||w("exiting due to exception: "+e),process.exit(t)},e.inspect=function(){return"[Emscripten Module object]"}):(d||y)&&(y?m=self.location.href:"undefined"!=typeof document&&document.currentScript&&(m=document.currentScript.src),_scriptDir&&(m=_scriptDir),m=0!==m.indexOf("blob:")?m.substr(0,m.replace(/[?#].*/,"").lastIndexOf("/")+1):"",i=t=>{var e=new XMLHttpRequest;return e.open("GET",t,!1),e.send(null),e.responseText},y&&(u=t=>{var e=new XMLHttpRequest;return e.open("GET",t,!1),e.responseType="arraybuffer",e.send(null),new Uint8Array(e.response)}),o=(t,e,n)=>{var r=new XMLHttpRequest;r.open("GET",t,!0),r.responseType="arraybuffer",r.onload=()=>{200==r.status||0==r.status&&r.response?e(r.response):n()},r.onerror=n,r.send(null)});var g,v=e.print||console.log.bind(console),w=e.printErr||console.warn.bind(console);Object.assign(e,f),f=null,e.thisProgram&&(p=e.thisProgram),e.quit&&(h=e.quit),e.wasmBinary&&(g=e.wasmBinary);var _=e.noExitRuntime||!1;"object"!=typeof WebAssembly&&V("no native wasm support detected");var O,A,S,T,E,M,C=!1,x="undefined"!=typeof TextDecoder?new TextDecoder("utf8"):void 0;function R(t,e,n){var r=(e>>>=0)+n;for(n=e;t[n]&&!(n>=r);)++n;if(16<n-e&&t.buffer&&x)return x.decode(t.subarray(e,n));for(r="";e<n;){var a=t[e++];if(128&a){var i=63&t[e++];if(192==(224&a))r+=String.fromCharCode((31&a)<<6|i);else{var o=63&t[e++];65536>(a=224==(240&a)?(15&a)<<12|i<<6|o:(7&a)<<18|i<<12|o<<6|63&t[e++])?r+=String.fromCharCode(a):(a-=65536,r+=String.fromCharCode(55296|a>>10,56320|1023&a))}}else r+=String.fromCharCode(a)}return r}function j(t,e){return(t>>>=0)?R(T,t,e):""}function k(t,e,n,r){if(!(0<r))return 0;var a=n>>>=0;r=n+r-1;for(var i=0;i<t.length;++i){var o=t.charCodeAt(i);if(55296<=o&&57343>=o&&(o=65536+((1023&o)<<10)|1023&t.charCodeAt(++i)),127>=o){if(n>=r)break;e[n++>>>0]=o}else{if(2047>=o){if(n+1>=r)break;e[n++>>>0]=192|o>>6}else{if(65535>=o){if(n+2>=r)break;e[n++>>>0]=224|o>>12}else{if(n+3>=r)break;e[n++>>>0]=240|o>>18,e[n++>>>0]=128|o>>12&63}e[n++>>>0]=128|o>>6&63}e[n++>>>0]=128|63&o}}return e[n>>>0]=0,n-a}function D(t){for(var e=0,n=0;n<t.length;++n){var r=t.charCodeAt(n);127>=r?e++:2047>=r?e+=2:55296<=r&&57343>=r?(e+=4,++n):e+=3}return e}function P(){var t=O.buffer;A=t,e.HEAP8=S=new Int8Array(t),e.HEAP16=new Int16Array(t),e.HEAP32=E=new Int32Array(t),e.HEAPU8=T=new Uint8Array(t),e.HEAPU16=new Uint16Array(t),e.HEAPU32=M=new Uint32Array(t),e.HEAPF32=new Float32Array(t),e.HEAPF64=new Float64Array(t)}var U,F=[],I=[],W=[],H=[],L=0;function z(){var t=e.preRun.shift();F.unshift(t)}var Y,B=0,G=null,N=null;function V(t){throw e.onAbort&&e.onAbort(t),w(t="Aborted("+t+")"),C=!0,t=new WebAssembly.RuntimeError(t+". Build with -sASSERTIONS for more info."),a(t),t}function $(){return Y.startsWith("data:application/octet-stream;base64,")}if(Y="ort-wasm.wasm",!$()){var q=Y;Y=e.locateFile?e.locateFile(q,m):m+q}function X(){var t=Y;try{if(t==Y&&g)return new Uint8Array(g);if(u)return u(t);throw"both async and sync fetching of the wasm failed"}catch(t){V(t)}}function J(t){this.name="ExitStatus",this.message="Program terminated with exit("+t+")",this.status=t}function Z(t){for(;0<t.length;)t.shift()(e)}var Q=[],K=0,tt=0;function et(t){this.Db=t,this.zb=t-24,this.Ub=function(t){M[this.zb+4>>2>>>0]=t},this.Eb=function(){return M[this.zb+4>>2>>>0]},this.Sb=function(t){M[this.zb+8>>2>>>0]=t},this.Wb=function(){return M[this.zb+8>>2>>>0]},this.Tb=function(){E[this.zb>>2>>>0]=0},this.Ib=function(t){S[this.zb+12>>0>>>0]=t?1:0},this.Pb=function(){return 0!=S[this.zb+12>>0>>>0]},this.Jb=function(t){S[this.zb+13>>0>>>0]=t?1:0},this.Lb=function(){return 0!=S[this.zb+13>>0>>>0]},this.Rb=function(t,e){this.Fb(0),this.Ub(t),this.Sb(e),this.Tb(),this.Ib(!1),this.Jb(!1)},this.Nb=function(){E[this.zb>>2>>>0]+=1},this.Xb=function(){var t=E[this.zb>>2>>>0];return E[this.zb>>2>>>0]=t-1,1===t},this.Fb=function(t){M[this.zb+16>>2>>>0]=t},this.Ob=function(){return M[this.zb+16>>2>>>0]},this.Qb=function(){if(Mt(this.Eb()))return M[this.Db>>2>>>0];var t=this.Ob();return 0!==t?t:this.Db}}function nt(t){return vt(new et(t).zb)}var rt=[];function at(t){var e=rt[t];return e||(t>=rt.length&&(rt.length=t+1),rt[t]=e=U.get(t)),e}function it(t){var e=D(t)+1,n=gt(e);return n&&k(t,S,n,e),n}var ot={};function ut(){if(!ct){var t,e={USER:"web_user",LOGNAME:"web_user",PATH:"/",PWD:"/",HOME:"/home/web_user",LANG:("object"==typeof navigator&&navigator.languages&&navigator.languages[0]||"C").replace("-","_")+".UTF-8",_:p||"./this.program"};for(t in ot)void 0===ot[t]?delete e[t]:e[t]=ot[t];var n=[];for(t in e)n.push(t+"="+e[t]);ct=n}return ct}var ct,st=[null,[],[]];function lt(t,e){var n=st[t];0===e||10===e?((1===t?v:w)(R(n,0)),n.length=0):n.push(e)}var ft=0;function pt(t){return 0==t%4&&(0!=t%100||0==t%400)}var ht=[31,29,31,30,31,30,31,31,30,31,30,31],dt=[31,28,31,30,31,30,31,31,30,31,30,31];function yt(t,e,n,r){function a(t,e,n){for(t="number"==typeof t?t.toString():t||"";t.length<e;)t=n[0]+t;return t}function i(t,e){return a(t,e,"0")}function o(t,e){function n(t){return 0>t?-1:0<t?1:0}var r;return 0===(r=n(t.getFullYear()-e.getFullYear()))&&0===(r=n(t.getMonth()-e.getMonth()))&&(r=n(t.getDate()-e.getDate())),r}function u(t){switch(t.getDay()){case 0:return new Date(t.getFullYear()-1,11,29);case 1:return t;case 2:return new Date(t.getFullYear(),0,3);case 3:return new Date(t.getFullYear(),0,2);case 4:return new Date(t.getFullYear(),0,1);case 5:return new Date(t.getFullYear()-1,11,31);case 6:return new Date(t.getFullYear()-1,11,30)}}function c(t){var e=t.Bb;for(t=new Date(new Date(t.Cb+1900,0,1).getTime());0<e;){var n=t.getMonth(),r=(pt(t.getFullYear())?ht:dt)[n];if(!(e>r-t.getDate())){t.setDate(t.getDate()+e);break}e-=r-t.getDate()+1,t.setDate(1),11>n?t.setMonth(n+1):(t.setMonth(0),t.setFullYear(t.getFullYear()+1))}return n=new Date(t.getFullYear()+1,0,4),e=u(new Date(t.getFullYear(),0,4)),n=u(n),0>=o(e,t)?0>=o(n,t)?t.getFullYear()+1:t.getFullYear():t.getFullYear()-1}var s=E[r+40>>2>>>0];for(var l in r={$b:E[r>>2>>>0],Zb:E[r+4>>2>>>0],Gb:E[r+8>>2>>>0],Kb:E[r+12>>2>>>0],Hb:E[r+16>>2>>>0],Cb:E[r+20>>2>>>0],Ab:E[r+24>>2>>>0],Bb:E[r+28>>2>>>0],bc:E[r+32>>2>>>0],Yb:E[r+36>>2>>>0],ac:s?j(s):""},n=j(n),s={"%c":"%a %b %d %H:%M:%S %Y","%D":"%m/%d/%y","%F":"%Y-%m-%d","%h":"%b","%r":"%I:%M:%S %p","%R":"%H:%M","%T":"%H:%M:%S","%x":"%m/%d/%y","%X":"%H:%M:%S","%Ec":"%c","%EC":"%C","%Ex":"%m/%d/%y","%EX":"%H:%M:%S","%Ey":"%y","%EY":"%Y","%Od":"%d","%Oe":"%e","%OH":"%H","%OI":"%I","%Om":"%m","%OM":"%M","%OS":"%S","%Ou":"%u","%OU":"%U","%OV":"%V","%Ow":"%w","%OW":"%W","%Oy":"%y"})n=n.replace(new RegExp(l,"g"),s[l]);var f="Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),p="January February March April May June July August September October November December".split(" ");for(l in s={"%a":function(t){return f[t.Ab].substring(0,3)},"%A":function(t){return f[t.Ab]},"%b":function(t){return p[t.Hb].substring(0,3)},"%B":function(t){return p[t.Hb]},"%C":function(t){return i((t.Cb+1900)/100|0,2)},"%d":function(t){return i(t.Kb,2)},"%e":function(t){return a(t.Kb,2," ")},"%g":function(t){return c(t).toString().substring(2)},"%G":function(t){return c(t)},"%H":function(t){return i(t.Gb,2)},"%I":function(t){return 0==(t=t.Gb)?t=12:12<t&&(t-=12),i(t,2)},"%j":function(t){for(var e=0,n=0;n<=t.Hb-1;e+=(pt(t.Cb+1900)?ht:dt)[n++]);return i(t.Kb+e,3)},"%m":function(t){return i(t.Hb+1,2)},"%M":function(t){return i(t.Zb,2)},"%n":function(){return"\\n"},"%p":function(t){return 0<=t.Gb&&12>t.Gb?"AM":"PM"},"%S":function(t){return i(t.$b,2)},"%t":function(){return"\\t"},"%u":function(t){return t.Ab||7},"%U":function(t){return i(Math.floor((t.Bb+7-t.Ab)/7),2)},"%V":function(t){var e=Math.floor((t.Bb+7-(t.Ab+6)%7)/7);if(2>=(t.Ab+371-t.Bb-2)%7&&e++,e)53==e&&(4==(n=(t.Ab+371-t.Bb)%7)||3==n&&pt(t.Cb)||(e=1));else{e=52;var n=(t.Ab+7-t.Bb-1)%7;(4==n||5==n&&pt(t.Cb%400-1))&&e++}return i(e,2)},"%w":function(t){return t.Ab},"%W":function(t){return i(Math.floor((t.Bb+7-(t.Ab+6)%7)/7),2)},"%y":function(t){return(t.Cb+1900).toString().substring(2)},"%Y":function(t){return t.Cb+1900},"%z":function(t){var e=0<=(t=t.Yb);return t=Math.abs(t)/60,(e?"+":"-")+String("0000"+(t/60*100+t%60)).slice(-4)},"%Z":function(t){return t.ac},"%%":function(){return"%"}},n=n.replace(/%%/g,"\\0\\0"),s)n.includes(l)&&(n=n.replace(new RegExp(l,"g"),s[l](r)));return l=function(t){var e=Array(D(t)+1);return k(t,e,0,e.length),e}(n=n.replace(/\\0\\0/g,"%")),l.length>e?0:(S.set(l,t>>>0),l.length-1)}var bt={a:function(t){return gt(t+24)+24},m:function(t){return(t=new et(t)).Pb()||(t.Ib(!0),K--),t.Jb(!1),Q.push(t),t.Nb(),t.Qb()},ia:function(t){throw w("Unexpected exception thrown, this is not properly supported - aborting"),C=!0,t},w:function(){Ot(0);var t=Q.pop();if(t.Xb()&&!t.Lb()){var e=t.Wb();e&&at(e)(t.Db),nt(t.Db)}tt=0},d:function(){var t=tt;if(!t)return ft=0;var e=new et(t);e.Fb(t);var n=e.Eb();if(!n)return ft=0,t;for(var r=Array.prototype.slice.call(arguments),a=0;a<r.length;a++){var i=r[a];if(0===i||i===n)break;if(Et(i,n,e.zb+16))return ft=i,t}return ft=n,t},k:function(){var t=tt;if(!t)return ft=0;var e=new et(t);e.Fb(t);var n=e.Eb();if(!n)return ft=0,t;for(var r=Array.prototype.slice.call(arguments),a=0;a<r.length;a++){var i=r[a];if(0===i||i===n)break;if(Et(i,n,e.zb+16))return ft=i,t}return ft=n,t},g:function(){var t=tt;if(!t)return ft=0;var e=new et(t);e.Fb(t);var n=e.Eb();if(!n)return ft=0,t;for(var r=Array.prototype.slice.call(arguments),a=0;a<r.length;a++){var i=r[a];if(0===i||i===n)break;if(Et(i,n,e.zb+16))return ft=i,t}return ft=n,t},s:nt,L:function(){var t=Q.pop();t||V("no exception to throw");var e=t.Db;throw t.Lb()||(Q.push(t),t.Jb(!0),t.Ib(!1),K++),tt=e,e},b:function(t,e,n){throw new et(t).Rb(e,n),tt=t,K++,t},la:function(){return K},i:function(t){throw tt||(tt=t),t},H:function(){return 0},Ba:function(){},pa:function(){},ra:function(){},ka:function(){return 0},za:function(){},ua:function(){},ya:function(){},R:function(){},qa:function(){},na:function(){},Aa:function(){},oa:function(){},Ha:function(){},Ja:function(){V("To use dlopen, you need enable dynamic linking, see https://github.com/emscripten-core/emscripten/wiki/Linking")},Ia:function(){V("To use dlopen, you need enable dynamic linking, see https://github.com/emscripten-core/emscripten/wiki/Linking")},S:function(){return Date.now()},Ca:function(){return!0},Da:function(t,e){t=new Date(1e3*(M[t>>>2]+4294967296*E[t+4>>>2])),E[e>>2>>>0]=t.getUTCSeconds(),E[e+4>>2>>>0]=t.getUTCMinutes(),E[e+8>>2>>>0]=t.getUTCHours(),E[e+12>>2>>>0]=t.getUTCDate(),E[e+16>>2>>>0]=t.getUTCMonth(),E[e+20>>2>>>0]=t.getUTCFullYear()-1900,E[e+24>>2>>>0]=t.getUTCDay(),E[e+28>>2>>>0]=(t.getTime()-Date.UTC(t.getUTCFullYear(),0,1,0,0,0,0))/864e5|0},Ea:function(t,e){t=new Date(1e3*(M[t>>>2]+4294967296*E[t+4>>>2])),E[e>>2>>>0]=t.getSeconds(),E[e+4>>2>>>0]=t.getMinutes(),E[e+8>>2>>>0]=t.getHours(),E[e+12>>2>>>0]=t.getDate(),E[e+16>>2>>>0]=t.getMonth(),E[e+20>>2>>>0]=t.getFullYear()-1900,E[e+24>>2>>>0]=t.getDay();var n=new Date(t.getFullYear(),0,1);E[e+28>>2>>>0]=(t.getTime()-n.getTime())/864e5|0,E[e+36>>2>>>0]=-60*t.getTimezoneOffset();var r=new Date(t.getFullYear(),6,1).getTimezoneOffset();n=n.getTimezoneOffset(),E[e+32>>2>>>0]=0|(r!=n&&t.getTimezoneOffset()==Math.min(n,r))},Fa:function(t){var e=new Date(E[t+20>>2>>>0]+1900,E[t+16>>2>>>0],E[t+12>>2>>>0],E[t+8>>2>>>0],E[t+4>>2>>>0],E[t>>2>>>0],0),n=E[t+32>>2>>>0],r=e.getTimezoneOffset(),a=new Date(e.getFullYear(),0,1),i=new Date(e.getFullYear(),6,1).getTimezoneOffset(),o=a.getTimezoneOffset(),u=Math.min(o,i);return 0>n?E[t+32>>2>>>0]=Number(i!=o&&u==r):0<n!=(u==r)&&(i=Math.max(o,i),e.setTime(e.getTime()+6e4*((0<n?u:i)-r))),E[t+24>>2>>>0]=e.getDay(),E[t+28>>2>>>0]=(e.getTime()-a.getTime())/864e5|0,E[t>>2>>>0]=e.getSeconds(),E[t+4>>2>>>0]=e.getMinutes(),E[t+8>>2>>>0]=e.getHours(),E[t+12>>2>>>0]=e.getDate(),E[t+16>>2>>>0]=e.getMonth(),e.getTime()/1e3|0},sa:function(){return-52},ta:function(){},Ga:function t(e,n,r){t.Vb||(t.Vb=!0,function(t,e,n){function r(t){return(t=t.toTimeString().match(/\\(([A-Za-z ]+)\\)$/))?t[1]:"GMT"}var a=(new Date).getFullYear(),i=new Date(a,0,1),o=new Date(a,6,1);a=i.getTimezoneOffset();var u=o.getTimezoneOffset();E[t>>2>>>0]=60*Math.max(a,u),E[e>>2>>>0]=Number(a!=u),t=r(i),e=r(o),t=it(t),e=it(e),u<a?(M[n>>2>>>0]=t,M[n+4>>2>>>0]=e):(M[n>>2>>>0]=e,M[n+4>>2>>>0]=t)}(e,n,r))},B:function(){V("")},ma:function(){return 4294901760},I:b?()=>{var t=process.hrtime();return 1e3*t[0]+t[1]/1e6}:()=>performance.now(),xa:function(t,e,n){T.copyWithin(t>>>0,e>>>0,e+n>>>0)},G:function(t){var e=T.length;if(4294901760<(t>>>=0))return!1;for(var n=1;4>=n;n*=2){var r=e*(1+.2/n);r=Math.min(r,t+100663296);var a=Math;r=Math.max(t,r),a=a.min.call(a,4294901760,r+(65536-r%65536)%65536);t:{try{O.grow(a-A.byteLength+65535>>>16),P();var i=1;break t}catch(t){}i=void 0}if(i)return!0}return!1},va:function(t,e){var n=0;return ut().forEach((function(r,a){var i=e+n;for(a=M[t+4*a>>2>>>0]=i,i=0;i<r.length;++i)S[a++>>0>>>0]=r.charCodeAt(i);S[a>>0>>>0]=0,n+=r.length+1})),0},wa:function(t,e){var n=ut();M[t>>2>>>0]=n.length;var r=0;return n.forEach((function(t){r+=t.length+1})),M[e>>2>>>0]=r,0},ba:function(t){_||0<L||(_t(),Z(W),wt(0),st[1].length&&lt(1,10),st[2].length&&lt(2,10)),_||0<L||(e.onExit&&e.onExit(t),C=!0),h(t,new J(t))},E:function(){return 52},Q:function(){return 52},ca:function(){return 70},P:function(t,e,n,r){for(var a=0,i=0;i<n;i++){var o=M[e>>2>>>0],u=M[e+4>>2>>>0];e+=8;for(var c=0;c<u;c++)lt(t,T[o+c>>>0]);a+=u}return M[r>>2>>>0]=a,0},c:function(){return ft},ja:function t(e,r){t.Mb||(t.Mb=function(){if("object"==typeof crypto&&"function"==typeof crypto.getRandomValues){var t=new Uint8Array(1);return()=>(crypto.getRandomValues(t),t[0])}if(b)try{var e=n(Object(function(){var t=new Error("Cannot find module \'crypto\'");throw t.code="MODULE_NOT_FOUND",t}()));return()=>e.randomBytes(1)[0]}catch(t){}return()=>V("randomDevice")}());for(var a=0;a<r;a++)S[e+a>>0>>>0]=t.Mb();return 0},ea:function(t,e,n){var r=At();try{return at(t)(e,n)}catch(t){if(St(r),t!==t+0)throw t;Ot(1,0)}},fa:function(t,e,n){var r=At();try{return at(t)(e,n)}catch(t){if(St(r),t!==t+0)throw t;Ot(1,0)}},J:function(t){var e=At();try{return at(t)()}catch(t){if(St(e),t!==t+0)throw t;Ot(1,0)}},e:function(t,e){var n=At();try{return at(t)(e)}catch(t){if(St(n),t!==t+0)throw t;Ot(1,0)}},N:function(t,e,n){var r=At();try{return at(t)(e,n)}catch(t){if(St(r),t!==t+0)throw t;Ot(1,0)}},O:function(t,e,n){var r=At();try{return at(t)(e,n)}catch(t){if(St(r),t!==t+0)throw t;Ot(1,0)}},j:function(t,e,n){var r=At();try{return at(t)(e,n)}catch(t){if(St(r),t!==t+0)throw t;Ot(1,0)}},o:function(t,e,n,r){var a=At();try{return at(t)(e,n,r)}catch(t){if(St(a),t!==t+0)throw t;Ot(1,0)}},p:function(t,e,n,r,a){var i=At();try{return at(t)(e,n,r,a)}catch(t){if(St(i),t!==t+0)throw t;Ot(1,0)}},M:function(t,e,n,r,a,i){var o=At();try{return at(t)(e,n,r,a,i)}catch(t){if(St(o),t!==t+0)throw t;Ot(1,0)}},r:function(t,e,n,r,a,i){var o=At();try{return at(t)(e,n,r,a,i)}catch(t){if(St(o),t!==t+0)throw t;Ot(1,0)}},v:function(t,e,n,r,a,i,o){var u=At();try{return at(t)(e,n,r,a,i,o)}catch(t){if(St(u),t!==t+0)throw t;Ot(1,0)}},K:function(t,e,n,r,a,i,o,u){var c=At();try{return at(t)(e,n,r,a,i,o,u)}catch(t){if(St(c),t!==t+0)throw t;Ot(1,0)}},D:function(t,e,n,r,a,i,o,u,c,s,l,f){var p=At();try{return at(t)(e,n,r,a,i,o,u,c,s,l,f)}catch(t){if(St(p),t!==t+0)throw t;Ot(1,0)}},X:function(t,e,n,r,a,i,o,u){var c=At();try{return Ft(t,e,n,r,a,i,o,u)}catch(t){if(St(c),t!==t+0)throw t;Ot(1,0)}},V:function(t,e,n,r,a,i,o){var u=At();try{return xt(t,e,n,r,a,i,o)}catch(t){if(St(u),t!==t+0)throw t;Ot(1,0)}},U:function(t,e,n,r,a){var i=At();try{return It(t,e,n,r,a)}catch(t){if(St(i),t!==t+0)throw t;Ot(1,0)}},Z:function(t,e,n,r){var a=At();try{return Pt(t,e,n,r)}catch(t){if(St(a),t!==t+0)throw t;Ot(1,0)}},W:function(t){var e=At();try{return Ct(t)}catch(t){if(St(e),t!==t+0)throw t;Ot(1,0)}},Y:function(t,e){var n=At();try{return Ut(t,e)}catch(t){if(St(n),t!==t+0)throw t;Ot(1,0)}},T:function(t,e,n){var r=At();try{return Rt(t,e,n)}catch(t){if(St(r),t!==t+0)throw t;Ot(1,0)}},f:function(t){var e=At();try{at(t)()}catch(t){if(St(e),t!==t+0)throw t;Ot(1,0)}},q:function(t,e){var n=At();try{at(t)(e)}catch(t){if(St(n),t!==t+0)throw t;Ot(1,0)}},h:function(t,e,n){var r=At();try{at(t)(e,n)}catch(t){if(St(r),t!==t+0)throw t;Ot(1,0)}},da:function(t,e,n,r){var a=At();try{at(t)(e,n,r)}catch(t){if(St(a),t!==t+0)throw t;Ot(1,0)}},l:function(t,e,n,r){var a=At();try{at(t)(e,n,r)}catch(t){if(St(a),t!==t+0)throw t;Ot(1,0)}},t:function(t,e,n,r,a){var i=At();try{at(t)(e,n,r,a)}catch(t){if(St(i),t!==t+0)throw t;Ot(1,0)}},u:function(t,e,n,r,a,i){var o=At();try{at(t)(e,n,r,a,i)}catch(t){if(St(o),t!==t+0)throw t;Ot(1,0)}},x:function(t,e,n,r,a,i,o){var u=At();try{at(t)(e,n,r,a,i,o)}catch(t){if(St(u),t!==t+0)throw t;Ot(1,0)}},z:function(t,e,n,r,a,i,o,u){var c=At();try{at(t)(e,n,r,a,i,o,u)}catch(t){if(St(c),t!==t+0)throw t;Ot(1,0)}},ga:function(t,e,n,r,a,i,o,u,c){var s=At();try{at(t)(e,n,r,a,i,o,u,c)}catch(t){if(St(s),t!==t+0)throw t;Ot(1,0)}},A:function(t,e,n,r,a,i,o,u,c,s,l){var f=At();try{at(t)(e,n,r,a,i,o,u,c,s,l)}catch(t){if(St(f),t!==t+0)throw t;Ot(1,0)}},C:function(t,e,n,r,a,i,o,u,c,s,l,f,p,h,d,y){var b=At();try{at(t)(e,n,r,a,i,o,u,c,s,l,f,p,h,d,y)}catch(t){if(St(b),t!==t+0)throw t;Ot(1,0)}},aa:function(t,e,n,r,a,i,o,u){var c=At();try{jt(t,e,n,r,a,i,o,u)}catch(t){if(St(c),t!==t+0)throw t;Ot(1,0)}},_:function(t,e,n,r,a,i,o,u,c,s,l,f){var p=At();try{Dt(t,e,n,r,a,i,o,u,c,s,l,f)}catch(t){if(St(p),t!==t+0)throw t;Ot(1,0)}},$:function(t,e,n,r,a,i){var o=At();try{kt(t,e,n,r,a,i)}catch(t){if(St(o),t!==t+0)throw t;Ot(1,0)}},n:function(t){return t},F:function(t){ft=t},ha:yt,y:function(t,e,n,r){return yt(t,e,n,r)}};!function(){function t(t){e.asm=t.exports,O=e.asm.Ka,P(),U=e.asm.ib,I.unshift(e.asm.La),B--,e.monitorRunDependencies&&e.monitorRunDependencies(B),0==B&&(null!==G&&(clearInterval(G),G=null),N&&(t=N,N=null,t()))}function n(e){t(e.instance)}function r(t){return function(){if(!g&&(d||y)){if("function"==typeof fetch&&!Y.startsWith("file://"))return fetch(Y,{credentials:"same-origin"}).then((function(t){if(!t.ok)throw"failed to load wasm binary file at \'"+Y+"\'";return t.arrayBuffer()})).catch((function(){return X()}));if(o)return new Promise((function(t,e){o(Y,(function(e){t(new Uint8Array(e))}),e)}))}return Promise.resolve().then((function(){return X()}))}().then((function(t){return WebAssembly.instantiate(t,i)})).then((function(t){return t})).then(t,(function(t){w("failed to asynchronously prepare wasm: "+t),V(t)}))}var i={a:bt};if(B++,e.monitorRunDependencies&&e.monitorRunDependencies(B),e.instantiateWasm)try{return e.instantiateWasm(i,t)}catch(t){return w("Module.instantiateWasm callback failed with error: "+t),!1}(g||"function"!=typeof WebAssembly.instantiateStreaming||$()||Y.startsWith("file://")||b||"function"!=typeof fetch?r(n):fetch(Y,{credentials:"same-origin"}).then((function(t){return WebAssembly.instantiateStreaming(t,i).then(n,(function(t){return w("wasm streaming compile failed: "+t),w("falling back to ArrayBuffer instantiation"),r(n)}))}))).catch(a)}(),e.___wasm_call_ctors=function(){return(e.___wasm_call_ctors=e.asm.La).apply(null,arguments)},e._OrtInit=function(){return(e._OrtInit=e.asm.Ma).apply(null,arguments)},e._OrtCreateSessionOptions=function(){return(e._OrtCreateSessionOptions=e.asm.Na).apply(null,arguments)},e._OrtAppendExecutionProvider=function(){return(e._OrtAppendExecutionProvider=e.asm.Oa).apply(null,arguments)},e._OrtAddSessionConfigEntry=function(){return(e._OrtAddSessionConfigEntry=e.asm.Pa).apply(null,arguments)},e._OrtReleaseSessionOptions=function(){return(e._OrtReleaseSessionOptions=e.asm.Qa).apply(null,arguments)},e._OrtCreateSession=function(){return(e._OrtCreateSession=e.asm.Ra).apply(null,arguments)},e._OrtReleaseSession=function(){return(e._OrtReleaseSession=e.asm.Sa).apply(null,arguments)},e._OrtGetInputCount=function(){return(e._OrtGetInputCount=e.asm.Ta).apply(null,arguments)},e._OrtGetOutputCount=function(){return(e._OrtGetOutputCount=e.asm.Ua).apply(null,arguments)},e._OrtGetInputName=function(){return(e._OrtGetInputName=e.asm.Va).apply(null,arguments)},e._OrtGetOutputName=function(){return(e._OrtGetOutputName=e.asm.Wa).apply(null,arguments)},e._OrtFree=function(){return(e._OrtFree=e.asm.Xa).apply(null,arguments)},e._OrtCreateTensor=function(){return(e._OrtCreateTensor=e.asm.Ya).apply(null,arguments)},e._OrtGetTensorData=function(){return(e._OrtGetTensorData=e.asm.Za).apply(null,arguments)},e._OrtReleaseTensor=function(){return(e._OrtReleaseTensor=e.asm._a).apply(null,arguments)},e._OrtCreateRunOptions=function(){return(e._OrtCreateRunOptions=e.asm.$a).apply(null,arguments)},e._OrtAddRunConfigEntry=function(){return(e._OrtAddRunConfigEntry=e.asm.ab).apply(null,arguments)},e._OrtReleaseRunOptions=function(){return(e._OrtReleaseRunOptions=e.asm.bb).apply(null,arguments)},e._OrtRun=function(){return(e._OrtRun=e.asm.cb).apply(null,arguments)},e._OrtEndProfiling=function(){return(e._OrtEndProfiling=e.asm.db).apply(null,arguments)};var mt,gt=e._malloc=function(){return(gt=e._malloc=e.asm.eb).apply(null,arguments)},vt=e._free=function(){return(vt=e._free=e.asm.fb).apply(null,arguments)},wt=e._fflush=function(){return(wt=e._fflush=e.asm.gb).apply(null,arguments)},_t=e.___funcs_on_exit=function(){return(_t=e.___funcs_on_exit=e.asm.hb).apply(null,arguments)},Ot=e._setThrew=function(){return(Ot=e._setThrew=e.asm.jb).apply(null,arguments)},At=e.stackSave=function(){return(At=e.stackSave=e.asm.kb).apply(null,arguments)},St=e.stackRestore=function(){return(St=e.stackRestore=e.asm.lb).apply(null,arguments)},Tt=e.stackAlloc=function(){return(Tt=e.stackAlloc=e.asm.mb).apply(null,arguments)},Et=e.___cxa_can_catch=function(){return(Et=e.___cxa_can_catch=e.asm.nb).apply(null,arguments)},Mt=e.___cxa_is_pointer_type=function(){return(Mt=e.___cxa_is_pointer_type=e.asm.ob).apply(null,arguments)},Ct=e.dynCall_j=function(){return(Ct=e.dynCall_j=e.asm.pb).apply(null,arguments)},xt=e.dynCall_iiiiij=function(){return(xt=e.dynCall_iiiiij=e.asm.qb).apply(null,arguments)},Rt=e.dynCall_jii=function(){return(Rt=e.dynCall_jii=e.asm.rb).apply(null,arguments)},jt=e.dynCall_viiiiij=function(){return(jt=e.dynCall_viiiiij=e.asm.sb).apply(null,arguments)},kt=e.dynCall_vjji=function(){return(kt=e.dynCall_vjji=e.asm.tb).apply(null,arguments)},Dt=e.dynCall_viiijjjii=function(){return(Dt=e.dynCall_viiijjjii=e.asm.ub).apply(null,arguments)},Pt=e.dynCall_iij=function(){return(Pt=e.dynCall_iij=e.asm.vb).apply(null,arguments)},Ut=e.dynCall_ji=function(){return(Ut=e.dynCall_ji=e.asm.wb).apply(null,arguments)},Ft=e.dynCall_iiiiiij=function(){return(Ft=e.dynCall_iiiiiij=e.asm.xb).apply(null,arguments)},It=e.dynCall_iiij=function(){return(It=e.dynCall_iiij=e.asm.yb).apply(null,arguments)};function Wt(){function t(){if(!mt&&(mt=!0,e.calledRun=!0,!C)){if(Z(I),r(e),e.onRuntimeInitialized&&e.onRuntimeInitialized(),e.postRun)for("function"==typeof e.postRun&&(e.postRun=[e.postRun]);e.postRun.length;){var t=e.postRun.shift();H.unshift(t)}Z(H)}}if(!(0<B)){if(e.preRun)for("function"==typeof e.preRun&&(e.preRun=[e.preRun]);e.preRun.length;)z();Z(F),0<B||(e.setStatus?(e.setStatus("Running..."),setTimeout((function(){setTimeout((function(){e.setStatus("")}),1),t()}),1)):t())}}if(e.UTF8ToString=j,e.stringToUTF8=function(t,e,n){return k(t,T,e,n)},e.lengthBytesUTF8=D,e.stackSave=At,e.stackRestore=St,e.stackAlloc=Tt,N=function t(){mt||Wt(),mt||(N=t)},e.preInit)for("function"==typeof e.preInit&&(e.preInit=[e.preInit]);0<e.preInit.length;)e.preInit.pop()();return Wt(),t.ready});t.exports=r},967:(t,e)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.iterateExtraOptions=void 0,e.iterateExtraOptions=(t,n,r,a)=>{if("object"==typeof t&&null!==t){if(r.has(t))throw new Error("Circular reference in options");r.add(t)}Object.entries(t).forEach((([t,i])=>{const o=n?n+t:t;if("object"==typeof i)(0,e.iterateExtraOptions)(i,o+".",r,a);else if("string"==typeof i||"number"==typeof i)a(o,i.toString());else{if("boolean"!=typeof i)throw new Error("Can\'t handle extra config type: "+typeof i);a(o,i?"1":"0")}}))}},586:(t,e,n)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.setRunOptions=void 0;const r=n(967),a=n(983),i=n(361);e.setRunOptions=t=>{const e=(0,i.getInstance)();let n=0;const o=[],u=t||{};try{if(void 0===(null==t?void 0:t.logSeverityLevel))u.logSeverityLevel=2;else if("number"!=typeof t.logSeverityLevel||!Number.isInteger(t.logSeverityLevel)||t.logSeverityLevel<0||t.logSeverityLevel>4)throw new Error(`log serverity level is not valid: ${t.logSeverityLevel}`);if(void 0===(null==t?void 0:t.logVerbosityLevel))u.logVerbosityLevel=0;else if("number"!=typeof t.logVerbosityLevel||!Number.isInteger(t.logVerbosityLevel))throw new Error(`log verbosity level is not valid: ${t.logVerbosityLevel}`);void 0===(null==t?void 0:t.terminate)&&(u.terminate=!1);let i=0;if(void 0!==(null==t?void 0:t.tag)&&(i=(0,a.allocWasmString)(t.tag,o)),n=e._OrtCreateRunOptions(u.logSeverityLevel,u.logVerbosityLevel,!!u.terminate,i),0===n)throw new Error("Can\'t create run options");return void 0!==(null==t?void 0:t.extra)&&(0,r.iterateExtraOptions)(t.extra,"",new WeakSet,((t,r)=>{const i=(0,a.allocWasmString)(t,o),u=(0,a.allocWasmString)(r,o);if(0!==e._OrtAddRunConfigEntry(n,i,u))throw new Error(`Can\'t set a run config entry: ${t} - ${r}`)})),[n,o]}catch(t){throw 0!==n&&e._OrtReleaseRunOptions(n),o.forEach(e._free),t}}},919:(t,e,n)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.setSessionOptions=void 0;const r=n(967),a=n(983),i=n(361);e.setSessionOptions=t=>{const e=(0,i.getInstance)();let n=0;const o=[],u=t||{};(t=>{t.extra||(t.extra={}),t.extra.session||(t.extra.session={});const e=t.extra.session;e.use_ort_model_bytes_directly||(e.use_ort_model_bytes_directly="1")})(u);try{void 0===(null==t?void 0:t.graphOptimizationLevel)&&(u.graphOptimizationLevel="all");const c=(t=>{switch(t){case"disabled":return 0;case"basic":return 1;case"extended":return 2;case"all":return 99;default:throw new Error(`unsupported graph optimization level: ${t}`)}})(u.graphOptimizationLevel);void 0===(null==t?void 0:t.enableCpuMemArena)&&(u.enableCpuMemArena=!0),void 0===(null==t?void 0:t.enableMemPattern)&&(u.enableMemPattern=!0),void 0===(null==t?void 0:t.executionMode)&&(u.executionMode="sequential");const s=(t=>{switch(t){case"sequential":return 0;case"parallel":return 1;default:throw new Error(`unsupported execution mode: ${t}`)}})(u.executionMode);let l=0;if(void 0!==(null==t?void 0:t.logId)&&(l=(0,a.allocWasmString)(t.logId,o)),void 0===(null==t?void 0:t.logSeverityLevel))u.logSeverityLevel=2;else if("number"!=typeof t.logSeverityLevel||!Number.isInteger(t.logSeverityLevel)||t.logSeverityLevel<0||t.logSeverityLevel>4)throw new Error(`log serverity level is not valid: ${t.logSeverityLevel}`);if(void 0===(null==t?void 0:t.logVerbosityLevel))u.logVerbosityLevel=0;else if("number"!=typeof t.logVerbosityLevel||!Number.isInteger(t.logVerbosityLevel))throw new Error(`log verbosity level is not valid: ${t.logVerbosityLevel}`);if(void 0===(null==t?void 0:t.enableProfiling)&&(u.enableProfiling=!1),n=e._OrtCreateSessionOptions(c,!!u.enableCpuMemArena,!!u.enableMemPattern,s,!!u.enableProfiling,0,l,u.logSeverityLevel,u.logVerbosityLevel),0===n)throw new Error("Can\'t create session options");return(null==t?void 0:t.executionProviders)&&((t,e,n)=>{for(const r of e){let e="string"==typeof r?r:r.name;switch(e){case"xnnpack":e="XNNPACK";break;case"wasm":case"cpu":continue;default:throw new Error(`not supported EP: ${e}`)}const o=(0,a.allocWasmString)(e,n);if(0!==(0,i.getInstance)()._OrtAppendExecutionProvider(t,o))throw new Error(`Can\'t append execution provider: ${e}`)}})(n,t.executionProviders,o),void 0!==(null==t?void 0:t.extra)&&(0,r.iterateExtraOptions)(t.extra,"",new WeakSet,((t,r)=>{const i=(0,a.allocWasmString)(t,o),u=(0,a.allocWasmString)(r,o);if(0!==e._OrtAddSessionConfigEntry(n,i,u))throw new Error(`Can\'t set a session config entry: ${t} - ${r}`)})),[n,o]}catch(t){throw 0!==n&&e._OrtReleaseSessionOptions(n),o.forEach(e._free),t}}},983:(t,e,n)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.allocWasmString=void 0;const r=n(361);e.allocWasmString=(t,e)=>{const n=(0,r.getInstance)(),a=n.lengthBytesUTF8(t)+1,i=n._malloc(a);return n.stringToUTF8(t,i,a),e.push(i),i}},349:(t,e,n)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.extractTransferableBuffers=e.endProfiling=e.run=e.releaseSession=e.createSession=e.createSessionFinalize=e.createSessionAllocate=e.initOrt=void 0;const r=n(586),a=n(919),i=n(983),o=n(361);e.initOrt=(t,e)=>{const n=(0,o.getInstance)()._OrtInit(t,e);if(0!==n)throw new Error(`Can\'t initialize onnxruntime. error code = ${n}`)};const u=new Map;e.createSessionAllocate=t=>{const e=(0,o.getInstance)(),n=e._malloc(t.byteLength);return e.HEAPU8.set(t,n),[n,t.byteLength]},e.createSessionFinalize=(t,e)=>{const n=(0,o.getInstance)();let r=0,i=0,c=[];try{if([i,c]=(0,a.setSessionOptions)(e),r=n._OrtCreateSession(t[0],t[1],i),0===r)throw new Error("Can\'t create a session")}finally{n._free(t[0]),n._OrtReleaseSessionOptions(i),c.forEach(n._free)}const s=n._OrtGetInputCount(r),l=n._OrtGetOutputCount(r),f=[],p=[],h=[],d=[];for(let t=0;t<s;t++){const e=n._OrtGetInputName(r,t);if(0===e)throw new Error("Can\'t get an input name");p.push(e),f.push(n.UTF8ToString(e))}for(let t=0;t<l;t++){const e=n._OrtGetOutputName(r,t);if(0===e)throw new Error("Can\'t get an output name");d.push(e),h.push(n.UTF8ToString(e))}return u.set(r,[r,p,d]),[r,f,h]},e.createSession=(t,n)=>{const r=(0,e.createSessionAllocate)(t);return(0,e.createSessionFinalize)(r,n)},e.releaseSession=t=>{const e=(0,o.getInstance)(),n=u.get(t);if(!n)throw new Error("invalid session id");const r=n[0],a=n[1],i=n[2];a.forEach(e._OrtFree),i.forEach(e._OrtFree),e._OrtReleaseSession(r),u.delete(t)};const c=t=>{switch(t){case"int8":return 3;case"uint8":return 2;case"bool":return 9;case"int16":return 5;case"uint16":return 4;case"int32":return 6;case"uint32":return 12;case"float32":return 1;case"float64":return 11;case"string":return 8;case"int64":return 7;case"uint64":return 13;default:throw new Error(`unsupported data type: ${t}`)}},s=t=>{switch(t){case 3:return"int8";case 2:return"uint8";case 9:return"bool";case 5:return"int16";case 4:return"uint16";case 6:return"int32";case 12:return"uint32";case 1:return"float32";case 11:return"float64";case 8:return"string";case 7:return"int64";case 13:return"uint64";default:throw new Error(`unsupported data type: ${t}`)}},l=t=>{switch(t){case"float32":return Float32Array;case"uint8":case"bool":return Uint8Array;case"int8":return Int8Array;case"uint16":return Uint16Array;case"int16":return Int16Array;case"int32":return Int32Array;case"float64":return Float64Array;case"uint32":return Uint32Array;case"int64":return BigInt64Array;case"uint64":return BigUint64Array;default:throw new Error(`unsupported type: ${t}`)}};e.run=(t,e,n,a,f)=>{const p=(0,o.getInstance)(),h=u.get(t);if(!h)throw new Error("invalid session id");const d=h[0],y=h[1],b=h[2],m=e.length,g=a.length;let v=0,w=[];const _=[],O=[];try{[v,w]=(0,r.setRunOptions)(f);for(let t=0;t<m;t++){const e=n[t][0],r=n[t][1],a=n[t][2];let o,u;if(Array.isArray(a)){u=4*a.length,o=p._malloc(u),O.push(o);let t=o/4;for(let e=0;e<a.length;e++){if("string"!=typeof a[e])throw new TypeError(`tensor data at index ${e} is not a string`);p.HEAPU32[t++]=(0,i.allocWasmString)(a[e],O)}}else u=a.byteLength,o=p._malloc(u),O.push(o),p.HEAPU8.set(new Uint8Array(a.buffer,a.byteOffset,u),o);const s=p.stackSave(),l=p.stackAlloc(4*r.length);try{let t=l/4;r.forEach((e=>p.HEAP32[t++]=e));const n=p._OrtCreateTensor(c(e),o,u,l,r.length);if(0===n)throw new Error("Can\'t create a tensor");_.push(n)}finally{p.stackRestore(s)}}const t=p.stackSave(),o=p.stackAlloc(4*m),u=p.stackAlloc(4*m),h=p.stackAlloc(4*g),A=p.stackAlloc(4*g);try{let n=o/4,r=u/4,i=h/4,c=A/4;for(let t=0;t<m;t++)p.HEAPU32[n++]=_[t],p.HEAPU32[r++]=y[e[t]];for(let t=0;t<g;t++)p.HEAPU32[i++]=0,p.HEAPU32[c++]=b[a[t]];let f=p._OrtRun(d,u,o,m,A,g,h,v);const w=[];if(0===f)for(let t=0;t<g;t++){const e=p.HEAPU32[h/4+t],n=p.stackSave(),r=p.stackAlloc(16);let a,i=0;try{if(f=p._OrtGetTensorData(e,r,r+4,r+8,r+12),0!==f)throw new Error(`Can\'t access output tensor data. error code = ${f}`);let t=r/4;const o=p.HEAPU32[t++];i=p.HEAPU32[t++];const u=p.HEAPU32[t++],c=p.HEAPU32[t++],h=[];for(let t=0;t<c;t++)h.push(p.HEAPU32[u/4+t]);p._OrtFree(u);const d=0===h.length?1:h.reduce(((t,e)=>t*e));if(a=s(o),"string"===a){const t=[];let e=i/4;for(let n=0;n<d;n++){const r=p.HEAPU32[e++],a=n===d-1?void 0:p.HEAPU32[e]-r;t.push(p.UTF8ToString(r,a))}w.push([a,h,t])}else{const t=new(l(a))(d);new Uint8Array(t.buffer,t.byteOffset,t.byteLength).set(p.HEAPU8.subarray(i,i+t.byteLength)),w.push([a,h,t])}}finally{p.stackRestore(n),"string"===a&&i&&p._free(i),p._OrtReleaseTensor(e)}}if(0===f)return w;throw new Error(`failed to call OrtRun(). error code = ${f}.`)}finally{p.stackRestore(t)}}finally{_.forEach(p._OrtReleaseTensor),O.forEach(p._free),p._OrtReleaseRunOptions(v),w.forEach(p._free)}},e.endProfiling=t=>{const e=(0,o.getInstance)(),n=u.get(t);if(!n)throw new Error("invalid session id");const r=n[0],a=e._OrtEndProfiling(r);if(0===a)throw new Error("Can\'t get an profile file name");e._OrtFree(a)},e.extractTransferableBuffers=t=>{const e=[];for(const n of t){const t=n[2];!Array.isArray(t)&&t.buffer&&e.push(t.buffer)}return e}},361:function(t,e,n){"use strict";var r=this&&this.__createBinding||(Object.create?function(t,e,n,r){void 0===r&&(r=n);var a=Object.getOwnPropertyDescriptor(e,n);a&&!("get"in a?!e.__esModule:a.writable||a.configurable)||(a={enumerable:!0,get:function(){return e[n]}}),Object.defineProperty(t,r,a)}:function(t,e,n,r){void 0===r&&(r=n),t[r]=e[n]}),a=this&&this.__setModuleDefault||(Object.create?function(t,e){Object.defineProperty(t,"default",{enumerable:!0,value:e})}:function(t,e){t.default=e}),i=this&&this.__importStar||function(t){if(t&&t.__esModule)return t;var e={};if(null!=t)for(var n in t)"default"!==n&&Object.prototype.hasOwnProperty.call(t,n)&&r(e,t,n);return a(e,t),e},o=this&&this.__importDefault||function(t){return t&&t.__esModule?t:{default:t}};Object.defineProperty(e,"__esModule",{value:!0}),e.dispose=e.getInstance=e.initializeWebAssembly=void 0;const u=i(n(449)),c=o(n(932)),s=n(474);let l,f=!1,p=!1,h=!1;const d=(t,e)=>e?t?"ort-wasm-simd-threaded.wasm":"ort-wasm-threaded.wasm":t?"ort-wasm-simd.wasm":"ort-wasm.wasm";e.initializeWebAssembly=async t=>{if(f)return Promise.resolve();if(p)throw new Error("multiple calls to \'initializeWebAssembly()\' detected.");if(h)throw new Error("previous call to \'initializeWebAssembly()\' failed.");p=!0;const e=t.initTimeout,r=t.numThreads,a=t.simd,i=r>1&&(()=>{try{return"undefined"!=typeof SharedArrayBuffer&&("undefined"!=typeof MessageChannel&&(new MessageChannel).port1.postMessage(new SharedArrayBuffer(1)),WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,5,4,1,3,1,1,10,11,1,9,0,65,0,254,16,2,0,26,11])))}catch(t){return!1}})(),o=a&&(()=>{try{return WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,30,1,28,0,65,0,253,15,253,12,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,253,186,1,26,11]))}catch(t){return!1}})(),y="string"==typeof t.wasmPaths?t.wasmPaths:void 0,b=d(!1,i),m=d(o,i),g="object"==typeof t.wasmPaths?t.wasmPaths[m]:void 0;let v=!1;const w=[];if(e>0&&w.push(new Promise((t=>{setTimeout((()=>{v=!0,t()}),e)}))),w.push(new Promise(((t,e)=>{const r=i?s:c.default,a={locateFile:(t,e)=>i&&t.endsWith(".worker.js")&&"undefined"!=typeof Blob?URL.createObjectURL(new Blob([n(154)],{type:"text/javascript"})):t===b?null!=g?g:(null!=y?y:e)+m:e+t};if(i)if("undefined"==typeof Blob)a.mainScriptUrlOrBlob=u.join("/","ort-wasm-threaded.js");else{const t=`var ortWasmThreaded=(function(){var _scriptDir;return ${r.toString()}})();`;a.mainScriptUrlOrBlob=new Blob([t],{type:"text/javascript"})}r(a).then((e=>{p=!1,f=!0,l=e,t()}),(t=>{p=!1,h=!0,e(t)}))}))),await Promise.race(w),v)throw new Error(`WebAssembly backend initializing failed due to timeout: ${e}ms`)},e.getInstance=()=>{if(f&&l)return l;throw new Error("WebAssembly is not initialized yet.")},e.dispose=()=>{var t;!f||p||h||(p=!0,null===(t=l.PThread)||void 0===t||t.terminateAllThreads(),l=void 0,p=!1,f=!1,h=!0)}},154:t=>{"use strict";t.exports=\'"use strict";var e={},t="object"==typeof process&&"object"==typeof process.versions&&"string"==typeof process.versions.node;if(t){var r=require("worker_threads"),a=r.parentPort;a.on("message",(e=>onmessage({data:e})));var o=require("fs");Object.assign(global,{self:global,require:require,Module:e,location:{href:__filename},Worker:r.Worker,importScripts:function(e){(0,eval)(o.readFileSync(e,"utf8"))},postMessage:function(e){a.postMessage(e)},performance:global.performance||{now:function(){return Date.now()}}})}var s=!1,n=[],i=function(){var e=Array.prototype.slice.call(arguments).join(" ");t?o.writeSync(2,e+"\\\\n"):console.error(e)};self.alert=function(){var t=Array.prototype.slice.call(arguments).join(" ");postMessage({cmd:"alert",text:t,threadId:e._pthread_self()})},e.instantiateWasm=(t,r)=>{var a=new WebAssembly.Instance(e.wasmModule,t);return r(a),e.wasmModule=null,a.exports},self.onunhandledrejection=e=>{throw e.reason??e},self.onmessage=t=>{try{if("load"===t.data.cmd){if(e.wasmModule=t.data.wasmModule,e.wasmMemory=t.data.wasmMemory,e.buffer=e.wasmMemory.buffer,e.ENVIRONMENT_IS_PTHREAD=!0,"string"==typeof t.data.urlOrBlob)importScripts(t.data.urlOrBlob);else{var r=URL.createObjectURL(t.data.urlOrBlob);importScripts(r),URL.revokeObjectURL(r)}ortWasmThreaded(e).then((function(t){e=t}))}else if("run"===t.data.cmd){e.__performance_now_clock_drift=performance.now()-t.data.time,e.__emscripten_thread_init(t.data.pthread_ptr,0,0,1),e.establishStackSpace(),e.PThread.receiveObjectTransfer(t.data),e.PThread.threadInitTLS(),s||(n.forEach((t=>{e.executeNotifiedProxyingQueue(t)})),n=[],s=!0);try{e.invokeEntryPoint(t.data.start_routine,t.data.arg)}catch(t){if("unwind"!=t){if(!(t instanceof e.ExitStatus))throw t;e.keepRuntimeAlive()||e.__emscripten_thread_exit(t.status)}}}else"cancel"===t.data.cmd?e._pthread_self()&&e.__emscripten_thread_exit(-1):"setimmediate"===t.data.target||("processProxyingQueue"===t.data.cmd?s?e.executeNotifiedProxyingQueue(t.data.queue):n.push(t.data.queue):(i("worker.js received unknown command "+t.data.cmd),i(t.data)))}catch(t){throw i("worker.js onmessage() captured an uncaught exception: "+t),t&&t.stack&&i(t.stack),e.__emscripten_thread_crashed&&e.__emscripten_thread_crashed(),t}};\\n\'},384:()=>{},993:()=>{},908:()=>{},953:()=>{},925:()=>{},449:()=>{}},e={};function n(r){var a=e[r];if(void 0!==a)return a.exports;var i=e[r]={exports:{}};return t[r].call(i.exports,i,i.exports,n),i.exports}n.g=function(){if("object"==typeof globalThis)return globalThis;try{return this||new Function("return this")()}catch(t){if("object"==typeof window)return window}}(),(()=>{"use strict";const t=n(349),e=n(361);self.onmessage=n=>{switch(n.data.type){case"init-wasm":(0,e.initializeWebAssembly)(n.data.in).then((()=>postMessage({type:"init-wasm"})),(t=>postMessage({type:"init-wasm",err:t})));break;case"init-ort":try{const{numThreads:e,loggingLevel:r}=n.data.in;(0,t.initOrt)(e,r),postMessage({type:"init-ort"})}catch(t){postMessage({type:"init-ort",err:t})}break;case"create_allocate":try{const{model:e}=n.data.in,r=(0,t.createSessionAllocate)(e);postMessage({type:"create_allocate",out:r})}catch(t){postMessage({type:"create_allocate",err:t})}break;case"create_finalize":try{const{modeldata:e,options:r}=n.data.in,a=(0,t.createSessionFinalize)(e,r);postMessage({type:"create_finalize",out:a})}catch(t){postMessage({type:"create_finalize",err:t})}break;case"create":try{const{model:e,options:r}=n.data.in,a=(0,t.createSession)(e,r);postMessage({type:"create",out:a})}catch(t){postMessage({type:"create",err:t})}break;case"release":try{const e=n.data.in;(0,t.releaseSession)(e),postMessage({type:"release"})}catch(t){postMessage({type:"release",err:t})}break;case"run":try{const{sessionId:e,inputIndices:r,inputs:a,outputIndices:i,options:o}=n.data.in,u=(0,t.run)(e,r,a,i,o);postMessage({type:"run",out:u},(0,t.extractTransferableBuffers)(u))}catch(t){postMessage({type:"run",err:t})}break;case"end-profiling":try{const e=n.data.in;(0,t.endProfiling)(e),postMessage({type:"end-profiling"})}catch(t){postMessage({type:"end-profiling",err:t})}}}})()})();\n',"Worker",void 0,void 0)}},477:F=>{F.exports=function(w,D,O,U){var G=self||window;try{try{var q;try{q=new G.Blob([w])}catch{(q=new(G.BlobBuilder||G.WebKitBlobBuilder||G.MozBlobBuilder||G.MSBlobBuilder)).append(w),q=q.getBlob()}var K=G.URL||G.webkitURL,ee=K.createObjectURL(q),Z=new G[D](ee,O);return K.revokeObjectURL(ee),Z}catch{return new G[D]("data:application/javascript,".concat(encodeURIComponent(w)),O)}}catch{if(!U)throw Error("Inline worker is not supported");return new G[D](U,O)}}},4154:F=>{F.exports=`"use strict";var e={},t="object"==typeof process&&"object"==typeof process.versions&&"string"==typeof process.versions.node;if(t){var r=require("worker_threads"),a=r.parentPort;a.on("message",(e=>onmessage({data:e})));var o=require("fs");Object.assign(global,{self:global,require:require,Module:e,location:{href:__filename},Worker:r.Worker,importScripts:function(e){(0,eval)(o.readFileSync(e,"utf8"))},postMessage:function(e){a.postMessage(e)},performance:global.performance||{now:function(){return Date.now()}}})}var s=!1,n=[],i=function(){var e=Array.prototype.slice.call(arguments).join(" ");t?o.writeSync(2,e+"\\n"):console.error(e)};self.alert=function(){var t=Array.prototype.slice.call(arguments).join(" ");postMessage({cmd:"alert",text:t,threadId:e._pthread_self()})},e.instantiateWasm=(t,r)=>{var a=new WebAssembly.Instance(e.wasmModule,t);return r(a),e.wasmModule=null,a.exports},self.onunhandledrejection=e=>{throw e.reason??e},self.onmessage=t=>{try{if("load"===t.data.cmd){if(e.wasmModule=t.data.wasmModule,e.wasmMemory=t.data.wasmMemory,e.buffer=e.wasmMemory.buffer,e.ENVIRONMENT_IS_PTHREAD=!0,"string"==typeof t.data.urlOrBlob)importScripts(t.data.urlOrBlob);else{var r=URL.createObjectURL(t.data.urlOrBlob);importScripts(r),URL.revokeObjectURL(r)}ortWasmThreaded(e).then((function(t){e=t}))}else if("run"===t.data.cmd){e.__performance_now_clock_drift=performance.now()-t.data.time,e.__emscripten_thread_init(t.data.pthread_ptr,0,0,1),e.establishStackSpace(),e.PThread.receiveObjectTransfer(t.data),e.PThread.threadInitTLS(),s||(n.forEach((t=>{e.executeNotifiedProxyingQueue(t)})),n=[],s=!0);try{e.invokeEntryPoint(t.data.start_routine,t.data.arg)}catch(t){if("unwind"!=t){if(!(t instanceof e.ExitStatus))throw t;e.keepRuntimeAlive()||e.__emscripten_thread_exit(t.status)}}}else"cancel"===t.data.cmd?e._pthread_self()&&e.__emscripten_thread_exit(-1):"setimmediate"===t.data.target||("processProxyingQueue"===t.data.cmd?s?e.executeNotifiedProxyingQueue(t.data.queue):n.push(t.data.queue):(i("worker.js received unknown command "+t.data.cmd),i(t.data)))}catch(t){throw i("worker.js onmessage() captured an uncaught exception: "+t),t&&t.stack&&i(t.stack),e.__emscripten_thread_crashed&&e.__emscripten_thread_crashed(),t}};
`},1670:F=>{F.exports=__WEBPACK_EXTERNAL_MODULE__1670__},7067:()=>{},1296:()=>{},1384:()=>{},3993:()=>{},908:()=>{},6953:()=>{},9925:()=>{},2806:()=>{},6449:()=>{},2850:()=>{},5381:()=>{},5686:(F,w,D)=>{D.r(w),D.d(w,{flatbuffers:()=>O});var O={};O.Offset,O.Table,O.SIZEOF_SHORT=2,O.SIZEOF_INT=4,O.FILE_IDENTIFIER_LENGTH=4,O.SIZE_PREFIX_LENGTH=4,O.Encoding={UTF8_BYTES:1,UTF16_STRING:2},O.int32=new Int32Array(2),O.float32=new Float32Array(O.int32.buffer),O.float64=new Float64Array(O.int32.buffer),O.isLittleEndian=new Uint16Array(new Uint8Array([1,0]).buffer)[0]===1,O.Long=function(U,G){this.low=0|U,this.high=0|G},O.Long.create=function(U,G){return U==0&&G==0?O.Long.ZERO:new O.Long(U,G)},O.Long.prototype.toFloat64=function(){return(this.low>>>0)+4294967296*this.high},O.Long.prototype.equals=function(U){return this.low==U.low&&this.high==U.high},O.Long.ZERO=new O.Long(0,0),O.Builder=function(U){if(U)G=U;else var G=1024;this.bb=O.ByteBuffer.allocate(G),this.space=G,this.minalign=1,this.vtable=null,this.vtable_in_use=0,this.isNested=!1,this.object_start=0,this.vtables=[],this.vector_num_elems=0,this.force_defaults=!1},O.Builder.prototype.clear=function(){this.bb.clear(),this.space=this.bb.capacity(),this.minalign=1,this.vtable=null,this.vtable_in_use=0,this.isNested=!1,this.object_start=0,this.vtables=[],this.vector_num_elems=0,this.force_defaults=!1},O.Builder.prototype.forceDefaults=function(U){this.force_defaults=U},O.Builder.prototype.dataBuffer=function(){return this.bb},O.Builder.prototype.asUint8Array=function(){return this.bb.bytes().subarray(this.bb.position(),this.bb.position()+this.offset())},O.Builder.prototype.prep=function(U,G){U>this.minalign&&(this.minalign=U);for(var q=1+~(this.bb.capacity()-this.space+G)&U-1;this.space<q+U+G;){var K=this.bb.capacity();this.bb=O.Builder.growByteBuffer(this.bb),this.space+=this.bb.capacity()-K}this.pad(q)},O.Builder.prototype.pad=function(U){for(var G=0;G<U;G++)this.bb.writeInt8(--this.space,0)},O.Builder.prototype.writeInt8=function(U){this.bb.writeInt8(this.space-=1,U)},O.Builder.prototype.writeInt16=function(U){this.bb.writeInt16(this.space-=2,U)},O.Builder.prototype.writeInt32=function(U){this.bb.writeInt32(this.space-=4,U)},O.Builder.prototype.writeInt64=function(U){this.bb.writeInt64(this.space-=8,U)},O.Builder.prototype.writeFloat32=function(U){this.bb.writeFloat32(this.space-=4,U)},O.Builder.prototype.writeFloat64=function(U){this.bb.writeFloat64(this.space-=8,U)},O.Builder.prototype.addInt8=function(U){this.prep(1,0),this.writeInt8(U)},O.Builder.prototype.addInt16=function(U){this.prep(2,0),this.writeInt16(U)},O.Builder.prototype.addInt32=function(U){this.prep(4,0),this.writeInt32(U)},O.Builder.prototype.addInt64=function(U){this.prep(8,0),this.writeInt64(U)},O.Builder.prototype.addFloat32=function(U){this.prep(4,0),this.writeFloat32(U)},O.Builder.prototype.addFloat64=function(U){this.prep(8,0),this.writeFloat64(U)},O.Builder.prototype.addFieldInt8=function(U,G,q){(this.force_defaults||G!=q)&&(this.addInt8(G),this.slot(U))},O.Builder.prototype.addFieldInt16=function(U,G,q){(this.force_defaults||G!=q)&&(this.addInt16(G),this.slot(U))},O.Builder.prototype.addFieldInt32=function(U,G,q){(this.force_defaults||G!=q)&&(this.addInt32(G),this.slot(U))},O.Builder.prototype.addFieldInt64=function(U,G,q){!this.force_defaults&&G.equals(q)||(this.addInt64(G),this.slot(U))},O.Builder.prototype.addFieldFloat32=function(U,G,q){(this.force_defaults||G!=q)&&(this.addFloat32(G),this.slot(U))},O.Builder.prototype.addFieldFloat64=function(U,G,q){(this.force_defaults||G!=q)&&(this.addFloat64(G),this.slot(U))},O.Builder.prototype.addFieldOffset=function(U,G,q){(this.force_defaults||G!=q)&&(this.addOffset(G),this.slot(U))},O.Builder.prototype.addFieldStruct=function(U,G,q){G!=q&&(this.nested(G),this.slot(U))},O.Builder.prototype.nested=function(U){if(U!=this.offset())throw new Error("FlatBuffers: struct must be serialized inline.")},O.Builder.prototype.notNested=function(){if(this.isNested)throw new Error("FlatBuffers: object serialization must not be nested.")},O.Builder.prototype.slot=function(U){this.vtable[U]=this.offset()},O.Builder.prototype.offset=function(){return this.bb.capacity()-this.space},O.Builder.growByteBuffer=function(U){var G=U.capacity();if(3221225472&G)throw new Error("FlatBuffers: cannot grow buffer beyond 2 gigabytes.");var q=G<<1,K=O.ByteBuffer.allocate(q);return K.setPosition(q-G),K.bytes().set(U.bytes(),q-G),K},O.Builder.prototype.addOffset=function(U){this.prep(O.SIZEOF_INT,0),this.writeInt32(this.offset()-U+O.SIZEOF_INT)},O.Builder.prototype.startObject=function(U){this.notNested(),this.vtable==null&&(this.vtable=[]),this.vtable_in_use=U;for(var G=0;G<U;G++)this.vtable[G]=0;this.isNested=!0,this.object_start=this.offset()},O.Builder.prototype.endObject=function(){if(this.vtable==null||!this.isNested)throw new Error("FlatBuffers: endObject called without startObject");this.addInt32(0);for(var U=this.offset(),G=this.vtable_in_use-1;G>=0&&this.vtable[G]==0;G--);for(var q=G+1;G>=0;G--)this.addInt16(this.vtable[G]!=0?U-this.vtable[G]:0);this.addInt16(U-this.object_start);var K=(q+2)*O.SIZEOF_SHORT;this.addInt16(K);var ee=0,Z=this.space;e:for(G=0;G<this.vtables.length;G++){var ie=this.bb.capacity()-this.vtables[G];if(K==this.bb.readInt16(ie)){for(var Y=O.SIZEOF_SHORT;Y<K;Y+=O.SIZEOF_SHORT)if(this.bb.readInt16(Z+Y)!=this.bb.readInt16(ie+Y))continue e;ee=this.vtables[G];break}}return ee?(this.space=this.bb.capacity()-U,this.bb.writeInt32(this.space,ee-U)):(this.vtables.push(this.offset()),this.bb.writeInt32(this.bb.capacity()-U,this.offset()-U)),this.isNested=!1,U},O.Builder.prototype.finish=function(U,G,q){var K=q?O.SIZE_PREFIX_LENGTH:0;if(G){var ee=G;if(this.prep(this.minalign,O.SIZEOF_INT+O.FILE_IDENTIFIER_LENGTH+K),ee.length!=O.FILE_IDENTIFIER_LENGTH)throw new Error("FlatBuffers: file identifier must be length "+O.FILE_IDENTIFIER_LENGTH);for(var Z=O.FILE_IDENTIFIER_LENGTH-1;Z>=0;Z--)this.writeInt8(ee.charCodeAt(Z))}this.prep(this.minalign,O.SIZEOF_INT+K),this.addOffset(U),K&&this.addInt32(this.bb.capacity()-this.space),this.bb.setPosition(this.space)},O.Builder.prototype.finishSizePrefixed=function(U,G){this.finish(U,G,!0)},O.Builder.prototype.requiredField=function(U,G){var q=this.bb.capacity()-U,K=q-this.bb.readInt32(q);if(this.bb.readInt16(K+G)==0)throw new Error("FlatBuffers: field "+G+" must be set")},O.Builder.prototype.startVector=function(U,G,q){this.notNested(),this.vector_num_elems=G,this.prep(O.SIZEOF_INT,U*G),this.prep(q,U*G)},O.Builder.prototype.endVector=function(){return this.writeInt32(this.vector_num_elems),this.offset()},O.Builder.prototype.createString=function(U){if(U instanceof Uint8Array)var G=U;else{G=[];for(var q=0;q<U.length;){var K,ee=U.charCodeAt(q++);(K=ee<55296||ee>=56320?ee:(ee<<10)+U.charCodeAt(q++)+-56613888)<128?G.push(K):(K<2048?G.push(K>>6&31|192):(K<65536?G.push(K>>12&15|224):G.push(K>>18&7|240,K>>12&63|128),G.push(K>>6&63|128)),G.push(63&K|128))}}this.addInt8(0),this.startVector(1,G.length,1),this.bb.setPosition(this.space-=G.length),q=0;for(var Z=this.space,ie=this.bb.bytes();q<G.length;q++)ie[Z++]=G[q];return this.endVector()},O.Builder.prototype.createLong=function(U,G){return O.Long.create(U,G)},O.ByteBuffer=function(U){this.bytes_=U,this.position_=0},O.ByteBuffer.allocate=function(U){return new O.ByteBuffer(new Uint8Array(U))},O.ByteBuffer.prototype.clear=function(){this.position_=0},O.ByteBuffer.prototype.bytes=function(){return this.bytes_},O.ByteBuffer.prototype.position=function(){return this.position_},O.ByteBuffer.prototype.setPosition=function(U){this.position_=U},O.ByteBuffer.prototype.capacity=function(){return this.bytes_.length},O.ByteBuffer.prototype.readInt8=function(U){return this.readUint8(U)<<24>>24},O.ByteBuffer.prototype.readUint8=function(U){return this.bytes_[U]},O.ByteBuffer.prototype.readInt16=function(U){return this.readUint16(U)<<16>>16},O.ByteBuffer.prototype.readUint16=function(U){return this.bytes_[U]|this.bytes_[U+1]<<8},O.ByteBuffer.prototype.readInt32=function(U){return this.bytes_[U]|this.bytes_[U+1]<<8|this.bytes_[U+2]<<16|this.bytes_[U+3]<<24},O.ByteBuffer.prototype.readUint32=function(U){return this.readInt32(U)>>>0},O.ByteBuffer.prototype.readInt64=function(U){return new O.Long(this.readInt32(U),this.readInt32(U+4))},O.ByteBuffer.prototype.readUint64=function(U){return new O.Long(this.readUint32(U),this.readUint32(U+4))},O.ByteBuffer.prototype.readFloat32=function(U){return O.int32[0]=this.readInt32(U),O.float32[0]},O.ByteBuffer.prototype.readFloat64=function(U){return O.int32[O.isLittleEndian?0:1]=this.readInt32(U),O.int32[O.isLittleEndian?1:0]=this.readInt32(U+4),O.float64[0]},O.ByteBuffer.prototype.writeInt8=function(U,G){this.bytes_[U]=G},O.ByteBuffer.prototype.writeUint8=function(U,G){this.bytes_[U]=G},O.ByteBuffer.prototype.writeInt16=function(U,G){this.bytes_[U]=G,this.bytes_[U+1]=G>>8},O.ByteBuffer.prototype.writeUint16=function(U,G){this.bytes_[U]=G,this.bytes_[U+1]=G>>8},O.ByteBuffer.prototype.writeInt32=function(U,G){this.bytes_[U]=G,this.bytes_[U+1]=G>>8,this.bytes_[U+2]=G>>16,this.bytes_[U+3]=G>>24},O.ByteBuffer.prototype.writeUint32=function(U,G){this.bytes_[U]=G,this.bytes_[U+1]=G>>8,this.bytes_[U+2]=G>>16,this.bytes_[U+3]=G>>24},O.ByteBuffer.prototype.writeInt64=function(U,G){this.writeInt32(U,G.low),this.writeInt32(U+4,G.high)},O.ByteBuffer.prototype.writeUint64=function(U,G){this.writeUint32(U,G.low),this.writeUint32(U+4,G.high)},O.ByteBuffer.prototype.writeFloat32=function(U,G){O.float32[0]=G,this.writeInt32(U,O.int32[0])},O.ByteBuffer.prototype.writeFloat64=function(U,G){O.float64[0]=G,this.writeInt32(U,O.int32[O.isLittleEndian?0:1]),this.writeInt32(U+4,O.int32[O.isLittleEndian?1:0])},O.ByteBuffer.prototype.getBufferIdentifier=function(){if(this.bytes_.length<this.position_+O.SIZEOF_INT+O.FILE_IDENTIFIER_LENGTH)throw new Error("FlatBuffers: ByteBuffer is too short to contain an identifier.");for(var U="",G=0;G<O.FILE_IDENTIFIER_LENGTH;G++)U+=String.fromCharCode(this.readInt8(this.position_+O.SIZEOF_INT+G));return U},O.ByteBuffer.prototype.__offset=function(U,G){var q=U-this.readInt32(U);return G<this.readInt16(q)?this.readInt16(q+G):0},O.ByteBuffer.prototype.__union=function(U,G){return U.bb_pos=G+this.readInt32(G),U.bb=this,U},O.ByteBuffer.prototype.__string=function(U,G){U+=this.readInt32(U);var q=this.readInt32(U),K="",ee=0;if(U+=O.SIZEOF_INT,G===O.Encoding.UTF8_BYTES)return this.bytes_.subarray(U,U+q);for(;ee<q;){var Z,ie=this.readUint8(U+ee++);if(ie<192)Z=ie;else{var Y=this.readUint8(U+ee++);if(ie<224)Z=(31&ie)<<6|63&Y;else{var W=this.readUint8(U+ee++);Z=ie<240?(15&ie)<<12|(63&Y)<<6|63&W:(7&ie)<<18|(63&Y)<<12|(63&W)<<6|63&this.readUint8(U+ee++)}}Z<65536?K+=String.fromCharCode(Z):(Z-=65536,K+=String.fromCharCode(55296+(Z>>10),56320+(1023&Z)))}return K},O.ByteBuffer.prototype.__indirect=function(U){return U+this.readInt32(U)},O.ByteBuffer.prototype.__vector=function(U){return U+this.readInt32(U)+O.SIZEOF_INT},O.ByteBuffer.prototype.__vector_len=function(U){return this.readInt32(U+this.readInt32(U))},O.ByteBuffer.prototype.__has_identifier=function(U){if(U.length!=O.FILE_IDENTIFIER_LENGTH)throw new Error("FlatBuffers: file identifier must be length "+O.FILE_IDENTIFIER_LENGTH);for(var G=0;G<O.FILE_IDENTIFIER_LENGTH;G++)if(U.charCodeAt(G)!=this.readInt8(this.position_+O.SIZEOF_INT+G))return!1;return!0},O.ByteBuffer.prototype.createLong=function(U,G){return O.Long.create(U,G)}}},__webpack_module_cache__={};function __webpack_require__(F){var w=__webpack_module_cache__[F];if(w!==void 0)return w.exports;var D=__webpack_module_cache__[F]={exports:{}};return __webpack_modules__[F].call(D.exports,D,D.exports,__webpack_require__),D.exports}__webpack_require__.n=F=>{var w=F&&F.__esModule?()=>F.default:()=>F;return __webpack_require__.d(w,{a:w}),w},__webpack_require__.d=(F,w)=>{for(var D in w)__webpack_require__.o(w,D)&&!__webpack_require__.o(F,D)&&Object.defineProperty(F,D,{enumerable:!0,get:w[D]})},__webpack_require__.g=(function(){if(typeof globalThis=="object")return globalThis;try{return this||new Function("return this")()}catch{if(typeof window=="object")return window}})(),__webpack_require__.o=(F,w)=>Object.prototype.hasOwnProperty.call(F,w),__webpack_require__.r=F=>{typeof Symbol<"u"&&Symbol.toStringTag&&Object.defineProperty(F,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(F,"__esModule",{value:!0})};var __webpack_exports__=__webpack_require__(6018);return __webpack_exports__})()))})(ortWeb_min$1)),ortWeb_min$1.exports}var ortWeb_minExports=requireOrtWeb_min();const ortWeb_min=getDefaultExportFromCjs(ortWeb_minExports),ONNX_WEB=_mergeNamespaces({__proto__:null,default:ortWeb_min},[ortWeb_minExports]);let ONNX;const executionProviders=["wasm"];typeof process<"u"&&process?.release?.name==="node"?(ONNX=sharp??ONNX_NODE,executionProviders.unshift("cpu")):(ONNX=ortWeb_min??ONNX_WEB,typeof navigator<"u"&&/iP(hone|od|ad).+16_4.+AppleWebKit/.test(navigator.userAgent)&&(ONNX.env.wasm.simd=!1));const{env:onnx_env}=ONNX,VERSION="2.17.2",WEB_CACHE_AVAILABLE=typeof self<"u"&&"caches"in self,FS_AVAILABLE=!isEmpty(sharp),PATH_AVAILABLE=!isEmpty(sharp),RUNNING_LOCALLY=FS_AVAILABLE&&PATH_AVAILABLE,__dirname=RUNNING_LOCALLY?sharp.dirname(sharp.dirname(sharp.fileURLToPath(import.meta.url))):"./",DEFAULT_CACHE_DIR=RUNNING_LOCALLY?sharp.join(__dirname,"/.cache/"):null,DEFAULT_LOCAL_MODEL_PATH="/models/",localModelPath=RUNNING_LOCALLY?sharp.join(__dirname,DEFAULT_LOCAL_MODEL_PATH):DEFAULT_LOCAL_MODEL_PATH;onnx_env?.wasm&&(onnx_env.wasm.wasmPaths=RUNNING_LOCALLY?sharp.join(__dirname,"/dist/"):`https://cdn.jsdelivr.net/npm/@xenova/transformers@${VERSION}/dist/`);const env$1={version:VERSION,remoteHost:"https://huggingface.co/",remotePathTemplate:"{model}/resolve/{revision}/",localModelPath,useFS:FS_AVAILABLE,useBrowserCache:WEB_CACHE_AVAILABLE,useFSCache:FS_AVAILABLE,cacheDir:DEFAULT_CACHE_DIR};function isEmpty(F){return Object.keys(F).length===0}var define_process_env_default={};class FileResponse{_CONTENT_TYPE_MAP={txt:"text/plain",html:"text/html",css:"text/css",js:"text/javascript",json:"application/json",png:"image/png",jpg:"image/jpeg",jpeg:"image/jpeg",gif:"image/gif"};constructor(w){if(this.filePath=w,this.headers=new Headers,this.exists=sharp.existsSync(w),this.exists){this.status=200,this.statusText="OK";let D=sharp.statSync(w);this.headers.set("content-length",D.size.toString()),this.updateContentType();let O=this;this.body=new ReadableStream({start(U){O.arrayBuffer().then(G=>{U.enqueue(new Uint8Array(G)),U.close()})}})}else this.status=404,this.statusText="Not Found",this.body=null}updateContentType(){const w=this.filePath.toString().split(".").pop().toLowerCase();this.headers.set("content-type",this._CONTENT_TYPE_MAP[w]??"application/octet-stream")}clone(){let w=new FileResponse(this.filePath);return w.exists=this.exists,w.status=this.status,w.statusText=this.statusText,w.headers=new Headers(this.headers),w}async arrayBuffer(){return(await sharp.promises.readFile(this.filePath)).buffer}async blob(){const w=await sharp.promises.readFile(this.filePath);return new Blob([w],{type:this.headers.get("content-type")})}async text(){return await sharp.promises.readFile(this.filePath,"utf8")}async json(){return JSON.parse(await this.text())}}function isValidUrl(F,w=null,D=null){let O;try{O=new URL(F)}catch{return!1}return!(w&&!w.includes(O.protocol)||D&&!D.includes(O.hostname))}async function getFile(F){if(env$1.useFS&&!isValidUrl(F,["http:","https:","blob:"]))return new FileResponse(F);if(typeof process<"u"&&process?.release?.name==="node"){const w=!!define_process_env_default?.TESTING_REMOTELY,D=env$1.version,O=new Headers;if(O.set("User-Agent",`transformers.js/${D}; is_ci/${w};`),isValidUrl(F,["http:","https:"],["huggingface.co","hf.co"])){const G=define_process_env_default?.HF_TOKEN??define_process_env_default?.HF_ACCESS_TOKEN;G&&O.set("Authorization",`Bearer ${G}`)}return fetch(F,{headers:O})}else return fetch(F)}const ERROR_MAPPING={400:"Bad request error occurred while trying to load file",401:"Unauthorized access to file",403:"Forbidden access to file",404:"Could not locate file",408:"Request timeout error occurred while trying to load file",500:"Internal server error error occurred while trying to load file",502:"Bad gateway error occurred while trying to load file",503:"Service unavailable error occurred while trying to load file",504:"Gateway timeout error occurred while trying to load file"};function handleError(F,w,D){if(!D)return null;const O=ERROR_MAPPING[F]??`Error (${F}) occurred while trying to load file`;throw Error(`${O}: "${w}".`)}class FileCache{constructor(w){this.path=w}async match(w){let D=sharp.join(this.path,w),O=new FileResponse(D);if(O.exists)return O}async put(w,D){const O=Buffer.from(await D.arrayBuffer());let U=sharp.join(this.path,w);try{await sharp.promises.mkdir(sharp.dirname(U),{recursive:!0}),await sharp.promises.writeFile(U,O)}catch(G){console.warn("An error occurred while writing the file to cache:",G)}}}async function tryCache(F,...w){for(let D of w)try{let O=await F.match(D);if(O)return O}catch{continue}}async function getModelFile(F,w,D=!0,O={}){dispatchCallback(O.progress_callback,{status:"initiate",name:F,file:w});let U;if(!U&&env$1.useBrowserCache){if(typeof caches>"u")throw Error("Browser cache is not available in this environment.");try{U=await caches.open("transformers-cache")}catch(he){console.warn("An error occurred while opening the browser cache:",he)}}!U&&env$1.useFSCache&&(U=new FileCache(O.cache_dir??env$1.cacheDir));const G=O.revision??"main";let q=pathJoin(F,w),K=pathJoin(env$1.localModelPath,q),ee=pathJoin(env$1.remoteHost,env$1.remotePathTemplate.replaceAll("{model}",F).replaceAll("{revision}",encodeURIComponent(G)),w),Z=G==="main"?q:pathJoin(F,G,w),ie,Y=U instanceof FileCache?Z:ee,W=!1,ne;U&&(ne=await tryCache(U,K,Y));const se=ne!==void 0;if(ne===void 0){if(isValidUrl(q,["http:","https:"])){if(O.local_files_only)throw new Error(`\`local_files_only=true\`, but attempted to load a remote file from: ${q}.`)}else try{ne=await getFile(K),ie=K}catch(pe){console.warn(`Unable to load from local path "${K}": "${pe}"`)}if(ne===void 0||ne.status===404){if(O.local_files_only){if(D)throw Error(`\`local_files_only=true\` or \`env.allowRemoteModels=false\` and file was not found locally at "${K}".`);return null}if(ne=await getFile(ee),ne.status!==200)return handleError(ne.status,ee,D);ie=Y}W=U&&typeof Response<"u"&&ne instanceof Response&&ne.status===200}dispatchCallback(O.progress_callback,{status:"download",name:F,file:w});const le={status:"progress",name:F,file:w};let ce;return O.progress_callback?se&&typeof navigator<"u"&&/firefox/i.test(navigator.userAgent)?(ce=new Uint8Array(await ne.arrayBuffer()),dispatchCallback(O.progress_callback,{...le,progress:100,loaded:ce.length,total:ce.length})):ce=await readResponse(ne,he=>{dispatchCallback(O.progress_callback,{...le,...he})}):ce=new Uint8Array(await ne.arrayBuffer()),W&&ie&&await U.match(ie)===void 0&&await U.put(ie,new Response(ce,{headers:ne.headers})).catch(he=>{console.warn(`Unable to add response to browser cache: ${he}.`)}),dispatchCallback(O.progress_callback,{status:"done",name:F,file:w}),ce}async function getModelJSON(F,w,D=!0,O={}){let U=await getModelFile(F,w,D,O);if(U===null)return{};let q=new TextDecoder("utf-8").decode(U);return JSON.parse(q)}async function readResponse(F,w){const D=F.headers.get("Content-Length");D===null&&console.warn("Unable to determine content-length from response headers. Will expand buffer when needed.");let O=parseInt(D??"0"),U=new Uint8Array(O),G=0;const q=F.body.getReader();async function K(){const{done:ee,value:Z}=await q.read();if(ee)return;let ie=G+Z.length;if(ie>O){O=ie;let W=new Uint8Array(O);W.set(U),U=W}U.set(Z,G),G=ie;const Y=G/O*100;return w({progress:Y,loaded:G,total:O}),K()}return await K(),U}function pathJoin(...F){return F=F.map((w,D)=>(D&&(w=w.replace(new RegExp("^/"),"")),D!==F.length-1&&(w=w.replace(new RegExp("/$"),"")),w)),F.join("/")}function interpolate_data(F,[w,D,O],[U,G],q="bilinear",K=!1){const ee=G/O,Z=U/D,ie=new F.constructor(U*G*w),Y=D*O,W=U*G;for(let ne=0;ne<U;++ne)for(let se=0;se<G;++se){const le=ne*G+se,ce=(se+.5)/ee-.5,he=(ne+.5)/Z-.5;let pe=Math.floor(ce),me=Math.floor(he);const be=Math.min(pe+1,O-1),ge=Math.min(me+1,D-1);pe=Math.max(pe,0),me=Math.max(me,0);const ve=ce-pe,Se=he-me,Me=(1-ve)*(1-Se),Ee=ve*(1-Se),we=(1-ve)*Se,Re=ve*Se,Le=me*O,Ne=ge*O,Oe=Le+pe,Pe=Le+be,Ce=Ne+pe,Be=Ne+be;for(let ze=0;ze<w;++ze){const Xe=ze*Y;ie[ze*W+le]=Me*F[Xe+Oe]+Ee*F[Xe+Pe]+we*F[Xe+Ce]+Re*F[Xe+Be]}}return ie}function permute_data(F,w,D){const O=new Array(D.length),U=new Array(D.length);for(let K=D.length-1,ee=1;K>=0;--K)U[K]=ee,O[K]=w[D[K]],ee*=O[K];const G=D.map((K,ee)=>U[D.indexOf(ee)]),q=new F.constructor(F.length);for(let K=0;K<F.length;++K){let ee=0;for(let Z=w.length-1,ie=K;Z>=0;--Z)ee+=ie%w[Z]*G[Z],ie=Math.floor(ie/w[Z]);q[ee]=F[K]}return[q,O]}function softmax(F){const w=max(F)[0],D=F.map(G=>Math.exp(G-w)),O=D.reduce((G,q)=>G+q,0);return D.map(G=>G/O)}function log_softmax(F){return softmax(F).map(O=>Math.log(O))}function getTopItems(F,w=0){return F=Array.from(F).map((D,O)=>[O,D]).sort((D,O)=>O[1]-D[1]),w!==null&&w>0&&(F=F.slice(0,w)),F}function min(F){if(F.length===0)throw Error("Array must not be empty");let w=F[0],D=0;for(let O=1;O<F.length;++O)F[O]<w&&(w=F[O],D=O);return[w,D]}function max(F){if(F.length===0)throw Error("Array must not be empty");let w=F[0],D=0;for(let O=1;O<F.length;++O)F[O]>w&&(w=F[O],D=O);return[Number(w),D]}function isPowerOfTwo(F){return F>0&&(F&F-1)===0}class P2FFT{constructor(w){if(this.size=w|0,this.size<=1||!isPowerOfTwo(this.size))throw new Error("FFT size must be a power of two larger than 1");this._csize=w<<1,this.table=new Float64Array(this.size*2);for(let O=0;O<this.table.length;O+=2){const U=Math.PI*O/this.size;this.table[O]=Math.cos(U),this.table[O+1]=-Math.sin(U)}let D=0;for(let O=1;this.size>O;O<<=1)++D;this._width=D%2===0?D-1:D,this._bitrev=new Int32Array(1<<this._width);for(let O=0;O<this._bitrev.length;++O){this._bitrev[O]=0;for(let U=0;U<this._width;U+=2){const G=this._width-U-2;this._bitrev[O]|=(O>>>U&3)<<G}}}createComplexArray(){return new Float64Array(this._csize)}fromComplexArray(w,D){const O=D||new Array(w.length>>>1);for(let U=0;U<w.length;U+=2)O[U>>>1]=w[U];return O}toComplexArray(w,D){const O=D||this.createComplexArray();for(let U=0;U<O.length;U+=2)O[U]=w[U>>>1],O[U+1]=0;return O}transform(w,D){if(w===D)throw new Error("Input and output buffers must be different");this._transform4(w,D,1)}realTransform(w,D){if(w===D)throw new Error("Input and output buffers must be different");this._realTransform4(w,D,1)}inverseTransform(w,D){if(w===D)throw new Error("Input and output buffers must be different");this._transform4(w,D,-1);for(let O=0;O<w.length;++O)w[O]/=this.size}_transform4(w,D,O){const U=this._csize;let q=1<<this._width,K=U/q<<1,ee,Z;const ie=this._bitrev;if(K===4)for(ee=0,Z=0;ee<U;ee+=K,++Z){const W=ie[Z];this._singleTransform2(D,w,ee,W,q)}else for(ee=0,Z=0;ee<U;ee+=K,++Z){const W=ie[Z];this._singleTransform4(D,w,ee,W,q,O)}const Y=this.table;for(q>>=2;q>=2;q>>=2){K=U/q<<1;const W=K>>>2;for(ee=0;ee<U;ee+=K){const ne=ee+W-1;for(let se=ee,le=0;se<ne;se+=2,le+=q){const ce=se,he=ce+W,pe=he+W,me=pe+W,be=w[ce],ge=w[ce+1],ve=w[he],Se=w[he+1],Me=w[pe],Ee=w[pe+1],we=w[me],Re=w[me+1],Le=Y[le],Ne=O*Y[le+1],Oe=ve*Le-Se*Ne,Pe=ve*Ne+Se*Le,Ce=Y[2*le],Be=O*Y[2*le+1],ze=Me*Ce-Ee*Be,Xe=Me*Be+Ee*Ce,lt=Y[3*le],ke=O*Y[3*le+1],rt=we*lt-Re*ke,St=we*ke+Re*lt,Lt=be+ze,$t=ge+Xe,mt=be-ze,bt=ge-Xe,Xt=Oe+rt,hn=Pe+St,Jt=O*(Oe-rt),Mn=O*(Pe-St);w[ce]=Lt+Xt,w[ce+1]=$t+hn,w[he]=mt+Mn,w[he+1]=bt-Jt,w[pe]=Lt-Xt,w[pe+1]=$t-hn,w[me]=mt-Mn,w[me+1]=bt+Jt}}}}_singleTransform2(w,D,O,U,G){const q=w[U],K=w[U+1],ee=w[U+G],Z=w[U+G+1];D[O]=q+ee,D[O+1]=K+Z,D[O+2]=q-ee,D[O+3]=K-Z}_singleTransform4(w,D,O,U,G,q){const K=G*2,ee=G*3,Z=w[U],ie=w[U+1],Y=w[U+G],W=w[U+G+1],ne=w[U+K],se=w[U+K+1],le=w[U+ee],ce=w[U+ee+1],he=Z+ne,pe=ie+se,me=Z-ne,be=ie-se,ge=Y+le,ve=W+ce,Se=q*(Y-le),Me=q*(W-ce);D[O]=he+ge,D[O+1]=pe+ve,D[O+2]=me+Me,D[O+3]=be-Se,D[O+4]=he-ge,D[O+5]=pe-ve,D[O+6]=me-Me,D[O+7]=be+Se}_realTransform4(w,D,O){const U=this._csize;let q=1<<this._width,K=U/q<<1,ee,Z;const ie=this._bitrev;if(K===4)for(ee=0,Z=0;ee<U;ee+=K,++Z){const ne=ie[Z];this._singleRealTransform2(D,w,ee,ne>>>1,q>>>1)}else for(ee=0,Z=0;ee<U;ee+=K,++Z){const ne=ie[Z];this._singleRealTransform4(D,w,ee,ne>>>1,q>>>1,O)}const Y=this.table;for(q>>=2;q>=2;q>>=2){K=U/q<<1;const ne=K>>>1,se=ne>>>1,le=se>>>1;for(ee=0;ee<U;ee+=K)for(let ce=0,he=0;ce<=le;ce+=2,he+=q){const pe=ee+ce,me=pe+se,be=me+se,ge=be+se,ve=w[pe],Se=w[pe+1],Me=w[me],Ee=w[me+1],we=w[be],Re=w[be+1],Le=w[ge],Ne=w[ge+1],Oe=ve,Pe=Se,Ce=Y[he],Be=O*Y[he+1],ze=Me*Ce-Ee*Be,Xe=Me*Be+Ee*Ce,lt=Y[2*he],ke=O*Y[2*he+1],rt=we*lt-Re*ke,St=we*ke+Re*lt,Lt=Y[3*he],$t=O*Y[3*he+1],mt=Le*Lt-Ne*$t,bt=Le*$t+Ne*Lt,Xt=Oe+rt,hn=Pe+St,Jt=Oe-rt,Mn=Pe-St,Zn=ze+mt,vn=Xe+bt,In=O*(ze-mt),st=O*(Xe-bt);if(w[pe]=Xt+Zn,w[pe+1]=hn+vn,w[me]=Jt+st,w[me+1]=Mn-In,ce===0){w[be]=Xt-Zn,w[be+1]=hn-vn;continue}if(ce===le)continue;const Gn=ee+se-ce,qn=ee+ne-ce;w[Gn]=Jt-O*st,w[Gn+1]=-Mn-O*In,w[qn]=Xt-O*Zn,w[qn+1]=-hn+O*vn}}const W=U>>>1;for(let ne=2;ne<W;ne+=2)w[U-ne]=w[ne],w[U-ne+1]=-w[ne+1]}_singleRealTransform2(w,D,O,U,G){const q=w[U],K=w[U+G];D[O]=q+K,D[O+1]=0,D[O+2]=q-K,D[O+3]=0}_singleRealTransform4(w,D,O,U,G,q){const K=G*2,ee=G*3,Z=w[U],ie=w[U+G],Y=w[U+K],W=w[U+ee],ne=Z+Y,se=Z-Y,le=ie+W,ce=q*(ie-W);D[O]=ne+le,D[O+1]=0,D[O+2]=se,D[O+3]=-ce,D[O+4]=ne-le,D[O+5]=0,D[O+6]=se,D[O+7]=ce}}class NP2FFT{constructor(w){const D=2*(w-1),O=2*(2*w-1),U=2**Math.ceil(Math.log2(O));this.bufferSize=U,this._a=D;const G=new Float64Array(O),q=new Float64Array(U);this._chirpBuffer=new Float64Array(U),this._buffer1=new Float64Array(U),this._buffer2=new Float64Array(U),this._outBuffer1=new Float64Array(U),this._outBuffer2=new Float64Array(U);const K=-2*Math.PI/w,ee=Math.cos(K),Z=Math.sin(K);for(let ie=0;ie<O>>1;++ie){const Y=(ie+1-w)**2/2,W=Math.sqrt(ee**2+Z**2)**Y,ne=Y*Math.atan2(Z,ee),se=2*ie;G[se]=W*Math.cos(ne),G[se+1]=W*Math.sin(ne),q[se]=G[se],q[se+1]=-G[se+1]}this._slicedChirpBuffer=G.subarray(D,O),this._f=new P2FFT(U>>1),this._f.transform(this._chirpBuffer,q)}_transform(w,D,O){const U=this._buffer1,G=this._buffer2,q=this._outBuffer1,K=this._outBuffer2,ee=this._chirpBuffer,Z=this._slicedChirpBuffer,ie=this._a;if(O)for(let Y=0;Y<Z.length;Y+=2){const W=Y+1,ne=Y>>1,se=D[ne];U[Y]=se*Z[Y],U[W]=se*Z[W]}else for(let Y=0;Y<Z.length;Y+=2){const W=Y+1;U[Y]=D[Y]*Z[Y]-D[W]*Z[W],U[W]=D[Y]*Z[W]+D[W]*Z[Y]}this._f.transform(q,U);for(let Y=0;Y<ee.length;Y+=2){const W=Y+1;G[Y]=q[Y]*ee[Y]-q[W]*ee[W],G[W]=q[Y]*ee[W]+q[W]*ee[Y]}this._f.inverseTransform(K,G);for(let Y=0;Y<K.length;Y+=2){const W=K[Y+ie],ne=K[Y+ie+1],se=Z[Y],le=Z[Y+1];w[Y]=W*se-ne*le,w[Y+1]=W*le+ne*se}}transform(w,D){this._transform(w,D,!1)}realTransform(w,D){this._transform(w,D,!0)}}class FFT{constructor(w){this.fft_length=w,this.isPowerOfTwo=isPowerOfTwo(w),this.isPowerOfTwo?(this.fft=new P2FFT(w),this.outputBufferSize=2*w):(this.fft=new NP2FFT(w),this.outputBufferSize=this.fft.bufferSize)}realTransform(w,D){this.fft.realTransform(w,D)}transform(w,D){this.fft.transform(w,D)}}function medianFilter(F,w){if(w%2===0||w<=0)throw new Error("Window size must be a positive odd number");const D=new F.constructor(F.length),O=new F.constructor(w),U=Math.floor(w/2);for(let G=0;G<F.length;++G){let q=0;for(let K=-U;K<=U;++K){let ee=G+K;ee<0?ee=Math.abs(ee):ee>=F.length&&(ee=2*(F.length-1)-ee),O[q++]=F[ee]}O.sort(),D[G]=O[U]}return D}function round(F,w){const D=Math.pow(10,w);return Math.round(F*D)/D}function bankers_round(F){const w=Math.round(F);return Math.abs(F)%1===.5?w%2===0?w:w-1:w}const DataTypeMap=Object.freeze({float32:Float32Array,float64:Float64Array,string:Array,int8:Int8Array,uint8:Uint8Array,int16:Int16Array,uint16:Uint16Array,int32:Int32Array,uint32:Uint32Array,int64:BigInt64Array,uint64:BigUint64Array,bool:Uint8Array}),ONNXTensor$1=ONNX.Tensor;class Tensor{dims;type;data;size;constructor(...w){return w[0]instanceof ONNXTensor$1?Object.assign(this,w[0]):Object.assign(this,new ONNXTensor$1(w[0],w[1],w[2])),new Proxy(this,{get:(D,O)=>{if(typeof O=="string"){let U=Number(O);if(Number.isInteger(U))return D._getitem(U)}return D[O]},set:(D,O,U)=>D[O]=U})}*[Symbol.iterator](){const[w,...D]=this.dims;if(D.length>0){const O=D.reduce((U,G)=>U*G);for(let U=0;U<w;++U)yield this._subarray(U,O,D)}else yield*this.data}_getitem(w){const[D,...O]=this.dims;if(w=safeIndex(w,D),O.length>0){const U=O.reduce((G,q)=>G*q);return this._subarray(w,U,O)}else return new Tensor(this.type,[this.data[w]],O)}indexOf(w){for(let D=0;D<this.data.length;++D)if(this.data[D]==w)return D;return-1}_subarray(w,D,O){const U=w*D,G=(w+1)*D,q="subarray"in this.data?this.data.subarray(U,G):this.data.slice(U,G);return new Tensor(this.type,q,O)}item(){if(this.data.length!==1)throw new Error(`a Tensor with ${this.data.length} elements cannot be converted to Scalar`);return this.data[0]}tolist(){return reshape(this.data,this.dims)}sigmoid(){return this.clone().sigmoid_()}sigmoid_(){for(let w=0;w<this.data.length;++w)this.data[w]=1/(1+Math.exp(-this.data[w]));return this}mul(w){return this.clone().mul_(w)}mul_(w){for(let D=0;D<this.data.length;++D)this.data[D]*=w;return this}add(w){return this.clone().add_(w)}add_(w){for(let D=0;D<this.data.length;++D)this.data[D]+=w;return this}clone(){return new Tensor(this.type,this.data.slice(),this.dims.slice())}slice(...w){let D=[],O=[];for(let ee=0;ee<this.dims.length;++ee){let Z=w[ee];if(Z==null)O.push([0,this.dims[ee]]),D.push(this.dims[ee]);else if(typeof Z=="number")Z=safeIndex(Z,this.dims[ee],ee),O.push([Z,Z+1]);else if(Array.isArray(Z)&&Z.length===2){if(Z[0]>Z[1])throw new Error(`Invalid slice: ${Z}`);let ie=[Math.max(Z[0],0),Math.min(Z[1],this.dims[ee])];O.push(ie),D.push(ie[1]-ie[0])}else throw new Error(`Invalid slice: ${Z}`)}let U=O.map(([ee,Z])=>Z-ee),G=U.reduce((ee,Z)=>ee*Z),q=new this.data.constructor(G);const K=this.stride();for(let ee=0;ee<G;++ee){let Z=0;for(let ie=U.length-1,Y=ee;ie>=0;--ie){const W=U[ie];Z+=(Y%W+O[ie][0])*K[ie],Y=Math.floor(Y/W)}q[ee]=this.data[Z]}return new Tensor(this.type,q,D)}permute(...w){return permute(this,w)}transpose(...w){return this.permute(...w)}sum(w=null,D=!1){return this.norm(1,w,D)}norm(w="fro",D=null,O=!1){if(w==="fro")w=2;else if(typeof w=="string")throw Error(`Unsupported norm: ${w}`);if(D===null){let q=this.data.reduce((K,ee)=>K+ee**w,0)**(1/w);return new Tensor(this.type,[q],[])}D=safeIndex(D,this.dims.length);const U=this.dims.slice();U[D]=1;const G=new this.data.constructor(this.data.length/this.dims[D]);for(let q=0;q<this.data.length;++q){let K=0;for(let ee=this.dims.length-1,Z=q,ie=1;ee>=0;--ee){const Y=this.dims[ee];if(ee!==D){const W=Z%Y;K+=W*ie,ie*=U[ee]}Z=Math.floor(Z/Y)}G[K]+=this.data[q]**w}if(w!==1)for(let q=0;q<G.length;++q)G[q]=G[q]**(1/w);return O||U.splice(D,1),new Tensor(this.type,G,U)}normalize_(w=2,D=1){D=safeIndex(D,this.dims.length);const O=this.norm(w,D,!0);for(let U=0;U<this.data.length;++U){let G=0;for(let q=this.dims.length-1,K=U,ee=1;q>=0;--q){const Z=this.dims[q];if(q!==D){const ie=K%Z;G+=ie*ee,ee*=this.dims[q]}K=Math.floor(K/Z)}this.data[U]/=O.data[G]}return this}normalize(w=2,D=1){return this.clone().normalize_(w,D)}stride(){return dimsToStride(this.dims)}squeeze(w=null){return new Tensor(this.type,this.data,calc_squeeze_dims(this.dims,w))}squeeze_(w=null){return this.dims=calc_squeeze_dims(this.dims,w),this}unsqueeze(w=null){return new Tensor(this.type,this.data,calc_unsqueeze_dims(this.dims,w))}unsqueeze_(w=null){return this.dims=calc_unsqueeze_dims(this.dims,w),this}flatten_(w=0,D=-1){D=(D+this.dims.length)%this.dims.length;let O=this.dims.slice(0,w),U=this.dims.slice(w,D+1),G=this.dims.slice(D+1);return this.dims=[...O,U.reduce((q,K)=>q*K,1),...G],this}flatten(w=0,D=-1){return this.clone().flatten_(w,D)}view(...w){let D=-1;for(let O=0;O<w.length;++O)if(w[O]===-1){if(D!==-1)throw new Error("Only one dimension can be inferred");D=O}if(D!==-1){const O=w.reduce((U,G,q)=>q!==D?U*G:U,1);w[D]=this.data.length/O}return new Tensor(this.type,this.data,w)}neg_(){for(let w=0;w<this.data.length;++w)this.data[w]=-this.data[w];return this}neg(){return this.clone().neg_()}clamp_(w,D){for(let O=0;O<this.data.length;++O)this.data[O]=Math.min(Math.max(this.data[O],w),D);return this}clamp(w,D){return this.clone().clamp_(w,D)}round_(){for(let w=0;w<this.data.length;++w)this.data[w]=Math.round(this.data[w]);return this}round(){return this.clone().round_()}to(w){if(this.type===w)return this;if(!DataTypeMap.hasOwnProperty(w))throw new Error(`Unsupported type: ${w}`);return new Tensor(w,DataTypeMap[w].from(this.data),this.dims)}}function reshape(F,w){const D=F.length,O=w.reduce((G,q)=>G*q);if(D!==O)throw Error(`cannot reshape array of size ${D} into shape (${w})`);let U=F;for(let G=w.length-1;G>=0;G--)U=U.reduce((q,K)=>{let ee=q[q.length-1];return ee.length<w[G]?ee.push(K):q.push([K]),q},[[]]);return U[0]}function permute(F,w){const[D,O]=permute_data(F.data,F.dims,w);return new Tensor(F.type,D,O)}function interpolate(F,[w,D],O="bilinear",U=!1){const G=F.dims.at(-3)??1,q=F.dims.at(-2),K=F.dims.at(-1);let ee=interpolate_data(F.data,[G,q,K],[w,D],O,U);return new Tensor(F.type,ee,[G,w,D])}function mean_pooling(F,w){let D=[F.dims[0],F.dims[2]],O=new F.data.constructor(D[0]*D[1]),[U,G,q]=F.dims,K=0;for(let ee=0;ee<U;++ee){let Z=ee*q*G;for(let ie=0;ie<q;++ie){let Y=0,W=0,ne=ee*G,se=Z+ie;for(let ce=0;ce<G;++ce){let he=Number(w.data[ne+ce]);W+=he,Y+=F.data[se+ce*q]*he}let le=Y/W;O[K++]=le}}return new Tensor(F.type,O,D)}function calc_squeeze_dims(F,w){return F=F.slice(),w===null?F=F.filter(D=>D!==1):typeof w=="number"?F[w]===1&&F.splice(w,1):Array.isArray(w)&&(F=F.filter((D,O)=>D!==1||!w.includes(O))),F}function calc_unsqueeze_dims(F,w){return w=safeIndex(w,F.length+1),F=F.slice(),F.splice(w,0,1),F}function safeIndex(F,w,D=null){if(F<-w||F>=w)throw new Error(`IndexError: index ${F} is out of bounds for dimension${D===null?"":" "+D} with size ${w}`);return F<0&&(F=(F%w+w)%w),F}function cat(F,w=0){w=safeIndex(w,F[0].dims.length);const D=F[0].dims.slice();D[w]=F.reduce((q,K)=>q+K.dims[w],0);const O=D.reduce((q,K)=>q*K,1),U=new F[0].data.constructor(O),G=F[0].type;if(w===0){let q=0;for(let K of F)U.set(K.data,q),q+=K.data.length}else{let q=0;for(let K=0;K<F.length;++K){let ee=F[K];for(let Z=0;Z<ee.data.length;++Z){let ie=0;for(let Y=ee.dims.length-1,W=Z,ne=1;Y>=0;--Y){const se=ee.dims[Y];let le=W%se;Y===w&&(le+=q),ie+=le*ne,ne*=D[Y],W=Math.floor(W/se)}U[ie]=ee.data[Z]}q+=ee.dims[w]}}return new Tensor(G,U,D)}function stack(F,w=0){return cat(F.map(D=>D.unsqueeze(w)),w)}function std_mean(F,w=null,D=1,O=!1){if(w===null){const Z=F.data.reduce((ne,se)=>ne+se,0)/F.data.length,ie=Math.sqrt(F.data.reduce((ne,se)=>ne+(se-Z)**2,0)/(F.data.length-D)),Y=new Tensor(F.type,[Z],[]);return[new Tensor(F.type,[ie],[]),Y]}w=safeIndex(w,F.dims.length);const U=mean(F,w,O),G=F.dims.slice();G[w]=1;const q=new F.data.constructor(F.data.length/F.dims[w]);for(let ee=0;ee<F.data.length;++ee){let Z=0;for(let ie=F.dims.length-1,Y=ee,W=1;ie>=0;--ie){const ne=F.dims[ie];if(ie!==w){const se=Y%ne;Z+=se*W,W*=G[ie]}Y=Math.floor(Y/ne)}q[Z]+=(F.data[ee]-U.data[Z])**2}for(let ee=0;ee<q.length;++ee)q[ee]=Math.sqrt(q[ee]/(F.dims[w]-D));return O||G.splice(w,1),[new Tensor(F.type,q,G),U]}function mean(F,w=null,D=!1){if(w===null){let G=F.data.reduce((q,K)=>q+K,0);return new Tensor(F.type,[G/F.data.length],[])}w=safeIndex(w,F.dims.length);const O=F.dims.slice();O[w]=1;const U=new F.data.constructor(F.data.length/F.dims[w]);for(let G=0;G<F.data.length;++G){let q=0;for(let K=F.dims.length-1,ee=G,Z=1;K>=0;--K){const ie=F.dims[K];if(K!==w){const Y=ee%ie;q+=Y*Z,Z*=O[K]}ee=Math.floor(ee/ie)}U[q]+=F.data[G]}if(F.dims[w]!==1)for(let G=0;G<U.length;++G)U[G]=U[G]/F.dims[w];return D||O.splice(w,1),new Tensor(F.type,U,O)}function dynamicTimeWarping(F){const[w,D]=F.dims,O=[w+1,D+1],U=new Tensor("float32",new Float32Array(O[0]*O[1]).fill(1/0),O),G=new Tensor("float32",new Float32Array(O[0]*O[1]).fill(-1),O);U[0].data[0]=0;for(let ie=1;ie<D+1;++ie)for(let Y=1;Y<w+1;++Y){const W=U[Y-1][ie-1].item(),ne=U[Y-1][ie].item(),se=U[Y][ie-1].item();let le,ce;W<ne&&W<se?(le=W,ce=0):ne<W&&ne<se?(le=ne,ce=1):(le=se,ce=2),U[Y].data[ie]=F[Y-1][ie-1].item()+le,G[Y].data[ie]=ce}let q=w,K=D;G.data.fill(2,0,O[1]);for(let ie=0;ie<O[0];++ie)G[ie].data[0]=1;let ee=[],Z=[];for(;q>0||K>0;)switch(ee.push(q-1),Z.push(K-1),G[q][K].item()){case 0:--q,--K;break;case 1:--q;break;case 2:--K;break;default:throw new Error(`Internal error in dynamic time warping. Unexpected trace[${q}, ${K}]. Please file a bug report.`)}return ee.reverse(),Z.reverse(),[ee,Z]}function dimsToStride(F){const w=new Array(F.length);for(let D=F.length-1,O=1;D>=0;--D)w[D]=O,O*=F[D];return w}function ones(F){const w=F.reduce((D,O)=>D*O,1);return new Tensor("int64",new BigInt64Array(w).fill(1n),F)}function ones_like(F){return ones(F.dims)}function quantize_embeddings(F,w){if(F.dims.length!==2)throw new Error("The tensor must have 2 dimensions");if(F.dims.at(-1)%8!==0)throw new Error("The last dimension of the tensor must be a multiple of 8");if(!["binary","ubinary"].includes(w))throw new Error("The precision must be either 'binary' or 'ubinary'");const D=w==="binary",O=D?"int8":"uint8",U=D?Int8Array:Uint8Array,G=F.data,q=new U(G.length/8);for(let K=0;K<G.length;++K){const ee=G[K]>0?1:0,Z=Math.floor(K/8),ie=K%8;q[Z]|=ee<<7-ie,D&&ie===0&&(q[Z]-=128)}return new Tensor(O,q,[F.dims[0],F.dims[1]/8])}class PriorityQueue{constructor(w=(D,O)=>D>O){this._heap=[],this._comparator=w}get size(){return this._heap.length}isEmpty(){return this.size===0}peek(){return this._heap[0]}push(...w){return this.extend(w)}extend(w){for(const D of w)this._heap.push(D),this._siftUp();return this.size}pop(){const w=this.peek(),D=this.size-1;return D>0&&this._swap(0,D),this._heap.pop(),this._siftDown(),w}replace(w){const D=this.peek();return this._heap[0]=w,this._siftDown(),D}_parent(w){return(w+1>>>1)-1}_left(w){return(w<<1)+1}_right(w){return w+1<<1}_greater(w,D){return this._comparator(this._heap[w],this._heap[D])}_swap(w,D){const O=this._heap[w];this._heap[w]=this._heap[D],this._heap[D]=O}_siftUp(){let w=this.size-1;for(;w>0&&this._greater(w,this._parent(w));)this._swap(w,this._parent(w)),w=this._parent(w)}_siftDown(){let w=0;for(;this._left(w)<this.size&&this._greater(this._left(w),w)||this._right(w)<this.size&&this._greater(this._right(w),w);){const D=this._right(w)<this.size&&this._greater(this._right(w),this._left(w))?this._right(w):this._left(w);this._swap(w,D),w=D}}}class CharTrie{constructor(){this.root=CharTrieNode.default()}extend(w){for(let D of w)this.push(D)}push(w){let D=this.root;for(let O of w){let U=D.children.get(O);U===void 0&&(U=CharTrieNode.default(),D.children.set(O,U)),D=U}D.isLeaf=!0}*commonPrefixSearch(w){let D=this.root,O="";for(let U=0;U<w.length&&D!==void 0;++U){const G=w[U];O+=G,D=D.children.get(G),D!==void 0&&D.isLeaf&&(yield O)}}}class CharTrieNode{constructor(w,D){this.isLeaf=w,this.children=D}static default(){return new CharTrieNode(!1,new Map)}}class TokenLattice{constructor(w,D,O){this.sentence=w,this.len=w.length,this.bosTokenId=D,this.eosTokenId=O,this.nodes=[],this.beginNodes=Array.from({length:this.len+1},()=>[]),this.endNodes=Array.from({length:this.len+1},()=>[]);const U=new TokenLatticeNode(this.bosTokenId,0,0,0,0),G=new TokenLatticeNode(this.eosTokenId,1,this.len,0,0);this.nodes.push(U.clone()),this.nodes.push(G.clone()),this.beginNodes[this.len].push(G),this.endNodes[0].push(U)}insert(w,D,O,U){const G=this.nodes.length,q=new TokenLatticeNode(U,G,w,D,O);this.beginNodes[w].push(q),this.endNodes[w+D].push(q),this.nodes.push(q)}viterbi(){const w=this.len;let D=0;for(;D<=w;){if(this.beginNodes[D].length==0)return[];for(let K of this.beginNodes[D]){K.prev=null;let ee=0,Z=null;for(let ie of this.endNodes[D]){const Y=ie.backtraceScore+K.score;(Z===null||Y>ee)&&(Z=ie.clone(),ee=Y)}if(Z!==null)K.prev=Z,K.backtraceScore=ee;else return[]}++D}const O=[],G=this.beginNodes[w][0].prev;if(G===null)return[];let q=G.clone();for(;q.prev!==null;)O.push(q.clone()),q=q.clone().prev.clone();return O.reverse(),O}piece(w){return this.sentence.slice(w.pos,w.pos+w.length)}tokens(){return this.viterbi().map(D=>this.piece(D))}tokenIds(){return this.viterbi().map(D=>D.tokenId)}}class TokenLatticeNode{constructor(w,D,O,U,G){this.tokenId=w,this.nodeId=D,this.pos=O,this.length=U,this.score=G,this.prev=null,this.backtraceScore=0}clone(){const w=new TokenLatticeNode(this.tokenId,this.nodeId,this.pos,this.length,this.score);return w.prev=this.prev,w.backtraceScore=this.backtraceScore,w}}var TOKEN_TYPES=Object.freeze({Text:"Text",NumericLiteral:"NumericLiteral",BooleanLiteral:"BooleanLiteral",StringLiteral:"StringLiteral",Identifier:"Identifier",Equals:"Equals",OpenParen:"OpenParen",CloseParen:"CloseParen",OpenStatement:"OpenStatement",CloseStatement:"CloseStatement",OpenExpression:"OpenExpression",CloseExpression:"CloseExpression",OpenSquareBracket:"OpenSquareBracket",CloseSquareBracket:"CloseSquareBracket",OpenCurlyBracket:"OpenCurlyBracket",CloseCurlyBracket:"CloseCurlyBracket",Comma:"Comma",Dot:"Dot",Colon:"Colon",Pipe:"Pipe",CallOperator:"CallOperator",AdditiveBinaryOperator:"AdditiveBinaryOperator",MultiplicativeBinaryOperator:"MultiplicativeBinaryOperator",ComparisonBinaryOperator:"ComparisonBinaryOperator",UnaryOperator:"UnaryOperator",Set:"Set",If:"If",For:"For",In:"In",Is:"Is",NotIn:"NotIn",Else:"Else",EndIf:"EndIf",ElseIf:"ElseIf",EndFor:"EndFor",And:"And",Or:"Or",Not:"UnaryOperator"}),KEYWORDS=Object.freeze({set:TOKEN_TYPES.Set,for:TOKEN_TYPES.For,in:TOKEN_TYPES.In,is:TOKEN_TYPES.Is,if:TOKEN_TYPES.If,else:TOKEN_TYPES.Else,endif:TOKEN_TYPES.EndIf,elif:TOKEN_TYPES.ElseIf,endfor:TOKEN_TYPES.EndFor,and:TOKEN_TYPES.And,or:TOKEN_TYPES.Or,not:TOKEN_TYPES.Not,"not in":TOKEN_TYPES.NotIn,true:TOKEN_TYPES.BooleanLiteral,false:TOKEN_TYPES.BooleanLiteral}),Token=class{constructor(F,w){this.value=F,this.type=w}};function isWord(F){return/\w/.test(F)}function isInteger(F){return/[0-9]/.test(F)}var ORDERED_MAPPING_TABLE=[["{%",TOKEN_TYPES.OpenStatement],["%}",TOKEN_TYPES.CloseStatement],["{{",TOKEN_TYPES.OpenExpression],["}}",TOKEN_TYPES.CloseExpression],["(",TOKEN_TYPES.OpenParen],[")",TOKEN_TYPES.CloseParen],["{",TOKEN_TYPES.OpenCurlyBracket],["}",TOKEN_TYPES.CloseCurlyBracket],["[",TOKEN_TYPES.OpenSquareBracket],["]",TOKEN_TYPES.CloseSquareBracket],[",",TOKEN_TYPES.Comma],[".",TOKEN_TYPES.Dot],[":",TOKEN_TYPES.Colon],["|",TOKEN_TYPES.Pipe],["<=",TOKEN_TYPES.ComparisonBinaryOperator],[">=",TOKEN_TYPES.ComparisonBinaryOperator],["==",TOKEN_TYPES.ComparisonBinaryOperator],["!=",TOKEN_TYPES.ComparisonBinaryOperator],["<",TOKEN_TYPES.ComparisonBinaryOperator],[">",TOKEN_TYPES.ComparisonBinaryOperator],["+",TOKEN_TYPES.AdditiveBinaryOperator],["-",TOKEN_TYPES.AdditiveBinaryOperator],["*",TOKEN_TYPES.MultiplicativeBinaryOperator],["/",TOKEN_TYPES.MultiplicativeBinaryOperator],["%",TOKEN_TYPES.MultiplicativeBinaryOperator],["=",TOKEN_TYPES.Equals]],ESCAPE_CHARACTERS=new Map([["n",`
`],["t","	"],["r","\r"],["b","\b"],["f","\f"],["v","\v"],["'","'"],['"','"'],["\\","\\"]]);function preprocess(F,w={}){return F.endsWith(`
`)&&(F=F.slice(0,-1)),F=F.replace(/{#.*?#}/gs,"{##}"),w.lstrip_blocks&&(F=F.replace(/^[ \t]*({[#%])/gm,"$1")),w.trim_blocks&&(F=F.replace(/([#%]})\n/g,"$1")),F.replace(/{##}/g,"").replace(/-%}\s*/g,"%}").replace(/\s*{%-/g,"{%").replace(/-}}\s*/g,"}}").replace(/\s*{{-/g,"{{")}function tokenize(F,w={}){const D=[],O=preprocess(F,w);let U=0;const G=q=>{let K="";for(;q(O[U]);){if(O[U]==="\\"){if(++U,U>=O.length)throw new SyntaxError("Unexpected end of input");const ee=O[U++],Z=ESCAPE_CHARACTERS.get(ee);if(Z===void 0)throw new SyntaxError(`Unexpected escaped character: ${ee}`);K+=Z;continue}if(K+=O[U++],U>=O.length)throw new SyntaxError("Unexpected end of input")}return K};e:for(;U<O.length;){const q=D.at(-1)?.type;if(q===void 0||q===TOKEN_TYPES.CloseStatement||q===TOKEN_TYPES.CloseExpression){let ee="";for(;U<O.length&&!(O[U]==="{"&&(O[U+1]==="%"||O[U+1]==="{"));)ee+=O[U++];if(ee.length>0){D.push(new Token(ee,TOKEN_TYPES.Text));continue}}G(ee=>/\s/.test(ee));const K=O[U];if(K==="-"||K==="+"){const ee=D.at(-1)?.type;if(ee===TOKEN_TYPES.Text||ee===void 0)throw new SyntaxError(`Unexpected character: ${K}`);switch(ee){case TOKEN_TYPES.Identifier:case TOKEN_TYPES.NumericLiteral:case TOKEN_TYPES.BooleanLiteral:case TOKEN_TYPES.StringLiteral:case TOKEN_TYPES.CloseParen:case TOKEN_TYPES.CloseSquareBracket:break;default:{++U;const Z=G(isInteger);D.push(new Token(`${K}${Z}`,Z.length>0?TOKEN_TYPES.NumericLiteral:TOKEN_TYPES.UnaryOperator));continue}}}for(const[ee,Z]of ORDERED_MAPPING_TABLE)if(O.slice(U,U+ee.length)===ee){D.push(new Token(ee,Z)),U+=ee.length;continue e}if(K==="'"||K==='"'){++U;const ee=G(Z=>Z!==K);D.push(new Token(ee,TOKEN_TYPES.StringLiteral)),++U;continue}if(isInteger(K)){const ee=G(isInteger);D.push(new Token(ee,TOKEN_TYPES.NumericLiteral));continue}if(isWord(K)){const ee=G(isWord),Z=Object.hasOwn(KEYWORDS,ee)?KEYWORDS[ee]:TOKEN_TYPES.Identifier;Z===TOKEN_TYPES.In&&D.at(-1)?.type===TOKEN_TYPES.Not?(D.pop(),D.push(new Token("not in",TOKEN_TYPES.NotIn))):D.push(new Token(ee,Z));continue}throw new SyntaxError(`Unexpected character: ${K}`)}return D}var Statement=class{type="Statement"},Program=class extends Statement{constructor(F){super(),this.body=F}type="Program"},If=class extends Statement{constructor(F,w,D){super(),this.test=F,this.body=w,this.alternate=D}type="If"},For=class extends Statement{constructor(F,w,D){super(),this.loopvar=F,this.iterable=w,this.body=D}type="For"},SetStatement=class extends Statement{constructor(F,w){super(),this.assignee=F,this.value=w}type="Set"},Expression=class extends Statement{type="Expression"},MemberExpression=class extends Expression{constructor(F,w,D){super(),this.object=F,this.property=w,this.computed=D}type="MemberExpression"},CallExpression=class extends Expression{constructor(F,w){super(),this.callee=F,this.args=w}type="CallExpression"},Identifier=class extends Expression{constructor(F){super(),this.value=F}type="Identifier"},Literal=class extends Expression{constructor(F){super(),this.value=F}type="Literal"},NumericLiteral=class extends Literal{type="NumericLiteral"},StringLiteral=class extends Literal{type="StringLiteral"},BooleanLiteral=class extends Literal{type="BooleanLiteral"},ArrayLiteral=class extends Literal{type="ArrayLiteral"},TupleLiteral=class extends Literal{type="TupleLiteral"},ObjectLiteral=class extends Literal{type="ObjectLiteral"},BinaryExpression=class extends Expression{constructor(F,w,D){super(),this.operator=F,this.left=w,this.right=D}type="BinaryExpression"},FilterExpression=class extends Expression{constructor(F,w){super(),this.operand=F,this.filter=w}type="FilterExpression"},TestExpression=class extends Expression{constructor(F,w,D){super(),this.operand=F,this.negate=w,this.test=D}type="TestExpression"},UnaryExpression=class extends Expression{constructor(F,w){super(),this.operator=F,this.argument=w}type="UnaryExpression"},SliceExpression=class extends Expression{constructor(F=void 0,w=void 0,D=void 0){super(),this.start=F,this.stop=w,this.step=D}type="SliceExpression"},KeywordArgumentExpression=class extends Expression{constructor(F,w){super(),this.key=F,this.value=w}type="KeywordArgumentExpression"};function parse(F){const w=new Program([]);let D=0;function O(Pe,Ce){const Be=F[D++];if(!Be||Be.type!==Pe)throw new Error(`Parser Error: ${Ce}. ${Be.type} !== ${Pe}.`);return Be}function U(){switch(F[D].type){case TOKEN_TYPES.Text:return K();case TOKEN_TYPES.OpenStatement:return ee();case TOKEN_TYPES.OpenExpression:return Z();default:throw new SyntaxError(`Unexpected token type: ${F[D].type}`)}}function G(...Pe){return D+Pe.length<=F.length&&Pe.some((Ce,Be)=>Ce!==F[D+Be].type)}function q(...Pe){return D+Pe.length<=F.length&&Pe.every((Ce,Be)=>Ce===F[D+Be].type)}function K(){return new StringLiteral(O(TOKEN_TYPES.Text,"Expected text token").value)}function ee(){O(TOKEN_TYPES.OpenStatement,"Expected opening statement token");let Pe;switch(F[D].type){case TOKEN_TYPES.Set:++D,Pe=ie(),O(TOKEN_TYPES.CloseStatement,"Expected closing statement token");break;case TOKEN_TYPES.If:++D,Pe=Y(),O(TOKEN_TYPES.OpenStatement,"Expected {% token"),O(TOKEN_TYPES.EndIf,"Expected endif token"),O(TOKEN_TYPES.CloseStatement,"Expected %} token");break;case TOKEN_TYPES.For:++D,Pe=ne(),O(TOKEN_TYPES.OpenStatement,"Expected {% token"),O(TOKEN_TYPES.EndFor,"Expected endfor token"),O(TOKEN_TYPES.CloseStatement,"Expected %} token");break;default:throw new SyntaxError(`Unknown statement type: ${F[D].type}`)}return Pe}function Z(){O(TOKEN_TYPES.OpenExpression,"Expected opening expression token");const Pe=se();return O(TOKEN_TYPES.CloseExpression,"Expected closing expression token"),Pe}function ie(){const Pe=se();if(q(TOKEN_TYPES.Equals)){++D;const Ce=ie();return new SetStatement(Pe,Ce)}return Pe}function Y(){const Pe=se();O(TOKEN_TYPES.CloseStatement,"Expected closing statement token");const Ce=[],Be=[];for(;!(F[D]?.type===TOKEN_TYPES.OpenStatement&&(F[D+1]?.type===TOKEN_TYPES.ElseIf||F[D+1]?.type===TOKEN_TYPES.Else||F[D+1]?.type===TOKEN_TYPES.EndIf));)Ce.push(U());if(F[D]?.type===TOKEN_TYPES.OpenStatement&&F[D+1]?.type!==TOKEN_TYPES.EndIf)if(++D,q(TOKEN_TYPES.ElseIf))O(TOKEN_TYPES.ElseIf,"Expected elseif token"),Be.push(Y());else for(O(TOKEN_TYPES.Else,"Expected else token"),O(TOKEN_TYPES.CloseStatement,"Expected closing statement token");!(F[D]?.type===TOKEN_TYPES.OpenStatement&&F[D+1]?.type===TOKEN_TYPES.EndIf);)Be.push(U());return new If(Pe,Ce,Be)}function W(Pe=!1){const Ce=Pe?Oe:se,Be=[Ce()],ze=q(TOKEN_TYPES.Comma);for(;ze&&(++D,Be.push(Ce()),!!q(TOKEN_TYPES.Comma)););return ze?new TupleLiteral(Be):Be[0]}function ne(){const Pe=W(!0);if(!(Pe instanceof Identifier||Pe instanceof TupleLiteral))throw new SyntaxError(`Expected identifier/tuple for the loop variable, got ${Pe.type} instead`);O(TOKEN_TYPES.In,"Expected `in` keyword following loop variable");const Ce=se();O(TOKEN_TYPES.CloseStatement,"Expected closing statement token");const Be=[];for(;G(TOKEN_TYPES.OpenStatement,TOKEN_TYPES.EndFor);)Be.push(U());return new For(Pe,Ce,Be)}function se(){return le()}function le(){const Pe=ce();if(q(TOKEN_TYPES.If)){++D;const Ce=ce();O(TOKEN_TYPES.Else,"Expected else token");const Be=ce();return new If(Ce,[Pe],[Be])}return Pe}function ce(){let Pe=he();for(;q(TOKEN_TYPES.Or);){const Ce=F[D];++D;const Be=he();Pe=new BinaryExpression(Ce,Pe,Be)}return Pe}function he(){let Pe=pe();for(;q(TOKEN_TYPES.And);){const Ce=F[D];++D;const Be=pe();Pe=new BinaryExpression(Ce,Pe,Be)}return Pe}function pe(){let Pe;for(;q(TOKEN_TYPES.Not);){const Ce=F[D];++D;const Be=pe();Pe=new UnaryExpression(Ce,Be)}return Pe??me()}function me(){let Pe=be();for(;q(TOKEN_TYPES.ComparisonBinaryOperator)||q(TOKEN_TYPES.In)||q(TOKEN_TYPES.NotIn);){const Ce=F[D];++D;const Be=be();Pe=new BinaryExpression(Ce,Pe,Be)}return Pe}function be(){let Pe=Re();for(;q(TOKEN_TYPES.AdditiveBinaryOperator);){const Ce=F[D];++D;const Be=Re();Pe=new BinaryExpression(Ce,Pe,Be)}return Pe}function ge(){const Pe=we();return q(TOKEN_TYPES.OpenParen)?ve(Pe):Pe}function ve(Pe){let Ce=new CallExpression(Pe,Se());return q(TOKEN_TYPES.OpenParen)&&(Ce=ve(Ce)),Ce}function Se(){O(TOKEN_TYPES.OpenParen,"Expected opening parenthesis for arguments list");const Pe=Me();return O(TOKEN_TYPES.CloseParen,"Expected closing parenthesis for arguments list"),Pe}function Me(){const Pe=[];for(;!q(TOKEN_TYPES.CloseParen);){let Ce=se();if(q(TOKEN_TYPES.Equals)){if(++D,!(Ce instanceof Identifier))throw new SyntaxError("Expected identifier for keyword argument");const Be=se();Ce=new KeywordArgumentExpression(Ce,Be)}Pe.push(Ce),q(TOKEN_TYPES.Comma)&&++D}return Pe}function Ee(){const Pe=[];let Ce=!1;for(;!q(TOKEN_TYPES.CloseSquareBracket);)q(TOKEN_TYPES.Colon)?(Pe.push(void 0),++D,Ce=!0):(Pe.push(se()),q(TOKEN_TYPES.Colon)&&(++D,Ce=!0));if(Pe.length===0)throw new SyntaxError("Expected at least one argument for member/slice expression");if(Ce){if(Pe.length>3)throw new SyntaxError("Expected 0-3 arguments for slice expression");return new SliceExpression(...Pe)}return Pe[0]}function we(){let Pe=Oe();for(;q(TOKEN_TYPES.Dot)||q(TOKEN_TYPES.OpenSquareBracket);){const Ce=F[D];++D;let Be;const ze=Ce.type!==TOKEN_TYPES.Dot;if(ze)Be=Ee(),O(TOKEN_TYPES.CloseSquareBracket,"Expected closing square bracket");else if(Be=Oe(),Be.type!=="Identifier")throw new SyntaxError("Expected identifier following dot operator");Pe=new MemberExpression(Pe,Be,ze)}return Pe}function Re(){let Pe=Le();for(;q(TOKEN_TYPES.MultiplicativeBinaryOperator);){const Ce=F[D];++D;const Be=Le();Pe=new BinaryExpression(Ce,Pe,Be)}return Pe}function Le(){let Pe=Ne();for(;q(TOKEN_TYPES.Is);){++D;const Ce=q(TOKEN_TYPES.Not);Ce&&++D;let Be=Oe();if(Be instanceof BooleanLiteral&&(Be=new Identifier(Be.value.toString())),!(Be instanceof Identifier))throw new SyntaxError("Expected identifier for the test");Pe=new TestExpression(Pe,Ce,Be)}return Pe}function Ne(){let Pe=ge();for(;q(TOKEN_TYPES.Pipe);){++D;let Ce=Oe();if(!(Ce instanceof Identifier))throw new SyntaxError("Expected identifier for the filter");q(TOKEN_TYPES.OpenParen)&&(Ce=ve(Ce)),Pe=new FilterExpression(Pe,Ce)}return Pe}function Oe(){const Pe=F[D];switch(Pe.type){case TOKEN_TYPES.NumericLiteral:return++D,new NumericLiteral(Number(Pe.value));case TOKEN_TYPES.StringLiteral:return++D,new StringLiteral(Pe.value);case TOKEN_TYPES.BooleanLiteral:return++D,new BooleanLiteral(Pe.value==="true");case TOKEN_TYPES.Identifier:return++D,new Identifier(Pe.value);case TOKEN_TYPES.OpenParen:{++D;const Ce=W();if(F[D].type!==TOKEN_TYPES.CloseParen)throw new SyntaxError(`Expected closing parenthesis, got ${F[D].type} instead`);return++D,Ce}case TOKEN_TYPES.OpenSquareBracket:{++D;const Ce=[];for(;!q(TOKEN_TYPES.CloseSquareBracket);)Ce.push(se()),q(TOKEN_TYPES.Comma)&&++D;return++D,new ArrayLiteral(Ce)}case TOKEN_TYPES.OpenCurlyBracket:{++D;const Ce=new Map;for(;!q(TOKEN_TYPES.CloseCurlyBracket);){const Be=se();O(TOKEN_TYPES.Colon,"Expected colon between key and value in object literal");const ze=se();Ce.set(Be,ze),q(TOKEN_TYPES.Comma)&&++D}return++D,new ObjectLiteral(Ce)}default:throw new SyntaxError(`Unexpected token: ${Pe.type}`)}}for(;D<F.length;)w.body.push(U());return w}function range(F,w,D=1){w===void 0&&(w=F,F=0);const O=[];for(let U=F;U<w;U+=D)O.push(U);return O}function slice(F,w,D,O=1){const U=Math.sign(O);U>=0?(w=(w??=0)<0?Math.max(F.length+w,0):Math.min(w,F.length),D=(D??=F.length)<0?Math.max(F.length+D,0):Math.min(D,F.length)):(w=(w??=F.length-1)<0?Math.max(F.length+w,-1):Math.min(w,F.length-1),D=(D??=-1)<-1?Math.max(F.length+D,-1):Math.min(D,F.length-1));const G=[];for(let q=w;U*q<U*D;q+=O)G.push(F[q]);return G}function titleCase(F){return F.replace(/\b\w/g,w=>w.toUpperCase())}var RuntimeValue=class{type="RuntimeValue";value;builtins=new Map;constructor(F=void 0){this.value=F}__bool__(){return new BooleanValue(!!this.value)}},NumericValue=class extends RuntimeValue{type="NumericValue"},StringValue=class extends RuntimeValue{type="StringValue";builtins=new Map([["upper",new FunctionValue(()=>new StringValue(this.value.toUpperCase()))],["lower",new FunctionValue(()=>new StringValue(this.value.toLowerCase()))],["strip",new FunctionValue(()=>new StringValue(this.value.trim()))],["title",new FunctionValue(()=>new StringValue(titleCase(this.value)))],["length",new NumericValue(this.value.length)]])},BooleanValue=class extends RuntimeValue{type="BooleanValue"},ObjectValue=class extends RuntimeValue{type="ObjectValue";__bool__(){return new BooleanValue(this.value.size>0)}builtins=new Map([["get",new FunctionValue(([F,w])=>{if(!(F instanceof StringValue))throw new Error(`Object key must be a string: got ${F.type}`);return this.value.get(F.value)??w??new NullValue})],["items",new FunctionValue(()=>new ArrayValue(Array.from(this.value.entries()).map(([F,w])=>new ArrayValue([new StringValue(F),w]))))]])},ArrayValue=class extends RuntimeValue{type="ArrayValue";builtins=new Map([["length",new NumericValue(this.value.length)]]);__bool__(){return new BooleanValue(this.value.length>0)}},TupleValue=class extends ArrayValue{type="TupleValue"},FunctionValue=class extends RuntimeValue{type="FunctionValue"},NullValue=class extends RuntimeValue{type="NullValue"},UndefinedValue=class extends RuntimeValue{type="UndefinedValue"},Environment=class{constructor(F){this.parent=F}variables=new Map([["namespace",new FunctionValue(F=>{if(F.length===0)return new ObjectValue(new Map);if(F.length!==1||!(F[0]instanceof ObjectValue))throw new Error("`namespace` expects either zero arguments or a single object argument");return F[0]})]]);tests=new Map([["boolean",F=>F.type==="BooleanValue"],["callable",F=>F instanceof FunctionValue],["odd",F=>{if(F.type!=="NumericValue")throw new Error(`Cannot apply test "odd" to type: ${F.type}`);return F.value%2!==0}],["even",F=>{if(F.type!=="NumericValue")throw new Error(`Cannot apply test "even" to type: ${F.type}`);return F.value%2===0}],["false",F=>F.type==="BooleanValue"&&!F.value],["true",F=>F.type==="BooleanValue"&&F.value],["number",F=>F.type==="NumericValue"],["integer",F=>F.type==="NumericValue"&&Number.isInteger(F.value)],["iterable",F=>F instanceof ArrayValue||F instanceof StringValue],["lower",F=>{const w=F.value;return F.type==="StringValue"&&w===w.toLowerCase()}],["upper",F=>{const w=F.value;return F.type==="StringValue"&&w===w.toUpperCase()}],["none",F=>F.type==="NullValue"],["defined",F=>F.type!=="UndefinedValue"],["undefined",F=>F.type==="UndefinedValue"],["equalto",(F,w)=>F.value===w.value]]);set(F,w){return this.declareVariable(F,convertToRuntimeValues(w))}declareVariable(F,w){if(this.variables.has(F))throw new SyntaxError(`Variable already declared: ${F}`);return this.variables.set(F,w),w}setVariable(F,w){return this.variables.set(F,w),w}resolve(F){if(this.variables.has(F))return this;if(this.parent)return this.parent.resolve(F);throw new Error(`Unknown variable: ${F}`)}lookupVariable(F){try{return this.resolve(F).variables.get(F)??new UndefinedValue}catch{return new UndefinedValue}}},Interpreter=class{global;constructor(F){this.global=F??new Environment}run(F){return this.evaluate(F,this.global)}evaluateBinaryExpression(F,w){const D=this.evaluate(F.left,w);switch(F.operator.value){case"and":return D.__bool__().value?this.evaluate(F.right,w):D;case"or":return D.__bool__().value?D:this.evaluate(F.right,w)}const O=this.evaluate(F.right,w);switch(F.operator.value){case"==":return new BooleanValue(D.value==O.value);case"!=":return new BooleanValue(D.value!=O.value)}if(D instanceof UndefinedValue||O instanceof UndefinedValue)throw new Error("Cannot perform operation on undefined values");if(D instanceof NullValue||O instanceof NullValue)throw new Error("Cannot perform operation on null values");if(D instanceof NumericValue&&O instanceof NumericValue)switch(F.operator.value){case"+":return new NumericValue(D.value+O.value);case"-":return new NumericValue(D.value-O.value);case"*":return new NumericValue(D.value*O.value);case"/":return new NumericValue(D.value/O.value);case"%":return new NumericValue(D.value%O.value);case"<":return new BooleanValue(D.value<O.value);case">":return new BooleanValue(D.value>O.value);case">=":return new BooleanValue(D.value>=O.value);case"<=":return new BooleanValue(D.value<=O.value)}else if(D instanceof ArrayValue&&O instanceof ArrayValue)switch(F.operator.value){case"+":return new ArrayValue(D.value.concat(O.value))}else if(O instanceof ArrayValue){const U=O.value.find(G=>G.value===D.value)!==void 0;switch(F.operator.value){case"in":return new BooleanValue(U);case"not in":return new BooleanValue(!U)}}if(D instanceof StringValue||O instanceof StringValue)switch(F.operator.value){case"+":return new StringValue(D.value.toString()+O.value.toString())}if(D instanceof StringValue&&O instanceof StringValue)switch(F.operator.value){case"in":return new BooleanValue(O.value.includes(D.value));case"not in":return new BooleanValue(!O.value.includes(D.value))}if(D instanceof StringValue&&O instanceof ObjectValue)switch(F.operator.value){case"in":return new BooleanValue(O.value.has(D.value));case"not in":return new BooleanValue(!O.value.has(D.value))}throw new SyntaxError(`Unknown operator "${F.operator.value}" between ${D.type} and ${O.type}`)}evaluateFilterExpression(F,w){const D=this.evaluate(F.operand,w);if(F.filter.type==="Identifier"){const O=F.filter;if(D instanceof ArrayValue)switch(O.value){case"list":return D;case"first":return D.value[0];case"last":return D.value[D.value.length-1];case"length":return new NumericValue(D.value.length);case"reverse":return new ArrayValue(D.value.reverse());case"sort":return new ArrayValue(D.value.sort((U,G)=>{if(U.type!==G.type)throw new Error(`Cannot compare different types: ${U.type} and ${G.type}`);switch(U.type){case"NumericValue":return U.value-G.value;case"StringValue":return U.value.localeCompare(G.value);default:throw new Error(`Cannot compare type: ${U.type}`)}}));default:throw new Error(`Unknown ArrayValue filter: ${O.value}`)}else if(D instanceof StringValue)switch(O.value){case"length":return new NumericValue(D.value.length);case"upper":return new StringValue(D.value.toUpperCase());case"lower":return new StringValue(D.value.toLowerCase());case"title":return new StringValue(titleCase(D.value));case"capitalize":return new StringValue(D.value.charAt(0).toUpperCase()+D.value.slice(1));case"trim":return new StringValue(D.value.trim());default:throw new Error(`Unknown StringValue filter: ${O.value}`)}else if(D instanceof NumericValue)switch(O.value){case"abs":return new NumericValue(Math.abs(D.value));default:throw new Error(`Unknown NumericValue filter: ${O.value}`)}else if(D instanceof ObjectValue)switch(O.value){case"items":return new ArrayValue(Array.from(D.value.entries()).map(([U,G])=>new ArrayValue([new StringValue(U),G])));case"length":return new NumericValue(D.value.size);default:throw new Error(`Unknown ObjectValue filter: ${O.value}`)}throw new Error(`Cannot apply filter "${O.value}" to type: ${D.type}`)}else if(F.filter.type==="CallExpression"){const O=F.filter;if(O.callee.type!=="Identifier")throw new Error(`Unknown filter: ${O.callee.type}`);const U=O.callee.value;if(D instanceof ArrayValue){switch(U){case"selectattr":{if(D.value.some(ie=>!(ie instanceof ObjectValue)))throw new Error("`selectattr` can only be applied to array of objects");if(O.args.some(ie=>ie.type!=="StringLiteral"))throw new Error("arguments of `selectattr` must be strings");const[G,q,K]=O.args.map(ie=>this.evaluate(ie,w));let ee;if(q){const ie=w.tests.get(q.value);if(!ie)throw new Error(`Unknown test: ${q.value}`);ee=ie}else ee=(...ie)=>ie[0].__bool__().value;const Z=D.value.filter(ie=>{const Y=ie.value.get(G.value);return Y?ee(Y,K):!1});return new ArrayValue(Z)}}throw new Error(`Unknown ArrayValue filter: ${U}`)}else throw new Error(`Cannot apply filter "${U}" to type: ${D.type}`)}throw new Error(`Unknown filter: ${F.filter.type}`)}evaluateTestExpression(F,w){const D=this.evaluate(F.operand,w),O=w.tests.get(F.test.value);if(!O)throw new Error(`Unknown test: ${F.test.value}`);const U=O(D);return new BooleanValue(F.negate?!U:U)}evaluateUnaryExpression(F,w){const D=this.evaluate(F.argument,w);switch(F.operator.value){case"not":return new BooleanValue(!D.value);default:throw new SyntaxError(`Unknown operator: ${F.operator.value}`)}}evalProgram(F,w){return this.evaluateBlock(F.body,w)}evaluateBlock(F,w){let D="";for(const O of F){const U=this.evaluate(O,w);U.type!=="NullValue"&&U.type!=="UndefinedValue"&&(D+=U.value)}return new StringValue(D)}evaluateIdentifier(F,w){return w.lookupVariable(F.value)}evaluateCallExpression(F,w){const D=[],O=new Map;for(const G of F.args)if(G.type==="KeywordArgumentExpression"){const q=G;O.set(q.key.value,this.evaluate(q.value,w))}else D.push(this.evaluate(G,w));O.size>0&&D.push(new ObjectValue(O));const U=this.evaluate(F.callee,w);if(U.type!=="FunctionValue")throw new Error(`Cannot call something that is not a function: got ${U.type}`);return U.value(D,w)}evaluateSliceExpression(F,w,D){if(!(F instanceof ArrayValue||F instanceof StringValue))throw new Error("Slice object must be an array or string");const O=this.evaluate(w.start,D),U=this.evaluate(w.stop,D),G=this.evaluate(w.step,D);if(!(O instanceof NumericValue||O instanceof UndefinedValue))throw new Error("Slice start must be numeric or undefined");if(!(U instanceof NumericValue||U instanceof UndefinedValue))throw new Error("Slice stop must be numeric or undefined");if(!(G instanceof NumericValue||G instanceof UndefinedValue))throw new Error("Slice step must be numeric or undefined");return F instanceof ArrayValue?new ArrayValue(slice(F.value,O.value,U.value,G.value)):new StringValue(slice(Array.from(F.value),O.value,U.value,G.value).join(""))}evaluateMemberExpression(F,w){const D=this.evaluate(F.object,w);let O;if(F.computed){if(F.property.type==="SliceExpression")return this.evaluateSliceExpression(D,F.property,w);O=this.evaluate(F.property,w)}else O=new StringValue(F.property.value);let U;if(D instanceof ObjectValue){if(!(O instanceof StringValue))throw new Error(`Cannot access property with non-string: got ${O.type}`);U=D.value.get(O.value)??D.builtins.get(O.value)}else if(D instanceof ArrayValue||D instanceof StringValue)if(O instanceof NumericValue)U=D.value.at(O.value),D instanceof StringValue&&(U=new StringValue(D.value.at(O.value)));else if(O instanceof StringValue)U=D.builtins.get(O.value);else throw new Error(`Cannot access property with non-string/non-number: got ${O.type}`);else{if(!(O instanceof StringValue))throw new Error(`Cannot access property with non-string: got ${O.type}`);U=D.builtins.get(O.value)}return U instanceof RuntimeValue?U:new UndefinedValue}evaluateSet(F,w){const D=this.evaluate(F.value,w);if(F.assignee.type==="Identifier"){const O=F.assignee.value;w.setVariable(O,D)}else if(F.assignee.type==="MemberExpression"){const O=F.assignee,U=this.evaluate(O.object,w);if(!(U instanceof ObjectValue))throw new Error("Cannot assign to member of non-object");if(O.property.type!=="Identifier")throw new Error("Cannot assign to member with non-identifier property");U.value.set(O.property.value,D)}else throw new Error(`Invalid LHS inside assignment expression: ${JSON.stringify(F.assignee)}`);return new NullValue}evaluateIf(F,w){const D=this.evaluate(F.test,w);return this.evaluateBlock(D.__bool__().value?F.body:F.alternate,w)}evaluateFor(F,w){const D=new Environment(w),O=this.evaluate(F.iterable,D);if(!(O instanceof ArrayValue))throw new Error(`Expected iterable type in for loop: got ${O.type}`);let U="";for(let G=0;G<O.value.length;++G){const q=new Map([["index",new NumericValue(G+1)],["index0",new NumericValue(G)],["revindex",new NumericValue(O.value.length-G)],["revindex0",new NumericValue(O.value.length-G-1)],["first",new BooleanValue(G===0)],["last",new BooleanValue(G===O.value.length-1)],["length",new NumericValue(O.value.length)],["previtem",G>0?O.value[G-1]:new UndefinedValue],["nextitem",G<O.value.length-1?O.value[G+1]:new UndefinedValue]]);D.setVariable("loop",new ObjectValue(q));const K=O.value[G];if(F.loopvar.type==="Identifier")D.setVariable(F.loopvar.value,K);else if(F.loopvar.type==="TupleLiteral"){const Z=F.loopvar;if(K.type!=="ArrayValue")throw new Error(`Cannot unpack non-iterable type: ${K.type}`);const ie=K;if(Z.value.length!==ie.value.length)throw new Error(`Too ${Z.value.length>ie.value.length?"few":"many"} items to unpack`);for(let Y=0;Y<Z.value.length;++Y){if(Z.value[Y].type!=="Identifier")throw new Error(`Cannot unpack non-identifier type: ${Z.value[Y].type}`);D.setVariable(Z.value[Y].value,ie.value[Y])}}const ee=this.evaluateBlock(F.body,D);U+=ee.value}return new StringValue(U)}evaluate(F,w){if(F===void 0)return new UndefinedValue;switch(F.type){case"Program":return this.evalProgram(F,w);case"Set":return this.evaluateSet(F,w);case"If":return this.evaluateIf(F,w);case"For":return this.evaluateFor(F,w);case"NumericLiteral":return new NumericValue(Number(F.value));case"StringLiteral":return new StringValue(F.value);case"BooleanLiteral":return new BooleanValue(F.value);case"ArrayLiteral":return new ArrayValue(F.value.map(D=>this.evaluate(D,w)));case"TupleLiteral":return new TupleValue(F.value.map(D=>this.evaluate(D,w)));case"ObjectLiteral":{const D=new Map;for(const[O,U]of F.value){const G=this.evaluate(O,w);if(!(G instanceof StringValue))throw new Error(`Object keys must be strings: got ${G.type}`);D.set(G.value,this.evaluate(U,w))}return new ObjectValue(D)}case"Identifier":return this.evaluateIdentifier(F,w);case"CallExpression":return this.evaluateCallExpression(F,w);case"MemberExpression":return this.evaluateMemberExpression(F,w);case"UnaryExpression":return this.evaluateUnaryExpression(F,w);case"BinaryExpression":return this.evaluateBinaryExpression(F,w);case"FilterExpression":return this.evaluateFilterExpression(F,w);case"TestExpression":return this.evaluateTestExpression(F,w);default:throw new SyntaxError(`Unknown node type: ${F.type}`)}}};function convertToRuntimeValues(F){switch(typeof F){case"number":return new NumericValue(F);case"string":return new StringValue(F);case"boolean":return new BooleanValue(F);case"object":return F===null?new NullValue:Array.isArray(F)?new ArrayValue(F.map(convertToRuntimeValues)):new ObjectValue(new Map(Object.entries(F).map(([w,D])=>[w,convertToRuntimeValues(D)])));case"function":return new FunctionValue((w,D)=>{const O=F(...w.map(U=>U.value))??null;return convertToRuntimeValues(O)});default:throw new Error(`Cannot convert to runtime value: ${F}`)}}var Template=class{parsed;constructor(F){const w=tokenize(F,{lstrip_blocks:!0,trim_blocks:!0});this.parsed=parse(w)}render(F){const w=new Environment;w.set("false",!1),w.set("true",!0),w.set("raise_exception",U=>{throw new Error(U)}),w.set("range",range);for(const[U,G]of Object.entries(F))w.set(U,G);return new Interpreter(w).run(this.parsed).value}};async function loadTokenizer(F,w){const D=await Promise.all([getModelJSON(F,"tokenizer.json",!0,w),getModelJSON(F,"tokenizer_config.json",!0,w)]);return w.legacy!==null&&(D[1].legacy=w.legacy),D}function regexSplit(F,w){const D=[];let O=0;for(const U of F.matchAll(w)){const G=U[0];O<U.index&&D.push(F.slice(O,U.index)),G.length>0&&D.push(G),O=U.index+G.length}return O<F.length&&D.push(F.slice(O)),D}function createPattern(F,w=!0){if(F.Regex!==void 0){let D=F.Regex.replace(/\\([#&~])/g,"$1");for(const[O,U]of PROBLEMATIC_REGEX_MAP)D=D.replaceAll(O,U);return new RegExp(D,"gu")}else if(F.String!==void 0){const D=escapeRegExp(F.String);return new RegExp(w?D:`(${D})`,"gu")}else return console.warn("Unknown pattern type:",F),null}function objectToMap(F){return new Map(Object.entries(F))}function prepareTensorForDecode(F){const w=F.dims;switch(w.length){case 1:return F.tolist();case 2:if(w[0]!==1)throw new Error("Unable to decode tensor with `batch size !== 1`. Use `tokenizer.batch_decode(...)` for batched inputs.");return F.tolist()[0];default:throw new Error(`Expected tensor to have 1-2 dimensions, got ${w.length}.`)}}function clean_up_tokenization(F){return F.replace(/ \./g,".").replace(/ \?/g,"?").replace(/ \!/g,"!").replace(/ ,/g,",").replace(/ \' /g,"'").replace(/ n\'t/g,"n't").replace(/ \'m/g,"'m").replace(/ \'s/g,"'s").replace(/ \'ve/g,"'ve").replace(/ \'re/g,"'re")}function remove_accents(F){return F.replace(/[\u0300-\u036f]/g,"")}function lowercase_and_remove_accent(F){return remove_accents(F.toLowerCase())}function fuse(F,w,D){const O=[];let U=0;for(;U<F.length;){if(O.push(F[U]),(D.get(F[U])??w)!==w){++U;continue}for(;U<F.length&&(D.get(F[U])??w)===w;)++U}return O}function whitespace_split(F){return F.match(/\S+/g)||[]}const PUNCTUATION_REGEX="\\p{P}\\u0021-\\u002F\\u003A-\\u0040\\u005B-\\u0060\\u007B-\\u007E",PROBLEMATIC_REGEX_MAP=new Map([["(?i:'s|'t|'re|'ve|'m|'ll|'d)","(?:'([sS]|[tT]|[rR][eE]|[vV][eE]|[mM]|[lL][lL]|[dD]))"]]);class AddedToken{constructor(w){this.content=w.content,this.id=w.id,this.single_word=w.single_word??!1,this.lstrip=w.lstrip??!1,this.rstrip=w.rstrip??!1,this.special=w.special??!1,this.normalized=w.normalized??null}}class TokenizerModel extends Callable{constructor(w){super(),this.config=w,this.vocab=[],this.tokens_to_ids=new Map,this.unk_token_id=void 0,this.unk_token=void 0,this.end_of_word_suffix=void 0,this.fuse_unk=this.config.fuse_unk??!1}static fromConfig(w,...D){switch(w.type){case"WordPiece":return new WordPieceTokenizer(w);case"Unigram":return new Unigram(w,...D);case"BPE":return new BPE(w);default:if(w.vocab)return new LegacyTokenizerModel(w,...D);throw new Error(`Unknown TokenizerModel type: ${w.type}`)}}_call(w){let D=this.encode(w);return this.fuse_unk&&(D=fuse(D,this.unk_token_id,this.tokens_to_ids)),D}encode(w){throw Error("encode should be implemented in subclass.")}convert_tokens_to_ids(w){return w.map(D=>this.tokens_to_ids.get(D)??this.unk_token_id)}convert_ids_to_tokens(w){return w.map(D=>this.vocab[D]??this.unk_token)}}class WordPieceTokenizer extends TokenizerModel{constructor(w){super(w),this.tokens_to_ids=objectToMap(w.vocab),this.unk_token_id=this.tokens_to_ids.get(w.unk_token),this.unk_token=w.unk_token,this.max_input_chars_per_word=w.max_input_chars_per_word??100,this.vocab=new Array(this.tokens_to_ids.size);for(const[D,O]of this.tokens_to_ids)this.vocab[O]=D}encode(w){const D=[];for(const O of w){const U=[...O];if(U.length>this.max_input_chars_per_word){D.push(this.unk_token);continue}let G=!1,q=0;const K=[];for(;q<U.length;){let ee=U.length,Z=null;for(;q<ee;){let ie=U.slice(q,ee).join("");if(q>0&&(ie=this.config.continuing_subword_prefix+ie),this.tokens_to_ids.has(ie)){Z=ie;break}--ee}if(Z===null){G=!0;break}K.push(Z),q=ee}G?D.push(this.unk_token):D.push(...K)}return D}}class Unigram extends TokenizerModel{constructor(w,D){super(w);const O=w.vocab.length;this.vocab=new Array(O),this.scores=new Array(O);for(let U=0;U<O;++U){const G=w.vocab[U];this.vocab[U]=G[0],this.scores[U]=G[1]}this.unk_token_id=w.unk_id,this.unk_token=this.vocab[w.unk_id],this.tokens_to_ids=new Map(this.vocab.map((U,G)=>[U,G])),this.bosToken=" ",this.bosTokenId=this.tokens_to_ids.get(this.bosToken),this.eosToken=D.eos_token,this.eosTokenId=this.tokens_to_ids.get(this.eosToken),this.unkToken=this.vocab[this.unk_token_id],this.minScore=min(this.scores)[0],this.unkScore=this.minScore-10,this.scores[this.unk_token_id]=this.unkScore,this.trie=new CharTrie,this.trie.extend(this.vocab),this.fuse_unk=!0}populateNodes(w){const D=w.sentence,O=D.length;let U=0;for(;U<O;){let q=!1;for(let K of this.trie.commonPrefixSearch(D.slice(U))){const ee=this.tokens_to_ids.get(K),Z=this.scores[ee],ie=K.length;w.insert(U,ie,Z,ee),!q&&ie===1&&(q=!0)}q||w.insert(U,1,this.unkScore,this.unk_token_id),U+=1}}tokenize(w){const D=new TokenLattice(w,this.bosTokenId,this.eosTokenId);return this.populateNodes(D),D.tokens()}encode(w){const D=[];for(const O of w){const U=this.tokenize(O);D.push(...U)}return D}}const BYTES_TO_UNICODE=(()=>{const F=[...Array.from({length:94},(U,G)=>G+33),...Array.from({length:12},(U,G)=>G+161),...Array.from({length:82},(U,G)=>G+174)],w=F.slice();let D=0;for(let U=0;U<256;++U)F.includes(U)||(F.push(U),w.push(256+D),D+=1);const O=w.map(U=>String.fromCharCode(U));return Object.fromEntries(F.map((U,G)=>[U,O[G]]))})(),UNICODE_TO_BYTES=reverseDictionary(BYTES_TO_UNICODE);class BPE extends TokenizerModel{constructor(w){super(w),this.BPE_SPLIT_TOKEN=" ",this.tokens_to_ids=objectToMap(w.vocab),this.unk_token_id=this.tokens_to_ids.get(w.unk_token),this.unk_token=w.unk_token,this.vocab=new Array(this.tokens_to_ids.size);for(const[D,O]of this.tokens_to_ids)this.vocab[O]=D;this.bpe_ranks=new Map(w.merges.map((D,O)=>[D,O])),this.merges=w.merges.map(D=>D.split(this.BPE_SPLIT_TOKEN)),this.end_of_word_suffix=w.end_of_word_suffix,this.continuing_subword_suffix=w.continuing_subword_suffix??null,this.byte_fallback=this.config.byte_fallback??!1,this.byte_fallback&&(this.text_encoder=new TextEncoder),this.ignore_merges=this.config.ignore_merges??!1,this.cache=new Map}bpe(w){if(w.length===0)return[];const D=this.cache.get(w);if(D!==void 0)return D;const O=Array.from(w);this.end_of_word_suffix&&(O[O.length-1]+=this.end_of_word_suffix);let U=[];if(O.length>1){const G=new PriorityQueue((ee,Z)=>ee.score<Z.score);let q={token:O[0],bias:0,prev:null,next:null},K=q;for(let ee=1;ee<O.length;++ee){const Z={bias:ee/O.length,token:O[ee],prev:K,next:null};K.next=Z,this._add_node(G,K),K=Z}for(;!G.isEmpty();){const ee=G.pop();if(ee.deleted||!ee.next||ee.next.deleted)continue;if(ee.deleted=!0,ee.next.deleted=!0,ee.prev){const ie={...ee.prev};ee.prev.deleted=!0,ee.prev=ie,ie.prev?ie.prev.next=ie:q=ie}const Z={token:ee.token+ee.next.token,bias:ee.bias,prev:ee.prev,next:ee.next.next};Z.prev?(Z.prev.next=Z,this._add_node(G,Z.prev)):q=Z,Z.next&&(Z.next.prev=Z,this._add_node(G,Z))}for(let ee=q;ee!==null;ee=ee.next)U.push(ee.token)}else U=O;if(this.continuing_subword_suffix)for(let G=0;G<U.length-1;++G)U[G]+=this.continuing_subword_suffix;return this.cache.set(w,U),U}_add_node(w,D){const O=this.bpe_ranks.get(D.token+this.BPE_SPLIT_TOKEN+D.next.token);O!==void 0&&(D.score=O+D.bias,w.push(D))}encode(w){const D=[];for(const O of w){if(this.ignore_merges&&this.tokens_to_ids.has(O)){D.push(O);continue}const U=this.bpe(O);for(const G of U)this.tokens_to_ids.has(G)?D.push(G):this.byte_fallback?D.push(...Array.from(this.text_encoder.encode(G)).map(q=>`<0x${q.toString(16).toUpperCase().padStart(2,"0")}>`)):D.push(this.unk_token)}return D}}class LegacyTokenizerModel extends TokenizerModel{constructor(w,D){super(w),this.tokens_to_ids=objectToMap(D.target_lang?w.vocab[D.target_lang]:w.vocab),this.bos_token=D.bos_token,this.bos_token_id=this.tokens_to_ids.get(this.bos_token),this.eos_token=D.eos_token,this.eos_token_id=this.tokens_to_ids.get(this.eos_token),this.pad_token=D.pad_token,this.pad_token_id=this.tokens_to_ids.get(this.pad_token),this.unk_token=D.unk_token,this.unk_token_id=this.tokens_to_ids.get(this.unk_token),this.vocab=new Array(this.tokens_to_ids.size);for(const[O,U]of this.tokens_to_ids)this.vocab[U]=O}encode(w){return w}}class Normalizer extends Callable{constructor(w){super(),this.config=w}static fromConfig(w){if(w===null)return null;switch(w.type){case"BertNormalizer":return new BertNormalizer(w);case"Precompiled":return new Precompiled(w);case"Sequence":return new NormalizerSequence(w);case"Replace":return new Replace(w);case"NFC":return new NFC(w);case"NFKC":return new NFKC(w);case"NFKD":return new NFKD(w);case"Strip":return new StripNormalizer(w);case"StripAccents":return new StripAccents(w);case"Lowercase":return new Lowercase(w);case"Prepend":return new Prepend(w);default:throw new Error(`Unknown Normalizer type: ${w.type}`)}}normalize(w){throw Error("normalize should be implemented in subclass.")}_call(w){return this.normalize(w)}}class Replace extends Normalizer{normalize(w){const D=createPattern(this.config.pattern);return D===null?w:w.replaceAll(D,this.config.content)}}class NFC extends Normalizer{normalize(w){return w=w.normalize("NFC"),w}}class NFKC extends Normalizer{normalize(w){return w=w.normalize("NFKC"),w}}class NFKD extends Normalizer{normalize(w){return w=w.normalize("NFKD"),w}}class StripNormalizer extends Normalizer{normalize(w){return this.config.strip_left&&this.config.strip_right?w=w.trim():(this.config.strip_left&&(w=w.trimStart()),this.config.strip_right&&(w=w.trimEnd())),w}}class StripAccents extends Normalizer{normalize(w){return w=remove_accents(w),w}}class Lowercase extends Normalizer{normalize(w){return w=w.toLowerCase(),w}}class Prepend extends Normalizer{normalize(w){return w=this.config.prepend+w,w}}class NormalizerSequence extends Normalizer{constructor(w){super(w),this.normalizers=w.normalizers.map(D=>Normalizer.fromConfig(D))}normalize(w){return this.normalizers.reduce((D,O)=>O.normalize(D),w)}}class BertNormalizer extends Normalizer{_tokenize_chinese_chars(w){const D=[];for(let O=0;O<w.length;++O){const U=w[O],G=U.charCodeAt(0);this._is_chinese_char(G)?(D.push(" "),D.push(U),D.push(" ")):D.push(U)}return D.join("")}_is_chinese_char(w){return w>=19968&&w<=40959||w>=13312&&w<=19903||w>=131072&&w<=173791||w>=173824&&w<=177983||w>=177984&&w<=178207||w>=178208&&w<=183983||w>=63744&&w<=64255||w>=194560&&w<=195103}stripAccents(w){return w.normalize("NFD").replace(/[\u0300-\u036f]/g,"")}_is_control(w){switch(w){case"	":case`
`:case"\r":return!1;default:return new RegExp("^\\p{Cc}|\\p{Cf}|\\p{Co}|\\p{Cs}$","u").test(w)}}_clean_text(w){const D=[];for(const O of w){const U=O.charCodeAt(0);U===0||U===65533||this._is_control(O)||(/^\s$/.test(O)?D.push(" "):D.push(O))}return D.join("")}normalize(w){return this.config.clean_text&&(w=this._clean_text(w)),this.config.handle_chinese_chars&&(w=this._tokenize_chinese_chars(w)),this.config.lowercase?(w=w.toLowerCase(),this.config.strip_accents!==!1&&(w=this.stripAccents(w))):this.config.strip_accents&&(w=this.stripAccents(w)),w}}class PreTokenizer extends Callable{static fromConfig(w){if(w===null)return null;switch(w.type){case"BertPreTokenizer":return new BertPreTokenizer(w);case"Sequence":return new PreTokenizerSequence(w);case"Whitespace":return new WhitespacePreTokenizer(w);case"WhitespaceSplit":return new WhitespaceSplit(w);case"Metaspace":return new MetaspacePreTokenizer(w);case"ByteLevel":return new ByteLevelPreTokenizer(w);case"Split":return new SplitPreTokenizer(w);case"Punctuation":return new PunctuationPreTokenizer(w);case"Digits":return new DigitsPreTokenizer(w);case"Replace":return new ReplacePreTokenizer(w);default:throw new Error(`Unknown PreTokenizer type: ${w.type}`)}}pre_tokenize_text(w,D){throw Error("pre_tokenize_text should be implemented in subclass.")}pre_tokenize(w,D){return(Array.isArray(w)?w.map(O=>this.pre_tokenize_text(O,D)):this.pre_tokenize_text(w,D)).flat()}_call(w,D){return this.pre_tokenize(w,D)}}class BertPreTokenizer extends PreTokenizer{constructor(w){super(),this.pattern=new RegExp(`[^\\s${PUNCTUATION_REGEX}]+|[${PUNCTUATION_REGEX}]`,"gu")}pre_tokenize_text(w,D){return w.trim().match(this.pattern)||[]}}class ByteLevelPreTokenizer extends PreTokenizer{constructor(w){super(),this.config=w,this.add_prefix_space=this.config.add_prefix_space,this.trim_offsets=this.config.trim_offsets,this.use_regex=this.config.use_regex??!0,this.pattern=new RegExp("'s|'t|'re|'ve|'m|'ll|'d| ?\\p{L}+| ?\\p{N}+| ?[^\\s\\p{L}\\p{N}]+|\\s+(?!\\S)|\\s+","gu"),this.byte_encoder=BYTES_TO_UNICODE,this.text_encoder=new TextEncoder}pre_tokenize_text(w,D){return this.add_prefix_space&&!w.startsWith(" ")&&(w=" "+w),(this.use_regex?w.match(this.pattern)||[]:[w]).map(U=>Array.from(this.text_encoder.encode(U),G=>this.byte_encoder[G]).join(""))}}class SplitPreTokenizer extends PreTokenizer{constructor(w){super(),this.config=w,this.pattern=createPattern(this.config.pattern,this.config.invert)}pre_tokenize_text(w,D){return this.pattern===null?[]:this.config.invert?w.match(this.pattern)||[]:regexSplit(w,this.pattern)}}class PunctuationPreTokenizer extends PreTokenizer{constructor(w){super(),this.config=w,this.pattern=new RegExp(`[^${PUNCTUATION_REGEX}]+|[${PUNCTUATION_REGEX}]+`,"gu")}pre_tokenize_text(w,D){return w.match(this.pattern)||[]}}class DigitsPreTokenizer extends PreTokenizer{constructor(w){super(),this.config=w;const D=`[^\\d]+|\\d${this.config.individual_digits?"":"+"}`;this.pattern=new RegExp(D,"gu")}pre_tokenize_text(w,D){return w.match(this.pattern)||[]}}class PostProcessor extends Callable{constructor(w){super(),this.config=w}static fromConfig(w){if(w===null)return null;switch(w.type){case"TemplateProcessing":return new TemplateProcessing(w);case"ByteLevel":return new ByteLevelPostProcessor(w);case"RobertaProcessing":return new RobertaProcessing(w);case"BertProcessing":return new BertProcessing(w);case"Sequence":return new PostProcessorSequence(w);default:throw new Error(`Unknown PostProcessor type: ${w.type}`)}}post_process(w,...D){throw Error("post_process should be implemented in subclass.")}_call(w,...D){return this.post_process(w,...D)}}class BertProcessing extends PostProcessor{constructor(w){super(w),this.cls=w.cls[0],this.sep=w.sep[0]}post_process(w,D=null,{add_special_tokens:O=!0}={}){O&&(w=mergeArrays([this.cls],w,[this.sep]));let U=new Array(w.length).fill(0);if(D!==null){const G=O&&this instanceof RobertaProcessing?[this.sep]:[],q=O?[this.sep]:[];w=mergeArrays(w,G,D,q),U=mergeArrays(U,new Array(D.length+G.length+q.length).fill(1))}return{tokens:w,token_type_ids:U}}}class RobertaProcessing extends BertProcessing{}class TemplateProcessing extends PostProcessor{constructor(w){super(w),this.single=w.single,this.pair=w.pair}post_process(w,D=null,{add_special_tokens:O=!0}={}){const U=D===null?this.single:this.pair;let G=[],q=[];for(const K of U)"SpecialToken"in K?O&&(G.push(K.SpecialToken.id),q.push(K.SpecialToken.type_id)):"Sequence"in K&&(K.Sequence.id==="A"?(G=mergeArrays(G,w),q=mergeArrays(q,new Array(w.length).fill(K.Sequence.type_id))):K.Sequence.id==="B"&&(G=mergeArrays(G,D),q=mergeArrays(q,new Array(D.length).fill(K.Sequence.type_id))));return{tokens:G,token_type_ids:q}}}class ByteLevelPostProcessor extends PostProcessor{post_process(w,D=null){return D&&(w=mergeArrays(w,D)),{tokens:w}}}class PostProcessorSequence extends PostProcessor{constructor(w){super(w),this.processors=w.processors.map(D=>PostProcessor.fromConfig(D))}post_process(w,D=null,O={}){let U;for(const G of this.processors)if(G instanceof ByteLevelPostProcessor)w=G.post_process(w).tokens,D&&(D=G.post_process(D).tokens);else{const q=G.post_process(w,D,O);w=q.tokens,U=q.token_type_ids}return{tokens:w,token_type_ids:U}}}class Decoder extends Callable{constructor(w){super(),this.config=w,this.added_tokens=[],this.end_of_word_suffix=null,this.trim_offsets=w.trim_offsets}static fromConfig(w){if(w===null)return null;switch(w.type){case"WordPiece":return new WordPieceDecoder(w);case"Metaspace":return new MetaspaceDecoder(w);case"ByteLevel":return new ByteLevelDecoder(w);case"Replace":return new ReplaceDecoder(w);case"ByteFallback":return new ByteFallback(w);case"Fuse":return new FuseDecoder(w);case"Strip":return new StripDecoder(w);case"Sequence":return new DecoderSequence(w);case"CTC":return new CTCDecoder(w);case"BPEDecoder":return new BPEDecoder(w);default:throw new Error(`Unknown Decoder type: ${w.type}`)}}_call(w){return this.decode(w)}decode(w){return this.decode_chain(w).join("")}decode_chain(w){throw Error("`decode_chain` should be implemented in subclass.")}}class ReplaceDecoder extends Decoder{decode_chain(w){const D=createPattern(this.config.pattern);return D===null?w:w.map(O=>O.replaceAll(D,this.config.content))}}class ByteFallback extends Decoder{constructor(w){super(w),this.text_decoder=new TextDecoder}decode_chain(w){const D=[];let O=[];for(const U of w){let G=null;if(U.length===6&&U.startsWith("<0x")&&U.endsWith(">")){const q=parseInt(U.slice(3,5),16);isNaN(q)||(G=q)}if(G!==null)O.push(G);else{if(O.length>0){const q=this.text_decoder.decode(Uint8Array.from(O));D.push(q),O=[]}D.push(U)}}if(O.length>0){const U=this.text_decoder.decode(Uint8Array.from(O));D.push(U),O=[]}return D}}class FuseDecoder extends Decoder{decode_chain(w){return[w.join("")]}}class StripDecoder extends Decoder{constructor(w){super(w),this.content=this.config.content,this.start=this.config.start,this.stop=this.config.stop}decode_chain(w){return w.map(D=>{let O=0;for(let G=0;G<this.start&&D[G]===this.content;++G){O=G+1;continue}let U=D.length;for(let G=0;G<this.stop;++G){const q=D.length-G-1;if(D[q]===this.content){U=q;continue}else break}return D.slice(O,U)})}}class WordPieceDecoder extends Decoder{constructor(w){super(w),this.cleanup=w.cleanup}decode_chain(w){return w.map((D,O)=>(O!==0&&(D.startsWith(this.config.prefix)?D=D.replace(this.config.prefix,""):D=" "+D),this.cleanup&&(D=clean_up_tokenization(D)),D))}}class ByteLevelDecoder extends Decoder{constructor(w){super(w),this.byte_decoder=UNICODE_TO_BYTES,this.text_decoder=new TextDecoder("utf-8",{fatal:!1,ignoreBOM:!0}),this.end_of_word_suffix=null}convert_tokens_to_string(w){const D=w.join(""),O=new Uint8Array([...D].map(G=>this.byte_decoder[G]));return this.text_decoder.decode(O)}decode_chain(w){const D=[];let O=[];for(const U of w)this.added_tokens.find(G=>G.content===U)!==void 0?(O.length>0&&(D.push(this.convert_tokens_to_string(O)),O=[]),D.push(U)):O.push(U);return O.length>0&&D.push(this.convert_tokens_to_string(O)),D}}class CTCDecoder extends Decoder{constructor(w){super(w),this.pad_token=this.config.pad_token,this.word_delimiter_token=this.config.word_delimiter_token,this.cleanup=this.config.cleanup}convert_tokens_to_string(w){if(w.length===0)return"";const D=[w[0]];for(let G=1;G<w.length;++G)w[G]!==D.at(-1)&&D.push(w[G]);let U=D.filter(G=>G!==this.pad_token).join("");return this.cleanup&&(U=clean_up_tokenization(U).replaceAll(this.word_delimiter_token," ").trim()),U}decode_chain(w){return[this.convert_tokens_to_string(w)]}}class DecoderSequence extends Decoder{constructor(w){super(w),this.decoders=w.decoders.map(D=>Decoder.fromConfig(D))}decode_chain(w){return this.decoders.reduce((D,O)=>O.decode_chain(D),w)}}class BPEDecoder extends Decoder{constructor(w){super(w),this.suffix=this.config.suffix}decode_chain(w){return w.map((D,O)=>D.replaceAll(this.suffix,O===w.length-1?"":" "))}}class VitsDecoder extends Decoder{decode_chain(w){let D="";for(let O=1;O<w.length;O+=2)D+=w[O];return[D]}}class MetaspacePreTokenizer extends PreTokenizer{constructor(w){super(),this.addPrefixSpace=w.add_prefix_space,this.replacement=w.replacement,this.strRep=w.str_rep||this.replacement,this.prepend_scheme=w.prepend_scheme??"always"}pre_tokenize_text(w,{section_index:D=void 0}={}){let O=w.replaceAll(" ",this.strRep);return this.addPrefixSpace&&!O.startsWith(this.replacement)&&(this.prepend_scheme==="always"||this.prepend_scheme==="first"&&D===0)&&(O=this.strRep+O),[O]}}class MetaspaceDecoder extends Decoder{constructor(w){super(w),this.addPrefixSpace=w.add_prefix_space,this.replacement=w.replacement}decode_chain(w){const D=[];for(let O=0;O<w.length;++O){let U=w[O].replaceAll(this.replacement," ");this.addPrefixSpace&&O==0&&U.startsWith(" ")&&(U=U.substring(1)),D.push(U)}return D}}class Precompiled extends Normalizer{constructor(w){super(w),this.charsmap=w.precompiled_charsmap}normalize(w){return w=w.replace(/[\u0001-\u0008\u000B\u000E-\u001F\u007F\u008F\u009F]/gm,""),w=w.replace(/[\u0009\u000A\u000C\u000D\u1680\u200B\u200C\u200E\u200F\u2028\u2029\u2581\uFEFF\uFFFD]/gm," "),w.includes("")?w=w.split("").map(O=>O.normalize("NFKC")).join(""):w=w.normalize("NFKC"),w}}class PreTokenizerSequence extends PreTokenizer{constructor(w){super(),this.tokenizers=w.pretokenizers.map(D=>PreTokenizer.fromConfig(D))}pre_tokenize_text(w,D){return this.tokenizers.reduce((O,U)=>U.pre_tokenize(O,D),[w])}}class WhitespacePreTokenizer extends PreTokenizer{constructor(w){super()}pre_tokenize_text(w,D){return w.match(/\w+|[^\w\s]+/g)||[]}}class WhitespaceSplit extends PreTokenizer{constructor(w){super()}pre_tokenize_text(w,D){return whitespace_split(w)}}class ReplacePreTokenizer extends PreTokenizer{constructor(w){super(),this.config=w,this.pattern=createPattern(this.config.pattern),this.content=this.config.content}pre_tokenize_text(w,D){return this.pattern===null?[w]:[w.replaceAll(this.pattern,this.config.content)]}}const SPECIAL_TOKEN_ATTRIBUTES=["bos_token","eos_token","unk_token","sep_token","pad_token","cls_token","mask_token"];function padHelper(F,w,D,O){for(const U of Object.keys(F)){const G=w-F[U].length,q=D(U),K=new Array(G).fill(q);F[U]=O==="right"?mergeArrays(F[U],K):mergeArrays(K,F[U])}}function truncateHelper(F,w){for(const D of Object.keys(F))F[D].length=w}class PreTrainedTokenizer extends Callable{return_token_type_ids=!1;_default_chat_template=`{% for message in messages %}{{'<|im_start|>' + message['role'] + '
' + message['content'] + '<|im_end|>' + '
'}}{% endfor %}{% if add_generation_prompt %}{{ '<|im_start|>assistant
' }}{% endif %}`;constructor(w,D){super(),this._tokenizer_config=D,this.normalizer=Normalizer.fromConfig(w.normalizer),this.pre_tokenizer=PreTokenizer.fromConfig(w.pre_tokenizer),this.model=TokenizerModel.fromConfig(w.model,D),this.post_processor=PostProcessor.fromConfig(w.post_processor),this.decoder=Decoder.fromConfig(w.decoder),this.special_tokens=[],this.all_special_ids=[],this.added_tokens=[];for(const O of w.added_tokens){const U=new AddedToken(O);this.added_tokens.push(U),this.model.tokens_to_ids.set(U.content,U.id),this.model.vocab[U.id]=U.content,U.special&&(this.special_tokens.push(U.content),this.all_special_ids.push(U.id))}if(this.additional_special_tokens=D.additional_special_tokens??[],this.special_tokens.push(...this.additional_special_tokens),this.special_tokens=[...new Set(this.special_tokens)],this.decoder&&(this.decoder.added_tokens=this.added_tokens,this.decoder.end_of_word_suffix=this.model.end_of_word_suffix),this.added_tokens_regex=this.added_tokens.length>0?new RegExp(this.added_tokens.map(O=>`${O.lstrip?"\\s*":""}(${escapeRegExp(O.content)})${O.rstrip?"\\s*":""}`).join("|")):null,this.mask_token=this.getToken("mask_token"),this.mask_token_id=this.model.tokens_to_ids.get(this.mask_token),this.pad_token=this.getToken("pad_token","eos_token"),this.pad_token_id=this.model.tokens_to_ids.get(this.pad_token),this.sep_token=this.getToken("sep_token"),this.sep_token_id=this.model.tokens_to_ids.get(this.sep_token),this.unk_token=this.getToken("unk_token"),this.unk_token_id=this.model.tokens_to_ids.get(this.unk_token),this.model_max_length=D.model_max_length,this.remove_space=D.remove_space,this.clean_up_tokenization_spaces=D.clean_up_tokenization_spaces??!0,this.do_lowercase_and_remove_accent=D.do_lowercase_and_remove_accent??!1,this.padding_side="right",this.legacy=!1,this.chat_template=D.chat_template??null,Array.isArray(this.chat_template)){const O=Object.create(null);for(const{name:U,template:G}of this.chat_template){if(typeof U!="string"||typeof G!="string")throw new Error('Chat template must be a list of objects with "name" and "template" properties');O[U]=G}this.chat_template=O}this._compiled_template_cache=new Map}getToken(...w){for(const D of w){const O=this._tokenizer_config[D];if(O)if(typeof O=="object"){if(O.__type==="AddedToken")return O.content;throw Error(`Unknown token: ${O}`)}else return O}return null}static async from_pretrained(w,{progress_callback:D=null,config:O=null,cache_dir:U=null,local_files_only:G=!1,revision:q="main",legacy:K=null}={}){const ee=await loadTokenizer(w,{progress_callback:D,cache_dir:U,local_files_only:G,revision:q,legacy:K});return new this(...ee)}_call(w,{text_pair:D=null,add_special_tokens:O=!0,padding:U=!1,truncation:G=null,max_length:q=null,return_tensor:K=!0,return_token_type_ids:ee=null}={}){const Z=Array.isArray(w);let ie;if(Z){if(w.length===0)throw Error("text array must be non-empty");if(D!==null){if(Array.isArray(D)){if(w.length!==D.length)throw Error("text and text_pair must have the same length")}else throw Error("text_pair must also be an array");ie=w.map((W,ne)=>this._encode_plus(W,D[ne],{add_special_tokens:O,return_token_type_ids:ee}))}else ie=w.map(W=>this._encode_plus(W,null,{add_special_tokens:O,return_token_type_ids:ee}))}else{if(w==null)throw Error("text may not be null or undefined");if(Array.isArray(D))throw Error("When specifying `text_pair`, since `text` is a string, `text_pair` must also be a string (i.e., not an array).");ie=[this._encode_plus(w,D,{add_special_tokens:O,return_token_type_ids:ee})]}if(q===null?U==="max_length"?q=this.model_max_length:q=max(ie.map(W=>W.input_ids.length))[0]:G||console.warn("Truncation was not explicitly activated but `max_length` is provided a specific value, please use `truncation=true` to explicitly truncate examples to max length."),q=Math.min(q,this.model_max_length),U||G)for(let W=0;W<ie.length;++W)ie[W].input_ids.length!==q&&(ie[W].input_ids.length>q?G&&truncateHelper(ie[W],q):U&&padHelper(ie[W],q,ne=>ne==="input_ids"?this.pad_token_id:0,this.padding_side));const Y={};if(K){if(!(U&&G)&&ie.some(ne=>{for(const se of Object.keys(ne))if(ne[se].length!==ie[0][se]?.length)return!0;return!1}))throw Error("Unable to create tensor, you should probably activate truncation and/or padding with 'padding=true' and 'truncation=true' to have batched tensors with the same length.");const W=[ie.length,ie[0].input_ids.length];for(const ne of Object.keys(ie[0]))Y[ne]=new Tensor("int64",BigInt64Array.from(ie.flatMap(se=>se[ne]).map(BigInt)),W)}else{for(const W of Object.keys(ie[0]))Y[W]=ie.map(ne=>ne[W]);if(!Z)for(const W of Object.keys(Y))Y[W]=Y[W][0]}return Y}_encode_text(w){return w===null?null:(this.added_tokens_regex?w.split(this.added_tokens_regex).filter(U=>U):[w]).map((U,G)=>{if(this.added_tokens.find(K=>K.content===U)!==void 0)return U;{if(this.remove_space===!0&&(U=U.trim().split(/\s+/).join(" ")),this.do_lowercase_and_remove_accent&&(U=lowercase_and_remove_accent(U)),this.normalizer!==null&&(U=this.normalizer(U)),U.length===0)return[];const K=this.pre_tokenizer!==null?this.pre_tokenizer(U,{section_index:G}):[U];return this.model(K)}}).flat()}_encode_plus(w,D=null,{add_special_tokens:O=!0,return_token_type_ids:U=null}={}){const G=this._encode_text(w),q=this._encode_text(D),K=this.post_processor?this.post_processor(G,q,{add_special_tokens:O}):{tokens:mergeArrays(G??[],q??[])},ee=this.model.convert_tokens_to_ids(K.tokens),Z={input_ids:ee,attention_mask:new Array(ee.length).fill(1)};return(U??this.return_token_type_ids)&&K.token_type_ids&&(Z.token_type_ids=K.token_type_ids),Z}encode(w,D=null,{add_special_tokens:O=!0,return_token_type_ids:U=null}={}){const{input_ids:G}=this._encode_plus(w,D,{add_special_tokens:O,return_token_type_ids:U});return G}batch_decode(w,D={}){return w instanceof Tensor&&(w=w.tolist()),w.map(O=>this.decode(O,D))}decode(w,D={}){if(w instanceof Tensor&&(w=prepareTensorForDecode(w)),!Array.isArray(w)||w.length===0||!isIntegralNumber(w[0]))throw Error("token_ids must be a non-empty array of integers.");return this.decode_single(w,D)}decode_single(w,{skip_special_tokens:D=!1,clean_up_tokenization_spaces:O=null}){let U=this.model.convert_ids_to_tokens(w);D&&(U=U.filter(q=>!this.special_tokens.includes(q)));let G=this.decoder?this.decoder(U):U.join(" ");return this.decoder&&this.decoder.end_of_word_suffix&&(G=G.replaceAll(this.decoder.end_of_word_suffix," "),D&&(G=G.trim())),(O??this.clean_up_tokenization_spaces)&&(G=clean_up_tokenization(G)),G}get default_chat_template(){return this._warned_about_chat_template||(console.warn("No chat template is defined for this tokenizer - using a default chat template that implements the ChatML format. If the default is not appropriate for your model, please set `tokenizer.chat_template` to an appropriate template. See https://huggingface.co/docs/transformers/main/chat_templating for more information."),this._warned_about_chat_template=!0),this._default_chat_template}apply_chat_template(w,{chat_template:D=null,add_generation_prompt:O=!1,tokenize:U=!0,padding:G=!1,truncation:q=!1,max_length:K=null,return_tensor:ee=!0,tokenizer_kwargs:Z={},...ie}={}){if(this.chat_template&&typeof this.chat_template=="object"||this.chat_template===null&&this.default_chat_template&&typeof this.default_chat_template=="object"){const se=this.chat_template??this.default_chat_template;if(D!==null&&Object.hasOwn(se,D))D=se[D];else if(D===null&&"default"in se)D=se.default;else if(D===null)throw Error(`This model has multiple chat templates with no default specified! Please either pass a chat template or the name of the template you wish to use to the 'chat_template' argument. Available template names are ${Object.keys(se).sort()}.`)}else D??=this.chat_template??this.default_chat_template;if(typeof D!="string")throw Error(`chat_template must be a string, but got ${typeof D}`);let Y=this._compiled_template_cache.get(D);Y===void 0&&(Y=new Template(D),this._compiled_template_cache.set(D,Y));const W=Object.create(null);for(const se of SPECIAL_TOKEN_ATTRIBUTES){const le=this.getToken(se);le&&(W[se]=le)}const ne=Y.render({messages:w,add_generation_prompt:O,...W,...ie});return U?this._call(ne,{add_special_tokens:!1,padding:G,truncation:q,max_length:K,return_tensor:ee,...Z}).input_ids:ne}}class BertTokenizer extends PreTrainedTokenizer{return_token_type_ids=!0}class AlbertTokenizer extends PreTrainedTokenizer{return_token_type_ids=!0}class MobileBertTokenizer extends PreTrainedTokenizer{return_token_type_ids=!0}class SqueezeBertTokenizer extends PreTrainedTokenizer{return_token_type_ids=!0}class DebertaTokenizer extends PreTrainedTokenizer{return_token_type_ids=!0}class DebertaV2Tokenizer extends PreTrainedTokenizer{return_token_type_ids=!0}class HerbertTokenizer extends PreTrainedTokenizer{return_token_type_ids=!0}class ConvBertTokenizer extends PreTrainedTokenizer{return_token_type_ids=!0}class RoFormerTokenizer extends PreTrainedTokenizer{return_token_type_ids=!0}class DistilBertTokenizer extends PreTrainedTokenizer{}class CamembertTokenizer extends PreTrainedTokenizer{}class XLMTokenizer extends PreTrainedTokenizer{return_token_type_ids=!0;constructor(w,D){super(w,D),console.warn('WARNING: `XLMTokenizer` is not yet supported by Hugging Face\'s "fast" tokenizers library. Therefore, you may experience slightly inaccurate results.')}}class ElectraTokenizer extends PreTrainedTokenizer{return_token_type_ids=!0}class T5Tokenizer extends PreTrainedTokenizer{}class GPT2Tokenizer extends PreTrainedTokenizer{_default_chat_template='{% for message in messages %}" "{{ message.content }}{{ eos_token }}" "{% endfor %}'}class BartTokenizer extends PreTrainedTokenizer{}class MBartTokenizer extends PreTrainedTokenizer{constructor(w,D){super(w,D),this.languageRegex=/^[a-z]{2}_[A-Z]{2}$/,this.language_codes=this.special_tokens.filter(O=>this.languageRegex.test(O)),this.lang_to_token=O=>O}_build_translation_inputs(w,D,O){return _build_translation_inputs(this,w,D,O)}}class MBart50Tokenizer extends MBartTokenizer{}class RobertaTokenizer extends PreTrainedTokenizer{}class BloomTokenizer extends GPT2Tokenizer{constructor(w,D){const O=".,!?",U=w.pre_tokenizer?.pretokenizers[0]?.pattern;U&&U.Regex===` ?[^(\\s|[${O}])]+`&&(U.Regex=` ?[^\\s${O}]+`),super(w,D)}}const SPIECE_UNDERLINE="";class LlamaTokenizer extends PreTrainedTokenizer{_default_chat_template=`{% if messages[0]['role'] == 'system' %}{% set loop_messages = messages[1:] %}{% set system_message = messages[0]['content'] %}{% elif USE_DEFAULT_PROMPT == true and not '<<SYS>>' in messages[0]['content'] %}{% set loop_messages = messages %}{% set system_message = 'DEFAULT_SYSTEM_MESSAGE' %}{% else %}{% set loop_messages = messages %}{% set system_message = false %}{% endif %}{% for message in loop_messages %}{% if (message['role'] == 'user') != (loop.index0 % 2 == 0) %}{{ raise_exception('Conversation roles must alternate user/assistant/user/assistant/...') }}{% endif %}{% if loop.index0 == 0 and system_message != false %}{% set content = '<<SYS>>
' + system_message + '
<</SYS>>

' + message['content'] %}{% else %}{% set content = message['content'] %}{% endif %}{% if message['role'] == 'user' %}{{ bos_token + '[INST] ' + content.strip() + ' [/INST]' }}{% elif message['role'] == 'system' %}{{ '<<SYS>>
' + content.strip() + '
<</SYS>>

' }}{% elif message['role'] == 'assistant' %}{{ ' '  + content.strip() + ' ' + eos_token }}{% endif %}{% endfor %}`;DEFAULT_SYSTEM_PROMPT=`You are a helpful, respectful and honest assistant. Always answer as helpfully as possible, while being safe. Your answers should not include any harmful, unethical, racist, sexist, toxic, dangerous, or illegal content. Please ensure that your responses are socially unbiased and positive in nature.

If a question does not make any sense, or is not factually coherent, explain why instead of answering something not correct. If you don't know the answer to a question, please don't share false information.`;constructor(w,D){super(w,D),this.use_default_system_prompt=D.use_default_system_prompt??!1,this.legacy=D.legacy??!0,this.legacy||(this.normalizer=null,this.pre_tokenizer=new MetaspacePreTokenizer({replacement:SPIECE_UNDERLINE,add_prefix_space:!0,prepend_scheme:"first"}))}_encode_text(w){if(w===null)return null;if(this.legacy||w.length===0)return super._encode_text(w);let D=super._encode_text(SPIECE_UNDERLINE+w.replaceAll(SPIECE_UNDERLINE," "));return D.length>1&&D[0]===SPIECE_UNDERLINE&&this.special_tokens.includes(D[1])&&(D=D.slice(1)),D}get default_chat_template(){return super.default_chat_template.replaceAll("USE_DEFAULT_PROMPT",this.use_default_system_prompt?"true":"false").replaceAll("DEFAULT_SYSTEM_MESSAGE",this.DEFAULT_SYSTEM_PROMPT.replaceAll(`
`,"\\n").replaceAll("'","\\'"))}}class CodeLlamaTokenizer extends LlamaTokenizer{}class XLMRobertaTokenizer extends PreTrainedTokenizer{}class MPNetTokenizer extends PreTrainedTokenizer{}class FalconTokenizer extends PreTrainedTokenizer{}class GPTNeoXTokenizer extends PreTrainedTokenizer{}class EsmTokenizer extends PreTrainedTokenizer{}class Qwen2Tokenizer extends PreTrainedTokenizer{}class GemmaTokenizer extends PreTrainedTokenizer{_default_chat_template=`{% if messages[0]['role'] == 'system' %}{{ raise_exception('System role not supported') }}{% endif %}{% for message in messages %}{% if (message['role'] == 'user') != (loop.index0 % 2 == 0) %}{{ raise_exception('Conversation roles must alternate user/assistant/user/assistant/...') }}{% endif %}{% if (message['role'] == 'assistant') %}{% set role = 'model' %}{% else %}{% set role = message['role'] %}{% endif %}{{ '<start_of_turn>' + role + '
' + message['content'] | trim + '<end_of_turn>
' }}{% endfor %}{% if add_generation_prompt %}{{'<start_of_turn>model
'}}{% endif %}`}class Grok1Tokenizer extends PreTrainedTokenizer{}function _build_translation_inputs(F,w,D,O){if(!("language_codes"in F)||!Array.isArray(F.language_codes))throw new Error("Tokenizer must have `language_codes` attribute set and it should be an array of language ids.");if(!("languageRegex"in F)||!(F.languageRegex instanceof RegExp))throw new Error("Tokenizer must have `languageRegex` attribute set and it should be a regular expression.");if(!("lang_to_token"in F)||typeof F.lang_to_token!="function")throw new Error("Tokenizer must have `lang_to_token` attribute set and it should be a function.");const U=O.src_lang,G=O.tgt_lang;if(!F.language_codes.includes(G))throw new Error(`Target language code "${G}" is not valid. Must be one of: {${F.language_codes.join(", ")}}`);if(U!==void 0){if(!F.language_codes.includes(U))throw new Error(`Source language code "${U}" is not valid. Must be one of: {${F.language_codes.join(", ")}}`);for(const q of F.post_processor.config.single)if("SpecialToken"in q&&F.languageRegex.test(q.SpecialToken.id)){q.SpecialToken.id=F.lang_to_token(U);break}}return O.forced_bos_token_id=F.model.convert_tokens_to_ids([F.lang_to_token(G)])[0],F._call(w,D)}class NllbTokenizer extends PreTrainedTokenizer{constructor(w,D){super(w,D),this.languageRegex=/^[a-z]{3}_[A-Z][a-z]{3}$/,this.language_codes=this.special_tokens.filter(O=>this.languageRegex.test(O)),this.lang_to_token=O=>O}_build_translation_inputs(w,D,O){return _build_translation_inputs(this,w,D,O)}}class M2M100Tokenizer extends PreTrainedTokenizer{constructor(w,D){super(w,D),this.languageRegex=/^__[a-z]{2,3}__$/,this.language_codes=this.special_tokens.filter(O=>this.languageRegex.test(O)).map(O=>O.slice(2,-2)),this.lang_to_token=O=>`__${O}__`}_build_translation_inputs(w,D,O){return _build_translation_inputs(this,w,D,O)}}const WHISPER_LANGUAGES=[["en","english"],["zh","chinese"],["de","german"],["es","spanish"],["ru","russian"],["ko","korean"],["fr","french"],["ja","japanese"],["pt","portuguese"],["tr","turkish"],["pl","polish"],["ca","catalan"],["nl","dutch"],["ar","arabic"],["sv","swedish"],["it","italian"],["id","indonesian"],["hi","hindi"],["fi","finnish"],["vi","vietnamese"],["he","hebrew"],["uk","ukrainian"],["el","greek"],["ms","malay"],["cs","czech"],["ro","romanian"],["da","danish"],["hu","hungarian"],["ta","tamil"],["no","norwegian"],["th","thai"],["ur","urdu"],["hr","croatian"],["bg","bulgarian"],["lt","lithuanian"],["la","latin"],["mi","maori"],["ml","malayalam"],["cy","welsh"],["sk","slovak"],["te","telugu"],["fa","persian"],["lv","latvian"],["bn","bengali"],["sr","serbian"],["az","azerbaijani"],["sl","slovenian"],["kn","kannada"],["et","estonian"],["mk","macedonian"],["br","breton"],["eu","basque"],["is","icelandic"],["hy","armenian"],["ne","nepali"],["mn","mongolian"],["bs","bosnian"],["kk","kazakh"],["sq","albanian"],["sw","swahili"],["gl","galician"],["mr","marathi"],["pa","punjabi"],["si","sinhala"],["km","khmer"],["sn","shona"],["yo","yoruba"],["so","somali"],["af","afrikaans"],["oc","occitan"],["ka","georgian"],["be","belarusian"],["tg","tajik"],["sd","sindhi"],["gu","gujarati"],["am","amharic"],["yi","yiddish"],["lo","lao"],["uz","uzbek"],["fo","faroese"],["ht","haitian creole"],["ps","pashto"],["tk","turkmen"],["nn","nynorsk"],["mt","maltese"],["sa","sanskrit"],["lb","luxembourgish"],["my","myanmar"],["bo","tibetan"],["tl","tagalog"],["mg","malagasy"],["as","assamese"],["tt","tatar"],["haw","hawaiian"],["ln","lingala"],["ha","hausa"],["ba","bashkir"],["jw","javanese"],["su","sundanese"]],WHISPER_LANGUAGE_MAPPING=new Map(WHISPER_LANGUAGES),WHISPER_TO_LANGUAGE_CODE_MAPPING=new Map([...WHISPER_LANGUAGES.map(([F,w])=>[w,F]),["burmese","my"],["valencian","ca"],["flemish","nl"],["haitian","ht"],["letzeburgesch","lb"],["pushto","ps"],["panjabi","pa"],["moldavian","ro"],["moldovan","ro"],["sinhalese","si"],["castilian","es"]]);class WhisperTokenizer extends PreTrainedTokenizer{_default_chat_template='{% for message in messages %}" "{{ message.content }}{{ eos_token }}" "{% endfor %}';_decode_asr(w,{return_timestamps:D=!1,return_language:O=!1,time_precision:U=null,force_full_sequences:G=!0}={}){if(U===null)throw Error("Must specify time_precision");let q=null;const K=D==="word";function ee(){return{language:q,timestamp:[null,null],text:""}}const Z=[];let ie=ee(),Y=0;const W=this.model.convert_tokens_to_ids(["<|notimestamps|>"])[0]+1;let ne=[],se=[],le=!1,ce=null;const he=new Set(this.all_special_ids);for(const be of w){const ge=be.tokens,ve=K?be.token_timestamps:null;let Se=null,Me=W;if("stride"in be){const[Re,Le,Ne]=be.stride;if(Y-=Le,ce=Re-Ne,Le&&(Me=Le/U+W),Ne)for(let Oe=ge.length-1;Oe>=0;--Oe){const Pe=ge[Oe];if(Pe>=W){if(Se!==null&&(Pe-W)*U<ce)break;Se=Pe}}}let Ee=[],we=[];for(let Re=0;Re<ge.length;++Re){const Le=ge[Re];if(he.has(Le)){const Ne=this.decode([Le]),Oe=WHISPER_LANGUAGE_MAPPING.get(Ne.slice(2,-2));if(Oe!==void 0){if(q!==null&&Oe!==q&&!D){ne.push(Ee);const Pe=this.findLongestCommonSequence(ne)[0],Ce=this.decode(Pe);ie.text=Ce,Z.push(ie),ne=[],Ee=[],ie=ee()}q=ie.language=Oe}}else if(Le>=W){const Ne=(Le-W)*U+Y,Oe=round(Ne,2);if(Se!==null&&Le>=Se)le=!0;else if(le||ne.length>0&&Le<Me)le=!1;else if(ie.timestamp[0]===null)ie.timestamp[0]=Oe;else if(Oe!==ie.timestamp[0]){ie.timestamp[1]=Oe,ne.push(Ee),K&&se.push(we);const[Pe,Ce]=this.findLongestCommonSequence(ne,se),Be=this.decode(Pe);ie.text=Be,K&&(ie.words=this.collateWordTimestamps(Pe,Ce,q)),Z.push(ie),ne=[],Ee=[],se=[],we=[],ie=ee()}}else if(Ee.push(Le),K){let Ne=round(ve[Re]+Y,2),Oe;Re+1<ve.length?Oe=round(ve[Re+1]+Y,2):Oe=null,we.push([Ne,Oe])}}if("stride"in be){const[Re,Le,Ne]=be.stride;Y+=Re-Ne}Ee.length>0?(ne.push(Ee),K&&se.push(we)):ne.every(Re=>Re.length===0)&&(ie=ee(),ne=[],Ee=[],se=[],we=[])}if(ne.length>0){if(G&&D)throw new Error("Whisper did not predict an ending timestamp, which can happen if audio is cut off in the middle of a word. Also make sure WhisperTimeStampLogitsProcessor was used during generation.");const[be,ge]=this.findLongestCommonSequence(ne,se),ve=this.decode(be);ie.text=ve,K&&(ie.words=this.collateWordTimestamps(be,ge,q)),Z.push(ie)}let pe=Object.create(null);const me=Z.map(be=>be.text).join("");if(D||O){for(let be=0;be<Z.length;++be){const ge=Z[be];D||delete ge.timestamp,O||delete ge.language}if(K){const be=[];for(const ge of Z)for(const ve of ge.words)be.push(ve);pe={chunks:be}}else pe={chunks:Z}}return[me,pe]}findLongestCommonSequence(w,D=null){let O=w[0],U=O.length,G=[];const q=Array.isArray(D)&&D.length>0;let K=q?[]:null,ee=q?D[0]:null;for(let Z=1;Z<w.length;++Z){const ie=w[Z];let Y=0,W=[U,U,0,0];const ne=ie.length;for(let be=1;be<U+ne;++be){const ge=be/1e4,ve=Math.max(0,U-be),Se=Math.min(U,U+ne-be),Me=O.slice(ve,Se),Ee=Math.max(0,be-U),we=Math.min(ne,be),Re=ie.slice(Ee,we);if(Me.length!==Re.length)throw new Error("There is a bug within whisper `decode_asr` function, please report it. Dropping to prevent bad inference.");const Le=Me.filter((Oe,Pe)=>Oe===Re[Pe]).length,Ne=Le/be+ge;Le>1&&Ne>Y&&(Y=Ne,W=[ve,Se,Ee,we])}const[se,le,ce,he]=W,pe=Math.floor((le+se)/2),me=Math.floor((he+ce)/2);G.push(...O.slice(0,pe)),O=ie.slice(me),U=O.length,q&&(K.push(...ee.slice(0,pe)),ee=D[Z].slice(me))}return G.push(...O),q?(K.push(...ee),[G,K]):[G,[]]}collateWordTimestamps(w,D,O){const[U,G,q]=this.combineTokensIntoWords(w,O),K=[];for(let ee=0;ee<U.length;++ee){const Z=q[ee];K.push({text:U[ee],timestamp:[D[Z.at(0)][0],D[Z.at(-1)][1]]})}return K}combineTokensIntoWords(w,D,O=`"'([{-`,U=`"'.,!?:)]}`){D=D??"english";let G,q,K;return["chinese","japanese","thai","lao","myanmar"].includes(D)?[G,q,K]=this.splitTokensOnUnicode(w):[G,q,K]=this.splitTokensOnSpaces(w),this.mergePunctuations(G,q,K,O,U)}decode(w,D){let O;return D&&D.decode_with_timestamps?(w instanceof Tensor&&(w=prepareTensorForDecode(w)),O=this.decodeWithTimestamps(w,D)):O=super.decode(w,D),O}decodeWithTimestamps(w,D){const O=D?.time_precision??.02,U=Array.from(this.all_special_ids).at(-1)+1;let G=[[]];for(const q of w)if(q>=U){const K=round((q-U)*O,2);G.push(`<|${K}|>`),G.push([])}else G[G.length-1].push(q);return G=G.map(q=>typeof q=="string"?q:super.decode(q,D)),G.join("")}splitTokensOnUnicode(w){const D=this.decode(w,{decode_with_timestamps:!0}),O="",U=[],G=[],q=[];let K=[],ee=[],Z=0;for(let ie=0;ie<w.length;++ie){const Y=w[ie];K.push(Y),ee.push(ie);const W=this.decode(K,{decode_with_timestamps:!0});(!W.includes(O)||D[Z+W.indexOf(O)]===O)&&(U.push(W),G.push(K),q.push(ee),K=[],ee=[],Z+=W.length)}return[U,G,q]}splitTokensOnSpaces(w){const[D,O,U]=this.splitTokensOnUnicode(w),G=[],q=[],K=[],ee=new RegExp(`^[${PUNCTUATION_REGEX}]$`,"gu");for(let Z=0;Z<D.length;++Z){const ie=D[Z],Y=O[Z],W=U[Z],ne=Y[0]>=this.model.tokens_to_ids.get("<|endoftext|>"),se=ie.startsWith(" "),le=ie.trim(),ce=ee.test(le);if(ne||se||ce||G.length===0)G.push(ie),q.push(Y),K.push(W);else{const he=G.length-1;G[he]+=ie,q[he].push(...Y),K[he].push(...W)}}return[G,q,K]}mergePunctuations(w,D,O,U,G){const q=structuredClone(w),K=structuredClone(D),ee=structuredClone(O);let Z=q.length-2,ie=q.length-1;for(;Z>=0;)q[Z].startsWith(" ")&&U.includes(q[Z].trim())?(q[ie]=q[Z]+q[ie],K[ie]=mergeArrays(K[Z],K[ie]),ee[ie]=mergeArrays(ee[Z],ee[ie]),q[Z]="",K[Z]=[],ee[Z]=[]):ie=Z,--Z;for(Z=0,ie=1;ie<q.length;)!q[Z].endsWith(" ")&&G.includes(q[ie])?(q[Z]+=q[ie],K[Z]=mergeArrays(K[Z],K[ie]),ee[Z]=mergeArrays(ee[Z],ee[ie]),q[ie]="",K[ie]=[],ee[ie]=[]):Z=ie,++ie;return[q.filter(Y=>Y),K.filter(Y=>Y.length>0),ee.filter(Y=>Y.length>0)]}get_decoder_prompt_ids({language:w=null,task:D=null,no_timestamps:O=!0}={}){const U=[];if(w){w=w.toLowerCase();let G=WHISPER_TO_LANGUAGE_CODE_MAPPING.get(w);if(G===void 0)if(WHISPER_LANGUAGE_MAPPING.has(w))G=w;else{const ee=w.length===2?WHISPER_LANGUAGE_MAPPING.keys():WHISPER_LANGUAGE_MAPPING.values();throw new Error(`Language "${w}" is not supported. Must be one of: ${JSON.stringify(ee)}`)}const q=this.model.tokens_to_ids.get(`<|${G}|>`);if(q===void 0)throw new Error(`Unable to find language "${G}" in model vocabulary. Please report this issue at https://github.com/xenova/transformers.js/issues/new/choose.`);U.push(q)}else U.push(null);if(D){if(D=D.toLowerCase(),D!=="transcribe"&&D!=="translate")throw new Error(`Task "${D}" is not supported. Must be one of: ["transcribe", "translate"]`);const G=this.model.tokens_to_ids.get(`<|${D}|>`);if(G===void 0)throw new Error(`Unable to find task "${D}" in model vocabulary. Please report this issue at https://github.com/xenova/transformers.js/issues/new/choose.`);U.push(G)}else U.push(null);if(O){const G=this.model.tokens_to_ids.get("<|notimestamps|>");if(G===void 0)throw new Error('Unable to find "<|notimestamps|>" in model vocabulary. Please report this issue at https://github.com/xenova/transformers.js/issues/new/choose.');U.push(G)}return U.map((G,q)=>[q+1,G]).filter(G=>G[1]!==null)}}class CodeGenTokenizer extends PreTrainedTokenizer{}class CLIPTokenizer extends PreTrainedTokenizer{}class SiglipTokenizer extends PreTrainedTokenizer{}class MarianTokenizer extends PreTrainedTokenizer{constructor(w,D){super(w,D),this.languageRegex=/^(>>\w+<<)\s*/g,this.supported_language_codes=this.model.vocab.filter(O=>this.languageRegex.test(O)),console.warn('WARNING: `MarianTokenizer` is not yet supported by Hugging Face\'s "fast" tokenizers library. Therefore, you may experience slightly inaccurate results.')}_encode_text(w){if(w===null)return null;const[D,...O]=w.trim().split(this.languageRegex);if(O.length===0)return super._encode_text(D);if(O.length===2){const[U,G]=O;return this.supported_language_codes.includes(U)||console.warn(`Unsupported language code "${U}" detected, which may lead to unexpected behavior. Should be one of: ${JSON.stringify(this.supported_language_codes)}`),mergeArrays([U],super._encode_text(G))}}}class Wav2Vec2CTCTokenizer extends PreTrainedTokenizer{}class BlenderbotTokenizer extends PreTrainedTokenizer{_default_chat_template="{% for message in messages %}{% if message['role'] == 'user' %}{{ ' ' }}{% endif %}{{ message['content'] }}{% if not loop.last %}{{ '  ' }}{% endif %}{% endfor %}{{ eos_token }}"}class BlenderbotSmallTokenizer extends BlenderbotTokenizer{}class SpeechT5Tokenizer extends PreTrainedTokenizer{}class NougatTokenizer extends PreTrainedTokenizer{}class VitsTokenizer extends PreTrainedTokenizer{constructor(w,D){super(w,D),this.decoder=new VitsDecoder({})}}class CohereTokenizer extends PreTrainedTokenizer{}class AutoTokenizer{static TOKENIZER_CLASS_MAPPING={T5Tokenizer,DistilBertTokenizer,CamembertTokenizer,DebertaTokenizer,DebertaV2Tokenizer,BertTokenizer,HerbertTokenizer,ConvBertTokenizer,RoFormerTokenizer,XLMTokenizer,ElectraTokenizer,MobileBertTokenizer,SqueezeBertTokenizer,AlbertTokenizer,GPT2Tokenizer,BartTokenizer,MBartTokenizer,MBart50Tokenizer,RobertaTokenizer,WhisperTokenizer,CodeGenTokenizer,CLIPTokenizer,SiglipTokenizer,MarianTokenizer,BloomTokenizer,NllbTokenizer,M2M100Tokenizer,LlamaTokenizer,CodeLlamaTokenizer,XLMRobertaTokenizer,MPNetTokenizer,FalconTokenizer,GPTNeoXTokenizer,EsmTokenizer,Wav2Vec2CTCTokenizer,BlenderbotTokenizer,BlenderbotSmallTokenizer,SpeechT5Tokenizer,NougatTokenizer,VitsTokenizer,Qwen2Tokenizer,GemmaTokenizer,Grok1Tokenizer,CohereTokenizer,PreTrainedTokenizer};static async from_pretrained(w,{quantized:D=!0,progress_callback:O=null,config:U=null,cache_dir:G=null,local_files_only:q=!1,revision:K="main",legacy:ee=null}={}){const[Z,ie]=await loadTokenizer(w,{progress_callback:O,cache_dir:G,local_files_only:q,revision:K,legacy:ee}),Y=ie.tokenizer_class?.replace(/Fast$/,"")??"PreTrainedTokenizer";let W=this.TOKENIZER_CLASS_MAPPING[Y];return W||(console.warn(`Unknown tokenizer class "${Y}", attempting to construct from base class.`),W=PreTrainedTokenizer),new W(Z,ie)}}async function loadConfig(F,w){return await getModelJSON(F,"config.json",!0,w)}class PretrainedConfig{constructor(w){this.model_type=null,this.is_encoder_decoder=!1,Object.assign(this,w)}static async from_pretrained(w,{progress_callback:D=null,config:O=null,cache_dir:U=null,local_files_only:G=!1,revision:q="main"}={}){let K=O??await loadConfig(w,{progress_callback:D,cache_dir:U,local_files_only:G,revision:q});return new this(K)}}class AutoConfig{static async from_pretrained(...w){return PretrainedConfig.from_pretrained(...w)}}class LogitsProcessorList extends Callable{constructor(){super(),this.processors=[]}push(w){this.processors.push(w)}extend(w){this.processors.push(...w)}_call(w,D){for(let O of D)this.processors.forEach(U=>U(w,O))}[Symbol.iterator](){return this.processors.values()}}class LogitsProcessor extends Callable{_call(w,D){throw Error("`_call` should be implemented in a subclass")}}class ForceTokensLogitsProcessor extends LogitsProcessor{constructor(w){super(),this.force_token_map=Object.fromEntries(w??[])}_call(w,D){let O=this.force_token_map[w.length];return exists(O)&&(D.data.fill(-1/0),D.data[O]=0),D}}class ForcedBOSTokenLogitsProcessor extends LogitsProcessor{constructor(w){super(),this.bos_token_id=w}_call(w,D){return w.length===1&&(D.data.fill(-1/0),D.data[this.bos_token_id]=0),D}}class ForcedEOSTokenLogitsProcessor extends LogitsProcessor{constructor(w,D){super(),this.max_length=w,this.forced_eos_token_id=D}_call(w,D){}}class SuppressTokensAtBeginLogitsProcessor extends LogitsProcessor{constructor(w,D){super(),this.begin_suppress_tokens=w,this.begin_index=D}_call(w,D){if(w.length===this.begin_index)for(let O of this.begin_suppress_tokens)D.data[O]=-1/0;return D}}class WhisperTimeStampLogitsProcessor extends LogitsProcessor{constructor(w){super(),this.eos_token_id=w.eos_token_id,this.no_timestamps_token_id=w.no_timestamps_token_id,this.timestamp_begin=this.no_timestamps_token_id+1,this.begin_index=(w.forced_decoder_ids||[]).length+2,w.forced_decoder_ids.slice(-1)[0][1]===this.no_timestamps_token_id&&(this.begin_index-=1),this.max_initial_timestamp_index=w.max_initial_timestamp_index}_call(w,D){const O=D.data;if(O[this.no_timestamps_token_id]=-1/0,w.length===this.begin_index-1)return O.fill(-1/0),O[this.timestamp_begin]=0,D;const U=w.slice(this.begin_index),G=U.length>=1&&U[U.length-1]>=this.timestamp_begin,q=U.length<2||U[U.length-2]>=this.timestamp_begin;if(G&&(q?O.subarray(this.timestamp_begin).fill(-1/0):O.subarray(0,this.eos_token_id).fill(-1/0)),w.length===this.begin_index&&this.max_initial_timestamp_index!==null){const ie=this.timestamp_begin+this.max_initial_timestamp_index;O.subarray(ie+1).fill(-1/0)}const K=log_softmax(O),ee=Math.log(K.subarray(this.timestamp_begin).map(Math.exp).reduce((ie,Y)=>ie+Y)),Z=max(K.subarray(0,this.timestamp_begin))[0];return ee>Z&&O.subarray(0,this.timestamp_begin).fill(-1/0),D}}class NoRepeatNGramLogitsProcessor extends LogitsProcessor{constructor(w){super(),this.no_repeat_ngram_size=w}getNgrams(w){const D=w.length,O=[];for(let G=0;G<D+1-this.no_repeat_ngram_size;++G){const q=[];for(let K=0;K<this.no_repeat_ngram_size;++K)q.push(w[G+K]);O.push(q)}const U=new Map;for(const G of O){const q=G.slice(0,G.length-1),K=JSON.stringify(q),ee=U.get(K)??[];ee.push(G[G.length-1]),U.set(K,ee)}return U}getGeneratedNgrams(w,D){const O=D.slice(D.length+1-this.no_repeat_ngram_size,D.length);return w.get(JSON.stringify(O))??[]}calcBannedNgramTokens(w){const D=[];if(w.length+1<this.no_repeat_ngram_size)return D;{const O=this.getNgrams(w);return this.getGeneratedNgrams(O,w)}}_call(w,D){const O=this.calcBannedNgramTokens(w);for(const U of O)D.data[U]=-1/0;return D}}class RepetitionPenaltyLogitsProcessor extends LogitsProcessor{constructor(w){super(),this.penalty=w}_call(w,D){for(const O of w)D.data[O]<0?D.data[O]*=this.penalty:D.data[O]/=this.penalty;return D}}class MinLengthLogitsProcessor extends LogitsProcessor{constructor(w,D){super(),this.min_length=w,this.eos_token_id=Array.isArray(D)?D:[D]}_call(w,D){if(w.length<this.min_length)for(const O of this.eos_token_id)D.data[O]=-1/0;return D}}class MinNewTokensLengthLogitsProcessor extends LogitsProcessor{constructor(w,D,O){super(),this.prompt_length_to_skip=w,this.min_new_tokens=D,this.eos_token_id=Array.isArray(O)?O:[O]}_call(w,D){if(w.length-this.prompt_length_to_skip<this.min_new_tokens)for(const U of this.eos_token_id)D.data[U]=-1/0;return D}}class NoBadWordsLogitsProcessor extends LogitsProcessor{constructor(w,D){super(),this.bad_words_ids=w,this.eos_token_id=Array.isArray(D)?D:[D]}_call(w,D){for(const O of this.bad_words_ids){let U=!0;for(let G=1;G<=O.length-1&&O.length<w.length;++G)if(O.at(-G-1)!==w.at(-G)){U=!1;break}U&&(D.data[O.at(-1)]=-1/0)}return D}}const GenerationConfig=class{constructor(F={}){this.max_length=F.max_length??20,this.max_new_tokens=F.max_new_tokens??null,this.min_length=F.min_length??0,this.min_new_tokens=F.min_new_tokens??null,this.early_stopping=F.early_stopping??!1,this.max_time=F.max_time??null,this.do_sample=F.do_sample??!1,this.num_beams=F.num_beams??1,this.num_beam_groups=F.num_beam_groups??1,this.penalty_alpha=F.penalty_alpha??null,this.use_cache=F.use_cache??!0,this.temperature=F.temperature??1,this.top_k=F.top_k??50,this.top_p=F.top_p??1,this.typical_p=F.typical_p??1,this.epsilon_cutoff=F.epsilon_cutoff??0,this.eta_cutoff=F.eta_cutoff??0,this.diversity_penalty=F.diversity_penalty??0,this.repetition_penalty=F.repetition_penalty??1,this.encoder_repetition_penalty=F.encoder_repetition_penalty??1,this.length_penalty=F.length_penalty??1,this.no_repeat_ngram_size=F.no_repeat_ngram_size??0,this.bad_words_ids=F.bad_words_ids??null,this.force_words_ids=F.force_words_ids??null,this.renormalize_logits=F.renormalize_logits??!1,this.constraints=F.constraints??null,this.forced_bos_token_id=F.forced_bos_token_id??null,this.forced_eos_token_id=F.forced_eos_token_id??null,this.remove_invalid_values=F.remove_invalid_values??!1,this.exponential_decay_length_penalty=F.exponential_decay_length_penalty??null,this.suppress_tokens=F.suppress_tokens??null,this.begin_suppress_tokens=F.begin_suppress_tokens??null,this.forced_decoder_ids=F.forced_decoder_ids??null,this.num_return_sequences=F.num_return_sequences??1,this.output_attentions=F.output_attentions??!1,this.output_hidden_states=F.output_hidden_states??!1,this.output_scores=F.output_scores??!1,this.return_dict_in_generate=F.return_dict_in_generate??!1,this.pad_token_id=F.pad_token_id??null,this.bos_token_id=F.bos_token_id??null,this.eos_token_id=F.eos_token_id??null,this.encoder_no_repeat_ngram_size=F.encoder_no_repeat_ngram_size??0,this.decoder_start_token_id=F.decoder_start_token_id??null,this.generation_kwargs=F.generation_kwargs??{}}};class Sampler extends Callable{constructor(w){super(),this.generation_config=w}_call(w,D=-1){return this.sample(w,D)}sample(w,D){throw Error("sample should be implemented in subclasses.")}getLogits(w,D){let O=w.dims.at(-1),U=w.data;if(D===-1)U=U.slice(-O);else{let G=D*O;U=U.slice(G,G+O)}return this.generation_config.temperature>0&&(U=U.map(G=>G/this.generation_config.temperature)),U}randomSelect(w){let D=w.reduce((U,G)=>U+G,0),O=Math.random()*D;for(let U=0;U<w.length;++U)if(O-=w[U],O<=0)return U;return 0}static getSampler(w){if(w.do_sample)return new MultinomialSampler(w);if(w.num_beams>1)return new BeamSearchSampler(w);if(w.num_return_sequences>1)throw Error(`num_return_sequences has to be 1 when doing greedy search, but is ${w.num_return_sequences}.`);return new GreedySampler(w)}}class GreedySampler extends Sampler{sample(w,D=-1){let O=this.getLogits(w,D);return[[max(O)[1],0]]}}class MultinomialSampler extends Sampler{sample(w,D=-1){let O=w.dims.at(-1);this.generation_config.top_k>0&&(O=Math.min(this.generation_config.top_k,O));const U=this.getLogits(w,D),G=getTopItems(U,O),q=softmax(G.map(K=>K[1]));return Array.from({length:this.generation_config.num_beams},()=>{const K=this.randomSelect(q);return[G[K][0],Math.log(q[K])]})}}class BeamSearchSampler extends Sampler{sample(w,D=-1){let O=w.dims.at(-1);this.generation_config.top_k>0&&(O=Math.min(this.generation_config.top_k,O));const U=this.getLogits(w,D),G=getTopItems(U,O),q=softmax(G.map(K=>K[1]));return Array.from({length:this.generation_config.num_beams},(K,ee)=>[G[ee][0],Math.log(q[ee])])}}const{InferenceSession,Tensor:ONNXTensor,env}=ONNX,MODEL_TYPES={EncoderOnly:0,EncoderDecoder:1,Seq2Seq:2,Vision2Seq:3,DecoderOnly:4,MaskGeneration:5},MODEL_TYPE_MAPPING=new Map,MODEL_NAME_TO_CLASS_MAPPING=new Map,MODEL_CLASS_TO_NAME_MAPPING=new Map;async function constructSession(F,w,D){let O=`onnx/${w}${D.quantized?"_quantized":""}.onnx`,U=await getModelFile(F,O,!0,D);try{return await InferenceSession.create(U,{executionProviders})}catch(G){if(executionProviders.length===1&&executionProviders[0]==="wasm")throw G;return console.warn(G),console.warn("Something went wrong during model construction (most likely a missing operation). Using `wasm` as a fallback. "),await InferenceSession.create(U,{executionProviders:["wasm"]})}}function validateInputs(F,w){const D=Object.create(null),O=[];for(const q of F.inputNames){const K=w[q];if(!(K instanceof Tensor)){O.push(q);continue}D[q]=env.wasm.proxy?K.clone():K}if(O.length>0)throw new Error(`An error occurred during model execution: "Missing the following inputs: ${O.join(", ")}.`);const U=Object.keys(w).length,G=F.inputNames.length;if(U>G){let q=Object.keys(w).filter(K=>!F.inputNames.includes(K));console.warn(`WARNING: Too many inputs were provided (${U} > ${G}). The following inputs will be ignored: "${q.join(", ")}".`)}return D}async function sessionRun(F,w){const D=validateInputs(F,w);try{let O=await F.run(D);return O=replaceTensors(O),O}catch(O){throw console.error(`An error occurred during model execution: "${O}".`),console.error("Inputs given to model:",D),O}}function replaceTensors(F){for(let w in F)F[w]instanceof ONNXTensor?F[w]=new Tensor(F[w]):typeof F[w]=="object"&&replaceTensors(F[w]);return F}function toI64Tensor(F){if(F instanceof Tensor)return F;if(F.length===0)throw Error("items must be non-empty");if(Array.isArray(F[0])){if(F.some(w=>w.length!==F[0].length))throw Error("Unable to create tensor, you should probably activate truncation and/or padding with 'padding=True' and/or 'truncation=True' to have batched tensors with the same length.");return new Tensor("int64",BigInt64Array.from(F.flat().map(w=>BigInt(w))),[F.length,F[0].length])}else return new Tensor("int64",BigInt64Array.from(F.map(w=>BigInt(w))),[1,F.length])}function prepareAttentionMask(F,w){let D=F.config.pad_token_id??null,O=F.config.eos_token_id??null;isIntegralNumber(O)&&(O=[O]);let U=w.indexOf(D)!==-1,G=O===null||!O.includes(D);if(U&&G){let q=BigInt64Array.from(w.data.map(K=>K!=D));return new Tensor("int64",q,w.dims)}else return ones_like(w)}function preparePositionIds(F,w,D){if(!F.inputNames.includes("position_ids"))return;const O=new BigInt64Array(w.attention_mask.data.length);for(let U=0;U<w.attention_mask.dims[0];++U){let G=U*w.attention_mask.dims[1],q=BigInt(0);for(let K=0;K<w.attention_mask.dims[1];++K){const ee=G+K;w.attention_mask.data[ee]===0n?O[ee]=BigInt(1):(O[ee]=q,q+=w.attention_mask.data[ee])}}w.position_ids=new Tensor("int64",O,w.attention_mask.dims),D&&(w.position_ids=w.position_ids.slice(null,-1).unsqueeze_(-1))}function boolTensor(F){return new Tensor("bool",[F],[1])}async function seq2seqForward(F,w){let{encoder_outputs:D,past_key_values:O}=w;D||(D=(await encoderForward(F,w)).last_hidden_state);let U={input_ids:w.decoder_input_ids,encoder_hidden_states:D};const G=!!O;F.decoder_merged_session.inputNames.includes("use_cache_branch")&&(U.use_cache_branch=boolTensor(G)),F.decoder_merged_session.inputNames.includes("encoder_attention_mask")&&(U.encoder_attention_mask=w.attention_mask),preparePositionIds(F.decoder_merged_session,U,G),F.addPastKeyValues(U,O);const q=await sessionRun(F.decoder_merged_session,U);let K=q.logits;O=F.getPastKeyValues(q,O);const ee=F.getAttentions(q);return new Seq2SeqLMOutput({logits:K,past_key_values:O,encoder_outputs:D,...ee})}function seq2seqStartBeams(F,w,D,O){let U=[],G=0;const q=F.requires_attention_mask??!0;let K=D.decoder_input_ids??D.decoder_start_token_id??D.bos_token_id??D.eos_token_id;K instanceof Tensor?K=K.tolist().flat():Array.isArray(K)||(K=[K]);for(let ee of w){ee.dims=[1,...ee.dims];let Z={inputs:ee,encoder_outputs:null,prev_model_outputs:null,output_token_ids:K,done:!1,score:0,id:G++};q&&(Z.attention_mask=prepareAttentionMask(F,ee)),U.push(Z)}return U}async function seq2seqRunBeam(F,w){const D=F.main_input_name;let O=w.output_token_ids;w.prev_model_outputs&&(O=O.slice(-1));let U={[D]:w.inputs,decoder_input_ids:toI64Tensor(O),encoder_outputs:w.encoder_outputs,past_key_values:w.prev_model_outputs?.past_key_values};w.attention_mask&&(U.attention_mask=w.attention_mask);let G=await F.forward(U);return w.prev_model_outputs=G,w.encoder_outputs=G.encoder_outputs,G}function seq2seqUpdatebeam(F,w){F.output_token_ids=[...F.output_token_ids,w]}async function encoderForward(F,w){const D=Object.create(null);for(const O of F.session.inputNames)D[O]=w[O];return F.session.inputNames.includes("token_type_ids")&&!D.token_type_ids&&(D.token_type_ids=new Tensor("int64",new BigInt64Array(D.input_ids.data.length),D.input_ids.dims)),await sessionRun(F.session,D)}async function decoderForward(F,w){let{input_ids:D,past_key_values:O,attention_mask:U}=w,G={input_ids:D,attention_mask:U??prepareAttentionMask(F,D)};const q=!!O;F.session.inputNames.includes("use_cache_branch")&&(G.use_cache_branch=boolTensor(q)),preparePositionIds(F.session,G,q),F.addPastKeyValues(G,O);let K=await sessionRun(F.session,G),ee=K.logits;return O=F.getPastKeyValues(K,O),{logits:ee,past_key_values:O}}function decoderStartBeams(F,w,D,O,U){let G=[],q=0;for(let K of w){let ee=K.tolist().map(Number);K.dims=[1,...K.dims];let Z;U?(Z=U[q],Z.dims=[1,...Z.dims]):Z=prepareAttentionMask(F,K);let ie={input:K,model_input_ids:K,attention_mask:Z,prev_model_outputs:null,output_token_ids:ee,num_output_tokens:O,done:!1,score:0,id:q++};G.push(ie)}return G}async function decoderRunBeam(F,w){let D=new BigInt64Array(w.output_token_ids.length).fill(1n),O={input_ids:w.model_input_ids,attention_mask:new Tensor("int64",D,[1,D.length]),past_key_values:w.prev_model_outputs?.past_key_values},U=await F.forward(O);return w.prev_model_outputs=U,U}function decoderUpdatebeam(F,w){F.output_token_ids=[...F.output_token_ids,w],F.model_input_ids=new Tensor("int64",[BigInt(w)],[1,1])}class PreTrainedModel extends Callable{main_input_name="input_ids";constructor(w,D){super(),this.config=w,this.session=D;const O=MODEL_CLASS_TO_NAME_MAPPING.get(this.constructor),U=MODEL_TYPE_MAPPING.get(O);this.can_generate=!1,this._runBeam=null,this._getStartBeams=null,this._updateBeam=null,this._forward=null,U===MODEL_TYPES.DecoderOnly?(this.can_generate=!0,this._runBeam=decoderRunBeam,this._getStartBeams=decoderStartBeams,this._updateBeam=decoderUpdatebeam,this._forward=decoderForward):U===MODEL_TYPES.Seq2Seq||U===MODEL_TYPES.Vision2Seq?(this.can_generate=!0,this._runBeam=seq2seqRunBeam,this._getStartBeams=seq2seqStartBeams,this._updateBeam=seq2seqUpdatebeam,this._forward=seq2seqForward):U===MODEL_TYPES.EncoderDecoder?this._forward=encoderForward:this._forward=encoderForward}async dispose(){const w=[];for(let D of Object.keys(this)){const O=this[D];O instanceof InferenceSession&&w.push(O.handler.dispose())}return await Promise.all(w)}static async from_pretrained(w,{quantized:D=!0,progress_callback:O=null,config:U=null,cache_dir:G=null,local_files_only:q=!1,revision:K="main",model_file_name:ee=null}={}){let Z={quantized:D,progress_callback:O,config:U,cache_dir:G,local_files_only:q,revision:K,model_file_name:ee};const ie=MODEL_CLASS_TO_NAME_MAPPING.get(this),Y=MODEL_TYPE_MAPPING.get(ie);let W;return Y===MODEL_TYPES.DecoderOnly?W=await Promise.all([AutoConfig.from_pretrained(w,Z),constructSession(w,Z.model_file_name??"decoder_model_merged",Z),getModelJSON(w,"generation_config.json",!1,Z)]):Y===MODEL_TYPES.Seq2Seq||Y===MODEL_TYPES.Vision2Seq?W=await Promise.all([AutoConfig.from_pretrained(w,Z),constructSession(w,"encoder_model",Z),constructSession(w,"decoder_model_merged",Z),getModelJSON(w,"generation_config.json",!1,Z)]):Y===MODEL_TYPES.MaskGeneration?W=await Promise.all([AutoConfig.from_pretrained(w,Z),constructSession(w,"vision_encoder",Z),constructSession(w,"prompt_encoder_mask_decoder",Z)]):Y===MODEL_TYPES.EncoderDecoder?W=await Promise.all([AutoConfig.from_pretrained(w,Z),constructSession(w,"encoder_model",Z),constructSession(w,"decoder_model_merged",Z)]):(Y!==MODEL_TYPES.EncoderOnly&&console.warn(`Model type for '${ie??U?.model_type}' not found, assuming encoder-only architecture. Please report this at https://github.com/xenova/transformers.js/issues/new/choose.`),W=await Promise.all([AutoConfig.from_pretrained(w,Z),constructSession(w,Z.model_file_name??"model",Z)])),new this(...W)}async _call(w){return await this.forward(w)}async forward(w){return await this._forward(this,w)}_get_logits_processor(w,D,O=null){const U=new LogitsProcessorList;if(w.repetition_penalty!==null&&w.repetition_penalty!==1&&U.push(new RepetitionPenaltyLogitsProcessor(w.repetition_penalty)),w.no_repeat_ngram_size!==null&&w.no_repeat_ngram_size>0&&U.push(new NoRepeatNGramLogitsProcessor(w.no_repeat_ngram_size)),w.bad_words_ids!==null&&U.push(new NoBadWordsLogitsProcessor(w.bad_words_ids,w.eos_token_id)),w.min_length!==null&&w.eos_token_id!==null&&w.min_length>0&&U.push(new MinLengthLogitsProcessor(w.min_length,w.eos_token_id)),w.min_new_tokens!==null&&w.eos_token_id!==null&&w.min_new_tokens>0&&U.push(new MinNewTokensLengthLogitsProcessor(D,w.min_new_tokens,w.eos_token_id)),w.forced_bos_token_id!==null&&U.push(new ForcedBOSTokenLogitsProcessor(w.forced_bos_token_id)),w.forced_eos_token_id!==null&&U.push(new ForcedEOSTokenLogitsProcessor(w.max_length,w.forced_eos_token_id)),w.begin_suppress_tokens!==null){let G=D>1||w.forced_bos_token_id===null?D:D+1;w.forced_decoder_ids!==null&&(G+=w.forced_decoder_ids[w.forced_decoder_ids.length-1][0]),U.push(new SuppressTokensAtBeginLogitsProcessor(w.begin_suppress_tokens,G))}return w.forced_decoder_ids!==null&&U.push(new ForceTokensLogitsProcessor(w.forced_decoder_ids)),O!==null&&U.extend(O),U}_get_generation_config(w){let D=new GenerationConfig(this.config);return"generation_config"in this&&Object.assign(D,this.generation_config),w!==null&&Object.assign(D,w),D}async generate(w,D=null,O=null,{inputs_attention_mask:U=null}={}){if(!this.can_generate){let ce=`The current model class (${MODEL_CLASS_TO_NAME_MAPPING.get(this.constructor)}) is not compatible with \`.generate()\`, as it doesn't have a language model head.`;const he=this.config.model_type,pe=MODEL_WITH_LM_HEAD_MAPPING_NAMES.get(he)??MODEL_FOR_SEQ_TO_SEQ_CAUSAL_LM_MAPPING_NAMES.get(he)??MODEL_FOR_SPEECH_SEQ_2_SEQ_MAPPING_NAMES.get(he)??MODEL_FOR_VISION_2_SEQ_MAPPING_NAMES.get(he);throw pe&&(ce+=` Please use the following class instead: '${pe[0]}'`),Error(ce)}if(!(w instanceof Tensor)&&!isTypedArray(w)&&!Array.isArray(w))throw Error(`\`inputs\` must be a Tensor, TypedArray, or Array, but is "${w.constructor.name}".`);let G;if(this.config.is_encoder_decoder)G=0;else if(G=w instanceof Tensor?w.dims.at(-1):w.length,G===0)throw Error("Must supply a non-empty array of input token ids.");D=this._get_generation_config(D),O=O??new LogitsProcessorList,O=this._get_logits_processor(D,G,O);let q=D.eos_token_id;q!==null&&!Array.isArray(q)&&(q=[q]);let K=1;const ee=K+(D.max_new_tokens??1/0),Z=Number.isInteger(D.max_length)&&(D.max_new_tokens??null)===null;let ie=Sampler.getSampler(D),Y=this.getStartBeams(w,D,K,U);for(;Y.some(le=>!le.done)&&K<ee;){let le=[];for(let ce of Y){if(ce.done){le.push(ce);continue}if(Z&&ce.output_token_ids.length>=D.max_length){ce.done=!0,le.push(ce);continue}let he=await this.runBeam(ce);D.output_attentions&&this.addAttentionsToBeam(ce,he),D.output_scores;let pe=he.logits.slice(null,-1,null);O(ce.output_token_ids,pe);let me=ie(pe);for(let[be,ge]of me){let ve={...ce};this.updateBeam(ve,be),ve.score+=ge,q&&q.includes(be)&&(ve.done=!0),le.push(ve)}}++K,le=this.groupBeams(le).map(ce=>ce.sort((he,pe)=>pe.score-he.score).slice(0,D.num_beams)),Y=le.flat(),D.callback_function&&D.callback_function(Y)}const W=this.groupBeams(Y),ne=le=>W.map(ce=>D.num_return_sequences>1?ce.slice(0,D.num_return_sequences).map(he=>he[le]):[ce[0][le]]).flat(),se=ne("output_token_ids");if(D.return_dict_in_generate){const le=ne("decoder_attentions"),ce=ne("cross_attentions");return{sequences:se,decoder_attentions:le,cross_attentions:ce}}else return se}addAttentionsToBeam(w,D){if(this.config.is_encoder_decoder){if(!D.cross_attentions||D.cross_attentions.length===0)throw Error("`output_attentions` is true, but the model did not produce cross-attentions. This is most likely because the model was not exported with `output_attentions=True`.");w.cross_attentions||(w.cross_attentions=[]),w.cross_attentions.push(D.cross_attentions)}if(!D.decoder_attentions||D.decoder_attentions.length===0)throw Error("`output_attentions` is true, but the model did not produce decoder-attentions. This is most likely because the model was not exported with `output_attentions=True`.");w.decoder_attentions||(w.decoder_attentions=[]),w.decoder_attentions.push(D.decoder_attentions)}groupBeams(w){const D=Object.create(null);for(const O of w)D[O.id]===void 0?D[O.id]=[O]:D[O.id].push(O);return Object.values(D)}getPastKeyValues(w,D){const O=Object.create(null);for(const U in w)if(U.startsWith("present")){let G=U.replace("present","past_key_values");D&&U.includes("encoder")?O[G]=D[G]:O[G]=w[U]}return O}getAttentions(w){const D=Object.create(null);for(const O of["cross_attentions","decoder_attentions"]){const U=[];for(const G in w)if(G.startsWith(O)){const q=G.split(".").pop();U[q]=w[G]}D[O]=U}return D}addPastKeyValues(w,D){if(D)Object.assign(w,D);else if(this.config.is_encoder_decoder&&(this.add_encoder_pkv??!0)){let U=[1,this.num_encoder_heads,0,this.encoder_dim_kv],G=[1,this.num_decoder_heads,0,this.decoder_dim_kv];for(let q=0;q<this.num_decoder_layers;++q)w[`past_key_values.${q}.encoder.key`]=new Tensor("float32",[],U),w[`past_key_values.${q}.encoder.value`]=new Tensor("float32",[],U),w[`past_key_values.${q}.decoder.key`]=new Tensor("float32",[],G),w[`past_key_values.${q}.decoder.value`]=new Tensor("float32",[],G)}else if(this.config.model_type==="falcon"){let U=[1*this.num_heads,0,this.dim_kv];for(let G=0;G<this.num_layers;++G)w[`past_key_values.${G}.key`]=new Tensor("float32",[],U),w[`past_key_values.${G}.value`]=new Tensor("float32",[],U)}else if(this.config.multi_query){let U=[1*this.num_heads,0,2*this.dim_kv];for(let G=0;G<this.num_layers;++G)w[`past_key_values.${G}.key_value`]=new Tensor("float32",[],U)}else if(this.config.model_type==="bloom"){let U=[1*this.num_heads,this.dim_kv,0],G=[1*this.num_heads,0,this.dim_kv];for(let q=0;q<this.num_layers;++q)w[`past_key_values.${q}.key`]=new Tensor("float32",[],U),w[`past_key_values.${q}.value`]=new Tensor("float32",[],G)}else{let U=[1,this.num_heads,0,this.dim_kv];for(let G=0;G<this.num_layers;++G)w[`past_key_values.${G}.key`]=new Tensor("float32",[],U),w[`past_key_values.${G}.value`]=new Tensor("float32",[],U)}}getStartBeams(w,D,O,U){return this._getStartBeams(this,w,D,O,U)}async runBeam(w){return await this._runBeam(this,w)}updateBeam(w,D){return this._updateBeam(w,D)}}class ModelOutput{}class BertPreTrainedModel extends PreTrainedModel{}class BertModel extends BertPreTrainedModel{}class BertForMaskedLM extends BertPreTrainedModel{async _call(w){return new MaskedLMOutput(await super._call(w))}}class BertForSequenceClassification extends BertPreTrainedModel{async _call(w){return new SequenceClassifierOutput(await super._call(w))}}class BertForTokenClassification extends BertPreTrainedModel{async _call(w){return new TokenClassifierOutput(await super._call(w))}}class BertForQuestionAnswering extends BertPreTrainedModel{async _call(w){return new QuestionAnsweringModelOutput(await super._call(w))}}class NomicBertPreTrainedModel extends PreTrainedModel{}class NomicBertModel extends NomicBertPreTrainedModel{}class RoFormerPreTrainedModel extends PreTrainedModel{}class RoFormerModel extends RoFormerPreTrainedModel{}class RoFormerForMaskedLM extends RoFormerPreTrainedModel{async _call(w){return new MaskedLMOutput(await super._call(w))}}class RoFormerForSequenceClassification extends RoFormerPreTrainedModel{async _call(w){return new SequenceClassifierOutput(await super._call(w))}}class RoFormerForTokenClassification extends RoFormerPreTrainedModel{async _call(w){return new TokenClassifierOutput(await super._call(w))}}class RoFormerForQuestionAnswering extends RoFormerPreTrainedModel{async _call(w){return new QuestionAnsweringModelOutput(await super._call(w))}}class ConvBertPreTrainedModel extends PreTrainedModel{}class ConvBertModel extends ConvBertPreTrainedModel{}class ConvBertForMaskedLM extends ConvBertPreTrainedModel{async _call(w){return new MaskedLMOutput(await super._call(w))}}class ConvBertForSequenceClassification extends ConvBertPreTrainedModel{async _call(w){return new SequenceClassifierOutput(await super._call(w))}}class ConvBertForTokenClassification extends ConvBertPreTrainedModel{async _call(w){return new TokenClassifierOutput(await super._call(w))}}class ConvBertForQuestionAnswering extends ConvBertPreTrainedModel{async _call(w){return new QuestionAnsweringModelOutput(await super._call(w))}}class ElectraPreTrainedModel extends PreTrainedModel{}class ElectraModel extends ElectraPreTrainedModel{}class ElectraForMaskedLM extends ElectraPreTrainedModel{async _call(w){return new MaskedLMOutput(await super._call(w))}}class ElectraForSequenceClassification extends ElectraPreTrainedModel{async _call(w){return new SequenceClassifierOutput(await super._call(w))}}class ElectraForTokenClassification extends ElectraPreTrainedModel{async _call(w){return new TokenClassifierOutput(await super._call(w))}}class ElectraForQuestionAnswering extends ElectraPreTrainedModel{async _call(w){return new QuestionAnsweringModelOutput(await super._call(w))}}class CamembertPreTrainedModel extends PreTrainedModel{}class CamembertModel extends CamembertPreTrainedModel{}class CamembertForMaskedLM extends CamembertPreTrainedModel{async _call(w){return new MaskedLMOutput(await super._call(w))}}class CamembertForSequenceClassification extends CamembertPreTrainedModel{async _call(w){return new SequenceClassifierOutput(await super._call(w))}}class CamembertForTokenClassification extends CamembertPreTrainedModel{async _call(w){return new TokenClassifierOutput(await super._call(w))}}class CamembertForQuestionAnswering extends CamembertPreTrainedModel{async _call(w){return new QuestionAnsweringModelOutput(await super._call(w))}}class DebertaPreTrainedModel extends PreTrainedModel{}class DebertaModel extends DebertaPreTrainedModel{}class DebertaForMaskedLM extends DebertaPreTrainedModel{async _call(w){return new MaskedLMOutput(await super._call(w))}}class DebertaForSequenceClassification extends DebertaPreTrainedModel{async _call(w){return new SequenceClassifierOutput(await super._call(w))}}class DebertaForTokenClassification extends DebertaPreTrainedModel{async _call(w){return new TokenClassifierOutput(await super._call(w))}}class DebertaForQuestionAnswering extends DebertaPreTrainedModel{async _call(w){return new QuestionAnsweringModelOutput(await super._call(w))}}class DebertaV2PreTrainedModel extends PreTrainedModel{}class DebertaV2Model extends DebertaV2PreTrainedModel{}class DebertaV2ForMaskedLM extends DebertaV2PreTrainedModel{async _call(w){return new MaskedLMOutput(await super._call(w))}}class DebertaV2ForSequenceClassification extends DebertaV2PreTrainedModel{async _call(w){return new SequenceClassifierOutput(await super._call(w))}}class DebertaV2ForTokenClassification extends DebertaV2PreTrainedModel{async _call(w){return new TokenClassifierOutput(await super._call(w))}}class DebertaV2ForQuestionAnswering extends DebertaV2PreTrainedModel{async _call(w){return new QuestionAnsweringModelOutput(await super._call(w))}}class DistilBertPreTrainedModel extends PreTrainedModel{}class DistilBertModel extends DistilBertPreTrainedModel{}class DistilBertForSequenceClassification extends DistilBertPreTrainedModel{async _call(w){return new SequenceClassifierOutput(await super._call(w))}}class DistilBertForTokenClassification extends DistilBertPreTrainedModel{async _call(w){return new TokenClassifierOutput(await super._call(w))}}class DistilBertForQuestionAnswering extends DistilBertPreTrainedModel{async _call(w){return new QuestionAnsweringModelOutput(await super._call(w))}}class DistilBertForMaskedLM extends DistilBertPreTrainedModel{async _call(w){return new MaskedLMOutput(await super._call(w))}}class EsmPreTrainedModel extends PreTrainedModel{}class EsmModel extends EsmPreTrainedModel{}class EsmForMaskedLM extends EsmPreTrainedModel{async _call(w){return new MaskedLMOutput(await super._call(w))}}class EsmForSequenceClassification extends EsmPreTrainedModel{async _call(w){return new SequenceClassifierOutput(await super._call(w))}}class EsmForTokenClassification extends EsmPreTrainedModel{async _call(w){return new TokenClassifierOutput(await super._call(w))}}class MobileBertPreTrainedModel extends PreTrainedModel{}class MobileBertModel extends MobileBertPreTrainedModel{}class MobileBertForMaskedLM extends MobileBertPreTrainedModel{async _call(w){return new MaskedLMOutput(await super._call(w))}}class MobileBertForSequenceClassification extends MobileBertPreTrainedModel{async _call(w){return new SequenceClassifierOutput(await super._call(w))}}class MobileBertForQuestionAnswering extends MobileBertPreTrainedModel{async _call(w){return new QuestionAnsweringModelOutput(await super._call(w))}}class MPNetPreTrainedModel extends PreTrainedModel{}class MPNetModel extends MPNetPreTrainedModel{}class MPNetForMaskedLM extends MPNetPreTrainedModel{async _call(w){return new MaskedLMOutput(await super._call(w))}}class MPNetForSequenceClassification extends MPNetPreTrainedModel{async _call(w){return new SequenceClassifierOutput(await super._call(w))}}class MPNetForTokenClassification extends MPNetPreTrainedModel{async _call(w){return new TokenClassifierOutput(await super._call(w))}}class MPNetForQuestionAnswering extends MPNetPreTrainedModel{async _call(w){return new QuestionAnsweringModelOutput(await super._call(w))}}class SqueezeBertPreTrainedModel extends PreTrainedModel{}class SqueezeBertModel extends SqueezeBertPreTrainedModel{}class SqueezeBertForMaskedLM extends SqueezeBertPreTrainedModel{async _call(w){return new MaskedLMOutput(await super._call(w))}}class SqueezeBertForSequenceClassification extends SqueezeBertPreTrainedModel{async _call(w){return new SequenceClassifierOutput(await super._call(w))}}class SqueezeBertForQuestionAnswering extends SqueezeBertPreTrainedModel{async _call(w){return new QuestionAnsweringModelOutput(await super._call(w))}}class AlbertPreTrainedModel extends PreTrainedModel{}class AlbertModel extends AlbertPreTrainedModel{}class AlbertForSequenceClassification extends AlbertPreTrainedModel{async _call(w){return new SequenceClassifierOutput(await super._call(w))}}class AlbertForQuestionAnswering extends AlbertPreTrainedModel{async _call(w){return new QuestionAnsweringModelOutput(await super._call(w))}}class AlbertForMaskedLM extends AlbertPreTrainedModel{async _call(w){return new MaskedLMOutput(await super._call(w))}}class T5PreTrainedModel extends PreTrainedModel{}class T5Model extends T5PreTrainedModel{}class T5ForConditionalGeneration extends T5PreTrainedModel{constructor(w,D,O,U){super(w,D),this.decoder_merged_session=O,this.generation_config=U,this.num_decoder_layers=this.config.num_decoder_layers,this.num_decoder_heads=this.config.num_heads,this.decoder_dim_kv=this.config.d_kv,this.num_encoder_layers=this.config.num_layers,this.num_encoder_heads=this.config.num_heads,this.encoder_dim_kv=this.config.d_kv}}class LongT5PreTrainedModel extends PreTrainedModel{}class LongT5Model extends LongT5PreTrainedModel{}class LongT5ForConditionalGeneration extends LongT5PreTrainedModel{constructor(w,D,O,U){super(w,D),this.decoder_merged_session=O,this.generation_config=U,this.num_decoder_layers=this.config.num_decoder_layers,this.num_decoder_heads=this.config.num_heads,this.decoder_dim_kv=this.config.d_kv,this.num_encoder_layers=this.config.num_layers,this.num_encoder_heads=this.config.num_heads,this.encoder_dim_kv=this.config.d_kv}}class MT5PreTrainedModel extends PreTrainedModel{}class MT5Model extends MT5PreTrainedModel{}class MT5ForConditionalGeneration extends MT5PreTrainedModel{constructor(w,D,O,U){super(w,D),this.decoder_merged_session=O,this.generation_config=U,this.num_decoder_layers=this.config.num_decoder_layers,this.num_decoder_heads=this.config.num_heads,this.decoder_dim_kv=this.config.d_kv,this.num_encoder_layers=this.config.num_layers,this.num_encoder_heads=this.config.num_heads,this.encoder_dim_kv=this.config.d_kv}}class BartPretrainedModel extends PreTrainedModel{}class BartModel extends BartPretrainedModel{}class BartForConditionalGeneration extends BartPretrainedModel{constructor(w,D,O,U){super(w,D),this.decoder_merged_session=O,this.generation_config=U,this.num_decoder_layers=this.config.decoder_layers,this.num_decoder_heads=this.config.decoder_attention_heads,this.decoder_dim_kv=this.config.d_model/this.num_decoder_heads,this.num_encoder_layers=this.config.encoder_layers,this.num_encoder_heads=this.config.encoder_attention_heads,this.encoder_dim_kv=this.config.d_model/this.num_encoder_heads}}class BartForSequenceClassification extends BartPretrainedModel{async _call(w){return new SequenceClassifierOutput(await super._call(w))}}class MBartPreTrainedModel extends PreTrainedModel{}class MBartModel extends MBartPreTrainedModel{}class MBartForConditionalGeneration extends MBartPreTrainedModel{constructor(w,D,O,U){super(w,D),this.decoder_merged_session=O,this.generation_config=U,this.num_decoder_layers=this.config.decoder_layers,this.num_decoder_heads=this.config.decoder_attention_heads,this.decoder_dim_kv=this.config.d_model/this.num_decoder_heads,this.num_encoder_layers=this.config.encoder_layers,this.num_encoder_heads=this.config.encoder_attention_heads,this.encoder_dim_kv=this.config.d_model/this.num_encoder_heads}}class MBartForSequenceClassification extends MBartPreTrainedModel{async _call(w){return new SequenceClassifierOutput(await super._call(w))}}class MBartForCausalLM extends MBartPreTrainedModel{constructor(w,D,O){super(w,D),this.generation_config=O,this.num_decoder_layers=this.config.decoder_layers,this.num_decoder_heads=this.config.decoder_attention_heads,this.decoder_dim_kv=this.config.d_model/this.num_decoder_heads,this.num_encoder_layers=this.config.encoder_layers,this.num_encoder_heads=this.config.encoder_attention_heads,this.encoder_dim_kv=this.config.d_model/this.num_encoder_heads}}class BlenderbotPreTrainedModel extends PreTrainedModel{}class BlenderbotModel extends BlenderbotPreTrainedModel{}class BlenderbotForConditionalGeneration extends BlenderbotPreTrainedModel{constructor(w,D,O,U){super(w,D),this.decoder_merged_session=O,this.generation_config=U,this.num_decoder_layers=this.config.decoder_layers,this.num_decoder_heads=this.config.decoder_attention_heads,this.decoder_dim_kv=this.config.d_model/this.num_decoder_heads,this.num_encoder_layers=this.config.encoder_layers,this.num_encoder_heads=this.config.encoder_attention_heads,this.encoder_dim_kv=this.config.d_model/this.num_encoder_heads}}class BlenderbotSmallPreTrainedModel extends PreTrainedModel{}class BlenderbotSmallModel extends BlenderbotSmallPreTrainedModel{}class BlenderbotSmallForConditionalGeneration extends BlenderbotSmallPreTrainedModel{constructor(w,D,O,U){super(w,D),this.decoder_merged_session=O,this.generation_config=U,this.num_decoder_layers=this.config.decoder_layers,this.num_decoder_heads=this.config.decoder_attention_heads,this.decoder_dim_kv=this.config.d_model/this.num_decoder_heads,this.num_encoder_layers=this.config.encoder_layers,this.num_encoder_heads=this.config.encoder_attention_heads,this.encoder_dim_kv=this.config.d_model/this.num_encoder_heads}}class RobertaPreTrainedModel extends PreTrainedModel{}class RobertaModel extends RobertaPreTrainedModel{}class RobertaForMaskedLM extends RobertaPreTrainedModel{async _call(w){return new MaskedLMOutput(await super._call(w))}}class RobertaForSequenceClassification extends RobertaPreTrainedModel{async _call(w){return new SequenceClassifierOutput(await super._call(w))}}class RobertaForTokenClassification extends RobertaPreTrainedModel{async _call(w){return new TokenClassifierOutput(await super._call(w))}}class RobertaForQuestionAnswering extends RobertaPreTrainedModel{async _call(w){return new QuestionAnsweringModelOutput(await super._call(w))}}class XLMPreTrainedModel extends PreTrainedModel{}class XLMModel extends XLMPreTrainedModel{}class XLMWithLMHeadModel extends XLMPreTrainedModel{async _call(w){return new MaskedLMOutput(await super._call(w))}}class XLMForSequenceClassification extends XLMPreTrainedModel{async _call(w){return new SequenceClassifierOutput(await super._call(w))}}class XLMForTokenClassification extends XLMPreTrainedModel{async _call(w){return new TokenClassifierOutput(await super._call(w))}}class XLMForQuestionAnswering extends XLMPreTrainedModel{async _call(w){return new QuestionAnsweringModelOutput(await super._call(w))}}class XLMRobertaPreTrainedModel extends PreTrainedModel{}class XLMRobertaModel extends XLMRobertaPreTrainedModel{}class XLMRobertaForMaskedLM extends XLMRobertaPreTrainedModel{async _call(w){return new MaskedLMOutput(await super._call(w))}}class XLMRobertaForSequenceClassification extends XLMRobertaPreTrainedModel{async _call(w){return new SequenceClassifierOutput(await super._call(w))}}class XLMRobertaForTokenClassification extends XLMRobertaPreTrainedModel{async _call(w){return new TokenClassifierOutput(await super._call(w))}}class XLMRobertaForQuestionAnswering extends XLMRobertaPreTrainedModel{async _call(w){return new QuestionAnsweringModelOutput(await super._call(w))}}class ASTPreTrainedModel extends PreTrainedModel{}class ASTModel extends ASTPreTrainedModel{}class ASTForAudioClassification extends ASTPreTrainedModel{}class WhisperPreTrainedModel extends PreTrainedModel{}class WhisperModel extends WhisperPreTrainedModel{}class WhisperForConditionalGeneration extends WhisperPreTrainedModel{requires_attention_mask=!1;main_input_name="input_features";constructor(w,D,O,U){super(w,D),this.decoder_merged_session=O,this.generation_config=U,this.num_decoder_layers=this.config.decoder_layers,this.num_decoder_heads=this.config.decoder_attention_heads,this.decoder_dim_kv=this.config.d_model/this.num_decoder_heads,this.num_encoder_layers=this.config.encoder_layers,this.num_encoder_heads=this.config.encoder_attention_heads,this.encoder_dim_kv=this.config.d_model/this.num_encoder_heads}async generate(w,D=null,O=null){if(D=this._get_generation_config(D),D.return_timestamps??=!1,D.return_timestamps&&(O=[new WhisperTimeStampLogitsProcessor(D)]),D.return_token_timestamps&&(D.output_attentions=!0,D.return_dict_in_generate=!0,D.task==="translate"&&console.warn("Token-level timestamps may not be reliable for task 'translate'."),!D.alignment_heads))throw new Error("Model generation config has no `alignment_heads`, token-level timestamps not available. See https://gist.github.com/hollance/42e32852f24243b748ae6bc1f985b13a on how to add this property to the generation config.");const U=await super.generate(w,D,O);return D.return_token_timestamps&&D.alignment_heads&&(U.token_timestamps=this._extract_token_timestamps(U,D.alignment_heads,D.num_frames)),U}_extract_token_timestamps(w,D,O=null,U=.02){if(!w.cross_attentions)throw new Error("Model outputs must contain cross attentions to extract timestamps. This is most likely because the model was not exported with `output_attentions=True`.");let G=this.config.median_filter_width;G===void 0&&(console.warn("Model config has no `median_filter_width`, using default value of 7."),G=7);const q=w.cross_attentions.map(Z=>{let ie=Array.from({length:this.config.decoder_layers},(ce,he)=>cat(Z.map(pe=>pe[he]),2)),Y=stack(D.map(([ce,he])=>O?ie[ce].slice(null,he,null,[0,O]):ie[ce].slice(null,he)));Y=Y.transpose(1,0,2,3);let[W,ne]=std_mean(Y,-2,0,!0),se=Y.clone();for(let ce=0;ce<se.dims[0];++ce){let he=se[ce];for(let pe=0;pe<he.dims[0];++pe){let me=he[pe];const be=W[ce][pe][0],ge=ne[ce][pe][0];for(let ve=0;ve<me.dims[0];++ve){let Se=me[ve];for(let Me=0;Me<Se.data.length;++Me)Se.data[Me]=(Se.data[Me]-ge.data[Me])/be.data[Me];Se.data.set(medianFilter(Se.data,G))}}}return mean(se,1)}),K=[w.sequences.length,w.sequences[0].length],ee=new Tensor("float32",new Float32Array(K[0]*K[1]),K);for(let Z=0;Z<K[0];++Z){const ie=q[Z].neg().squeeze_(0);let[Y,W]=dynamicTimeWarping(ie),ne=Array.from({length:Y.length-1},(ce,he)=>Y[he+1]-Y[he]),se=mergeArrays([1],ne).map(ce=>!!ce),le=[];for(let ce=0;ce<se.length;++ce)se[ce]&&le.push(W[ce]*U);ee[Z].data.set(le,1)}return ee}}class VisionEncoderDecoderModel extends PreTrainedModel{main_input_name="pixel_values";constructor(w,D,O,U){super(w,D),this.decoder_merged_session=O,this.generation_config=U;const G=this.config.encoder,q=this.config.decoder,K=G.model_type;(MODEL_MAPPING_NAMES_ENCODER_ONLY.get(K)??MODEL_MAPPING_NAMES_ENCODER_DECODER.get(K))||console.warn(`Model type for encoder '${K}' not found, assuming encoder-only architecture. Please report this at https://github.com/xenova/transformers.js/issues/new/choose.`);const Z=MODEL_WITH_LM_HEAD_MAPPING_NAMES.get(q.model_type);if(!Z)throw new Error(`Unable to construct \`VisionEncoderDecoder\` due to unsupported decoder: "${this.config.decoder.model_type}"`);const ie=Z[1],Y=new ie(q,O,U);this.add_encoder_pkv="num_decoder_layers"in Y,this.add_encoder_pkv?(this.num_decoder_layers=Y.num_decoder_layers,this.num_decoder_heads=Y.num_decoder_heads,this.decoder_dim_kv=Y.decoder_dim_kv,this.num_encoder_layers=Y.num_encoder_layers,this.num_encoder_heads=Y.num_encoder_heads,this.encoder_dim_kv=Y.encoder_dim_kv):(this.num_layers=Y.num_layers,this.num_heads=Y.num_heads,this.dim_kv=Y.dim_kv)}}class CLIPPreTrainedModel extends PreTrainedModel{}class CLIPModel extends CLIPPreTrainedModel{}class CLIPTextModelWithProjection extends CLIPPreTrainedModel{static async from_pretrained(w,D={}){return D.model_file_name??="text_model",super.from_pretrained(w,D)}}class CLIPVisionModelWithProjection extends CLIPPreTrainedModel{static async from_pretrained(w,D={}){return D.model_file_name??="vision_model",super.from_pretrained(w,D)}}class SiglipPreTrainedModel extends PreTrainedModel{}class SiglipModel extends SiglipPreTrainedModel{}class SiglipTextModel extends SiglipPreTrainedModel{static async from_pretrained(w,D={}){return D.model_file_name??="text_model",super.from_pretrained(w,D)}}class SiglipVisionModel extends CLIPPreTrainedModel{static async from_pretrained(w,D={}){return D.model_file_name??="vision_model",super.from_pretrained(w,D)}}class ChineseCLIPPreTrainedModel extends PreTrainedModel{}class ChineseCLIPModel extends ChineseCLIPPreTrainedModel{}class CLIPSegPreTrainedModel extends PreTrainedModel{}class CLIPSegModel extends CLIPSegPreTrainedModel{}class CLIPSegForImageSegmentation extends CLIPSegPreTrainedModel{}class GPT2PreTrainedModel extends PreTrainedModel{constructor(w,D,O){super(w,D),this.generation_config=O,this.config.pad_token_id=this.config.eos_token_id,this.num_heads=this.config.n_head,this.num_layers=this.config.n_layer,this.dim_kv=this.config.n_embd/this.num_heads}}class GPT2Model extends GPT2PreTrainedModel{}class GPT2LMHeadModel extends GPT2PreTrainedModel{}class GPTNeoPreTrainedModel extends PreTrainedModel{constructor(w,D,O){super(w,D),this.generation_config=O,this.config.pad_token_id=this.config.eos_token_id,this.num_heads=this.config.num_heads,this.num_layers=this.config.num_layers,this.dim_kv=this.config.hidden_size/this.num_heads}}class GPTNeoModel extends GPTNeoPreTrainedModel{}class GPTNeoForCausalLM extends GPTNeoPreTrainedModel{}class GPTNeoXPreTrainedModel extends PreTrainedModel{constructor(w,D,O){super(w,D),this.generation_config=O,this.config.pad_token_id=this.config.eos_token_id,this.num_heads=this.config.num_attention_heads,this.num_layers=this.config.num_hidden_layers,this.dim_kv=this.config.hidden_size/this.num_heads}}class GPTNeoXModel extends GPTNeoXPreTrainedModel{}class GPTNeoXForCausalLM extends GPTNeoXPreTrainedModel{}class GPTJPreTrainedModel extends PreTrainedModel{constructor(w,D,O){super(w,D),this.generation_config=O,this.config.pad_token_id=this.config.eos_token_id,this.num_heads=this.config.n_head,this.num_layers=this.config.n_layer,this.dim_kv=this.config.n_embd/this.num_heads}}class GPTJModel extends GPTJPreTrainedModel{}class GPTJForCausalLM extends GPTJPreTrainedModel{}class GPTBigCodePreTrainedModel extends PreTrainedModel{constructor(w,D,O){super(w,D),this.generation_config=O,this.config.pad_token_id=this.config.eos_token_id,this.num_heads=this.config.n_head,this.num_layers=this.config.n_layer,this.dim_kv=this.config.n_embd/this.num_heads}}class GPTBigCodeModel extends GPTBigCodePreTrainedModel{}class GPTBigCodeForCausalLM extends GPTBigCodePreTrainedModel{}class CodeGenPreTrainedModel extends PreTrainedModel{constructor(w,D,O){super(w,D),this.generation_config=O,this.config.pad_token_id=this.config.eos_token_id,this.num_heads=this.config.n_head,this.num_layers=this.config.n_layer,this.dim_kv=this.config.n_embd/this.num_heads}}class CodeGenModel extends CodeGenPreTrainedModel{}class CodeGenForCausalLM extends CodeGenPreTrainedModel{}class LlamaPreTrainedModel extends PreTrainedModel{constructor(w,D,O){super(w,D),this.generation_config=O,this.config.pad_token_id=this.config.eos_token_id,this.num_heads=this.config.num_key_value_heads??this.config.num_attention_heads,this.num_layers=this.config.num_hidden_layers,this.dim_kv=this.config.hidden_size/this.config.num_attention_heads}}class LlamaModel extends LlamaPreTrainedModel{}class LlamaForCausalLM extends LlamaPreTrainedModel{}class Qwen2PreTrainedModel extends PreTrainedModel{constructor(w,D,O){super(w,D),this.generation_config=O,this.config.pad_token_id=this.config.eos_token_id,this.num_heads=this.config.num_key_value_heads??this.config.num_attention_heads,this.num_layers=this.config.num_hidden_layers,this.dim_kv=this.config.hidden_size/this.config.num_attention_heads}}class Qwen2Model extends Qwen2PreTrainedModel{}class Qwen2ForCausalLM extends Qwen2PreTrainedModel{}class PhiPreTrainedModel extends PreTrainedModel{constructor(w,D,O){super(w,D),this.generation_config=O,this.config.pad_token_id=this.config.eos_token_id,this.num_heads=this.config.num_attention_heads,this.num_layers=this.config.num_hidden_layers,this.dim_kv=this.config.hidden_size/this.num_heads}}class PhiModel extends PhiPreTrainedModel{}class PhiForCausalLM extends PhiPreTrainedModel{}class BloomPreTrainedModel extends PreTrainedModel{constructor(w,D,O){super(w,D),this.generation_config=O,this.config.pad_token_id=this.config.eos_token_id,this.num_heads=this.config.n_head,this.num_layers=this.config.n_layer,this.dim_kv=this.config.hidden_size/this.num_heads}}class BloomModel extends BloomPreTrainedModel{}class BloomForCausalLM extends BloomPreTrainedModel{}class MptPreTrainedModel extends PreTrainedModel{constructor(w,D,O){super(w,D),this.generation_config=O,this.config.pad_token_id=this.config.eos_token_id,this.num_heads=this.config.n_heads,this.num_layers=this.config.n_layers,this.dim_kv=this.config.d_model/this.num_heads}}class MptModel extends MptPreTrainedModel{}class MptForCausalLM extends MptPreTrainedModel{}class OPTPreTrainedModel extends PreTrainedModel{constructor(w,D,O){super(w,D),this.generation_config=O,this.config.pad_token_id=this.config.eos_token_id,this.num_heads=this.config.num_attention_heads,this.num_layers=this.config.num_hidden_layers,this.dim_kv=this.config.hidden_size/this.num_heads}}class OPTModel extends OPTPreTrainedModel{}class OPTForCausalLM extends OPTPreTrainedModel{}class ViTPreTrainedModel extends PreTrainedModel{}class ViTModel extends ViTPreTrainedModel{}class ViTForImageClassification extends ViTPreTrainedModel{async _call(w){return new SequenceClassifierOutput(await super._call(w))}}class FastViTPreTrainedModel extends PreTrainedModel{}class FastViTModel extends FastViTPreTrainedModel{}class FastViTForImageClassification extends FastViTPreTrainedModel{async _call(w){return new SequenceClassifierOutput(await super._call(w))}}class VitMattePreTrainedModel extends PreTrainedModel{}class VitMatteForImageMatting extends VitMattePreTrainedModel{async _call(w){return new ImageMattingOutput(await super._call(w))}}class MobileViTPreTrainedModel extends PreTrainedModel{}class MobileViTModel extends MobileViTPreTrainedModel{}class MobileViTForImageClassification extends MobileViTPreTrainedModel{async _call(w){return new SequenceClassifierOutput(await super._call(w))}}class MobileViTV2PreTrainedModel extends PreTrainedModel{}class MobileViTV2Model extends MobileViTV2PreTrainedModel{}class MobileViTV2ForImageClassification extends MobileViTV2PreTrainedModel{async _call(w){return new SequenceClassifierOutput(await super._call(w))}}class OwlViTPreTrainedModel extends PreTrainedModel{}class OwlViTModel extends OwlViTPreTrainedModel{}class OwlViTForObjectDetection extends OwlViTPreTrainedModel{}class Owlv2PreTrainedModel extends PreTrainedModel{}class Owlv2Model extends Owlv2PreTrainedModel{}class Owlv2ForObjectDetection extends Owlv2PreTrainedModel{}class BeitPreTrainedModel extends PreTrainedModel{}class BeitModel extends BeitPreTrainedModel{}class BeitForImageClassification extends BeitPreTrainedModel{async _call(w){return new SequenceClassifierOutput(await super._call(w))}}class DetrPreTrainedModel extends PreTrainedModel{}class DetrModel extends DetrPreTrainedModel{}class DetrForObjectDetection extends DetrPreTrainedModel{async _call(w){return new DetrObjectDetectionOutput(await super._call(w))}}class DetrForSegmentation extends DetrPreTrainedModel{async _call(w){return new DetrSegmentationOutput(await super._call(w))}}class DetrObjectDetectionOutput extends ModelOutput{constructor({logits:w,pred_boxes:D}){super(),this.logits=w,this.pred_boxes=D}}class DetrSegmentationOutput extends ModelOutput{constructor({logits:w,pred_boxes:D,pred_masks:O}){super(),this.logits=w,this.pred_boxes=D,this.pred_masks=O}}class TableTransformerPreTrainedModel extends PreTrainedModel{}class TableTransformerModel extends TableTransformerPreTrainedModel{}class TableTransformerForObjectDetection extends TableTransformerPreTrainedModel{async _call(w){return new TableTransformerObjectDetectionOutput(await super._call(w))}}class TableTransformerObjectDetectionOutput extends DetrObjectDetectionOutput{}class DeiTPreTrainedModel extends PreTrainedModel{}class DeiTModel extends DeiTPreTrainedModel{}class DeiTForImageClassification extends DeiTPreTrainedModel{async _call(w){return new SequenceClassifierOutput(await super._call(w))}}class ResNetPreTrainedModel extends PreTrainedModel{}class ResNetModel extends ResNetPreTrainedModel{}class ResNetForImageClassification extends ResNetPreTrainedModel{async _call(w){return new SequenceClassifierOutput(await super._call(w))}}class SwinPreTrainedModel extends PreTrainedModel{}class SwinModel extends SwinPreTrainedModel{}class SwinForImageClassification extends SwinPreTrainedModel{async _call(w){return new SequenceClassifierOutput(await super._call(w))}}class Swin2SRPreTrainedModel extends PreTrainedModel{}class Swin2SRModel extends Swin2SRPreTrainedModel{}class Swin2SRForImageSuperResolution extends Swin2SRPreTrainedModel{}class DPTPreTrainedModel extends PreTrainedModel{}class DPTModel extends DPTPreTrainedModel{}class DPTForDepthEstimation extends DPTPreTrainedModel{}class DepthAnythingPreTrainedModel extends PreTrainedModel{}class DepthAnythingForDepthEstimation extends DepthAnythingPreTrainedModel{}class GLPNPreTrainedModel extends PreTrainedModel{}class GLPNModel extends GLPNPreTrainedModel{}class GLPNForDepthEstimation extends GLPNPreTrainedModel{}class DonutSwinPreTrainedModel extends PreTrainedModel{}class DonutSwinModel extends DonutSwinPreTrainedModel{}class ConvNextPreTrainedModel extends PreTrainedModel{}class ConvNextModel extends ConvNextPreTrainedModel{}class ConvNextForImageClassification extends ConvNextPreTrainedModel{async _call(w){return new SequenceClassifierOutput(await super._call(w))}}class ConvNextV2PreTrainedModel extends PreTrainedModel{}class ConvNextV2Model extends ConvNextV2PreTrainedModel{}class ConvNextV2ForImageClassification extends ConvNextV2PreTrainedModel{async _call(w){return new SequenceClassifierOutput(await super._call(w))}}class Dinov2PreTrainedModel extends PreTrainedModel{}class Dinov2Model extends Dinov2PreTrainedModel{}class Dinov2ForImageClassification extends Dinov2PreTrainedModel{async _call(w){return new SequenceClassifierOutput(await super._call(w))}}class YolosPreTrainedModel extends PreTrainedModel{}class YolosModel extends YolosPreTrainedModel{}class YolosForObjectDetection extends YolosPreTrainedModel{async _call(w){return new YolosObjectDetectionOutput(await super._call(w))}}class YolosObjectDetectionOutput extends ModelOutput{constructor({logits:w,pred_boxes:D}){super(),this.logits=w,this.pred_boxes=D}}class SamPreTrainedModel extends PreTrainedModel{}class SamModel extends SamPreTrainedModel{constructor(w,D,O){super(w,D),this.prompt_encoder_mask_decoder=O}async get_image_embeddings({pixel_values:w}){return await encoderForward(this,{pixel_values:w})}async forward(w){if((!w.image_embeddings||!w.image_positional_embeddings)&&(w={...w,...await this.get_image_embeddings(w)}),!w.input_labels){const D=w.input_points.dims.slice(0,-1),O=D.reduce((U,G)=>U*G,1);w.input_labels=new Tensor("int64",new BigInt64Array(O).fill(1n),D)}return await sessionRun(this.prompt_encoder_mask_decoder,{input_points:w.input_points,input_labels:w.input_labels,image_embeddings:w.image_embeddings,image_positional_embeddings:w.image_positional_embeddings})}async _call(w){return new SamImageSegmentationOutput(await super._call(w))}}class SamImageSegmentationOutput extends ModelOutput{constructor({iou_scores:w,pred_masks:D}){super(),this.iou_scores=w,this.pred_masks=D}}class MarianPreTrainedModel extends PreTrainedModel{}class MarianModel extends MarianPreTrainedModel{}class MarianMTModel extends MarianPreTrainedModel{constructor(w,D,O,U){super(w,D),this.decoder_merged_session=O,this.generation_config=U,this.num_decoder_layers=this.config.decoder_layers,this.num_decoder_heads=this.config.decoder_attention_heads,this.decoder_dim_kv=this.config.d_model/this.num_decoder_heads,this.num_encoder_layers=this.config.encoder_layers,this.num_encoder_heads=this.config.encoder_attention_heads,this.encoder_dim_kv=this.config.d_model/this.num_encoder_heads}}class M2M100PreTrainedModel extends PreTrainedModel{}class M2M100Model extends M2M100PreTrainedModel{}class M2M100ForConditionalGeneration extends M2M100PreTrainedModel{constructor(w,D,O,U){super(w,D),this.decoder_merged_session=O,this.generation_config=U,this.num_decoder_layers=this.config.decoder_layers,this.num_decoder_heads=this.config.decoder_attention_heads,this.decoder_dim_kv=this.config.d_model/this.num_decoder_heads,this.num_encoder_layers=this.config.encoder_layers,this.num_encoder_heads=this.config.encoder_attention_heads,this.encoder_dim_kv=this.config.d_model/this.num_encoder_heads}}class Wav2Vec2PreTrainedModel extends PreTrainedModel{}class Wav2Vec2Model extends Wav2Vec2PreTrainedModel{}class Wav2Vec2ForCTC extends Wav2Vec2PreTrainedModel{async _call(w){return new CausalLMOutput(await super._call(w))}}class Wav2Vec2ForSequenceClassification extends Wav2Vec2PreTrainedModel{async _call(w){return new SequenceClassifierOutput(await super._call(w))}}class Wav2Vec2ForAudioFrameClassification extends Wav2Vec2PreTrainedModel{async _call(w){return new TokenClassifierOutput(await super._call(w))}}class UniSpeechPreTrainedModel extends PreTrainedModel{}class UniSpeechModel extends UniSpeechPreTrainedModel{}class UniSpeechForCTC extends UniSpeechPreTrainedModel{async _call(w){return new CausalLMOutput(await super._call(w))}}class UniSpeechForSequenceClassification extends UniSpeechPreTrainedModel{async _call(w){return new SequenceClassifierOutput(await super._call(w))}}class UniSpeechSatPreTrainedModel extends PreTrainedModel{}class UniSpeechSatModel extends UniSpeechSatPreTrainedModel{}class UniSpeechSatForCTC extends UniSpeechSatPreTrainedModel{async _call(w){return new CausalLMOutput(await super._call(w))}}class UniSpeechSatForSequenceClassification extends UniSpeechSatPreTrainedModel{async _call(w){return new SequenceClassifierOutput(await super._call(w))}}class UniSpeechSatForAudioFrameClassification extends UniSpeechSatPreTrainedModel{async _call(w){return new TokenClassifierOutput(await super._call(w))}}class Wav2Vec2BertPreTrainedModel extends PreTrainedModel{}class Wav2Vec2BertModel extends Wav2Vec2BertPreTrainedModel{}class Wav2Vec2BertForCTC extends Wav2Vec2BertPreTrainedModel{async _call(w){return new CausalLMOutput(await super._call(w))}}class Wav2Vec2BertForSequenceClassification extends Wav2Vec2BertPreTrainedModel{async _call(w){return new SequenceClassifierOutput(await super._call(w))}}class HubertModel extends Wav2Vec2PreTrainedModel{}class HubertForCTC extends Wav2Vec2PreTrainedModel{async _call(w){return new CausalLMOutput(await super._call(w))}}class HubertForSequenceClassification extends Wav2Vec2PreTrainedModel{async _call(w){return new SequenceClassifierOutput(await super._call(w))}}class WavLMPreTrainedModel extends PreTrainedModel{}class WavLMModel extends WavLMPreTrainedModel{}class WavLMForCTC extends WavLMPreTrainedModel{async _call(w){return new CausalLMOutput(await super._call(w))}}class WavLMForSequenceClassification extends WavLMPreTrainedModel{async _call(w){return new SequenceClassifierOutput(await super._call(w))}}class WavLMForXVector extends WavLMPreTrainedModel{async _call(w){return new XVectorOutput(await super._call(w))}}class WavLMForAudioFrameClassification extends WavLMPreTrainedModel{async _call(w){return new TokenClassifierOutput(await super._call(w))}}class SpeechT5PreTrainedModel extends PreTrainedModel{}class SpeechT5ForSpeechToText extends SpeechT5PreTrainedModel{}class SpeechT5ForTextToSpeech extends SpeechT5PreTrainedModel{constructor(w,D,O,U){super(w,D),this.decoder_merged_session=O,this.generation_config=U,this.num_decoder_layers=this.config.decoder_layers,this.num_decoder_heads=this.config.decoder_attention_heads,this.decoder_dim_kv=this.config.hidden_size/this.num_decoder_heads,this.num_encoder_layers=this.config.encoder_layers,this.num_encoder_heads=this.config.encoder_attention_heads,this.encoder_dim_kv=this.config.hidden_size/this.num_encoder_heads}async generate_speech(w,D,{threshold:O=.5,minlenratio:U=0,maxlenratio:G=20,vocoder:q=null}={}){const K={input_ids:w},{encoder_outputs:ee,encoder_attention_mask:Z}=await encoderForward(this,K),ie=ee.dims[1]/this.config.reduction_factor,Y=Math.floor(ie*G),W=Math.floor(ie*U),ne=this.config.num_mel_bins;let se=[],le=null,ce=null,he=0;for(;;){++he;const be=boolTensor(!!ce);let ge;ce?ge=ce.output_sequence_out:ge=new Tensor("float32",new Float32Array(ne),[1,1,ne]);let ve={use_cache_branch:be,output_sequence:ge,encoder_attention_mask:Z,speaker_embeddings:D,encoder_hidden_states:ee};this.addPastKeyValues(ve,le),ce=await sessionRun(this.decoder_merged_session,ve),le=this.getPastKeyValues(ce,le);const{prob:Se,spectrum:Me}=ce;if(se.push(Me),he>=W&&(Array.from(Se.data).filter(Ee=>Ee>=O).length>0||he>=Y))break}const pe=cat(se),{waveform:me}=await sessionRun(q.session,{spectrogram:pe});return{spectrogram:pe,waveform:me}}}class SpeechT5HifiGan extends PreTrainedModel{main_input_name="spectrogram"}class TrOCRPreTrainedModel extends PreTrainedModel{constructor(w,D,O){super(w,D),this.generation_config=O,this.config.pad_token_id=this.config.eos_token_id,this.num_encoder_layers=this.num_decoder_layers=this.config.decoder_layers,this.num_encoder_heads=this.num_decoder_heads=this.config.decoder_attention_heads,this.encoder_dim_kv=this.decoder_dim_kv=this.config.d_model/this.num_decoder_heads}}class TrOCRForCausalLM extends TrOCRPreTrainedModel{}class MistralPreTrainedModel extends PreTrainedModel{constructor(w,D,O){super(w,D),this.generation_config=O,this.config.pad_token_id=this.config.eos_token_id,this.num_heads=this.config.num_key_value_heads,this.num_layers=this.config.num_hidden_layers,this.dim_kv=this.config.hidden_size/this.config.num_attention_heads}}class MistralModel extends MistralPreTrainedModel{}class MistralForCausalLM extends MistralPreTrainedModel{}class Starcoder2PreTrainedModel extends PreTrainedModel{constructor(w,D,O){super(w,D),this.generation_config=O,this.config.pad_token_id=this.config.eos_token_id,this.num_heads=this.config.num_key_value_heads,this.num_layers=this.config.num_hidden_layers,this.dim_kv=this.config.hidden_size/this.config.num_attention_heads}}class Starcoder2Model extends Starcoder2PreTrainedModel{}class Starcoder2ForCausalLM extends Starcoder2PreTrainedModel{}class FalconPreTrainedModel extends PreTrainedModel{constructor(w,D,O){super(w,D),this.generation_config=O,this.config.pad_token_id=this.config.eos_token_id,this.num_heads=this.config.num_attention_heads,this.num_layers=this.config.num_hidden_layers,this.dim_kv=this.config.hidden_size/this.config.num_attention_heads}}class FalconModel extends FalconPreTrainedModel{}class FalconForCausalLM extends FalconPreTrainedModel{}class ClapPreTrainedModel extends PreTrainedModel{}class ClapModel extends ClapPreTrainedModel{}class ClapTextModelWithProjection extends ClapPreTrainedModel{static async from_pretrained(w,D={}){return D.model_file_name??="text_model",super.from_pretrained(w,D)}}class ClapAudioModelWithProjection extends ClapPreTrainedModel{static async from_pretrained(w,D={}){return D.model_file_name??="audio_model",super.from_pretrained(w,D)}}class VitsPreTrainedModel extends PreTrainedModel{}class VitsModel extends VitsPreTrainedModel{async _call(w){return new VitsModelOutput(await super._call(w))}}class SegformerPreTrainedModel extends PreTrainedModel{}class SegformerForImageClassification extends SegformerPreTrainedModel{}class SegformerForSemanticSegmentation extends SegformerPreTrainedModel{}class StableLmPreTrainedModel extends PreTrainedModel{constructor(w,D,O){super(w,D),this.generation_config=O,this.config.pad_token_id=this.config.eos_token_id,this.num_heads=this.config.num_attention_heads,this.num_layers=this.config.num_hidden_layers,this.dim_kv=this.config.hidden_size/this.num_heads}}class StableLmForCausalLM extends StableLmPreTrainedModel{}class EfficientNetPreTrainedModel extends PreTrainedModel{}class EfficientNetModel extends EfficientNetPreTrainedModel{}class EfficientNetForImageClassification extends EfficientNetPreTrainedModel{async _call(w){return new SequenceClassifierOutput(await super._call(w))}}class PretrainedMixin{static MODEL_CLASS_MAPPINGS=null;static BASE_IF_FAIL=!1;static async from_pretrained(w,{quantized:D=!0,progress_callback:O=null,config:U=null,cache_dir:G=null,local_files_only:q=!1,revision:K="main",model_file_name:ee=null}={}){let Z={quantized:D,progress_callback:O,config:U,cache_dir:G,local_files_only:q,revision:K,model_file_name:ee};if(U=await AutoConfig.from_pretrained(w,Z),Z.config||(Z.config=U),!this.MODEL_CLASS_MAPPINGS)throw new Error("`MODEL_CLASS_MAPPINGS` not implemented for this type of `AutoClass`: "+this.name);for(let ie of this.MODEL_CLASS_MAPPINGS){const Y=ie.get(U.model_type);if(Y)return await Y[1].from_pretrained(w,Z)}if(this.BASE_IF_FAIL)return console.warn(`Unknown model class "${U.model_type}", attempting to construct from base class.`),await PreTrainedModel.from_pretrained(w,Z);throw Error(`Unsupported model type: ${U.model_type}`)}}const MODEL_MAPPING_NAMES_ENCODER_ONLY=new Map([["bert",["BertModel",BertModel]],["nomic_bert",["NomicBertModel",NomicBertModel]],["roformer",["RoFormerModel",RoFormerModel]],["electra",["ElectraModel",ElectraModel]],["esm",["EsmModel",EsmModel]],["convbert",["ConvBertModel",ConvBertModel]],["camembert",["CamembertModel",CamembertModel]],["deberta",["DebertaModel",DebertaModel]],["deberta-v2",["DebertaV2Model",DebertaV2Model]],["mpnet",["MPNetModel",MPNetModel]],["albert",["AlbertModel",AlbertModel]],["distilbert",["DistilBertModel",DistilBertModel]],["roberta",["RobertaModel",RobertaModel]],["xlm",["XLMModel",XLMModel]],["xlm-roberta",["XLMRobertaModel",XLMRobertaModel]],["clap",["ClapModel",ClapModel]],["clip",["CLIPModel",CLIPModel]],["clipseg",["CLIPSegModel",CLIPSegModel]],["chinese_clip",["ChineseCLIPModel",ChineseCLIPModel]],["siglip",["SiglipModel",SiglipModel]],["mobilebert",["MobileBertModel",MobileBertModel]],["squeezebert",["SqueezeBertModel",SqueezeBertModel]],["wav2vec2",["Wav2Vec2Model",Wav2Vec2Model]],["wav2vec2-bert",["Wav2Vec2BertModel",Wav2Vec2BertModel]],["unispeech",["UniSpeechModel",UniSpeechModel]],["unispeech-sat",["UniSpeechSatModel",UniSpeechSatModel]],["hubert",["HubertModel",HubertModel]],["wavlm",["WavLMModel",WavLMModel]],["audio-spectrogram-transformer",["ASTModel",ASTModel]],["vits",["VitsModel",VitsModel]],["detr",["DetrModel",DetrModel]],["table-transformer",["TableTransformerModel",TableTransformerModel]],["vit",["ViTModel",ViTModel]],["fastvit",["FastViTModel",FastViTModel]],["mobilevit",["MobileViTModel",MobileViTModel]],["mobilevitv2",["MobileViTV2Model",MobileViTV2Model]],["owlvit",["OwlViTModel",OwlViTModel]],["owlv2",["Owlv2Model",Owlv2Model]],["beit",["BeitModel",BeitModel]],["deit",["DeiTModel",DeiTModel]],["convnext",["ConvNextModel",ConvNextModel]],["convnextv2",["ConvNextV2Model",ConvNextV2Model]],["dinov2",["Dinov2Model",Dinov2Model]],["resnet",["ResNetModel",ResNetModel]],["swin",["SwinModel",SwinModel]],["swin2sr",["Swin2SRModel",Swin2SRModel]],["donut-swin",["DonutSwinModel",DonutSwinModel]],["yolos",["YolosModel",YolosModel]],["dpt",["DPTModel",DPTModel]],["glpn",["GLPNModel",GLPNModel]],["hifigan",["SpeechT5HifiGan",SpeechT5HifiGan]],["efficientnet",["EfficientNetModel",EfficientNetModel]]]),MODEL_MAPPING_NAMES_ENCODER_DECODER=new Map([["t5",["T5Model",T5Model]],["longt5",["LongT5Model",LongT5Model]],["mt5",["MT5Model",MT5Model]],["bart",["BartModel",BartModel]],["mbart",["MBartModel",MBartModel]],["marian",["MarianModel",MarianModel]],["whisper",["WhisperModel",WhisperModel]],["m2m_100",["M2M100Model",M2M100Model]],["blenderbot",["BlenderbotModel",BlenderbotModel]],["blenderbot-small",["BlenderbotSmallModel",BlenderbotSmallModel]]]),MODEL_MAPPING_NAMES_DECODER_ONLY=new Map([["bloom",["BloomModel",BloomModel]],["gpt2",["GPT2Model",GPT2Model]],["gptj",["GPTJModel",GPTJModel]],["gpt_bigcode",["GPTBigCodeModel",GPTBigCodeModel]],["gpt_neo",["GPTNeoModel",GPTNeoModel]],["gpt_neox",["GPTNeoXModel",GPTNeoXModel]],["codegen",["CodeGenModel",CodeGenModel]],["llama",["LlamaModel",LlamaModel]],["qwen2",["Qwen2Model",Qwen2Model]],["phi",["PhiModel",PhiModel]],["mpt",["MptModel",MptModel]],["opt",["OPTModel",OPTModel]],["mistral",["MistralModel",MistralModel]],["starcoder2",["Starcoder2Model",Starcoder2Model]],["falcon",["FalconModel",FalconModel]]]),MODEL_FOR_SPEECH_SEQ_2_SEQ_MAPPING_NAMES=new Map([["speecht5",["SpeechT5ForSpeechToText",SpeechT5ForSpeechToText]],["whisper",["WhisperForConditionalGeneration",WhisperForConditionalGeneration]]]),MODEL_FOR_TEXT_TO_SPECTROGRAM_MAPPING_NAMES=new Map([["speecht5",["SpeechT5ForTextToSpeech",SpeechT5ForTextToSpeech]]]),MODEL_FOR_TEXT_TO_WAVEFORM_MAPPING_NAMES=new Map([["vits",["VitsModel",VitsModel]]]),MODEL_FOR_SEQUENCE_CLASSIFICATION_MAPPING_NAMES=new Map([["bert",["BertForSequenceClassification",BertForSequenceClassification]],["roformer",["RoFormerForSequenceClassification",RoFormerForSequenceClassification]],["electra",["ElectraForSequenceClassification",ElectraForSequenceClassification]],["esm",["EsmForSequenceClassification",EsmForSequenceClassification]],["convbert",["ConvBertForSequenceClassification",ConvBertForSequenceClassification]],["camembert",["CamembertForSequenceClassification",CamembertForSequenceClassification]],["deberta",["DebertaForSequenceClassification",DebertaForSequenceClassification]],["deberta-v2",["DebertaV2ForSequenceClassification",DebertaV2ForSequenceClassification]],["mpnet",["MPNetForSequenceClassification",MPNetForSequenceClassification]],["albert",["AlbertForSequenceClassification",AlbertForSequenceClassification]],["distilbert",["DistilBertForSequenceClassification",DistilBertForSequenceClassification]],["roberta",["RobertaForSequenceClassification",RobertaForSequenceClassification]],["xlm",["XLMForSequenceClassification",XLMForSequenceClassification]],["xlm-roberta",["XLMRobertaForSequenceClassification",XLMRobertaForSequenceClassification]],["bart",["BartForSequenceClassification",BartForSequenceClassification]],["mbart",["MBartForSequenceClassification",MBartForSequenceClassification]],["mobilebert",["MobileBertForSequenceClassification",MobileBertForSequenceClassification]],["squeezebert",["SqueezeBertForSequenceClassification",SqueezeBertForSequenceClassification]]]),MODEL_FOR_TOKEN_CLASSIFICATION_MAPPING_NAMES=new Map([["bert",["BertForTokenClassification",BertForTokenClassification]],["roformer",["RoFormerForTokenClassification",RoFormerForTokenClassification]],["electra",["ElectraForTokenClassification",ElectraForTokenClassification]],["esm",["EsmForTokenClassification",EsmForTokenClassification]],["convbert",["ConvBertForTokenClassification",ConvBertForTokenClassification]],["camembert",["CamembertForTokenClassification",CamembertForTokenClassification]],["deberta",["DebertaForTokenClassification",DebertaForTokenClassification]],["deberta-v2",["DebertaV2ForTokenClassification",DebertaV2ForTokenClassification]],["mpnet",["MPNetForTokenClassification",MPNetForTokenClassification]],["distilbert",["DistilBertForTokenClassification",DistilBertForTokenClassification]],["roberta",["RobertaForTokenClassification",RobertaForTokenClassification]],["xlm",["XLMForTokenClassification",XLMForTokenClassification]],["xlm-roberta",["XLMRobertaForTokenClassification",XLMRobertaForTokenClassification]]]),MODEL_FOR_SEQ_TO_SEQ_CAUSAL_LM_MAPPING_NAMES=new Map([["t5",["T5ForConditionalGeneration",T5ForConditionalGeneration]],["longt5",["LongT5ForConditionalGeneration",LongT5ForConditionalGeneration]],["mt5",["MT5ForConditionalGeneration",MT5ForConditionalGeneration]],["bart",["BartForConditionalGeneration",BartForConditionalGeneration]],["mbart",["MBartForConditionalGeneration",MBartForConditionalGeneration]],["marian",["MarianMTModel",MarianMTModel]],["m2m_100",["M2M100ForConditionalGeneration",M2M100ForConditionalGeneration]],["blenderbot",["BlenderbotForConditionalGeneration",BlenderbotForConditionalGeneration]],["blenderbot-small",["BlenderbotSmallForConditionalGeneration",BlenderbotSmallForConditionalGeneration]]]),MODEL_WITH_LM_HEAD_MAPPING_NAMES=new Map([["bloom",["BloomForCausalLM",BloomForCausalLM]],["gpt2",["GPT2LMHeadModel",GPT2LMHeadModel]],["gptj",["GPTJForCausalLM",GPTJForCausalLM]],["gpt_bigcode",["GPTBigCodeForCausalLM",GPTBigCodeForCausalLM]],["gpt_neo",["GPTNeoForCausalLM",GPTNeoForCausalLM]],["gpt_neox",["GPTNeoXForCausalLM",GPTNeoXForCausalLM]],["codegen",["CodeGenForCausalLM",CodeGenForCausalLM]],["llama",["LlamaForCausalLM",LlamaForCausalLM]],["qwen2",["Qwen2ForCausalLM",Qwen2ForCausalLM]],["phi",["PhiForCausalLM",PhiForCausalLM]],["mpt",["MptForCausalLM",MptForCausalLM]],["opt",["OPTForCausalLM",OPTForCausalLM]],["mbart",["MBartForCausalLM",MBartForCausalLM]],["mistral",["MistralForCausalLM",MistralForCausalLM]],["starcoder2",["Starcoder2ForCausalLM",Starcoder2ForCausalLM]],["falcon",["FalconForCausalLM",FalconForCausalLM]],["trocr",["TrOCRForCausalLM",TrOCRForCausalLM]],["stablelm",["StableLmForCausalLM",StableLmForCausalLM]]]),MODEL_FOR_MASKED_LM_MAPPING_NAMES=new Map([["bert",["BertForMaskedLM",BertForMaskedLM]],["roformer",["RoFormerForMaskedLM",RoFormerForMaskedLM]],["electra",["ElectraForMaskedLM",ElectraForMaskedLM]],["esm",["EsmForMaskedLM",EsmForMaskedLM]],["convbert",["ConvBertForMaskedLM",ConvBertForMaskedLM]],["camembert",["CamembertForMaskedLM",CamembertForMaskedLM]],["deberta",["DebertaForMaskedLM",DebertaForMaskedLM]],["deberta-v2",["DebertaV2ForMaskedLM",DebertaV2ForMaskedLM]],["mpnet",["MPNetForMaskedLM",MPNetForMaskedLM]],["albert",["AlbertForMaskedLM",AlbertForMaskedLM]],["distilbert",["DistilBertForMaskedLM",DistilBertForMaskedLM]],["roberta",["RobertaForMaskedLM",RobertaForMaskedLM]],["xlm",["XLMWithLMHeadModel",XLMWithLMHeadModel]],["xlm-roberta",["XLMRobertaForMaskedLM",XLMRobertaForMaskedLM]],["mobilebert",["MobileBertForMaskedLM",MobileBertForMaskedLM]],["squeezebert",["SqueezeBertForMaskedLM",SqueezeBertForMaskedLM]]]),MODEL_FOR_QUESTION_ANSWERING_MAPPING_NAMES=new Map([["bert",["BertForQuestionAnswering",BertForQuestionAnswering]],["roformer",["RoFormerForQuestionAnswering",RoFormerForQuestionAnswering]],["electra",["ElectraForQuestionAnswering",ElectraForQuestionAnswering]],["convbert",["ConvBertForQuestionAnswering",ConvBertForQuestionAnswering]],["camembert",["CamembertForQuestionAnswering",CamembertForQuestionAnswering]],["deberta",["DebertaForQuestionAnswering",DebertaForQuestionAnswering]],["deberta-v2",["DebertaV2ForQuestionAnswering",DebertaV2ForQuestionAnswering]],["mpnet",["MPNetForQuestionAnswering",MPNetForQuestionAnswering]],["albert",["AlbertForQuestionAnswering",AlbertForQuestionAnswering]],["distilbert",["DistilBertForQuestionAnswering",DistilBertForQuestionAnswering]],["roberta",["RobertaForQuestionAnswering",RobertaForQuestionAnswering]],["xlm",["XLMForQuestionAnswering",XLMForQuestionAnswering]],["xlm-roberta",["XLMRobertaForQuestionAnswering",XLMRobertaForQuestionAnswering]],["mobilebert",["MobileBertForQuestionAnswering",MobileBertForQuestionAnswering]],["squeezebert",["SqueezeBertForQuestionAnswering",SqueezeBertForQuestionAnswering]]]),MODEL_FOR_VISION_2_SEQ_MAPPING_NAMES=new Map([["vision-encoder-decoder",["VisionEncoderDecoderModel",VisionEncoderDecoderModel]]]),MODEL_FOR_DOCUMENT_QUESTION_ANSWERING_MAPPING_NAMES=new Map([["vision-encoder-decoder",["VisionEncoderDecoderModel",VisionEncoderDecoderModel]]]),MODEL_FOR_IMAGE_CLASSIFICATION_MAPPING_NAMES=new Map([["vit",["ViTForImageClassification",ViTForImageClassification]],["fastvit",["FastViTForImageClassification",FastViTForImageClassification]],["mobilevit",["MobileViTForImageClassification",MobileViTForImageClassification]],["mobilevitv2",["MobileViTV2ForImageClassification",MobileViTV2ForImageClassification]],["beit",["BeitForImageClassification",BeitForImageClassification]],["deit",["DeiTForImageClassification",DeiTForImageClassification]],["convnext",["ConvNextForImageClassification",ConvNextForImageClassification]],["convnextv2",["ConvNextV2ForImageClassification",ConvNextV2ForImageClassification]],["dinov2",["Dinov2ForImageClassification",Dinov2ForImageClassification]],["resnet",["ResNetForImageClassification",ResNetForImageClassification]],["swin",["SwinForImageClassification",SwinForImageClassification]],["segformer",["SegformerForImageClassification",SegformerForImageClassification]],["efficientnet",["EfficientNetForImageClassification",EfficientNetForImageClassification]]]),MODEL_FOR_OBJECT_DETECTION_MAPPING_NAMES=new Map([["detr",["DetrForObjectDetection",DetrForObjectDetection]],["table-transformer",["TableTransformerForObjectDetection",TableTransformerForObjectDetection]],["yolos",["YolosForObjectDetection",YolosForObjectDetection]]]),MODEL_FOR_ZERO_SHOT_OBJECT_DETECTION_MAPPING_NAMES=new Map([["owlvit",["OwlViTForObjectDetection",OwlViTForObjectDetection]],["owlv2",["Owlv2ForObjectDetection",Owlv2ForObjectDetection]]]),MODEL_FOR_IMAGE_SEGMENTATION_MAPPING_NAMES=new Map([["detr",["DetrForSegmentation",DetrForSegmentation]],["clipseg",["CLIPSegForImageSegmentation",CLIPSegForImageSegmentation]]]),MODEL_FOR_SEMANTIC_SEGMENTATION_MAPPING_NAMES=new Map([["segformer",["SegformerForSemanticSegmentation",SegformerForSemanticSegmentation]]]),MODEL_FOR_MASK_GENERATION_MAPPING_NAMES=new Map([["sam",["SamModel",SamModel]]]),MODEL_FOR_CTC_MAPPING_NAMES=new Map([["wav2vec2",["Wav2Vec2ForCTC",Wav2Vec2ForCTC]],["wav2vec2-bert",["Wav2Vec2BertForCTC",Wav2Vec2BertForCTC]],["unispeech",["UniSpeechForCTC",UniSpeechForCTC]],["unispeech-sat",["UniSpeechSatForCTC",UniSpeechSatForCTC]],["wavlm",["WavLMForCTC",WavLMForCTC]],["hubert",["HubertForCTC",HubertForCTC]]]),MODEL_FOR_AUDIO_CLASSIFICATION_MAPPING_NAMES=new Map([["wav2vec2",["Wav2Vec2ForSequenceClassification",Wav2Vec2ForSequenceClassification]],["wav2vec2-bert",["Wav2Vec2BertForSequenceClassification",Wav2Vec2BertForSequenceClassification]],["unispeech",["UniSpeechForSequenceClassification",UniSpeechForSequenceClassification]],["unispeech-sat",["UniSpeechSatForSequenceClassification",UniSpeechSatForSequenceClassification]],["wavlm",["WavLMForSequenceClassification",WavLMForSequenceClassification]],["hubert",["HubertForSequenceClassification",HubertForSequenceClassification]],["audio-spectrogram-transformer",["ASTForAudioClassification",ASTForAudioClassification]]]),MODEL_FOR_AUDIO_XVECTOR_MAPPING_NAMES=new Map([["wavlm",["WavLMForXVector",WavLMForXVector]]]),MODEL_FOR_AUDIO_FRAME_CLASSIFICATION_MAPPING_NAMES=new Map([["unispeech-sat",["UniSpeechSatForAudioFrameClassification",UniSpeechSatForAudioFrameClassification]],["wavlm",["WavLMForAudioFrameClassification",WavLMForAudioFrameClassification]],["wav2vec2",["Wav2Vec2ForAudioFrameClassification",Wav2Vec2ForAudioFrameClassification]]]),MODEL_FOR_IMAGE_MATTING_MAPPING_NAMES=new Map([["vitmatte",["VitMatteForImageMatting",VitMatteForImageMatting]]]),MODEL_FOR_IMAGE_TO_IMAGE_MAPPING_NAMES=new Map([["swin2sr",["Swin2SRForImageSuperResolution",Swin2SRForImageSuperResolution]]]),MODEL_FOR_DEPTH_ESTIMATION_MAPPING_NAMES=new Map([["dpt",["DPTForDepthEstimation",DPTForDepthEstimation]],["depth_anything",["DepthAnythingForDepthEstimation",DepthAnythingForDepthEstimation]],["glpn",["GLPNForDepthEstimation",GLPNForDepthEstimation]]]),MODEL_FOR_IMAGE_FEATURE_EXTRACTION_MAPPING_NAMES=new Map([["clip",["CLIPVisionModelWithProjection",CLIPVisionModelWithProjection]],["siglip",["SiglipVisionModel",SiglipVisionModel]]]),MODEL_CLASS_TYPE_MAPPING=[[MODEL_MAPPING_NAMES_ENCODER_ONLY,MODEL_TYPES.EncoderOnly],[MODEL_MAPPING_NAMES_ENCODER_DECODER,MODEL_TYPES.EncoderDecoder],[MODEL_MAPPING_NAMES_DECODER_ONLY,MODEL_TYPES.DecoderOnly],[MODEL_FOR_SEQUENCE_CLASSIFICATION_MAPPING_NAMES,MODEL_TYPES.EncoderOnly],[MODEL_FOR_TOKEN_CLASSIFICATION_MAPPING_NAMES,MODEL_TYPES.EncoderOnly],[MODEL_FOR_SEQ_TO_SEQ_CAUSAL_LM_MAPPING_NAMES,MODEL_TYPES.Seq2Seq],[MODEL_FOR_SPEECH_SEQ_2_SEQ_MAPPING_NAMES,MODEL_TYPES.Seq2Seq],[MODEL_WITH_LM_HEAD_MAPPING_NAMES,MODEL_TYPES.DecoderOnly],[MODEL_FOR_MASKED_LM_MAPPING_NAMES,MODEL_TYPES.EncoderOnly],[MODEL_FOR_QUESTION_ANSWERING_MAPPING_NAMES,MODEL_TYPES.EncoderOnly],[MODEL_FOR_VISION_2_SEQ_MAPPING_NAMES,MODEL_TYPES.Vision2Seq],[MODEL_FOR_IMAGE_CLASSIFICATION_MAPPING_NAMES,MODEL_TYPES.EncoderOnly],[MODEL_FOR_IMAGE_SEGMENTATION_MAPPING_NAMES,MODEL_TYPES.EncoderOnly],[MODEL_FOR_SEMANTIC_SEGMENTATION_MAPPING_NAMES,MODEL_TYPES.EncoderOnly],[MODEL_FOR_IMAGE_MATTING_MAPPING_NAMES,MODEL_TYPES.EncoderOnly],[MODEL_FOR_IMAGE_TO_IMAGE_MAPPING_NAMES,MODEL_TYPES.EncoderOnly],[MODEL_FOR_DEPTH_ESTIMATION_MAPPING_NAMES,MODEL_TYPES.EncoderOnly],[MODEL_FOR_OBJECT_DETECTION_MAPPING_NAMES,MODEL_TYPES.EncoderOnly],[MODEL_FOR_ZERO_SHOT_OBJECT_DETECTION_MAPPING_NAMES,MODEL_TYPES.EncoderOnly],[MODEL_FOR_MASK_GENERATION_MAPPING_NAMES,MODEL_TYPES.MaskGeneration],[MODEL_FOR_CTC_MAPPING_NAMES,MODEL_TYPES.EncoderOnly],[MODEL_FOR_AUDIO_CLASSIFICATION_MAPPING_NAMES,MODEL_TYPES.EncoderOnly],[MODEL_FOR_TEXT_TO_SPECTROGRAM_MAPPING_NAMES,MODEL_TYPES.Seq2Seq],[MODEL_FOR_TEXT_TO_WAVEFORM_MAPPING_NAMES,MODEL_TYPES.EncoderOnly],[MODEL_FOR_AUDIO_XVECTOR_MAPPING_NAMES,MODEL_TYPES.EncoderOnly],[MODEL_FOR_AUDIO_FRAME_CLASSIFICATION_MAPPING_NAMES,MODEL_TYPES.EncoderOnly],[MODEL_FOR_IMAGE_FEATURE_EXTRACTION_MAPPING_NAMES,MODEL_TYPES.EncoderOnly]];for(const[F,w]of MODEL_CLASS_TYPE_MAPPING)for(const[D,O]of F.values())MODEL_TYPE_MAPPING.set(D,w),MODEL_CLASS_TO_NAME_MAPPING.set(O,D),MODEL_NAME_TO_CLASS_MAPPING.set(D,O);const CUSTOM_MAPPING=[["CLIPTextModelWithProjection",CLIPTextModelWithProjection,MODEL_TYPES.EncoderOnly],["SiglipTextModel",SiglipTextModel,MODEL_TYPES.EncoderOnly],["ClapTextModelWithProjection",ClapTextModelWithProjection,MODEL_TYPES.EncoderOnly],["ClapAudioModelWithProjection",ClapAudioModelWithProjection,MODEL_TYPES.EncoderOnly]];for(const[F,w,D]of CUSTOM_MAPPING)MODEL_TYPE_MAPPING.set(F,D),MODEL_CLASS_TO_NAME_MAPPING.set(w,F),MODEL_NAME_TO_CLASS_MAPPING.set(F,w);class AutoModel extends PretrainedMixin{static MODEL_CLASS_MAPPINGS=MODEL_CLASS_TYPE_MAPPING.map(w=>w[0]);static BASE_IF_FAIL=!0}class AutoModelForSequenceClassification extends PretrainedMixin{static MODEL_CLASS_MAPPINGS=[MODEL_FOR_SEQUENCE_CLASSIFICATION_MAPPING_NAMES]}class AutoModelForTokenClassification extends PretrainedMixin{static MODEL_CLASS_MAPPINGS=[MODEL_FOR_TOKEN_CLASSIFICATION_MAPPING_NAMES]}class AutoModelForSeq2SeqLM extends PretrainedMixin{static MODEL_CLASS_MAPPINGS=[MODEL_FOR_SEQ_TO_SEQ_CAUSAL_LM_MAPPING_NAMES]}class AutoModelForSpeechSeq2Seq extends PretrainedMixin{static MODEL_CLASS_MAPPINGS=[MODEL_FOR_SPEECH_SEQ_2_SEQ_MAPPING_NAMES]}class AutoModelForTextToSpectrogram extends PretrainedMixin{static MODEL_CLASS_MAPPINGS=[MODEL_FOR_TEXT_TO_SPECTROGRAM_MAPPING_NAMES]}class AutoModelForTextToWaveform extends PretrainedMixin{static MODEL_CLASS_MAPPINGS=[MODEL_FOR_TEXT_TO_WAVEFORM_MAPPING_NAMES]}class AutoModelForCausalLM extends PretrainedMixin{static MODEL_CLASS_MAPPINGS=[MODEL_WITH_LM_HEAD_MAPPING_NAMES]}class AutoModelForMaskedLM extends PretrainedMixin{static MODEL_CLASS_MAPPINGS=[MODEL_FOR_MASKED_LM_MAPPING_NAMES]}class AutoModelForQuestionAnswering extends PretrainedMixin{static MODEL_CLASS_MAPPINGS=[MODEL_FOR_QUESTION_ANSWERING_MAPPING_NAMES]}class AutoModelForVision2Seq extends PretrainedMixin{static MODEL_CLASS_MAPPINGS=[MODEL_FOR_VISION_2_SEQ_MAPPING_NAMES]}class AutoModelForImageClassification extends PretrainedMixin{static MODEL_CLASS_MAPPINGS=[MODEL_FOR_IMAGE_CLASSIFICATION_MAPPING_NAMES]}class AutoModelForImageSegmentation extends PretrainedMixin{static MODEL_CLASS_MAPPINGS=[MODEL_FOR_IMAGE_SEGMENTATION_MAPPING_NAMES]}class AutoModelForSemanticSegmentation extends PretrainedMixin{static MODEL_CLASS_MAPPINGS=[MODEL_FOR_SEMANTIC_SEGMENTATION_MAPPING_NAMES]}class AutoModelForObjectDetection extends PretrainedMixin{static MODEL_CLASS_MAPPINGS=[MODEL_FOR_OBJECT_DETECTION_MAPPING_NAMES]}class AutoModelForZeroShotObjectDetection extends PretrainedMixin{static MODEL_CLASS_MAPPINGS=[MODEL_FOR_ZERO_SHOT_OBJECT_DETECTION_MAPPING_NAMES]}class AutoModelForCTC extends PretrainedMixin{static MODEL_CLASS_MAPPINGS=[MODEL_FOR_CTC_MAPPING_NAMES]}class AutoModelForAudioClassification extends PretrainedMixin{static MODEL_CLASS_MAPPINGS=[MODEL_FOR_AUDIO_CLASSIFICATION_MAPPING_NAMES]}class AutoModelForDocumentQuestionAnswering extends PretrainedMixin{static MODEL_CLASS_MAPPINGS=[MODEL_FOR_DOCUMENT_QUESTION_ANSWERING_MAPPING_NAMES]}class AutoModelForImageToImage extends PretrainedMixin{static MODEL_CLASS_MAPPINGS=[MODEL_FOR_IMAGE_TO_IMAGE_MAPPING_NAMES]}class AutoModelForDepthEstimation extends PretrainedMixin{static MODEL_CLASS_MAPPINGS=[MODEL_FOR_DEPTH_ESTIMATION_MAPPING_NAMES]}class AutoModelForImageFeatureExtraction extends PretrainedMixin{static MODEL_CLASS_MAPPINGS=[MODEL_FOR_IMAGE_FEATURE_EXTRACTION_MAPPING_NAMES]}class Seq2SeqLMOutput extends ModelOutput{constructor({logits:w,past_key_values:D,encoder_outputs:O,decoder_attentions:U=null,cross_attentions:G=null}){super(),this.logits=w,this.past_key_values=D,this.encoder_outputs=O,this.decoder_attentions=U,this.cross_attentions=G}}class SequenceClassifierOutput extends ModelOutput{constructor({logits:w}){super(),this.logits=w}}class XVectorOutput extends ModelOutput{constructor({logits:w,embeddings:D}){super(),this.logits=w,this.embeddings=D}}class TokenClassifierOutput extends ModelOutput{constructor({logits:w}){super(),this.logits=w}}class MaskedLMOutput extends ModelOutput{constructor({logits:w}){super(),this.logits=w}}class QuestionAnsweringModelOutput extends ModelOutput{constructor({start_logits:w,end_logits:D}){super(),this.start_logits=w,this.end_logits=D}}class CausalLMOutput extends ModelOutput{constructor({logits:w}){super(),this.logits=w}}class ImageMattingOutput extends ModelOutput{constructor({alphas:w}){super(),this.alphas=w}}class VitsModelOutput extends ModelOutput{constructor({waveform:w,spectrogram:D}){super(),this.waveform=w,this.spectrogram=D}}const BROWSER_ENV=typeof self<"u",WEBWORKER_ENV=BROWSER_ENV&&self.constructor.name==="DedicatedWorkerGlobalScope";let createCanvasFunction,ImageDataClass,loadImageFunction;if(BROWSER_ENV)createCanvasFunction=(F,w)=>{if(!self.OffscreenCanvas)throw new Error("OffscreenCanvas not supported by this browser.");return new self.OffscreenCanvas(F,w)},loadImageFunction=self.createImageBitmap,ImageDataClass=self.ImageData;else if(sharp)loadImageFunction=async F=>{const D=(await F.metadata()).channels;let{data:O,info:U}=await F.rotate().raw().toBuffer({resolveWithObject:!0});const G=new RawImage(new Uint8ClampedArray(O),U.width,U.height,U.channels);return D!==void 0&&D!==U.channels&&G.convert(D),G};else throw new Error("Unable to load image processing library.");const RESAMPLING_MAPPING={0:"nearest",1:"lanczos",2:"bilinear",3:"bicubic",4:"box",5:"hamming"},CONTENT_TYPE_MAP=new Map([["png","image/png"],["jpg","image/jpeg"],["jpeg","image/jpeg"],["gif","image/gif"]]);class RawImage{constructor(w,D,O,U){this.data=w,this.width=D,this.height=O,this.channels=U}get size(){return[this.width,this.height]}static async read(w){if(w instanceof RawImage)return w;if(typeof w=="string"||w instanceof URL)return await this.fromURL(w);throw new Error(`Unsupported input type: ${typeof w}`)}static async fromURL(w){let D=await getFile(w);if(D.status!==200)throw new Error(`Unable to read image from "${w}" (${D.status} ${D.statusText})`);let O=await D.blob();return this.fromBlob(O)}static async fromBlob(w){if(BROWSER_ENV){let D=await loadImageFunction(w);const O=createCanvasFunction(D.width,D.height).getContext("2d");return O.drawImage(D,0,0),new this(O.getImageData(0,0,D.width,D.height).data,D.width,D.height,4)}else{let D=sharp(await w.arrayBuffer());return await loadImageFunction(D)}}static fromTensor(w,D="CHW"){if(w.dims.length!==3)throw new Error(`Tensor should have 3 dimensions, but has ${w.dims.length} dimensions.`);if(D==="CHW")w=w.transpose(1,2,0);else if(D!=="HWC")throw new Error(`Unsupported channel format: ${D}`);if(!(w.data instanceof Uint8ClampedArray||w.data instanceof Uint8Array))throw new Error(`Unsupported tensor type: ${w.type}`);switch(w.dims[2]){case 1:case 2:case 3:case 4:return new RawImage(w.data,w.dims[1],w.dims[0],w.dims[2]);default:throw new Error(`Unsupported number of channels: ${w.dims[2]}`)}}grayscale(){if(this.channels===1)return this;let w=new Uint8ClampedArray(this.width*this.height*1);switch(this.channels){case 3:case 4:for(let D=0,O=0;D<this.data.length;D+=this.channels){const U=this.data[D],G=this.data[D+1],q=this.data[D+2];w[O++]=Math.round(.2989*U+.587*G+.114*q)}break;default:throw new Error(`Conversion failed due to unsupported number of channels: ${this.channels}`)}return this._update(w,this.width,this.height,1)}rgb(){if(this.channels===3)return this;let w=new Uint8ClampedArray(this.width*this.height*3);switch(this.channels){case 1:for(let D=0,O=0;D<this.data.length;++D)w[O++]=this.data[D],w[O++]=this.data[D],w[O++]=this.data[D];break;case 4:for(let D=0,O=0;D<this.data.length;D+=4)w[O++]=this.data[D],w[O++]=this.data[D+1],w[O++]=this.data[D+2];break;default:throw new Error(`Conversion failed due to unsupported number of channels: ${this.channels}`)}return this._update(w,this.width,this.height,3)}rgba(){if(this.channels===4)return this;let w=new Uint8ClampedArray(this.width*this.height*4);switch(this.channels){case 1:for(let D=0,O=0;D<this.data.length;++D)w[O++]=this.data[D],w[O++]=this.data[D],w[O++]=this.data[D],w[O++]=255;break;case 3:for(let D=0,O=0;D<this.data.length;D+=3)w[O++]=this.data[D],w[O++]=this.data[D+1],w[O++]=this.data[D+2],w[O++]=255;break;default:throw new Error(`Conversion failed due to unsupported number of channels: ${this.channels}`)}return this._update(w,this.width,this.height,4)}async resize(w,D,{resample:O=2}={}){let U=RESAMPLING_MAPPING[O]??O;if(BROWSER_ENV){let G=this.channels,q=this.toCanvas();const K=createCanvasFunction(w,D).getContext("2d");return K.drawImage(q,0,0,w,D),new RawImage(K.getImageData(0,0,w,D).data,w,D,4).convert(G)}else{let G=this.toSharp();switch(U){case"box":case"hamming":(U==="box"||U==="hamming")&&(console.warn(`Resampling method ${U} is not yet supported. Using bilinear instead.`),U="bilinear");case"nearest":case"bilinear":case"bicubic":G=G.affine([w/this.width,0,0,D/this.height],{interpolator:U});break;case"lanczos":G=G.resize({width:w,height:D,fit:"fill",kernel:"lanczos3"});break;default:throw new Error(`Resampling method ${U} is not supported.`)}return await loadImageFunction(G)}}async pad([w,D,O,U]){if(w=Math.max(w,0),D=Math.max(D,0),O=Math.max(O,0),U=Math.max(U,0),w===0&&D===0&&O===0&&U===0)return this;if(BROWSER_ENV){let G=this.channels,q=this.toCanvas(),K=this.width+w+D,ee=this.height+O+U;const Z=createCanvasFunction(K,ee).getContext("2d");return Z.drawImage(q,0,0,this.width,this.height,w,O,K,ee),new RawImage(Z.getImageData(0,0,K,ee).data,K,ee,4).convert(G)}else{let G=this.toSharp().extend({left:w,right:D,top:O,bottom:U});return await loadImageFunction(G)}}async crop([w,D,O,U]){if(w=Math.max(w,0),D=Math.max(D,0),O=Math.min(O,this.width-1),U=Math.min(U,this.height-1),w===0&&D===0&&O===this.width-1&&U===this.height-1)return this;const G=O-w+1,q=U-D+1;if(BROWSER_ENV){const K=this.channels,ee=this.toCanvas(),Z=createCanvasFunction(G,q).getContext("2d");return Z.drawImage(ee,w,D,G,q,0,0,G,q),new RawImage(Z.getImageData(0,0,G,q).data,G,q,4).convert(K)}else{const K=this.toSharp().extract({left:w,top:D,width:G,height:q});return await loadImageFunction(K)}}async center_crop(w,D){if(this.width===w&&this.height===D)return this;let O=(this.width-w)/2,U=(this.height-D)/2;if(BROWSER_ENV){let G=this.channels,q=this.toCanvas();const K=createCanvasFunction(w,D).getContext("2d");let ee=0,Z=0,ie=0,Y=0;return O>=0?ee=O:ie=-O,U>=0?Z=U:Y=-U,K.drawImage(q,ee,Z,w,D,ie,Y,w,D),new RawImage(K.getImageData(0,0,w,D).data,w,D,4).convert(G)}else{let G=this.toSharp();if(O>=0&&U>=0)G=G.extract({left:Math.floor(O),top:Math.floor(U),width:w,height:D});else if(O<=0&&U<=0){let q=Math.floor(-U),K=Math.floor(-O);G=G.extend({top:q,left:K,right:w-this.width-K,bottom:D-this.height-q})}else{let q=[0,0],K=0;U<0?(q[0]=Math.floor(-U),q[1]=D-this.height-q[0]):K=Math.floor(U);let ee=[0,0],Z=0;O<0?(ee[0]=Math.floor(-O),ee[1]=w-this.width-ee[0]):Z=Math.floor(O),G=G.extend({top:q[0],bottom:q[1],left:ee[0],right:ee[1]}).extract({left:Z,top:K,width:w,height:D})}return await loadImageFunction(G)}}async toBlob(w="image/png",D=1){if(!BROWSER_ENV)throw new Error("toBlob() is only supported in browser environments.");return await this.toCanvas().convertToBlob({type:w,quality:D})}toTensor(w="CHW"){let D=new Tensor("uint8",new Uint8Array(this.data),[this.height,this.width,this.channels]);if(w!=="HWC")if(w==="CHW")D=D.permute(2,0,1);else throw new Error(`Unsupported channel format: ${w}`);return D}toCanvas(){if(!BROWSER_ENV)throw new Error("toCanvas() is only supported in browser environments.");let w=this.clone().rgba(),D=createCanvasFunction(w.width,w.height),O=new ImageDataClass(w.data,w.width,w.height);return D.getContext("2d").putImageData(O,0,0),D}_update(w,D,O,U=null){return this.data=w,this.width=D,this.height=O,U!==null&&(this.channels=U),this}clone(){return new RawImage(this.data.slice(),this.width,this.height,this.channels)}convert(w){if(this.channels===w)return this;switch(w){case 1:this.grayscale();break;case 3:this.rgb();break;case 4:this.rgba();break;default:throw new Error(`Conversion failed due to unsupported number of channels: ${this.channels}`)}return this}async save(w){if(BROWSER_ENV){if(WEBWORKER_ENV)throw new Error("Unable to save an image from a Web Worker.");const D=w.split(".").pop().toLowerCase(),O=CONTENT_TYPE_MAP.get(D)??"image/png",U=await this.toBlob(O),G=URL.createObjectURL(U),q=document.createElement("a");q.href=G,q.download=w,q.click(),q.remove()}else{if(env$1.useFS)return await this.toSharp().toFile(w);throw new Error("Unable to save the image because filesystem is disabled in this environment.")}}toSharp(){if(BROWSER_ENV)throw new Error("toSharp() is only supported in server-side environments.");return sharp(this.data,{raw:{width:this.width,height:this.height,channels:this.channels}})}}async function read_audio(F,w){if(typeof AudioContext>"u")throw Error("Unable to load audio from path/URL since `AudioContext` is not available in your environment. Instead, audio data should be passed directly to the pipeline/processor. For more information and some example code, see https://huggingface.co/docs/transformers.js/guides/node-audio-processing.");const D=await(await getFile(F)).arrayBuffer(),O=new AudioContext({sampleRate:w});typeof w>"u"&&console.warn(`No sampling rate provided, using default of ${O.sampleRate}Hz.`);const U=await O.decodeAudioData(D);let G;if(U.numberOfChannels===2){const q=Math.sqrt(2),K=U.getChannelData(0),ee=U.getChannelData(1);G=new Float32Array(K.length);for(let Z=0;Z<U.length;++Z)G[Z]=q*(K[Z]+ee[Z])/2}else G=U.getChannelData(0);return G}function hanning(F){if(F<1)return new Float64Array;if(F===1)return new Float64Array([1]);const w=F-1,D=Math.PI/w,O=new Float64Array(F);for(let U=0;U<F;++U){const G=2*U-w;O[U]=.5+.5*Math.cos(D*G)}return O}const HERTZ_TO_MEL_MAPPING={htk:F=>2595*Math.log10(1+F/700),kaldi:F=>1127*Math.log(1+F/700),slaney:(F,w=1e3,D=15,O=27/Math.log(6.4))=>F>=w?D+Math.log(F/w)*O:3*F/200};function hertz_to_mel(F,w="htk"){const D=HERTZ_TO_MEL_MAPPING[w];if(!D)throw new Error('mel_scale should be one of "htk", "slaney" or "kaldi".');return typeof F=="number"?D(F):F.map(O=>D(O))}const MEL_TO_HERTZ_MAPPING={htk:F=>700*(10**(F/2595)-1),kaldi:F=>700*(Math.exp(F/1127)-1),slaney:(F,w=1e3,D=15,O=Math.log(6.4)/27)=>F>=D?w*Math.exp(O*(F-D)):200*F/3};function mel_to_hertz(F,w="htk"){const D=MEL_TO_HERTZ_MAPPING[w];if(!D)throw new Error('mel_scale should be one of "htk", "slaney" or "kaldi".');return typeof F=="number"?D(F):F.map(O=>D(O))}function _create_triangular_filter_bank(F,w){const D=Float64Array.from({length:w.length-1},(q,K)=>w[K+1]-w[K]),O=Array.from({length:F.length},()=>new Array(w.length));for(let q=0;q<F.length;++q){const K=O[q];for(let ee=0;ee<w.length;++ee)K[ee]=w[ee]-F[q]}const U=w.length-2,G=Array.from({length:U},()=>new Array(F.length));for(let q=0;q<F.length;++q){const K=O[q];for(let ee=0;ee<U;++ee){const Z=-K[ee]/D[ee],ie=K[ee+2]/D[ee+1];G[ee][q]=Math.max(0,Math.min(Z,ie))}}return G}function linspace(F,w,D){const O=(w-F)/(D-1);return Float64Array.from({length:D},(U,G)=>F+O*G)}function mel_filter_bank(F,w,D,O,U,G=null,q="htk",K=!1){if(G!==null&&G!=="slaney")throw new Error('norm must be one of null or "slaney"');const ee=hertz_to_mel(D,q),Z=hertz_to_mel(O,q),ie=linspace(ee,Z,w+2);let Y=mel_to_hertz(ie,q),W;if(K){const se=U/(F*2);W=hertz_to_mel(Float64Array.from({length:F},(le,ce)=>ce*se),q),Y=ie}else W=linspace(0,Math.floor(U/2),F);const ne=_create_triangular_filter_bank(W,Y);if(G!==null&&G==="slaney")for(let se=0;se<w;++se){const le=ne[se],ce=2/(Y[se+2]-Y[se]);for(let he=0;he<F;++he)le[he]*=ce}return ne}function padReflect(F,w,D){const O=new F.constructor(F.length+w+D),U=F.length-1;for(let G=0;G<F.length;++G)O[w+G]=F[G];for(let G=1;G<=w;++G)O[w-G]=F[calculateReflectOffset(G,U)];for(let G=1;G<=D;++G)O[U+w+G]=F[calculateReflectOffset(U-G,U)];return O}function _db_conversion_helper(F,w,D,O,U){if(D<=0)throw new Error("reference must be greater than zero");if(O<=0)throw new Error("min_value must be greater than zero");D=Math.max(O,D);const G=Math.log10(D);for(let q=0;q<F.length;++q)F[q]=w*Math.log10(Math.max(O,F[q])-G);if(U!==null){if(U<=0)throw new Error("db_range must be greater than zero");const q=max(F)[0]-U;for(let K=0;K<F.length;++K)F[K]=Math.max(F[K],q)}return F}function amplitude_to_db(F,w=1,D=1e-5,O=null){return _db_conversion_helper(F,20,w,D,O)}function power_to_db(F,w=1,D=1e-10,O=null){return _db_conversion_helper(F,10,w,D,O)}function spectrogram(F,w,D,O,{fft_length:U=null,power:G=1,center:q=!0,pad_mode:K="reflect",onesided:ee=!0,preemphasis:Z=null,mel_filters:ie=null,mel_floor:Y=1e-10,log_mel:W=null,reference:ne=1,min_value:se=1e-10,db_range:le=null,remove_dc_offset:ce=null,max_num_frames:he=null,do_pad:pe=!0,transpose:me=!1}={}){const be=w.length;if(U===null&&(U=D),D>U)throw Error(`frame_length (${D}) may not be larger than fft_length (${U})`);if(be!==D)throw new Error(`Length of the window (${be}) must equal frame_length (${D})`);if(O<=0)throw new Error("hop_length must be greater than zero");if(G===null&&ie!==null)throw new Error("You have provided `mel_filters` but `power` is `None`. Mel spectrogram computation is not yet supported for complex-valued spectrogram. Specify `power` to fix this issue.");if(q){if(K!=="reflect")throw new Error(`pad_mode="${K}" not implemented yet.`);const Ce=Math.floor((U-1)/2)+1;F=padReflect(F,Ce,Ce)}const ge=Math.floor(1+Math.floor((F.length-D)/O)),ve=ee?Math.floor(U/2)+1:U;let Se=ge,Me=ge;he!==null&&(he>ge?pe&&(Me=he):Me=Se=he);const Ee=new FFT(U),we=new Float64Array(U),Re=new Float64Array(Ee.outputBufferSize),Le=new Array(Se);for(let Ce=0;Ce<Se;++Ce){const Be=Ce*O;for(let Xe=0;Xe<D;++Xe)we[Xe]=F[Be+Xe];if(ce){let Xe=0;for(let ke=0;ke<D;++ke)Xe+=we[ke];const lt=Xe/D;for(let ke=0;ke<D;++ke)we[ke]-=lt}if(Z!==null){for(let Xe=D-1;Xe>=1;--Xe)we[Xe]-=Z*we[Xe-1];we[0]*=1-Z}for(let Xe=0;Xe<w.length;++Xe)we[Xe]*=w[Xe];Ee.realTransform(Re,we);const ze=new Array(ve);for(let Xe=0;Xe<ze.length;++Xe){const lt=Xe<<1;ze[Xe]=Re[lt]**2+Re[lt+1]**2}Le[Ce]=ze}if(G!==null&&G!==2){const Ce=2/G;for(let Be=0;Be<Le.length;++Be){const ze=Le[Be];for(let Xe=0;Xe<ze.length;++Xe)ze[Xe]**=Ce}}const Ne=ie.length,Oe=new Float32Array(Ne*Me),Pe=me?[Me,Ne]:[Ne,Me];for(let Ce=0;Ce<Ne;++Ce){const Be=ie[Ce];for(let ze=0;ze<Se;++ze){const Xe=Le[ze];let lt=0;for(let ke=0;ke<ve;++ke)lt+=Be[ke]*Xe[ke];Oe[me?ze*Ne+Ce:Ce*Se+ze]=Math.max(Y,lt)}}if(G!==null&&W!==null){const Ce=Math.min(Oe.length,Se*Ne);switch(W){case"log":for(let Be=0;Be<Ce;++Be)Oe[Be]=Math.log(Oe[Be]);break;case"log10":for(let Be=0;Be<Ce;++Be)Oe[Be]=Math.log10(Oe[Be]);break;case"dB":if(G===1)amplitude_to_db(Oe,ne,se,le);else if(G===2)power_to_db(Oe,ne,se,le);else throw new Error(`Cannot use log_mel option '${W}' with power ${G}`);break;default:throw new Error(`log_mel must be one of null, 'log', 'log10' or 'dB'. Got '${W}'`)}}return{data:Oe,dims:Pe}}function window_function(F,w,{periodic:D=!0,frame_length:O=null,center:U=!0}={}){const G=D?F+1:F;let q;switch(w){case"boxcar":q=new Float64Array(G).fill(1);break;case"hann":case"hann_window":q=hanning(G);break;case"povey":q=hanning(G).map(K=>Math.pow(K,.85));break;default:throw new Error(`Unknown window type ${w}.`)}if(D&&(q=q.subarray(0,F)),O===null)return q;if(F>O)throw new Error(`Length of the window (${F}) may not be larger than frame_length (${O})`);return q}function center_to_corners_format([F,w,D,O]){return[F-D/2,w-O/2,F+D/2,w+O/2]}function post_process_object_detection(F,w=.5,D=null,O=!1){const U=F.logits,G=F.pred_boxes,[q,K,ee]=U.dims;if(D!==null&&D.length!==q)throw Error("Make sure that you pass in as many target sizes as the batch dimension of the logits");let Z=[];for(let ie=0;ie<q;++ie){let Y=D!==null?D[ie]:null,W={boxes:[],classes:[],scores:[]},ne=U[ie],se=G[ie];for(let le=0;le<K;++le){let ce=ne[le],he=[],pe;if(O){pe=ce.sigmoid().data;for(let me=0;me<pe.length;++me)pe[me]>w&&he.push(me)}else{let me=max(ce.data)[1];if(me===ee-1)continue;he.push(me),pe=softmax(ce.data)}for(const me of he){let be=se[le].data;be=center_to_corners_format(be),Y!==null&&(be=be.map((ge,ve)=>ge*Y[(ve+1)%2])),W.boxes.push(be),W.classes.push(me),W.scores.push(pe[me])}}Z.push(W)}return Z}function validate_audio_inputs(F,w){if(!(F instanceof Float32Array||F instanceof Float64Array))throw new Error(`${w} expects input to be a Float32Array or a Float64Array, but got ${F?.constructor?.name??typeof F} instead. If using the feature extractor directly, remember to use \`read_audio(url, sampling_rate)\` to obtain the raw audio data of the file/url.`)}function constraint_to_multiple_of(F,w,D=0,O=null){const U=F/w;let G=bankers_round(U)*w;return O!==null&&G>O&&(G=Math.floor(U)*w),G<D&&(G=Math.ceil(U)*w),G}function enforce_size_divisibility([F,w],D){return[Math.max(Math.floor(F/D),1)*D,Math.max(Math.floor(w/D),1)*D]}class FeatureExtractor extends Callable{constructor(w){super(),this.config=w}}class ImageFeatureExtractor extends FeatureExtractor{constructor(w){super(w),this.image_mean=this.config.image_mean??this.config.mean,this.image_std=this.config.image_std??this.config.std,this.resample=this.config.resample??2,this.do_rescale=this.config.do_rescale??!0,this.rescale_factor=this.config.rescale_factor??1/255,this.do_normalize=this.config.do_normalize,this.do_resize=this.config.do_resize,this.do_thumbnail=this.config.do_thumbnail,this.size=this.config.size,this.size_divisibility=this.config.size_divisibility??this.config.size_divisor,this.do_center_crop=this.config.do_center_crop,this.crop_size=this.config.crop_size,this.do_convert_rgb=this.config.do_convert_rgb??!0,this.do_crop_margin=this.config.do_crop_margin,this.pad_size=this.config.pad_size,this.do_pad=this.config.do_pad,this.do_pad&&!this.pad_size&&this.size&&this.size.width!==void 0&&this.size.height!==void 0&&(this.pad_size=this.size),this.do_flip_channel_order=this.config.do_flip_channel_order??!1}async thumbnail(w,D,O=2){const U=w.height,G=w.width,q=D.height,K=D.width;let ee=Math.min(U,q),Z=Math.min(G,K);return ee===U&&Z===G?w:(U>G?Z=Math.floor(G*ee/U):G>U&&(ee=Math.floor(U*Z/G)),await w.resize(Z,ee,{resample:O}))}async crop_margin(w,D=200){const O=w.clone().grayscale(),U=min(O.data)[0],q=max(O.data)[0]-U;if(q===0)return w;const K=D/255;let ee=O.width,Z=O.height,ie=0,Y=0;for(let W=0;W<O.height;++W){const ne=W*O.width;for(let se=0;se<O.width;++se)(O.data[ne+se]-U)/q<K&&(ee=Math.min(ee,se),Z=Math.min(Z,W),ie=Math.max(ie,se),Y=Math.max(Y,W))}return w=await w.crop([ee,Z,ie,Y]),w}pad_image(w,D,O,{mode:U="constant",center:G=!1,constant_values:q=0}={}){const[K,ee,Z]=D;let ie,Y;if(typeof O=="number"?(ie=O,Y=O):(ie=O.width,Y=O.height),ie!==ee||Y!==K){const W=new Float32Array(ie*Y*Z);if(Array.isArray(q))for(let le=0;le<W.length;++le)W[le]=q[le%Z];else q!==0&&W.fill(q);const[ne,se]=G?[Math.floor((ie-ee)/2),Math.floor((Y-K)/2)]:[0,0];for(let le=0;le<K;++le){const ce=(le+se)*ie,he=le*ee;for(let pe=0;pe<ee;++pe){const me=(ce+pe+ne)*Z,be=(he+pe)*Z;for(let ge=0;ge<Z;++ge)W[me+ge]=w[be+ge]}}if(U==="symmetric"){if(G)throw new Error("`center` padding is not supported when `mode` is set to `symmetric`.");const le=K-1,ce=ee-1;for(let he=0;he<Y;++he){const pe=he*ie,me=calculateReflectOffset(he,le)*ee;for(let be=0;be<ie;++be){if(he<K&&be<ee)continue;const ge=(pe+be)*Z,ve=(me+calculateReflectOffset(be,ce))*Z;for(let Se=0;Se<Z;++Se)W[ge+Se]=w[ve+Se]}}}w=W,D=[Y,ie,Z]}return[w,D]}rescale(w){for(let D=0;D<w.length;++D)w[D]=this.rescale_factor*w[D]}get_resize_output_image_size(w,D){const[O,U]=w.size;let G,q;if(this.do_thumbnail){const{height:K,width:ee}=D;G=Math.min(K,ee)}else Number.isInteger(D)?(G=D,q=this.config.max_size??G):D!==void 0&&(G=D.shortest_edge,q=D.longest_edge);if(G!==void 0||q!==void 0){const K=G===void 0?1:Math.max(G/O,G/U),ee=O*K,Z=U*K,ie=q===void 0?1:Math.min(q/ee,q/Z);let Y=Math.floor(Number((ee*ie).toFixed(2))),W=Math.floor(Number((Z*ie).toFixed(2)));return this.size_divisibility!==void 0&&([Y,W]=enforce_size_divisibility([Y,W],this.size_divisibility)),[Y,W]}else if(D!==void 0&&D.width!==void 0&&D.height!==void 0){let K=D.width,ee=D.height;if(this.config.keep_aspect_ratio&&this.config.ensure_multiple_of){let Z=ee/U,ie=K/O;Math.abs(1-ie)<Math.abs(1-Z)?Z=ie:ie=Z,ee=constraint_to_multiple_of(Z*U,this.config.ensure_multiple_of),K=constraint_to_multiple_of(ie*O,this.config.ensure_multiple_of)}return[K,ee]}else{if(this.size_divisibility!==void 0)return enforce_size_divisibility([O,U],this.size_divisibility);throw new Error(`Could not resize image due to unsupported \`this.size\` option in config: ${JSON.stringify(D)}`)}}async resize(w){const[D,O]=this.get_resize_output_image_size(w,this.size);return await w.resize(D,O,{resample:this.resample})}async preprocess(w,{do_normalize:D=null,do_pad:O=null,do_convert_rgb:U=null,do_convert_grayscale:G=null,do_flip_channel_order:q=null}={}){this.do_crop_margin&&(w=await this.crop_margin(w));const[K,ee]=w.size;if(U??this.do_convert_rgb?w=w.rgb():G&&(w=w.grayscale()),this.do_resize&&(w=await this.resize(w)),this.do_thumbnail&&(w=await this.thumbnail(w,this.size,this.resample)),this.do_center_crop){let ne,se;Number.isInteger(this.crop_size)?(ne=this.crop_size,se=this.crop_size):(ne=this.crop_size.width,se=this.crop_size.height),w=await w.center_crop(ne,se)}const Z=[w.height,w.width];let ie=Float32Array.from(w.data),Y=[w.height,w.width,w.channels];if(this.do_rescale&&this.rescale(ie),D??this.do_normalize){let ne=this.image_mean;Array.isArray(this.image_mean)||(ne=new Array(w.channels).fill(ne));let se=this.image_std;if(Array.isArray(this.image_std)||(se=new Array(w.channels).fill(ne)),ne.length!==w.channels||se.length!==w.channels)throw new Error(`When set to arrays, the length of \`image_mean\` (${ne.length}) and \`image_std\` (${se.length}) must match the number of channels in the image (${w.channels}).`);for(let le=0;le<ie.length;le+=w.channels)for(let ce=0;ce<w.channels;++ce)ie[le+ce]=(ie[le+ce]-ne[ce])/se[ce]}if(O??this.do_pad){if(this.pad_size)[ie,Y]=this.pad_image(ie,[w.height,w.width,w.channels],this.pad_size);else if(this.size_divisibility){const[ne,se]=enforce_size_divisibility([Y[1],Y[0]],this.size_divisibility);[ie,Y]=this.pad_image(ie,Y,{width:ne,height:se})}}if(q??this.do_flip_channel_order){if(Y[2]!==3)throw new Error("Flipping channel order is only supported for RGB images.");for(let ne=0;ne<ie.length;ne+=3){const se=ie[ne];ie[ne]=ie[ne+2],ie[ne+2]=se}}const W=new Tensor("float32",ie,Y).permute(2,0,1);return{original_size:[ee,K],reshaped_input_size:Z,pixel_values:W}}async _call(w,...D){Array.isArray(w)||(w=[w]);const O=await Promise.all(w.map(G=>this.preprocess(G)));return{pixel_values:stack(O.map(G=>G.pixel_values),0),original_sizes:O.map(G=>G.original_size),reshaped_input_sizes:O.map(G=>G.reshaped_input_size)}}}class SegformerFeatureExtractor extends ImageFeatureExtractor{post_process_semantic_segmentation(w,D=null){const O=w.logits,U=O.dims[0];if(D!==null&&D.length!==U)throw Error("Make sure that you pass in as many target sizes as the batch dimension of the logits");const G=[];for(let q=0;q<U;++q){const K=D!==null?D[q]:null;let ee=O[q];K!==null&&(ee=interpolate(ee,K,"bilinear",!1));const[Z,ie]=K??ee.dims.slice(-2),Y=new Tensor("int32",new Int32Array(Z*ie),[Z,ie]),W=ee[0].data;for(let ce=1;ce<ee.dims[0];++ce){const he=ee[ce].data;for(let pe=0;pe<he.length;++pe)he[pe]>W[pe]&&(W[pe]=he[pe],Y.data[pe]=ce)}const ne=new Array(ee.dims[0]),se=Y.data;for(let ce=0;ce<se.length;++ce){const he=se[ce];ne[he]=he}const le=ne.filter(ce=>ce!==void 0);G.push({segmentation:Y,labels:le})}return G}}class DPTFeatureExtractor extends ImageFeatureExtractor{}class DPTImageProcessor extends DPTFeatureExtractor{}class BitImageProcessor extends ImageFeatureExtractor{}class GLPNFeatureExtractor extends ImageFeatureExtractor{}class CLIPFeatureExtractor extends ImageFeatureExtractor{}class ChineseCLIPFeatureExtractor extends ImageFeatureExtractor{}class SiglipImageProcessor extends ImageFeatureExtractor{}class ConvNextFeatureExtractor extends ImageFeatureExtractor{constructor(w){super(w),this.crop_pct=this.config.crop_pct??224/256}async resize(w){const D=this.size?.shortest_edge;if(D===void 0)throw new Error("Size dictionary must contain 'shortest_edge' key.");if(D<384){const O=Math.floor(D/this.crop_pct),[U,G]=this.get_resize_output_image_size(w,{shortest_edge:O});w=await w.resize(U,G,{resample:this.resample}),w=await w.center_crop(D,D)}else w=await w.resize(D,D,{resample:this.resample});return w}}class ConvNextImageProcessor extends ConvNextFeatureExtractor{}class ViTFeatureExtractor extends ImageFeatureExtractor{}class ViTImageProcessor extends ImageFeatureExtractor{}class EfficientNetImageProcessor extends ImageFeatureExtractor{constructor(w){super(w),this.include_top=this.config.include_top??!0,this.include_top&&(this.image_std=this.image_std.map(D=>D*D))}}class MobileViTFeatureExtractor extends ImageFeatureExtractor{}class MobileViTImageProcessor extends MobileViTFeatureExtractor{}class OwlViTFeatureExtractor extends ImageFeatureExtractor{post_process_object_detection(...w){return post_process_object_detection(...w)}}class Owlv2ImageProcessor extends OwlViTFeatureExtractor{}class DeiTFeatureExtractor extends ImageFeatureExtractor{}class BeitFeatureExtractor extends ImageFeatureExtractor{}class DonutFeatureExtractor extends ImageFeatureExtractor{pad_image(w,D,O,U={}){const[G,q,K]=D;let ee=this.image_mean;Array.isArray(this.image_mean)||(ee=new Array(K).fill(ee));let Z=this.image_std;Array.isArray(Z)||(Z=new Array(K).fill(ee));const ie=ee.map((Y,W)=>-Y/Z[W]);return super.pad_image(w,D,O,{center:!0,constant_values:ie,...U})}}class NougatImageProcessor extends DonutFeatureExtractor{}class DetrFeatureExtractor extends ImageFeatureExtractor{async _call(w){const D=await super._call(w),O=[D.pixel_values.dims[0],64,64],U=new Tensor("int64",new BigInt64Array(O.reduce((G,q)=>G*q)).fill(1n),O);return{...D,pixel_mask:U}}post_process_object_detection(...w){return post_process_object_detection(...w)}remove_low_and_no_objects(w,D,O,U){let G=[],q=[],K=[];for(let ee=0;ee<w.dims[0];++ee){let Z=w[ee],ie=D[ee],Y=max(Z.data)[1];if(Y===U)continue;let ne=softmax(Z.data)[Y];ne>O&&(G.push(ie),q.push(ne),K.push(Y))}return[G,q,K]}check_segment_validity(w,D,O,U=.5,G=.8){let q=[],K=0,ee=0;for(let ie=0;ie<w.length;++ie)w[ie]===O&&(q.push(ie),++K),D[O].data[ie]>=U&&++ee;let Z=K>0&&ee>0;return Z&&(Z=K/ee>G),[Z,q]}compute_segments(w,D,O,U,G,q=null,K=null){let[ee,Z]=K??w[0].dims,ie=new Tensor("int32",new Int32Array(ee*Z),[ee,Z]),Y=[];if(K!==null)for(let le=0;le<w.length;++le)w[le]=interpolate(w[le],K,"bilinear",!1);let W=new Int32Array(w[0].data.length),ne=new Float32Array(w[0].data.length);for(let le=0;le<w.length;++le){let ce=D[le];for(let he=0;he<w[le].data.length;++he)w[le].data[he]*=ce,w[le].data[he]>ne[he]&&(W[he]=le,ne[he]=w[le].data[he])}let se=0;for(let le=0;le<O.length;++le){let ce=O[le],[he,pe]=this.check_segment_validity(W,w,le,U,G);if(he){++se;for(let me of pe)ie.data[me]=se;Y.push({id:se,label_id:ce,score:D[le]})}}return[ie,Y]}post_process_panoptic_segmentation(w,D=.5,O=.5,U=.8,G=null,q=null){G===null&&(console.warn("`label_ids_to_fuse` unset. No instance will be fused."),G=new Set);const K=w.logits,Z=w.pred_masks.sigmoid();let[ie,Y,W]=K.dims;if(W-=1,q!==null&&q.length!==ie)throw Error("Make sure that you pass in as many target sizes as the batch dimension of the logits");let ne=[];for(let se=0;se<ie;++se){let le=q!==null?q[se]:null,ce=K[se],he=Z[se],[pe,me,be]=this.remove_low_and_no_objects(ce,he,D,W);if(be.length===0){let[Se,Me]=le??he.dims.slice(-2),Ee=new Tensor("int32",new Int32Array(Se*Me).fill(-1),[Se,Me]);ne.push({segmentation:Ee,segments_info:[]});continue}let[ge,ve]=this.compute_segments(pe,me,be,O,U,G,le);ne.push({segmentation:ge,segments_info:ve})}return ne}post_process_instance_segmentation(){throw Error("Not implemented yet")}}class YolosFeatureExtractor extends ImageFeatureExtractor{post_process_object_detection(...w){return post_process_object_detection(...w)}}class SamImageProcessor extends ImageFeatureExtractor{reshape_input_points(w,D,O){w=structuredClone(w);let U=calculateDimensions(w);if(U.length===3)U=[1,...U],w=[w];else if(U.length!==4)throw Error("The input_points must be a 4D tensor of shape `batch_size`, `point_batch_size`, `nb_points_per_image`, `2`.");for(let G=0;G<w.length;++G){let q=D[G],K=O[G],ee=[K[0]/q[0],K[1]/q[1]];for(let Z=0;Z<w[G].length;++Z)for(let ie=0;ie<w[G][Z].length;++ie)for(let Y=0;Y<w[G][Z][ie].length;++Y)w[G][Z][ie][Y]*=ee[Y]}return new Tensor("float32",Float32Array.from(w.flat(1/0)),U)}add_input_labels(w,D){let O=calculateDimensions(w);if(O.length===2)O=[1,...O],w=[w];else if(O.length!==3)throw Error("The input_points must be a 4D tensor of shape `batch_size`, `point_batch_size`, `nb_points_per_image`, `2`.");if(O.some((U,G)=>U!==D.dims[G]))throw Error(`The first ${O.length} dimensions of 'input_points' and 'input_labels' must be the same.`);return new Tensor("int64",w.flat(1/0).map(BigInt),O)}async _call(w,D=null,O=null){const U=await super._call(w);if(D&&(U.input_points=this.reshape_input_points(D,U.original_sizes,U.reshaped_input_sizes)),O){if(!U.input_points)throw Error("`input_points` must be provided if `input_labels` are provided.");U.input_labels=this.add_input_labels(O,U.input_points)}return U}post_process_masks(w,D,O,{mask_threshold:U=0,binarize:G=!0,pad_size:q=null}={}){const K=[];q=q??this.pad_size;const ee=[q.height,q.width];for(let Z=0;Z<D.length;++Z){const ie=D[Z],Y=O[Z],W=w[Z],ne=[];for(let se=0;se<W.dims[0];++se){const le=W[se];let ce=interpolate(le,ee,"bilinear",!1);if(ce=ce.slice(null,[0,Y[0]],[0,Y[1]]),ce=interpolate(ce,ie,"bilinear",!1),G){const he=new Uint8Array(ce.data.length);for(let pe=0;pe<ce.data.length;++pe)ce.data[pe]>U&&(he[pe]=1);ce=new Tensor("bool",he,ce.dims)}ne.push(ce)}K.push(stack(ne))}return K}}class Swin2SRImageProcessor extends ImageFeatureExtractor{pad_image(w,D,O,U={}){const[G,q,K]=D;return super.pad_image(w,D,{width:q+(O-q%O)%O,height:G+(O-G%O)%O},{mode:"symmetric",center:!1,constant_values:-1,...U})}}class VitMatteImageProcessor extends ImageFeatureExtractor{async _call(w,D){Array.isArray(w)||(w=[w]),Array.isArray(D)||(D=[D]);const O=await Promise.all(w.map(q=>this.preprocess(q))),U=await Promise.all(D.map(q=>this.preprocess(q,{do_normalize:!1,do_convert_rgb:!1,do_convert_grayscale:!0})));return{pixel_values:stack(O.map((q,K)=>cat([q.pixel_values,U[K].pixel_values],0)),0),original_sizes:O.map(q=>q.original_size),reshaped_input_sizes:O.map(q=>q.reshaped_input_size)}}}class WhisperFeatureExtractor extends FeatureExtractor{constructor(w){super(w),this.config.mel_filters??=mel_filter_bank(Math.floor(1+this.config.n_fft/2),this.config.feature_size,0,8e3,this.config.sampling_rate,"slaney","slaney"),this.window=window_function(this.config.n_fft,"hann")}_extract_fbank_features(w){const{data:D,dims:O}=spectrogram(w,this.window,this.config.n_fft,this.config.hop_length,{power:2,mel_filters:this.config.mel_filters,log_mel:"log10",max_num_frames:this.config.nb_max_frames}),U=max(D)[0];for(let G=0;G<D.length;++G)D[G]=(Math.max(D[G],U-8)+4)/4;return{data:D,dims:O}}async _call(w){validate_audio_inputs(w,"WhisperFeatureExtractor");let D;w.length>this.config.n_samples?(console.warn("Attempting to extract features for audio longer than 30 seconds. If using a pipeline to extract transcript from a long audio clip, remember to specify `chunk_length_s` and/or `stride_length_s`."),D=w.slice(0,this.config.n_samples)):(D=new Float32Array(this.config.n_samples),D.set(w));const{data:O,dims:U}=this._extract_fbank_features(D);return{input_features:new Tensor("float32",O,[1,...U])}}}class Wav2Vec2FeatureExtractor extends FeatureExtractor{_zero_mean_unit_var_norm(w){const O=w.reduce((G,q)=>G+q,0)/w.length,U=w.reduce((G,q)=>G+(q-O)**2,0)/w.length;return w.map(G=>(G-O)/Math.sqrt(U+1e-7))}async _call(w){validate_audio_inputs(w,"Wav2Vec2FeatureExtractor"),w instanceof Float64Array&&(w=new Float32Array(w));let D=w;this.config.do_normalize&&(D=this._zero_mean_unit_var_norm(D));const O=[1,D.length];return{input_values:new Tensor("float32",D,O),attention_mask:new Tensor("int64",new BigInt64Array(D.length).fill(1n),O)}}}class SeamlessM4TFeatureExtractor extends FeatureExtractor{constructor(w){super(w);const D=this.config.sampling_rate,O=mel_filter_bank(256,this.config.num_mel_bins,20,Math.floor(D/2),D,null,"kaldi",!0);for(let U=0;U<O.length;++U)O[U].push(0);this.mel_filters=O,this.window=window_function(400,"povey",{periodic:!1})}_extract_fbank_features(w,D){return w=w.map(O=>O*32768),spectrogram(w,this.window,400,160,{fft_length:512,power:2,center:!1,preemphasis:.97,mel_filters:this.mel_filters,log_mel:"log",mel_floor:1192092955078125e-22,remove_dc_offset:!0,max_num_frames:D,transpose:!0})}async _call(w,{padding:D=!0,pad_to_multiple_of:O=2,do_normalize_per_mel_bins:U=!0,return_attention_mask:G=!0}={}){validate_audio_inputs(w,"SeamlessM4TFeatureExtractor");let q=this._extract_fbank_features(w,this.config.max_length);if(U){const[se,le]=q.dims;for(let ce=0;ce<le;++ce){let he=0;for(let ge=0;ge<se;++ge)he+=q.data[ge*le+ce];const pe=he/se;let me=0;for(let ge=0;ge<se;++ge)me+=(q.data[ge*le+ce]-pe)**2;me/=se-1;const be=Math.sqrt(me+1e-7);for(let ge=0;ge<se;++ge){const ve=ge*le+ce;q.data[ve]=(q.data[ve]-pe)/be}}}let K;if(D){const[se,le]=q.dims,ce=se%O;if(ce>0){const he=new Float32Array(le*(se+ce));he.set(q.data),he.fill(this.config.padding_value,q.data.length);const pe=se+ce;q={data:he,dims:[pe,le]},G&&(K=new Tensor("int64",new BigInt64Array(pe),[1,pe]),K.data.fill(1n,0,se))}}const[ee,Z]=q.dims,ie=this.config.stride;if(ee%ie!==0)throw new Error(`The number of frames (${ee}) must be a multiple of the stride (${ie}).`);const W=new Tensor("float32",q.data,q.dims).view(1,Math.floor(ee/ie),Z*ie),ne={input_features:W};if(G){const se=W.dims[1],le=new Tensor("int64",new BigInt64Array(se),[1,se]);if(K)for(let ce=1,he=0;ce<ee;ce+=ie,++he)le.data[he]=K.data[ce];else le.data.fill(1n);ne.attention_mask=le}return ne}}class ASTFeatureExtractor extends FeatureExtractor{constructor(w){super(w);const D=this.config.sampling_rate,O=mel_filter_bank(256,this.config.num_mel_bins,20,Math.floor(D/2),D,null,"kaldi",!0);for(let U=0;U<O.length;++U)O[U].push(0);this.mel_filters=O,this.window=window_function(400,"hann",{periodic:!1}),this.mean=this.config.mean,this.std=this.config.std}_extract_fbank_features(w,D){return spectrogram(w,this.window,400,160,{fft_length:512,power:2,center:!1,preemphasis:.97,mel_filters:this.mel_filters,log_mel:"log",mel_floor:1192092955078125e-22,remove_dc_offset:!0,max_num_frames:D,transpose:!0})}async _call(w){validate_audio_inputs(w,"ASTFeatureExtractor");const D=this._extract_fbank_features(w,this.config.max_length);if(this.config.do_normalize){const O=this.std*2;for(let U=0;U<D.data.length;++U)D.data[U]=(D.data[U]-this.mean)/O}return{input_values:new Tensor("float32",D.data,[1,...D.dims])}}}class ClapFeatureExtractor extends FeatureExtractor{constructor(w){super(w),this.mel_filters=mel_filter_bank(this.config.nb_frequency_bins,this.config.feature_size,this.config.frequency_min,this.config.frequency_max,this.config.sampling_rate,null,"htk"),this.mel_filters_slaney=mel_filter_bank(this.config.nb_frequency_bins,this.config.feature_size,this.config.frequency_min,this.config.frequency_max,this.config.sampling_rate,"slaney","slaney"),this.window=window_function(this.config.fft_window_size,"hann")}_get_input_mel(w,D,O,U){let G,q=!1;const K=w.length-D;if(K>0)if(O==="rand_trunc"){q=!0;const ee=Math.floor(Math.random()*(K+1));w=w.subarray(ee,ee+D),G=this._extract_fbank_features(w,this.mel_filters_slaney,this.config.nb_max_samples),G.dims=[1,...G.dims]}else throw new Error(`Truncation strategy "${O}" not implemented`);else{if(K<0){let ee=new Float64Array(D);if(ee.set(w),U==="repeat")for(let Z=w.length;Z<D;Z+=w.length)ee.set(w.subarray(0,Math.min(w.length,D-Z)),Z);else if(U==="repeatpad")for(let Z=w.length;Z<-K;Z+=w.length)ee.set(w,Z);w=ee}if(O==="fusion")throw new Error(`Truncation strategy "${O}" not implemented`);G=this._extract_fbank_features(w,this.mel_filters_slaney,this.config.nb_max_samples),G.dims=[1,...G.dims]}return{...G,longer:q}}_extract_fbank_features(w,D,O=null){return spectrogram(w,this.window,this.config.fft_window_size,this.config.hop_length,{power:2,mel_filters:D,log_mel:"dB",max_num_frames:O,do_pad:!1,transpose:!0})}async _call(w,{max_length:D=null}={}){validate_audio_inputs(w,"ClapFeatureExtractor");const O=this._get_input_mel(w,D??this.config.nb_max_samples,this.config.truncation,this.config.padding);return{input_features:new Tensor("float32",O.data,[1,...O.dims])}}}class SpeechT5FeatureExtractor extends FeatureExtractor{}class Processor extends Callable{constructor(w){super(),this.feature_extractor=w}async _call(w,...D){return await this.feature_extractor(w,...D)}}class SamProcessor extends Processor{async _call(...w){return await this.feature_extractor(...w)}post_process_masks(...w){return this.feature_extractor.post_process_masks(...w)}reshape_input_points(...w){return this.feature_extractor.reshape_input_points(...w)}}class WhisperProcessor extends Processor{async _call(w){return await this.feature_extractor(w)}}class Wav2Vec2ProcessorWithLM extends Processor{async _call(w){return await this.feature_extractor(w)}}class SpeechT5Processor extends Processor{async _call(w){return await this.feature_extractor(w)}}class OwlViTProcessor extends Processor{}class AutoProcessor{static FEATURE_EXTRACTOR_CLASS_MAPPING={ImageFeatureExtractor,WhisperFeatureExtractor,ViTFeatureExtractor,MobileViTFeatureExtractor,MobileViTImageProcessor,OwlViTFeatureExtractor,Owlv2ImageProcessor,CLIPFeatureExtractor,ChineseCLIPFeatureExtractor,SiglipImageProcessor,ConvNextFeatureExtractor,ConvNextImageProcessor,SegformerFeatureExtractor,BitImageProcessor,DPTImageProcessor,DPTFeatureExtractor,GLPNFeatureExtractor,BeitFeatureExtractor,DeiTFeatureExtractor,DetrFeatureExtractor,YolosFeatureExtractor,DonutFeatureExtractor,NougatImageProcessor,EfficientNetImageProcessor,ViTImageProcessor,VitMatteImageProcessor,SamImageProcessor,Swin2SRImageProcessor,Wav2Vec2FeatureExtractor,SeamlessM4TFeatureExtractor,SpeechT5FeatureExtractor,ASTFeatureExtractor,ClapFeatureExtractor};static PROCESSOR_CLASS_MAPPING={WhisperProcessor,Wav2Vec2ProcessorWithLM,SamProcessor,SpeechT5Processor,OwlViTProcessor};static async from_pretrained(w,{progress_callback:D=null,config:O=null,cache_dir:U=null,local_files_only:G=!1,revision:q="main"}={}){let K=O??await getModelJSON(w,"preprocessor_config.json",!0,{progress_callback:D,cache_dir:U,local_files_only:G,revision:q}),ee=K.feature_extractor_type??K.image_processor_type,Z=this.FEATURE_EXTRACTOR_CLASS_MAPPING[ee];if(!Z)if(K.size!==void 0)console.warn(`Feature extractor type "${ee}" not found, assuming ImageFeatureExtractor due to size parameter in config.`),Z=ImageFeatureExtractor;else throw new Error(`Unknown Feature Extractor type: ${ee}`);let ie=this.PROCESSOR_CLASS_MAPPING[K.processor_class]??Processor,Y=new Z(K);return new ie(Y)}}async function prepareImages(F){return Array.isArray(F)||(F=[F]),await Promise.all(F.map(w=>RawImage.read(w)))}async function prepareAudios(F,w){return Array.isArray(F)||(F=[F]),await Promise.all(F.map(D=>typeof D=="string"||D instanceof URL?read_audio(D,w):D instanceof Float64Array?new Float32Array(D):D))}function get_bounding_box(F,w){w&&(F=F.map(q=>q|0));const[D,O,U,G]=F;return{xmin:D,ymin:O,xmax:U,ymax:G}}class Pipeline extends Callable{constructor({task:w,model:D,tokenizer:O=null,processor:U=null}){super(),this.task=w,this.model=D,this.tokenizer=O,this.processor=U}async dispose(){await this.model.dispose()}}class TextClassificationPipeline extends Pipeline{constructor(w){super(w)}async _call(w,{topk:D=1}={}){const O=this.tokenizer(w,{padding:!0,truncation:!0}),U=await this.model(O),G=this.model.config.problem_type==="multi_label_classification"?ee=>ee.sigmoid().data:ee=>softmax(ee.data),q=this.model.config.id2label,K=[];for(const ee of U.logits){const Z=G(ee),Y=getTopItems(Z,D).map(W=>({label:q[W[0]],score:W[1]}));D===1?K.push(...Y):K.push(Y)}return Array.isArray(w)||D===1?K:K[0]}}class TokenClassificationPipeline extends Pipeline{constructor(w){super(w)}async _call(w,{ignore_labels:D=["O"]}={}){const O=Array.isArray(w),U=this.tokenizer(O?w:[w],{padding:!0,truncation:!0}),q=(await this.model(U)).logits,K=this.model.config.id2label,ee=[];for(let Z=0;Z<q.dims[0];++Z){const ie=U.input_ids[Z],Y=q[Z],W=[];for(let ne=0;ne<Y.dims[0];++ne){const se=Y[ne],le=max(se.data)[1],ce=K?K[le]:`LABEL_${le}`;if(D.includes(ce))continue;const he=this.tokenizer.decode([ie[ne].item()],{skip_special_tokens:!0});if(he==="")continue;const pe=softmax(se.data);W.push({entity:ce,score:pe[le],index:ne,word:he,start:null,end:null})}ee.push(W)}return O?ee:ee[0]}}class QuestionAnsweringPipeline extends Pipeline{constructor(w){super(w)}async _call(w,D,{topk:O=1}={}){const U=this.tokenizer(w,{text_pair:D,padding:!0,truncation:!0}),G=await this.model(U),q=[];for(let K=0;K<G.start_logits.dims[0];++K){const ee=U.input_ids[K],Z=ee.indexOf(this.tokenizer.sep_token_id),ie=Array.from(softmax(G.start_logits[K].data)).map((ne,se)=>[ne,se]).filter(ne=>ne[1]>Z),Y=Array.from(softmax(G.end_logits[K].data)).map((ne,se)=>[ne,se]).filter(ne=>ne[1]>Z),W=product(ie,Y).filter(ne=>ne[0][1]<=ne[1][1]).map(ne=>[ne[0][1],ne[1][1],ne[0][0]*ne[1][0]]).sort((ne,se)=>se[2]-ne[2]);for(let ne=0;ne<Math.min(W.length,O);++ne){const[se,le,ce]=W[ne],he=[...ee].slice(se,le+1),pe=this.tokenizer.decode(he,{skip_special_tokens:!0});q.push({answer:pe,score:ce})}}return O===1?q[0]:q}}class FillMaskPipeline extends Pipeline{constructor(w){super(w)}async _call(w,{topk:D=5}={}){const O=this.tokenizer(w,{padding:!0,truncation:!0}),U=await this.model(O),G=[];for(let q=0;q<O.input_ids.dims[0];++q){const K=O.input_ids[q],ee=K.indexOf(this.tokenizer.mask_token_id);if(ee===-1)throw Error(`Mask token (${this.tokenizer.mask_token}) not found in text.`);const ie=U.logits[q][ee],Y=getTopItems(softmax(ie.data),D);G.push(Y.map(W=>{const ne=[...K];return ne[ee]=W[0],{score:W[1],token:W[0],token_str:this.tokenizer.model.vocab[W[0]],sequence:this.tokenizer.decode(ne,{skip_special_tokens:!0})}}))}return Array.isArray(w)?G:G[0]}}class Text2TextGenerationPipeline extends Pipeline{_key="generated_text";constructor(w){super(w)}async _call(w,D={}){Array.isArray(w)||(w=[w]),this.model.config.prefix&&(w=w.map(ee=>this.model.config.prefix+ee));const O=this.model.config.task_specific_params;O&&O[this.task]&&O[this.task].prefix&&(w=w.map(ee=>O[this.task].prefix+ee));const U=this.tokenizer,G={padding:!0,truncation:!0};let q;this instanceof TranslationPipeline&&"_build_translation_inputs"in U?q=U._build_translation_inputs(w,G,D).input_ids:q=U(w,G).input_ids;const K=await this.model.generate(q,D);return U.batch_decode(K,{skip_special_tokens:!0}).map(ee=>({[this._key]:ee}))}}class SummarizationPipeline extends Text2TextGenerationPipeline{_key="summary_text";constructor(w){super(w)}}class TranslationPipeline extends Text2TextGenerationPipeline{_key="translation_text";constructor(w){super(w)}}function isChat(F){return Array.isArray(F)&&F.every(w=>"role"in w&&"content"in w)}class TextGenerationPipeline extends Pipeline{constructor(w){super(w)}async _call(w,D={}){let O=!1,U=!1,G;if(typeof w=="string")G=w=[w];else if(Array.isArray(w)&&w.every(se=>typeof se=="string"))O=!0,G=w;else{if(isChat(w))w=[w];else if(Array.isArray(w)&&w.every(isChat))O=!0;else throw new Error("Input must be a string, an array of strings, a Chat, or an array of Chats");U=!0,G=w.map(se=>this.tokenizer.apply_chat_template(se,{tokenize:!1,add_generation_prompt:!0}))}const q=D.add_special_tokens??!1,K=U?!1:D.return_full_text??!0;this.tokenizer.padding_side="left";const{input_ids:ee,attention_mask:Z}=this.tokenizer(G,{add_special_tokens:q,padding:!0,truncation:!0}),ie=await this.model.generate(ee,D,null,{inputs_attention_mask:Z});let Y=this.tokenizer.batch_decode(ie,{skip_special_tokens:!0}),W;!K&&ee.dims.at(-1)>0&&(W=this.tokenizer.batch_decode(ee,{skip_special_tokens:!0}).map(se=>se.length));const ne=Array.from({length:w.length},se=>[]);for(let se=0;se<Y.length;++se){const le=Math.floor(se/ie.length*w.length);W&&(Y[se]=Y[se].slice(W[le])),ne[le].push({generated_text:U?[...w[le],{role:"assistant",content:Y[se]}]:Y[se]})}return!O&&ne.length===1?ne[0]:ne}}class ZeroShotClassificationPipeline extends Pipeline{constructor(w){super(w),this.label2id=Object.fromEntries(Object.entries(this.model.config.label2id).map(([D,O])=>[D.toLowerCase(),O])),this.entailment_id=this.label2id.entailment,this.entailment_id===void 0&&(console.warn("Could not find 'entailment' in label2id mapping. Using 2 as entailment_id."),this.entailment_id=2),this.contradiction_id=this.label2id.contradiction??this.label2id.not_entailment,this.contradiction_id===void 0&&(console.warn("Could not find 'contradiction' in label2id mapping. Using 0 as contradiction_id."),this.contradiction_id=0)}async _call(w,D,{hypothesis_template:O="This example is {}.",multi_label:U=!1}={}){const G=Array.isArray(w);G||(w=[w]),Array.isArray(D)||(D=[D]);const q=D.map(Z=>O.replace("{}",Z)),K=U||D.length===1,ee=[];for(const Z of w){const ie=[];for(const ne of q){const se=this.tokenizer(Z,{text_pair:ne,padding:!0,truncation:!0}),le=await this.model(se);K?ie.push([le.logits.data[this.contradiction_id],le.logits.data[this.entailment_id]]):ie.push(le.logits.data[this.entailment_id])}const W=(K?ie.map(ne=>softmax(ne)[1]):softmax(ie)).map((ne,se)=>[ne,se]).sort((ne,se)=>se[0]-ne[0]);ee.push({sequence:Z,labels:W.map(ne=>D[ne[1]]),scores:W.map(ne=>ne[0])})}return G?ee:ee[0]}}class FeatureExtractionPipeline extends Pipeline{constructor(w){super(w)}async _call(w,{pooling:D="none",normalize:O=!1,quantize:U=!1,precision:G="binary"}={}){const q=this.tokenizer(w,{padding:!0,truncation:!0}),K=await this.model(q);let ee=K.last_hidden_state??K.logits??K.token_embeddings;if(D!=="none")if(D==="mean")ee=mean_pooling(ee,q.attention_mask);else if(D==="cls")ee=ee.slice(null,0);else throw Error(`Pooling method '${D}' not supported.`);return O&&(ee=ee.normalize(2,-1)),U&&(ee=quantize_embeddings(ee,G)),ee}}class ImageFeatureExtractionPipeline extends Pipeline{constructor(w){super(w)}async _call(w,{pool:D=null}={}){const O=await prepareImages(w),{pixel_values:U}=await this.processor(O),G=await this.model({pixel_values:U});let q;if(D){if(!("pooler_output"in G))throw Error("No pooled output was returned. Make sure the model has a 'pooler' layer when using the 'pool' option.");q=G.pooler_output}else q=G.last_hidden_state??G.logits??G.image_embeds;return q}}class AudioClassificationPipeline extends Pipeline{constructor(w){super(w)}async _call(w,{topk:D=null}={}){const O=!Array.isArray(w),U=this.processor.feature_extractor.config.sampling_rate,G=await prepareAudios(w,U),q=this.model.config.id2label,K=[];for(const ee of G){const Z=await this.processor(ee),Y=(await this.model(Z)).logits[0],ne=getTopItems(softmax(Y.data),D).map(se=>({label:q[se[0]],score:se[1]}));D===1?K.push(...ne):K.push(ne)}return!O||D===1?K:K[0]}}class ZeroShotAudioClassificationPipeline extends Pipeline{constructor(w){super(w)}async _call(w,D,{hypothesis_template:O="This is a sound of {}."}={}){const U=!Array.isArray(w);U&&(w=[w]);const G=D.map(ie=>O.replace("{}",ie)),q=this.tokenizer(G,{padding:!0,truncation:!0}),K=this.processor.feature_extractor.config.sampling_rate,ee=await prepareAudios(w,K),Z=[];for(const ie of ee){const Y=await this.processor(ie),W=await this.model({...q,...Y}),ne=softmax(W.logits_per_audio.data);Z.push([...ne].map((se,le)=>({score:se,label:D[le]})))}return U?Z[0]:Z}}class AutomaticSpeechRecognitionPipeline extends Pipeline{constructor(w){super(w)}async _call(w,D={}){switch(this.model.config.model_type){case"whisper":return this._call_whisper(w,D);case"wav2vec2":case"wav2vec2-bert":case"unispeech":case"unispeech-sat":case"hubert":return this._call_wav2vec2(w,D);default:throw new Error(`AutomaticSpeechRecognitionPipeline does not support model type '${this.model.config.model_type}'.`)}}async _call_wav2vec2(w,D={}){D.language&&console.warn('`language` parameter is not yet supported for `wav2vec2` models, defaulting to "English".'),D.task&&console.warn('`task` parameter is not yet supported for `wav2vec2` models, defaulting to "transcribe".');const O=!Array.isArray(w);O&&(w=[w]);const U=this.processor.feature_extractor.config.sampling_rate,G=await prepareAudios(w,U),q=[];for(const K of G){const ee=await this.processor(K),ie=(await this.model(ee)).logits[0],Y=[];for(const ne of ie)Y.push(max(ne.data)[1]);const W=this.tokenizer.decode(Y);q.push({text:W})}return O?q[0]:q}async _call_whisper(w,D={}){const O=D.return_timestamps??!1,U=D.chunk_length_s??0,G=D.chunk_callback??null,q=D.force_full_sequences??!1;let K=D.stride_length_s??null;O==="word"&&(D.return_token_timestamps=!0);const ee=pop(D,"language",null),Z=pop(D,"task",null);if(ee||Z||O){if(D.forced_decoder_ids)throw new Error("Cannot specify `language`/`task`/`return_timestamps` and `forced_decoder_ids` at the same time.");const ce=this.tokenizer.get_decoder_prompt_ids({language:ee,task:Z,no_timestamps:!O});ce.length>0&&(D.forced_decoder_ids=ce)}const ie=!Array.isArray(w);ie&&(w=[w]);const Y=this.processor.feature_extractor.config.chunk_length/this.model.config.max_source_positions,W=this.processor.feature_extractor.config.hop_length,ne=this.processor.feature_extractor.config.sampling_rate,se=await prepareAudios(w,ne),le=[];for(const ce of se){let he=[];if(U>0){if(K===null)K=U/6;else if(U<=K)throw Error("`chunk_length_s` must be larger than `stride_length_s`.");const be=ne*U,ge=ne*K,ve=be-2*ge;let Se=0;for(;Se<ce.length;){const Me=ce.subarray(Se,Se+be),Ee=await this.processor(Me),we=Se===0,Re=Se+ve>=ce.length;he.push({stride:[Me.length,we?0:ge,Re?0:ge],input_features:Ee.input_features,is_last:Re}),Se+=ve}}else he=[{stride:[ce.length,0,0],input_features:(await this.processor(ce)).input_features,is_last:!0}];for(const be of he){D.num_frames=Math.floor(be.stride[0]/W);const ge=await this.model.generate(be.input_features,D);O==="word"?(be.tokens=ge.sequences[0],be.token_timestamps=ge.token_timestamps.tolist()[0].map(ve=>round(ve,2))):be.tokens=ge[0],be.stride=be.stride.map(ve=>ve/ne),G!==null&&G(be)}const[pe,me]=this.tokenizer._decode_asr(he,{time_precision:Y,return_timestamps:O,force_full_sequences:q});le.push({text:pe,...me})}return ie?le[0]:le}}class ImageToTextPipeline extends Pipeline{constructor(w){super(w)}async _call(w,D={}){const O=Array.isArray(w),U=await prepareImages(w),{pixel_values:G}=await this.processor(U),q=[];for(const K of G){K.dims=[1,...K.dims];const ee=await this.model.generate(K,D),Z=this.tokenizer.batch_decode(ee,{skip_special_tokens:!0}).map(ie=>({generated_text:ie.trim()}));q.push(Z)}return O?q:q[0]}}class ImageClassificationPipeline extends Pipeline{constructor(w){super(w)}async _call(w,{topk:D=1}={}){const O=Array.isArray(w),U=await prepareImages(w),{pixel_values:G}=await this.processor(U),q=await this.model({pixel_values:G}),K=this.model.config.id2label,ee=[];for(const Z of q.logits){const Y=getTopItems(softmax(Z.data),D).map(W=>({label:K[W[0]],score:W[1]}));D===1?ee.push(...Y):ee.push(Y)}return O||D===1?ee:ee[0]}}class ImageSegmentationPipeline extends Pipeline{constructor(w){super(w),this.subtasks_mapping={panoptic:"post_process_panoptic_segmentation",instance:"post_process_instance_segmentation",semantic:"post_process_semantic_segmentation"}}async _call(w,{threshold:D=.5,mask_threshold:O=.5,overlap_mask_area_threshold:U=.8,label_ids_to_fuse:G=null,target_sizes:q=null,subtask:K=null}={}){if(Array.isArray(w)&&w.length!==1)throw Error("Image segmentation pipeline currently only supports a batch size of 1.");const Z=await prepareImages(w),ie=Z.map(he=>[he.height,he.width]),{pixel_values:Y,pixel_mask:W}=await this.processor(Z),ne=await this.model({pixel_values:Y,pixel_mask:W});let se=null;if(K!==null)se=this.subtasks_mapping[K];else for(let[he,pe]of Object.entries(this.subtasks_mapping))if(pe in this.processor.feature_extractor){se=this.processor.feature_extractor[pe].bind(this.processor.feature_extractor),K=he;break}const le=this.model.config.id2label,ce=[];if(K==="panoptic"||K==="instance"){const he=se(ne,D,O,U,G,q??ie)[0],pe=he.segmentation;for(const me of he.segments_info){const be=new Uint8ClampedArray(pe.data.length);for(let ve=0;ve<pe.data.length;++ve)pe.data[ve]===me.id&&(be[ve]=255);const ge=new RawImage(be,pe.dims[1],pe.dims[0],1);ce.push({score:me.score,label:le[me.label_id],mask:ge})}}else if(K==="semantic"){const{segmentation:he,labels:pe}=se(ne,q??ie)[0];for(const me of pe){const be=new Uint8ClampedArray(he.data.length);for(let ve=0;ve<he.data.length;++ve)he.data[ve]===me&&(be[ve]=255);const ge=new RawImage(be,he.dims[1],he.dims[0],1);ce.push({score:null,label:le[me],mask:ge})}}else throw Error(`Subtask ${K} not supported.`);return ce}}class ZeroShotImageClassificationPipeline extends Pipeline{constructor(w){super(w)}async _call(w,D,{hypothesis_template:O="This is a photo of {}"}={}){const U=Array.isArray(w),G=await prepareImages(w),q=D.map(W=>O.replace("{}",W)),K=this.tokenizer(q,{padding:this.model.config.model_type==="siglip"?"max_length":!0,truncation:!0}),{pixel_values:ee}=await this.processor(G),Z=await this.model({...K,pixel_values:ee}),ie=this.model.config.model_type==="siglip"?W=>W.sigmoid().data:W=>softmax(W.data),Y=[];for(const W of Z.logits_per_image){const se=[...ie(W)].map((le,ce)=>({score:le,label:D[ce]}));se.sort((le,ce)=>ce.score-le.score),Y.push(se)}return U?Y:Y[0]}}class ObjectDetectionPipeline extends Pipeline{constructor(w){super(w)}async _call(w,{threshold:D=.9,percentage:O=!1}={}){const U=Array.isArray(w);if(U&&w.length!==1)throw Error("Object detection pipeline currently only supports a batch size of 1.");const G=await prepareImages(w),q=O?null:G.map(ne=>[ne.height,ne.width]),{pixel_values:K,pixel_mask:ee}=await this.processor(G),Z=await this.model({pixel_values:K,pixel_mask:ee}),ie=this.processor.feature_extractor.post_process_object_detection(Z,D,q),Y=this.model.config.id2label,W=ie.map(ne=>ne.boxes.map((se,le)=>({score:ne.scores[le],label:Y[ne.classes[le]],box:get_bounding_box(se,!O)})));return U?W:W[0]}}class ZeroShotObjectDetectionPipeline extends Pipeline{constructor(w){super(w)}async _call(w,D,{threshold:O=.1,topk:U=null,percentage:G=!1}={}){const q=Array.isArray(w),K=await prepareImages(w),ee=this.tokenizer(D,{padding:!0,truncation:!0}),Z=await this.processor(K),ie=[];for(let Y=0;Y<K.length;++Y){const W=K[Y],ne=G?null:[[W.height,W.width]],se=Z.pixel_values[Y].unsqueeze_(0),le=await this.model({...ee,pixel_values:se}),ce=this.processor.feature_extractor.post_process_object_detection(le,O,ne,!0)[0];let he=ce.boxes.map((pe,me)=>({score:ce.scores[me],label:D[ce.classes[me]],box:get_bounding_box(pe,!G)})).sort((pe,me)=>me.score-pe.score);U!==null&&(he=he.slice(0,U)),ie.push(he)}return q?ie:ie[0]}}class DocumentQuestionAnsweringPipeline extends Pipeline{constructor(w){super(w)}async _call(w,D,O={}){const U=(await prepareImages(w))[0],{pixel_values:G}=await this.processor(U),q=`<s_docvqa><s_question>${D}</s_question><s_answer>`,K=this.tokenizer(q,{add_special_tokens:!1,padding:!0,truncation:!0}).input_ids,ee=await this.model.generate(G,{...O,decoder_input_ids:K,max_length:this.model.config.decoder.max_position_embeddings}),ie=this.tokenizer.batch_decode(ee)[0].match(/<s_answer>(.*?)<\/s_answer>/);let Y=null;return ie&&ie.length>=2&&(Y=ie[1].trim()),[{answer:Y}]}}class TextToAudioPipeline extends Pipeline{DEFAULT_VOCODER_ID="Xenova/speecht5_hifigan";constructor(w){super(w),this.vocoder=w.vocoder??null}async _call(w,{speaker_embeddings:D=null}={}){return this.processor?this._call_text_to_spectrogram(w,{speaker_embeddings:D}):this._call_text_to_waveform(w)}async _call_text_to_waveform(w){const D=this.tokenizer(w,{padding:!0,truncation:!0}),{waveform:O}=await this.model(D),U=this.model.config.sampling_rate;return{audio:O.data,sampling_rate:U}}async _call_text_to_spectrogram(w,{speaker_embeddings:D}){if(this.vocoder||(console.log("No vocoder specified, using default HifiGan vocoder."),this.vocoder=await AutoModel.from_pretrained(this.DEFAULT_VOCODER_ID,{quantized:!1})),(typeof D=="string"||D instanceof URL)&&(D=new Float32Array(await(await fetch(D)).arrayBuffer())),D instanceof Float32Array)D=new Tensor("float32",D,[1,D.length]);else if(!(D instanceof Tensor))throw new Error("Speaker embeddings must be a `Tensor`, `Float32Array`, `string`, or `URL`.");const{input_ids:O}=this.tokenizer(w,{padding:!0,truncation:!0}),{waveform:U}=await this.model.generate_speech(O,D,{vocoder:this.vocoder}),G=this.processor.feature_extractor.config.sampling_rate;return{audio:U.data,sampling_rate:G}}}class ImageToImagePipeline extends Pipeline{constructor(w){super(w)}async _call(w){const D=await prepareImages(w),O=await this.processor(D),U=await this.model(O),G=[];for(const q of U.reconstruction){const K=q.squeeze().clamp_(0,1).mul_(255).round_().to("uint8");G.push(RawImage.fromTensor(K))}return G.length>1?G:G[0]}}class DepthEstimationPipeline extends Pipeline{constructor(w){super(w)}async _call(w){const D=await prepareImages(w),O=await this.processor(D),{predicted_depth:U}=await this.model(O),G=[];for(let q=0;q<D.length;++q){const K=interpolate(U[q],D[q].size.reverse(),"bilinear",!1),ee=K.mul_(255/max(K.data)[0]).to("uint8");G.push({predicted_depth:U[q],depth:RawImage.fromTensor(ee)})}return G.length>1?G:G[0]}}const SUPPORTED_TASKS=Object.freeze({"text-classification":{tokenizer:AutoTokenizer,pipeline:TextClassificationPipeline,model:AutoModelForSequenceClassification,default:{model:"Xenova/distilbert-base-uncased-finetuned-sst-2-english"},type:"text"},"token-classification":{tokenizer:AutoTokenizer,pipeline:TokenClassificationPipeline,model:AutoModelForTokenClassification,default:{model:"Xenova/bert-base-multilingual-cased-ner-hrl"},type:"text"},"question-answering":{tokenizer:AutoTokenizer,pipeline:QuestionAnsweringPipeline,model:AutoModelForQuestionAnswering,default:{model:"Xenova/distilbert-base-cased-distilled-squad"},type:"text"},"fill-mask":{tokenizer:AutoTokenizer,pipeline:FillMaskPipeline,model:AutoModelForMaskedLM,default:{model:"Xenova/bert-base-uncased"},type:"text"},summarization:{tokenizer:AutoTokenizer,pipeline:SummarizationPipeline,model:AutoModelForSeq2SeqLM,default:{model:"Xenova/distilbart-cnn-6-6"},type:"text"},translation:{tokenizer:AutoTokenizer,pipeline:TranslationPipeline,model:AutoModelForSeq2SeqLM,default:{model:"Xenova/t5-small"},type:"text"},"text2text-generation":{tokenizer:AutoTokenizer,pipeline:Text2TextGenerationPipeline,model:AutoModelForSeq2SeqLM,default:{model:"Xenova/flan-t5-small"},type:"text"},"text-generation":{tokenizer:AutoTokenizer,pipeline:TextGenerationPipeline,model:AutoModelForCausalLM,default:{model:"Xenova/gpt2"},type:"text"},"zero-shot-classification":{tokenizer:AutoTokenizer,pipeline:ZeroShotClassificationPipeline,model:AutoModelForSequenceClassification,default:{model:"Xenova/distilbert-base-uncased-mnli"},type:"text"},"audio-classification":{pipeline:AudioClassificationPipeline,model:AutoModelForAudioClassification,processor:AutoProcessor,default:{model:"Xenova/wav2vec2-base-superb-ks"},type:"audio"},"zero-shot-audio-classification":{tokenizer:AutoTokenizer,pipeline:ZeroShotAudioClassificationPipeline,model:AutoModel,processor:AutoProcessor,default:{model:"Xenova/clap-htsat-unfused"},type:"multimodal"},"automatic-speech-recognition":{tokenizer:AutoTokenizer,pipeline:AutomaticSpeechRecognitionPipeline,model:[AutoModelForSpeechSeq2Seq,AutoModelForCTC],processor:AutoProcessor,default:{model:"Xenova/whisper-tiny.en"},type:"multimodal"},"text-to-audio":{tokenizer:AutoTokenizer,pipeline:TextToAudioPipeline,model:[AutoModelForTextToWaveform,AutoModelForTextToSpectrogram],processor:[AutoProcessor,null],default:{model:"Xenova/speecht5_tts"},type:"text"},"image-to-text":{tokenizer:AutoTokenizer,pipeline:ImageToTextPipeline,model:AutoModelForVision2Seq,processor:AutoProcessor,default:{model:"Xenova/vit-gpt2-image-captioning"},type:"multimodal"},"image-classification":{pipeline:ImageClassificationPipeline,model:AutoModelForImageClassification,processor:AutoProcessor,default:{model:"Xenova/vit-base-patch16-224"},type:"multimodal"},"image-segmentation":{pipeline:ImageSegmentationPipeline,model:[AutoModelForImageSegmentation,AutoModelForSemanticSegmentation],processor:AutoProcessor,default:{model:"Xenova/detr-resnet-50-panoptic"},type:"multimodal"},"zero-shot-image-classification":{tokenizer:AutoTokenizer,pipeline:ZeroShotImageClassificationPipeline,model:AutoModel,processor:AutoProcessor,default:{model:"Xenova/clip-vit-base-patch32"},type:"multimodal"},"object-detection":{pipeline:ObjectDetectionPipeline,model:AutoModelForObjectDetection,processor:AutoProcessor,default:{model:"Xenova/detr-resnet-50"},type:"multimodal"},"zero-shot-object-detection":{tokenizer:AutoTokenizer,pipeline:ZeroShotObjectDetectionPipeline,model:AutoModelForZeroShotObjectDetection,processor:AutoProcessor,default:{model:"Xenova/owlvit-base-patch32"},type:"multimodal"},"document-question-answering":{tokenizer:AutoTokenizer,pipeline:DocumentQuestionAnsweringPipeline,model:AutoModelForDocumentQuestionAnswering,processor:AutoProcessor,default:{model:"Xenova/donut-base-finetuned-docvqa"},type:"multimodal"},"image-to-image":{pipeline:ImageToImagePipeline,model:AutoModelForImageToImage,processor:AutoProcessor,default:{model:"Xenova/swin2SR-classical-sr-x2-64"},type:"image"},"depth-estimation":{pipeline:DepthEstimationPipeline,model:AutoModelForDepthEstimation,processor:AutoProcessor,default:{model:"Xenova/dpt-large"},type:"image"},"feature-extraction":{tokenizer:AutoTokenizer,pipeline:FeatureExtractionPipeline,model:AutoModel,default:{model:"Xenova/all-MiniLM-L6-v2"},type:"text"},"image-feature-extraction":{processor:AutoProcessor,pipeline:ImageFeatureExtractionPipeline,model:[AutoModelForImageFeatureExtraction,AutoModel],default:{model:"Xenova/vit-base-patch16-224-in21k"},type:"image"}}),TASK_ALIASES=Object.freeze({"sentiment-analysis":"text-classification",ner:"token-classification",asr:"automatic-speech-recognition","text-to-speech":"text-to-audio",embeddings:"feature-extraction"});async function pipeline(F,w=null,{quantized:D=!0,progress_callback:O=null,config:U=null,cache_dir:G=null,local_files_only:q=!1,revision:K="main",model_file_name:ee=null}={}){F=TASK_ALIASES[F]??F;const Z=SUPPORTED_TASKS[F.split("_",1)[0]];if(!Z)throw Error(`Unsupported pipeline: ${F}. Must be one of [${Object.keys(SUPPORTED_TASKS)}]`);w||(w=Z.default.model,console.log(`No model specified. Using default model: "${w}".`));const ie={quantized:D,progress_callback:O,config:U,cache_dir:G,local_files_only:q,revision:K,model_file_name:ee},Y=new Map([["tokenizer",Z.tokenizer],["model",Z.model],["processor",Z.processor]]),W=await loadItems(Y,w,ie);W.task=F,dispatchCallback(O,{status:"ready",task:F,model:w});const ne=Z.pipeline;return new ne(W)}async function loadItems(F,w,D){const O=Object.create(null),U=[];for(let[G,q]of F.entries()){if(!q)continue;let K;Array.isArray(q)?K=new Promise(async(ee,Z)=>{let ie;for(let Y of q){if(Y===null){ee(null);return}try{ee(await Y.from_pretrained(w,D));return}catch(W){ie=W}}Z(ie)}):K=q.from_pretrained(w,D),O[G]=K,U.push(K)}await Promise.all(U);for(let[G,q]of Object.entries(O))O[G]=await q;return O}const ruleBot=(F,w)=>{const D=F.toLowerCase(),O=w?.name?.toLowerCase()||"";return/halo|hi|hai/.test(D)?"Halo! Ada yang bisa saya bantu tentang produk 3D ini?":/toilet|wc|closet/.test(D)||O.includes("toilet")?"Toilet pintar: flush otomatis, hemat air 50%, pemanas dudukan, anti-bakteri UV.":/sepatu|shoe|sneaker/.test(D)||O.includes("shoe")?"Sepatu tahan air 100%, anti-slip, memory foam, cocok untuk jogging & daily use.":/tisu|tissue|cosmo/.test(D)||O.includes("tissue")?"Tisu 3 ply ultra-soft, hypoallergenic, aroma therapy, kemasan premium foil.":/astronaut|nasa|luar angkasa/.test(D)||O.includes("astronaut")?"Model astronaut berbasis NASA EMU, cocok untuk simulasi VR luar angkasa.":/kotak|box|kemasan/.test(D)||O.includes("box")?"Kotak kemasan premium: emboss 3D, foil gold, food-safe, ramah lingkungan.":/ar|augmented/.test(D)?'Tekan "Tap to Place" saat AR aktif untuk meletakkan model di lantai.':`Maaf, saya belum paham: "${F}". Coba tanya fitur produk atau AR!`};function App(){const[F,w]=reactExports.useState(""),[D,O]=reactExports.useState(!1),[U,G]=reactExports.useState(!1),[q,K]=reactExports.useState(null),[ee,Z]=reactExports.useState(null),[ie,Y]=reactExports.useState(!1),[W,ne]=reactExports.useState([]),[se,le]=reactExports.useState(""),[ce,he]=reactExports.useState(!1),[pe,me]=reactExports.useState(!1),be=reactExports.useRef(null),ge=reactExports.useRef(null),ve=reactExports.useRef(null);reactExports.useEffect(()=>{let Pe=!1;return(async()=>{if(!(ge.current||Pe))try{Me("system","Memuat AI lokal (gpt2)... sekali saja");const Be=await pipeline("text-generation","Xenova/gpt2",{quantized:!0,progress_callback:ze=>{!Pe&&ze.status==="downloading"&&Me("system",`Download model: ${Math.round(ze.progress)}%`)}});Pe||(ge.current=Be,Me("system","AI lokal siap! Kamu bisa bicara sekarang."))}catch(Be){console.error("AI init error:",Be),Me("system","Gagal muat AI. Pakai mode sederhana.")}})(),()=>{Pe=!0}},[]),reactExports.useEffect(()=>{const Pe=window.SpeechRecognition||window.webkitSpeechRecognition;if(!Pe){Me("system","Browser tidak mendukung mic. Gunakan Chrome/Edge.");return}const Ce=new Pe;Ce.lang="id-ID",Ce.interimResults=!1,Ce.continuous=!1,Ce.onresult=Be=>{const ze=Array.from(Be.results).map(Xe=>Xe[0].transcript).join("");le(ze),Ee(ze)},Ce.onerror=()=>{he(!1),Me("system","Mic error. Coba lagi.")},Ce.onend=()=>he(!1),be.current=Ce},[]);const Se=Pe=>new Promise(Ce=>{if(!("speechSynthesis"in window))return Ce();const Be=new SpeechSynthesisUtterance(Pe);Be.lang="id-ID",Be.rate=.9,Be.pitch=1,Be.volume=1,Be.onend=Ce,window.speechSynthesis.cancel(),window.speechSynthesis.speak(Be)}),Me=(Pe,Ce)=>{ne(Be=>[...Be,{role:Pe,content:Ce,id:Date.now()}]),setTimeout(()=>{ve.current&&(ve.current.scrollTop=0)},50)},Ee=async Pe=>{if(!Pe.trim())return;const Ce=Pe.trim();Me("user",Ce),le(""),me(!0);let Be="";if(ge.current)try{Be=(await ge.current(`Q: ${Ce}
A:`,{max_new_tokens:80,do_sample:!0,temperature:.7,top_k:50}))[0].generated_text.split("A:")[1]?.trim()||"Saya tidak yakin."}catch{Be=ruleBot(Ce,ee)}else Be=ruleBot(Ce,ee);Me("bot",Be),await Se(Be),me(!1)},we=()=>{be.current&&(ce?be.current.stop():(be.current.start(),he(!0)))},Re=Pe=>{if(Pe instanceof File){const Ce=URL.createObjectURL(Pe);K(Ce),w(Ce),Z({name:Pe.name,sizeFormatted:`${(Pe.size/1024).toFixed(2)} KB`,desc_left:{title:"File",value:"Lokal"},desc_right:{title:"Ukuran",value:`${(Pe.size/1024).toFixed(2)} KB`}})}else K(null),w(Pe.fullUrl),Z(Pe);O(!0)},Le=()=>{O(!1),q&&setTimeout(()=>URL.revokeObjectURL(q),500),w(""),K(null),Z(null)},Ne=()=>G(!0),Oe=()=>G(!1);return reactExports.useEffect(()=>()=>{q&&URL.revokeObjectURL(q)},[q]),D&&F?jsxRuntimeExports.jsxs(motion.div,{initial:{opacity:0},animate:{opacity:1},exit:{opacity:0},children:[jsxRuntimeExports.jsx(ARViewer,{modelUrl:F,model:ee,onBack:Le}),jsxRuntimeExports.jsx("button",{onClick:()=>Y(!0),className:"fixed bottom-6 right-6 z-50 p-4 bg-gradient-to-r from-cyan-500 to-purple-600 rounded-full shadow-2xl hover:scale-110 transition-all",children:jsxRuntimeExports.jsx(MessageCircle,{className:"w-6 h-6 text-white"})})]}):U?jsxRuntimeExports.jsx(UnityARViewer,{onBack:Oe}):jsxRuntimeExports.jsxs("div",{className:"relative min-h-screen overflow-hidden bg-gradient-to-br from-slate-950 via-cyan-950 to-slate-950 text-white",children:[jsxRuntimeExports.jsx("button",{onClick:()=>Y(!0),className:"fixed bottom-24 right-6 z-50 p-4 bg-gradient-to-r from-pink-500 to-purple-600 rounded-full shadow-2xl hover:scale-110 transition-all animate-pulse",children:jsxRuntimeExports.jsx(Sparkles,{className:"w-6 h-6 text-white"})}),ie&&jsxRuntimeExports.jsx(motion.div,{initial:{opacity:0,scale:.9,y:100},animate:{opacity:1,scale:1,y:0},exit:{opacity:0,scale:.9},className:"fixed inset-0 z-[9999] flex items-end justify-center p-4",onClick:()=>Y(!1),children:jsxRuntimeExports.jsxs("div",{className:"w-full max-w-lg bg-slate-900/95 backdrop-blur-2xl rounded-3xl shadow-2xl border border-white/10 overflow-hidden",onClick:Pe=>Pe.stopPropagation(),children:[jsxRuntimeExports.jsxs("div",{className:"p-4 bg-gradient-to-r from-cyan-600 to-purple-600 flex items-center justify-between",children:[jsxRuntimeExports.jsxs("div",{className:"flex items-center gap-3",children:[jsxRuntimeExports.jsx("div",{className:"w-10 h-10 bg-white/20 rounded-full flex items-center justify-center",children:jsxRuntimeExports.jsx(Sparkles,{className:"w-6 h-6 text-white"})}),jsxRuntimeExports.jsxs("div",{children:[jsxRuntimeExports.jsx("h3",{className:"font-bold text-white",children:"Asisten AR"}),jsxRuntimeExports.jsx("p",{className:"text-xs text-cyan-100",children:"Tanya fitur produk atau AR"})]})]}),jsxRuntimeExports.jsx("button",{onClick:()=>Y(!1),className:"text-white/70 hover:text-white",children:jsxRuntimeExports.jsx(X,{className:"w-5 h-5"})})]}),jsxRuntimeExports.jsxs("div",{ref:ve,className:"h-96 overflow-y-auto p-4 space-y-3",children:[W.map(Pe=>jsxRuntimeExports.jsx("div",{className:`flex ${Pe.role==="user"?"justify-end":"justify-start"}`,children:jsxRuntimeExports.jsx("div",{className:`max-w-xs px-4 py-2 rounded-2xl text-sm ${Pe.role==="user"?"bg-cyan-600 text-white":Pe.role==="bot"?"bg-purple-600 text-white":"bg-slate-700 text-cyan-300 text-xs italic"}`,children:Pe.content})},Pe.id)),pe&&jsxRuntimeExports.jsx("div",{className:"flex justify-start",children:jsxRuntimeExports.jsx("div",{className:"px-4 py-2 bg-slate-700 text-cyan-300 text-sm rounded-2xl",children:jsxRuntimeExports.jsx("span",{className:"animate-pulse",children:"Mengetik..."})})})]}),jsxRuntimeExports.jsxs("div",{className:"p-4 border-t border-white/10 flex gap-2",children:[jsxRuntimeExports.jsx("button",{onClick:we,className:`p-3 rounded-full transition-all ${ce?"bg-red-500 animate-pulse":"bg-slate-700 hover:bg-slate-600"}`,children:ce?jsxRuntimeExports.jsx(MicOff,{className:"w-5 h-5 text-white"}):jsxRuntimeExports.jsx(Mic,{className:"w-5 h-5 text-white"})}),jsxRuntimeExports.jsx("input",{type:"text",value:se,onChange:Pe=>le(Pe.target.value),onKeyDown:Pe=>Pe.key==="Enter"&&!Pe.shiftKey&&Ee(se),placeholder:"Tanya tentang produk...",className:"flex-1 bg-slate-800 text-white px-4 py-2 rounded-full focus:outline-none focus:ring-2 focus:ring-cyan-500"}),jsxRuntimeExports.jsx("button",{onClick:()=>Ee(se),disabled:pe,className:"p-3 bg-gradient-to-r from-cyan-500 to-purple-600 rounded-full hover:scale-110 transition-all disabled:opacity-50",children:jsxRuntimeExports.jsx(Send,{className:"w-5 h-5 text-white"})})]})]})}),jsxRuntimeExports.jsx("div",{className:"w-screen flex justify-center items-center",children:jsxRuntimeExports.jsx("div",{className:"fixed bg-white/14 w-max px-20 h-[16vh] flex flex-col items-center backdrop-blur-xl justify-center bottom-0 md:bottom-4 rounded-3xl shadow-xl z-[2333] mt-12 text-center",children:jsxRuntimeExports.jsxs(motion.div,{initial:{opacity:0,y:20},animate:{opacity:1,y:0},transition:{delay:.6},children:[jsxRuntimeExports.jsxs("button",{onClick:Ne,className:"group flex cursor-pointer relative inline-flex items-center gap-3 px-5 py-3 bg-gradient-to-r from-purple-600 to-pink-600 text-white font-bold text-lg rounded-full shadow-2xl hover:shadow-purple-500/50 transform hover:scale-103 transition-all duration-300 overflow-hidden",children:[jsxRuntimeExports.jsx(Sparkles,{className:"w-6 h-6 group-hover:animate-pulse"}),jsxRuntimeExports.jsx("p",{className:"text-sm",children:"Coba AR Unity (Image Target)"}),jsxRuntimeExports.jsx("div",{className:"absolute inset-0 bg-white/20 translate-x-[-100%] group-hover:translate-x-[100%] transition-transform duration-700"})]}),jsxRuntimeExports.jsxs("div",{className:"mt-3 flex items-center justify-center gap-1 text-xs text-yellow-300",children:[jsxRuntimeExports.jsx(CircleAlert,{className:"w-4 h-4"}),jsxRuntimeExports.jsxs("p",{className:"text-sm text-white font-mono tracking-widest",children:["POWERED BY ",jsxRuntimeExports.jsx("span",{className:"text-white",children:"UNITY"}),"  ",jsxRuntimeExports.jsx("span",{className:"text-pink-400",children:"2025"})]})]})]})})}),jsxRuntimeExports.jsxs("div",{className:"absolute inset-0 opacity-30",children:[jsxRuntimeExports.jsx("div",{className:"absolute inset-0 bg-gradient-to-tr from-cyan-500/20 via-purple-600/20 to-pink-600/20 animate-pulse"}),jsxRuntimeExports.jsx("div",{className:"absolute inset-0 bg-gradient-to-bl from-emerald-500/10 via-blue-600/10 to-indigo-600/10 animate-pulse animation-delay-2000"})]}),jsxRuntimeExports.jsxs("div",{className:"relative z-10 md:max-w-7xl mx-auto px-3 md:px-6 py-12",children:[jsxRuntimeExports.jsx(motion.div,{className:"absolute inset-0 -z-10 blur-3xl",animate:{background:["radial-gradient(circle at 20% 80%, rgba(120, 219, 226, 0.3), transparent 50%)","radial-gradient(circle at 80% 20%, rgba(173, 109, 244, 0.3), transparent 50%)","radial-gradient(circle at 40% 40%, rgba(255, 105, 180, 0.3), transparent 50%)"]},transition:{duration:10,repeat:1/0,repeatType:"reverse"}}),jsxRuntimeExports.jsxs(motion.div,{initial:{opacity:0,y:-50},animate:{opacity:1,y:0},transition:{duration:.8},children:[jsxRuntimeExports.jsxs("div",{className:"w-full md:flex justify-center items-center gap-6 mb-6",children:[jsxRuntimeExports.jsx("div",{className:"flex md:hidden",children:jsxRuntimeExports.jsx(motion.div,{className:"mx-auto mb-6",children:jsxRuntimeExports.jsx(Box,{size:80,className:"text-cyan-400 drop-shadow-glow"})})}),jsxRuntimeExports.jsx("h1",{className:"text-4xl md:text-7xl font-black bg-clip-text text-transparent bg-gradient-to-r from-cyan-400 via-blue-500 to-purple-600",children:"AR VIEWER COSMO"})]}),jsxRuntimeExports.jsx(motion.p,{initial:{opacity:0},animate:{opacity:1},transition:{delay:.5},className:"text-sm md:text-xl text-cyan-200 font-light max-w-3xl mx-auto",children:"Pilih model 3D atau coba AR interaktif dengan Unity (Image Target)."})]}),jsxRuntimeExports.jsx(motion.div,{initial:{opacity:0,scale:.95},animate:{opacity:1,scale:1},transition:{delay:.3,duration:.6},className:"relative w-full md:max-w-2xl mx-auto z-10",children:jsxRuntimeExports.jsx("div",{className:"p-0 md:p-8 h-max",children:jsxRuntimeExports.jsx(ModelSelector,{onModelSelect:Re})})}),jsxRuntimeExports.jsx("div",{className:"h-20 md:h-14"}),jsxRuntimeExports.jsx("div",{className:"relative mt-0 md:mt-40 grid grid-cols-1 md:grid-cols-3 gap-6 w-full md:px-0 px-4 md:max-w-5xl mx-auto z-20",children:[{icon:jsxRuntimeExports.jsx(Info,{className:"w-5 h-5"}),title:"WebXR Ready",desc:"Chrome Android  Safari iOS"},{icon:jsxRuntimeExports.jsx(ArrowLeft,{className:"w-5 h-5"}),title:"Tap to Place",desc:"Arahkan ke lantai saat AR aktif"},{icon:jsxRuntimeExports.jsx(Sparkles,{className:"w-5 h-5"}),title:"Real-time",desc:"Interaksi penuh: putar, zoom, geser"}].map((Pe,Ce)=>jsxRuntimeExports.jsxs(motion.div,{initial:{opacity:0,y:30},animate:{opacity:1,y:0},transition:{delay:.5+Ce*.1},whileHover:{y:-8,scale:1.01},className:"group relative p-6 bg-white/5 backdrop-blur-xl border border-white/10 rounded-2xl overflow-hidden",children:[jsxRuntimeExports.jsx("div",{className:"absolute inset-0 bg-gradient-to-br from-cyan-500/10 to-purple-600/10 opacity-0 group-hover:opacity-100 transition-opacity duration-300"}),jsxRuntimeExports.jsxs("div",{className:"relative z-10 flex items-start gap-3",children:[jsxRuntimeExports.jsx("div",{className:"p-2 bg-cyan-500/20 rounded-lg text-cyan-400 group-hover:scale-110 transition-transform duration-300",children:Pe.icon}),jsxRuntimeExports.jsxs("div",{children:[jsxRuntimeExports.jsx("h3",{className:"font-semibold text-lg text-white",children:Pe.title}),jsxRuntimeExports.jsx("p",{className:"text-sm text-cyan-200/80",children:Pe.desc})]})]})]},Ce))}),jsxRuntimeExports.jsx(motion.div,{initial:{opacity:0},animate:{opacity:1},transition:{delay:.8},className:"mt-20 text-center",children:jsxRuntimeExports.jsx("p",{className:"text-sm text-cyan-300/60 font-mono tracking-widest",children:"AR"})})]}),jsxRuntimeExports.jsx("style",{dangerouslySetInnerHTML:{__html:`
        .drop-shadow-glow { filter: drop-shadow(0 0 20px rgba(34, 211, 238, 0.6)); }
        .animation-delay-2000 { animation-delay: 2s; }
      `}})]})}clientExports.createRoot(document.getElementById("root")).render(jsxRuntimeExports.jsx(reactExports.StrictMode,{children:jsxRuntimeExports.jsx(App,{})}));
